_ZN3tox4test16FakeNetworkStackC2ERNS0_15NetworkUniverseERK2IP:
   98|     43|    : universe_(universe)
   99|     43|    , node_ip_(node_ip)
  100|     43|{
  101|     43|}
_ZN3tox4test16FakeNetworkStackD2Ev:
  103|     43|FakeNetworkStack::~FakeNetworkStack() = default;
_ZN3tox4test16FakeNetworkStack9c_networkEv:
  105|     43|struct Network FakeNetworkStack::c_network() { return Network{&kNetworkVtable, this}; }
_ZN3tox4test16FakeNetworkStack6socketEiii:
  108|     83|{
  109|     83|    std::lock_guard<std::mutex> lock(mutex_);
  110|     83|    int fd = next_fd_++;
  111|       |
  112|     83|    std::unique_ptr<FakeSocket> sock;
  113|     83|    if (type == SOCK_DGRAM) {
  ------------------
  |  Branch (113:9): [True: 83, False: 0]
  ------------------
  114|     83|        if (universe_.is_verbose()) {
  ------------------
  |  Branch (114:13): [True: 0, False: 83]
  ------------------
  115|      0|            std::cerr << "[FakeNetworkStack] create UDP socket fd=" << fd << std::endl;
  116|      0|        }
  117|     83|        sock = std::make_unique<FakeUdpSocket>(universe_);
  118|     83|    } else if (type == SOCK_STREAM) {
  ------------------
  |  Branch (118:16): [True: 0, False: 0]
  ------------------
  119|      0|        if (universe_.is_verbose()) {
  ------------------
  |  Branch (119:13): [True: 0, False: 0]
  ------------------
  120|      0|            std::cerr << "[FakeNetworkStack] create TCP socket fd=" << fd << std::endl;
  121|      0|        }
  122|      0|        sock = std::make_unique<FakeTcpSocket>(universe_);
  123|      0|    } else {
  124|       |        // Unknown type
  125|      0|        return net_socket_from_native(-1);
  126|      0|    }
  127|       |
  128|     83|    sockets_[fd] = std::move(sock);
  129|     83|    sockets_[fd]->set_ip(node_ip_);
  130|     83|    return net_socket_from_native(fd);
  131|     83|}
_ZN3tox4test16FakeNetworkStack8get_sockE6Socket:
  134|  2.70k|{
  135|  2.70k|    std::lock_guard<std::mutex> lock(mutex_);
  136|  2.70k|    auto it = sockets_.find(net_socket_to_native(sock));
  137|  2.70k|    if (it != sockets_.end()) {
  ------------------
  |  Branch (137:9): [True: 2.70k, False: 0]
  ------------------
  138|  2.70k|        return it->second.get();
  139|  2.70k|    }
  140|      0|    return nullptr;
  141|  2.70k|}
_ZN3tox4test16FakeNetworkStack5closeE6Socket:
  144|     40|{
  145|     40|    std::lock_guard<std::mutex> lock(mutex_);
  146|     40|    int fd = net_socket_to_native(sock);
  147|     40|    auto it = sockets_.find(fd);
  148|     40|    if (it == sockets_.end()) {
  ------------------
  |  Branch (148:9): [True: 0, False: 40]
  ------------------
  149|      0|        errno = EBADF;
  150|      0|        return -1;
  151|      0|    }
  152|     40|    it->second->close();
  153|     40|    sockets_.erase(it);
  154|     40|    return 0;
  155|     40|}
_ZN3tox4test16FakeNetworkStack4bindE6SocketPK7IP_Port:
  159|    123|{
  160|    123|    if (auto *s = get_sock(sock)) {
  ------------------
  |  Branch (160:15): [True: 123, False: 0]
  ------------------
  161|    123|        int ret = s->bind(addr);
  162|    123|        if (universe_.is_verbose() && ret == 0) {
  ------------------
  |  Branch (162:13): [True: 0, False: 123]
  |  Branch (162:39): [True: 0, False: 0]
  ------------------
  163|      0|            char ip_str[TOX_INET_ADDRSTRLEN];
  164|      0|            ip_parse_addr(&s->ip_address(), ip_str, sizeof(ip_str));
  165|      0|            std::cerr << "[FakeNetworkStack] bound socket to " << ip_str << ":" << s->local_port()
  166|      0|                      << std::endl;
  167|      0|        }
  168|    123|        return ret;
  169|    123|    }
  170|    123|    errno = EBADF;
  171|      0|    return -1;
  172|    123|}
_ZN3tox4test16FakeNetworkStack8recvfromE6SocketPhmP7IP_Port:
  249|  2.33k|{
  250|  2.33k|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (250:15): [True: 2.33k, False: 0]
  ------------------
  251|  2.33k|        return s->recvfrom(buf, len, addr);
  252|  2.33k|    errno = EBADF;
  253|      0|    return -1;
  254|  2.33k|}
_ZN3tox4test16FakeNetworkStack15socket_nonblockE6Socketb:
  257|     40|{
  258|     40|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (258:15): [True: 40, False: 0]
  ------------------
  259|     40|        return s->socket_nonblock(nonblock);
  260|     40|    errno = EBADF;
  261|      0|    return -1;
  262|     40|}
_ZN3tox4test16FakeNetworkStack10getsockoptE6SocketiiPvPm:
  265|     40|{
  266|     40|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (266:15): [True: 40, False: 0]
  ------------------
  267|     40|        return s->getsockopt(level, optname, optval, optlen);
  268|     40|    errno = EBADF;
  269|      0|    return -1;
  270|     40|}
_ZN3tox4test16FakeNetworkStack10setsockoptE6SocketiiPKvm:
  274|    160|{
  275|    160|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (275:15): [True: 160, False: 0]
  ------------------
  276|    160|        return s->setsockopt(level, optname, optval, optlen);
  277|    160|    errno = EBADF;
  278|      0|    return -1;
  279|    160|}
_ZN3tox4test16FakeNetworkStack21get_bound_udp_socketsEv:
  292|     43|{
  293|     43|    std::lock_guard<std::mutex> lock(mutex_);
  294|     43|    std::vector<FakeUdpSocket *> result;
  295|     43|    for (const auto &pair : sockets_) {
  ------------------
  |  Branch (295:27): [True: 43, False: 43]
  ------------------
  296|     43|        FakeSocket *s = pair.second.get();
  297|     43|        if (s->type() == SOCK_DGRAM && s->local_port() != 0) {
  ------------------
  |  Branch (297:13): [True: 43, False: 0]
  |  Branch (297:40): [True: 43, False: 0]
  ------------------
  298|     43|            result.push_back(static_cast<FakeUdpSocket *>(s));
  299|     43|        }
  300|     43|    }
  301|     43|    return result;
  302|     43|}
fake_network_stack.cc:_ZNK3tox4test3$_0clEPv6Socket:
   13|     40|                 Socket sock) { return static_cast<FakeNetworkStack *>(obj)->close(sock); },
fake_network_stack.cc:_ZNK3tox4test3$_2clEPv6SocketPK7IP_Port:
   17|     80|        [](void *_Nonnull obj, Socket sock, const IP_Port *_Nonnull addr) {
   18|     80|            return static_cast<FakeNetworkStack *>(obj)->bind(sock, addr);
   19|     80|        },
fake_network_stack.cc:_ZNK3tox4test3$_7clEPv6SocketPhmP7IP_Port:
   33|  2.33k|            IP_Port *_Nonnull addr) {
   34|  2.33k|            return static_cast<FakeNetworkStack *>(obj)->recvfrom(sock, buf, len, addr);
   35|  2.33k|        },
fake_network_stack.cc:_ZNK3tox4test4$_10clEPviii:
   45|     40|          int proto) { return static_cast<FakeNetworkStack *>(obj)->socket(domain, type, proto); },
fake_network_stack.cc:_ZNK3tox4test4$_11clEPv6Socketb:
   47|     40|        [](void *_Nonnull obj, Socket sock, bool nonblock) {
   48|     40|            return static_cast<FakeNetworkStack *>(obj)->socket_nonblock(sock, nonblock);
   49|     40|        },
fake_network_stack.cc:_ZNK3tox4test4$_12clEPv6SocketiiS2_Pm:
   52|     40|            size_t *_Nonnull optlen) {
   53|     40|            return static_cast<FakeNetworkStack *>(obj)->getsockopt(
   54|     40|                sock, level, optname, optval, optlen);
   55|     40|        },
fake_network_stack.cc:_ZNK3tox4test4$_13clEPv6SocketiiPKvm:
   58|    160|            size_t optlen) {
   59|    160|            return static_cast<FakeNetworkStack *>(obj)->setsockopt(
   60|    160|                sock, level, optname, optval, optlen);
   61|    160|        },

_ZN3tox4test10FakeSocketC2ERNS0_15NetworkUniverseEi:
   19|     83|    : universe_(universe)
   20|     83|    , type_(type)
   21|     83|{
   22|     83|    ip_init(&ip_, false);
   23|     83|    ip_.ip.v4.uint32 = net_htonl(0x7F000001);
   24|     83|}
_ZN3tox4test10FakeSocketD2Ev:
   26|     83|FakeSocket::~FakeSocket() = default;
_ZN3tox4test10FakeSocket10getsockoptEiiPvPm:
   35|     40|{
   36|     40|    return 0;
   37|     40|}
_ZN3tox4test10FakeSocket10setsockoptEiiPKvm:
   39|    160|{
   40|    160|    return 0;
   41|    160|}
_ZN3tox4test10FakeSocket15socket_nonblockEb:
   43|     40|{
   44|     40|    nonblocking_ = nonblock;
   45|     40|    return 0;
   46|     40|}
_ZN3tox4test13FakeUdpSocketC2ERNS0_15NetworkUniverseE:
   51|     83|    : FakeSocket(universe, SOCK_DGRAM)
   52|     83|{
   53|     83|}
_ZN3tox4test13FakeUdpSocketD2Ev:
   55|     83|FakeUdpSocket::~FakeUdpSocket() { close_impl(); }
_ZN3tox4test13FakeUdpSocket5closeEv:
   58|     40|{
   59|     40|    std::lock_guard<std::mutex> lock(mutex_);
   60|     40|    close_impl();
   61|     40|    return 0;
   62|     40|}
_ZN3tox4test13FakeUdpSocket10close_implEv:
   65|    123|{
   66|    123|    if (local_port_ != 0) {
  ------------------
  |  Branch (66:9): [True: 83, False: 40]
  ------------------
   67|     83|        universe_.unbind_udp(ip_, local_port_);
   68|     83|        local_port_ = 0;
   69|     83|    }
   70|    123|}
_ZN3tox4test13FakeUdpSocket4bindEPK7IP_Port:
   73|    123|{
   74|    123|    std::lock_guard<std::mutex> lock(mutex_);
   75|    123|    if (local_port_ != 0)
  ------------------
  |  Branch (75:9): [True: 0, False: 123]
  ------------------
   76|      0|        return -1;  // Already bound
   77|       |
   78|    123|    uint16_t port = addr->port;
   79|    123|    if (port == 0) {
  ------------------
  |  Branch (79:9): [True: 0, False: 123]
  ------------------
   80|      0|        port = universe_.find_free_port(ip_);
   81|    123|    } else {
   82|    123|        port = net_ntohs(port);
   83|    123|    }
   84|       |
   85|    123|    if (universe_.bind_udp(ip_, port, this)) {
  ------------------
  |  Branch (85:9): [True: 83, False: 40]
  ------------------
   86|     83|        local_port_ = port;
   87|     83|        return 0;
   88|     83|    }
   89|    123|    errno = EADDRINUSE;
   90|     40|    return -1;
   91|    123|}
_ZN3tox4test13FakeUdpSocket8recvfromEPhmP7IP_Port:
  160|  2.33k|{
  161|  2.33k|    RecvObserver observer_copy;
  162|  2.33k|    std::vector<uint8_t> data_copy;
  163|  2.33k|    IP_Port from_copy;
  164|  2.33k|    size_t copy_len = 0;
  165|       |
  166|  2.33k|    {
  167|  2.33k|        std::lock_guard<std::mutex> lock(mutex_);
  168|       |
  169|  2.33k|        if (recv_queue_.empty() && packet_source_) {
  ------------------
  |  Branch (169:13): [True: 2.33k, False: 0]
  |  Branch (169:36): [True: 0, False: 2.33k]
  ------------------
  170|       |            // NOTE: We call packet_source_ with lock held.
  171|       |            // Be careful not to call back into socket methods from packet_source_.
  172|      0|            std::vector<uint8_t> data;
  173|      0|            IP_Port from;
  174|      0|            if (packet_source_(data, from)) {
  ------------------
  |  Branch (174:17): [True: 0, False: 0]
  ------------------
  175|      0|                recv_queue_.push_back({std::move(data), from});
  176|      0|            }
  177|      0|        }
  178|       |
  179|  2.33k|        if (recv_queue_.empty()) {
  ------------------
  |  Branch (179:13): [True: 2.33k, False: 0]
  ------------------
  180|  2.33k|            errno = EWOULDBLOCK;
  181|  2.33k|            return -1;
  182|  2.33k|        }
  183|       |
  184|      0|        auto &p = recv_queue_.front();
  185|      0|        copy_len = std::min(len, p.data.size());
  186|      0|        std::memcpy(buf, p.data.data(), copy_len);
  187|      0|        *addr = p.from;
  188|       |
  189|      0|        if (recv_observer_) {
  ------------------
  |  Branch (189:13): [True: 0, False: 0]
  ------------------
  190|      0|            observer_copy = recv_observer_;
  191|      0|            data_copy = p.data;
  192|      0|            from_copy = p.from;
  193|      0|        }
  194|       |
  195|      0|        recv_queue_.pop_front();
  196|      0|    }
  197|       |
  198|      0|    if (observer_copy) {
  ------------------
  |  Branch (198:9): [True: 0, False: 0]
  ------------------
  199|      0|        observer_copy(data_copy, from_copy);
  200|      0|    }
  201|       |
  202|      0|    if (universe_.is_verbose()) {
  ------------------
  |  Branch (202:9): [True: 0, False: 0]
  ------------------
  203|      0|        std::cerr << "[FakeUdpSocket] recv " << copy_len << " bytes at port " << local_port_
  204|      0|                  << " from port " << net_ntohs(addr->port) << std::endl;
  205|      0|    }
  206|       |
  207|      0|    return copy_len;
  208|  2.33k|}

_ZNK3tox4test10FakeSocket4typeEv:
   59|     43|    int type() const { return type_; }
_ZNK3tox4test10FakeSocket10local_portEv:
   60|     43|    uint16_t local_port() const { return local_port_; }
_ZN3tox4test10FakeSocket6set_ipERK2IP:
   63|     83|    void set_ip(const IP &ip) { ip_ = ip; }

_ZNK3tox4test15NetworkUniverse11IP_Port_KeyltERKS2_:
   35|    446|{
   36|    446|    if (port != other.port)
  ------------------
  |  Branch (36:9): [True: 200, False: 246]
  ------------------
   37|    200|        return port < other.port;
   38|    246|    if (ip.family.value != other.ip.family.value)
  ------------------
  |  Branch (38:9): [True: 0, False: 246]
  ------------------
   39|      0|        return ip.family.value < other.ip.family.value;
   40|       |
   41|    246|    if (net_family_is_ipv4(ip.family)) {
  ------------------
  |  Branch (41:9): [True: 246, False: 0]
  ------------------
   42|    246|        return ip.ip.v4.uint32 < other.ip.ip.v4.uint32;
   43|    246|    }
   44|       |
   45|      0|    return std::memcmp(&ip.ip.v6, &other.ip.ip.v6, sizeof(ip.ip.v6)) < 0;
   46|    246|}
_ZN3tox4test15NetworkUniverseC2Ev:
   48|     43|NetworkUniverse::NetworkUniverse() { }
_ZN3tox4test15NetworkUniverseD2Ev:
   49|     43|NetworkUniverse::~NetworkUniverse() { }
_ZN3tox4test15NetworkUniverse8bind_udpE2IPtPNS0_13FakeUdpSocketE:
   52|    123|{
   53|    123|    std::lock_guard<std::recursive_mutex> lock(mutex_);
   54|    123|    IP_Port_Key key{ip, port};
   55|    123|    if (udp_bindings_.count(key))
  ------------------
  |  Branch (55:9): [True: 40, False: 83]
  ------------------
   56|     40|        return false;
   57|     83|    udp_bindings_[key] = socket;
   58|     83|    return true;
   59|    123|}
_ZN3tox4test15NetworkUniverse10unbind_udpE2IPt:
   62|     83|{
   63|     83|    std::lock_guard<std::recursive_mutex> lock(mutex_);
   64|     83|    udp_bindings_.erase({ip, port});
   65|     83|}
_ZN3tox4test15NetworkUniverse14process_eventsEm:
  161|  2.33k|{
  162|  2.33k|    while (true) {
  ------------------
  |  Branch (162:12): [True: 2.33k, Folded]
  ------------------
  163|  2.33k|        Packet p;
  164|  2.33k|        std::vector<FakeTcpSocket *> tcp_targets;
  165|  2.33k|        FakeUdpSocket *udp_target = nullptr;
  166|  2.33k|        bool has_packet = false;
  167|       |
  168|  2.33k|        {
  169|  2.33k|            std::lock_guard<std::recursive_mutex> lock(mutex_);
  170|  2.33k|            if (!event_queue_.empty()) {
  ------------------
  |  Branch (170:17): [True: 0, False: 2.33k]
  ------------------
  171|      0|                const Packet &top = event_queue_.top();
  172|      0|                if (verbose_) {
  ------------------
  |  Branch (172:21): [True: 0, False: 0]
  ------------------
  173|      0|                    std::cerr << "[NetworkUniverse] Peek packet: time=" << top.delivery_time
  174|      0|                              << " current=" << current_time_ms << " tcp=" << top.is_tcp
  175|      0|                              << std::endl;
  176|      0|                }
  177|      0|            }
  178|       |
  179|  2.33k|            if (!event_queue_.empty() && event_queue_.top().delivery_time <= current_time_ms) {
  ------------------
  |  Branch (179:17): [True: 0, False: 2.33k]
  |  Branch (179:42): [True: 0, False: 0]
  ------------------
  180|      0|                p = event_queue_.top();
  181|      0|                event_queue_.pop();
  182|      0|                has_packet = true;
  183|       |
  184|      0|                if (verbose_) {
  ------------------
  |  Branch (184:21): [True: 0, False: 0]
  ------------------
  185|      0|                    Ip_Ntoa from_str, to_str;
  186|      0|                    net_ip_ntoa(&p.from.ip, &from_str);
  187|      0|                    net_ip_ntoa(&p.to.ip, &to_str);
  188|      0|                    std::cerr << "[NetworkUniverse] Processing packet #" << p.sequence_number
  189|      0|                              << " from " << from_str.buf << ":" << net_ntohs(p.from.port) << " to "
  190|      0|                              << to_str.buf << ":" << net_ntohs(p.to.port)
  191|      0|                              << " (TCP=" << (p.is_tcp ? "true" : "false");
  ------------------
  |  Branch (191:47): [True: 0, False: 0]
  ------------------
  192|      0|                    if (p.is_tcp) {
  ------------------
  |  Branch (192:25): [True: 0, False: 0]
  ------------------
  193|      0|                        std::cerr << " Flags=" << TcpFlags{p.tcp_flags} << " Seq=" << p.seq
  194|      0|                                  << " Ack=" << p.ack;
  195|      0|                    }
  196|      0|                    std::cerr << " Size=" << p.data.size() << ")" << std::endl;
  197|      0|                }
  198|       |
  199|      0|                IP target_ip = p.to.ip;
  200|       |
  201|      0|                if (p.is_tcp) {
  ------------------
  |  Branch (201:21): [True: 0, False: 0]
  ------------------
  202|      0|                    if (is_loopback(target_ip)
  ------------------
  |  Branch (202:25): [True: 0, False: 0]
  |  Branch (202:25): [True: 0, False: 0]
  ------------------
  203|      0|                        && tcp_bindings_.count({target_ip, net_ntohs(p.to.port)}) == 0) {
  ------------------
  |  Branch (203:28): [True: 0, False: 0]
  ------------------
  204|      0|                        if (verbose_) {
  ------------------
  |  Branch (204:29): [True: 0, False: 0]
  ------------------
  205|      0|                            std::cerr << "[NetworkUniverse] Loopback packet to "
  206|      0|                                      << static_cast<int>(target_ip.ip.v4.uint8[3])
  207|      0|                                      << " redirected to "
  208|      0|                                      << static_cast<int>(p.from.ip.ip.v4.uint8[3]) << std::endl;
  209|      0|                        }
  210|      0|                        target_ip = p.from.ip;
  211|      0|                    }
  212|       |
  213|      0|                    auto range = tcp_bindings_.equal_range({target_ip, net_ntohs(p.to.port)});
  214|      0|                    FakeTcpSocket *listen_match = nullptr;
  215|       |
  216|      0|                    for (auto it = range.first; it != range.second; ++it) {
  ------------------
  |  Branch (216:49): [True: 0, False: 0]
  ------------------
  217|      0|                        FakeTcpSocket *s = it->second;
  218|      0|                        if (s->state() == FakeTcpSocket::LISTEN) {
  ------------------
  |  Branch (218:29): [True: 0, False: 0]
  ------------------
  219|      0|                            listen_match = s;
  220|      0|                        } else {
  221|      0|                            const IP_Port &remote = s->remote_addr();
  222|      0|                            if (net_ntohs(p.from.port) == net_ntohs(remote.port)) {
  ------------------
  |  Branch (222:33): [True: 0, False: 0]
  ------------------
  223|      0|                                if (ip_equal(&p.from.ip, &remote.ip)
  ------------------
  |  Branch (223:37): [True: 0, False: 0]
  ------------------
  224|      0|                                    || (is_loopback(p.from.ip) && ip_equal(&remote.ip, &target_ip))
  ------------------
  |  Branch (224:41): [True: 0, False: 0]
  |  Branch (224:67): [True: 0, False: 0]
  ------------------
  225|      0|                                    || (is_loopback(remote.ip)
  ------------------
  |  Branch (225:41): [True: 0, False: 0]
  ------------------
  226|      0|                                        && ip_equal(&p.from.ip, &target_ip))) {
  ------------------
  |  Branch (226:44): [True: 0, False: 0]
  ------------------
  227|      0|                                    tcp_targets.push_back(s);
  228|      0|                                }
  229|      0|                            }
  230|      0|                        }
  231|      0|                    }
  232|       |
  233|      0|                    if (listen_match && (p.tcp_flags & 0x02)) {
  ------------------
  |  Branch (233:25): [True: 0, False: 0]
  |  Branch (233:41): [True: 0, False: 0]
  ------------------
  234|      0|                        tcp_targets.push_back(listen_match);
  235|      0|                    }
  236|       |
  237|      0|                    if (verbose_) {
  ------------------
  |  Branch (237:25): [True: 0, False: 0]
  ------------------
  238|      0|                        std::cerr << "[NetworkUniverse] Routing TCP to "
  239|      0|                                  << static_cast<int>(target_ip.ip.v4.uint8[0]) << "."
  240|      0|                                  << static_cast<int>(target_ip.ip.v4.uint8[3]) << ":"
  241|      0|                                  << net_ntohs(p.to.port)
  242|      0|                                  << ". Targets found: " << tcp_targets.size() << std::endl;
  243|      0|                    }
  244|      0|                    if (tcp_targets.empty()) {
  ------------------
  |  Branch (244:25): [True: 0, False: 0]
  ------------------
  245|      0|                        if (verbose_) {
  ------------------
  |  Branch (245:29): [True: 0, False: 0]
  ------------------
  246|      0|                            std::cerr << "[NetworkUniverse] WARNING: No TCP targets for "
  247|      0|                                      << static_cast<int>(target_ip.ip.v4.uint8[0]) << "."
  248|      0|                                      << static_cast<int>(target_ip.ip.v4.uint8[3]) << ":"
  249|      0|                                      << net_ntohs(p.to.port) << std::endl;
  250|      0|                        }
  251|      0|                    }
  252|      0|                } else {
  253|      0|                    if (is_loopback(target_ip)
  ------------------
  |  Branch (253:25): [True: 0, False: 0]
  |  Branch (253:25): [True: 0, False: 0]
  ------------------
  254|      0|                        && udp_bindings_.count({target_ip, net_ntohs(p.to.port)}) == 0) {
  ------------------
  |  Branch (254:28): [True: 0, False: 0]
  ------------------
  255|      0|                        target_ip = p.from.ip;
  256|      0|                    }
  257|       |
  258|      0|                    if (udp_bindings_.count({target_ip, net_ntohs(p.to.port)})) {
  ------------------
  |  Branch (258:25): [True: 0, False: 0]
  ------------------
  259|      0|                        udp_target = udp_bindings_[{target_ip, net_ntohs(p.to.port)}];
  260|      0|                    } else if (is_ipv4_mapped(target_ip)) {
  ------------------
  |  Branch (260:32): [True: 0, False: 0]
  ------------------
  261|      0|                        IP ip4 = extract_ipv4(target_ip);
  262|      0|                        if (udp_bindings_.count({ip4, net_ntohs(p.to.port)})) {
  ------------------
  |  Branch (262:29): [True: 0, False: 0]
  ------------------
  263|      0|                            udp_target = udp_bindings_[{ip4, net_ntohs(p.to.port)}];
  264|      0|                        }
  265|      0|                    }
  266|      0|                }
  267|      0|            }
  268|  2.33k|        }
  269|       |
  270|  2.33k|        if (!has_packet) {
  ------------------
  |  Branch (270:13): [True: 2.33k, False: 0]
  ------------------
  271|  2.33k|            break;
  272|  2.33k|        }
  273|       |
  274|      0|        if (p.is_tcp) {
  ------------------
  |  Branch (274:13): [True: 0, False: 0]
  ------------------
  275|      0|            for (auto *it : tcp_targets) {
  ------------------
  |  Branch (275:27): [True: 0, False: 0]
  ------------------
  276|      0|                if (it->handle_packet(p)) {
  ------------------
  |  Branch (276:21): [True: 0, False: 0]
  ------------------
  277|      0|                    break;
  278|      0|                }
  279|      0|            }
  280|      0|        } else {
  281|      0|            if (udp_target) {
  ------------------
  |  Branch (281:17): [True: 0, False: 0]
  ------------------
  282|      0|                udp_target->push_packet(std::move(p.data), p.from);
  283|      0|            }
  284|      0|        }
  285|      0|    }
  286|  2.33k|}
_ZNK3tox4test15NetworkUniverse10is_verboseEv:
  292|    249|bool NetworkUniverse::is_verbose() const { return verbose_; }

_ZNK3tox4test9Fuzz_Data4sizeEv:
  101|    856|    std::size_t size() const { return size_; }
_ZN3tox4test9Fuzz_Data7consumeEPKcm:
  107|    408|    {
  108|    408|        if (count > size_)
  ------------------
  |  Branch (108:13): [True: 0, False: 408]
  ------------------
  109|      0|            return nullptr;
  110|    408|        const uint8_t *_Nonnull val = data_;
  111|    408|        if (FUZZ_DEBUG) {
  ------------------
  |  Branch (111:13): [Folded, False: 408]
  ------------------
  112|      0|            if (count == 1) {
  ------------------
  |  Branch (112:17): [True: 0, False: 0]
  ------------------
  113|      0|                std::printf("consume@%zu(%s): %d (0x%02x)\n", pos(), func, val[0], val[0]);
  114|      0|            } else if (count != 0) {
  ------------------
  |  Branch (114:24): [True: 0, False: 0]
  ------------------
  115|      0|                std::printf("consume@%zu(%s): %02x..%02x[%zu]\n", pos(), func, val[0],
  116|      0|                    val[count - 1], count);
  117|      0|            }
  118|      0|        }
  119|    408|        data_ += count;
  120|    408|        size_ -= count;
  121|    408|        return val;
  122|    408|    }
net_crypto_fuzz_test.cc:_ZN3tox4test18fuzz_select_targetIJXadL_ZN12_GLOBAL__N_113TestNetCryptoERNS0_9Fuzz_DataEEEEEEvPKhm:
  176|     45|{
  177|     45|    Fuzz_Data input{data, size};
  178|       |
  179|     45|    CONSUME1_OR_RETURN(const uint8_t, selector, input);
  ------------------
  |  |  126|     45|    if ((INPUT).size() < sizeof(TYPE)) {      \
  |  |  ------------------
  |  |  |  Branch (126:9): [True: 0, False: 45]
  |  |  ------------------
  |  |  127|      0|        return;                               \
  |  |  128|      0|    }                                         \
  |  |  129|     45|    TYPE NAME = (INPUT).consume1(__func__)
  ------------------
  180|     45|    return Fuzz_Target_Selector<Args...>::select(selector, input);
  181|     45|}
_ZN3tox4test9Fuzz_DataC2EPKhm:
   25|     45|        : data_(input_data)
   26|     45|        , base_(input_data)
   27|     45|        , size_(input_size)
   28|     45|    {
   29|     45|    }
_ZN3tox4test9Fuzz_Data8consume1EPKc:
   63|     45|    Consumer consume1(const char *_Nonnull func) { return Consumer{func, *this}; }
_ZN3tox4test9Fuzz_Data8ConsumercvT_IhEEv:
   53|     45|        {
   54|     45|            if (sizeof(T) > fd.size())
  ------------------
  |  Branch (54:17): [True: 0, False: 45]
  ------------------
   55|      0|                return T{};
   56|     45|            const uint8_t *_Nonnull bytes = fd.consume(func, sizeof(T));
   57|     45|            T val;
   58|     45|            std::memcpy(&val, bytes, sizeof(T));
   59|     45|            return val;
   60|     45|        }
net_crypto_fuzz_test.cc:_ZN3tox4test20Fuzz_Target_SelectorIJXadL_ZN12_GLOBAL__N_113TestNetCryptoERNS0_9Fuzz_DataEEEEE6selectEhS4_:
  157|     45|    {
  158|     45|        if (selector == sizeof...(Args)) {
  ------------------
  |  Branch (158:13): [True: 44, False: 1]
  ------------------
  159|     44|            return Arg(input);
  160|     44|        }
  161|      1|        return Fuzz_Target_Selector<Args...>::select(selector, input);
  162|     45|    }
_ZN3tox4test20Fuzz_Target_SelectorIJEE6selectEhRNS0_9Fuzz_DataE:
  168|      1|    {
  169|       |        // The selector selected no function, so we do nothing and rely on the
  170|       |        // fuzzer to come up with a better selector.
  171|      1|    }

_ZN3tox4test10Simulation5clockEv:
  155|    126|    FakeClock &clock() { return *clock_; }
_ZN3tox4test10Simulation3netEv:
  157|     43|    NetworkUniverse &net() { return *net_; }
_ZN3tox4test13SimulatedNode12fake_networkEv:
  201|     86|    FakeNetworkStack &fake_network() { return *network_; }
_ZN3tox4test9LogFilterC2Ev:
   51|     43|    LogFilter() = default;

_ZN3tox4test11ClockSystemD2Ev:
    5|     43|ClockSystem::~ClockSystem() = default;

_ZN3tox4test11EnvironmentD2Ev:
    5|     86|Environment::~Environment() = default;

_ZN3tox4test9FakeClockC2Em:
    6|     43|    : now_ms_(start_time_ms)
    7|     43|{
    8|     43|}
_ZNK3tox4test9FakeClock15current_time_msEv:
   10|  4.71k|uint64_t FakeClock::current_time_ms() const { return now_ms_; }
_ZN3tox4test9FakeClock7advanceEm:
   14|  2.38k|void FakeClock::advance(uint64_t ms) { now_ms_ += ms; }

_ZN3tox4test10FakeMemoryC2Ev:
   25|     86|FakeMemory::FakeMemory() = default;
_ZN3tox4test10FakeMemoryD2Ev:
   26|     86|FakeMemory::~FakeMemory() = default;
_ZN3tox4test10FakeMemory6mallocEm:
   29|    694|{
   30|    694|    bool fail = failure_injector_ && failure_injector_(size);
  ------------------
  |  Branch (30:17): [True: 694, False: 0]
  |  Branch (30:38): [True: 20, False: 674]
  ------------------
   31|       |
   32|    694|    if (observer_) {
  ------------------
  |  Branch (32:9): [True: 0, False: 694]
  ------------------
   33|      0|        observer_(!fail);
   34|      0|    }
   35|       |
   36|    694|    if (fail) {
  ------------------
  |  Branch (36:9): [True: 20, False: 674]
  ------------------
   37|     20|        return nullptr;
   38|     20|    }
   39|       |
   40|    674|    void *ptr = std::malloc(size + sizeof(Header));
   41|    674|    if (!ptr) {
  ------------------
  |  Branch (41:9): [True: 0, False: 674]
  ------------------
   42|      0|        return nullptr;
   43|      0|    }
   44|       |
   45|    674|    Header *header = static_cast<Header *>(ptr);
   46|    674|    header->size = size;
   47|    674|    header->magic = kMagic;
   48|       |
   49|    674|    on_allocation(size);
   50|       |
   51|    674|    return header + 1;
   52|    674|}
_ZN3tox4test10FakeMemory7reallocEPvm:
   55|    104|{
   56|    104|    if (!ptr) {
  ------------------
  |  Branch (56:9): [True: 76, False: 28]
  ------------------
   57|     76|        return malloc(size);
   58|     76|    }
   59|       |
   60|     28|    Header *old_header = static_cast<Header *>(ptr) - 1;
   61|     28|    if (old_header->magic != kMagic) {
  ------------------
  |  Branch (61:9): [True: 0, False: 28]
  ------------------
   62|      0|        if (old_header->magic == kFreeMagic) {
  ------------------
  |  Branch (62:13): [True: 0, False: 0]
  ------------------
   63|      0|            std::cerr << "[FakeMemory] realloc: Double realloc/free detected at " << ptr
   64|      0|                      << " (header=" << old_header << ")" << std::endl;
   65|      0|        } else {
   66|      0|            std::cerr << "[FakeMemory] realloc: Invalid pointer (wrong magic 0x" << std::hex
   67|      0|                      << old_header->magic << ") at " << ptr << " (header=" << old_header << ")"
   68|      0|                      << std::endl;
   69|      0|        }
   70|      0|        std::abort();
   71|      0|    }
   72|       |
   73|     28|    bool fail = failure_injector_ && failure_injector_(size);
  ------------------
  |  Branch (73:17): [True: 28, False: 0]
  |  Branch (73:38): [True: 1, False: 27]
  ------------------
   74|       |
   75|     28|    if (observer_) {
  ------------------
  |  Branch (75:9): [True: 0, False: 28]
  ------------------
   76|      0|        observer_(!fail);
   77|      0|    }
   78|       |
   79|     28|    if (fail) {
  ------------------
  |  Branch (79:9): [True: 1, False: 27]
  ------------------
   80|      1|        return nullptr;
   81|      1|    }
   82|       |
   83|     27|    size_t old_size = old_header->size;
   84|     27|    void *new_ptr = std::realloc(old_header, size + sizeof(Header));
   85|     27|    if (!new_ptr) {
  ------------------
  |  Branch (85:9): [True: 0, False: 27]
  ------------------
   86|      0|        return nullptr;
   87|      0|    }
   88|       |
   89|     27|    on_deallocation(old_size);
   90|     27|    on_allocation(size);
   91|       |
   92|     27|    Header *header = static_cast<Header *>(new_ptr);
   93|     27|    header->size = size;
   94|     27|    header->magic = kMagic;
   95|       |
   96|     27|    return header + 1;
   97|     27|}
_ZN3tox4test10FakeMemory4freeEPv:
  100|    771|{
  101|    771|    if (!ptr) {
  ------------------
  |  Branch (101:9): [True: 97, False: 674]
  ------------------
  102|     97|        return;
  103|     97|    }
  104|       |
  105|    674|    Header *header = static_cast<Header *>(ptr) - 1;
  106|    674|    if (header->magic != kMagic) {
  ------------------
  |  Branch (106:9): [True: 0, False: 674]
  ------------------
  107|      0|        if (header->magic == kFreeMagic) {
  ------------------
  |  Branch (107:13): [True: 0, False: 0]
  ------------------
  108|      0|            std::cerr << "[FakeMemory] free: Double free detected at " << ptr
  109|      0|                      << " (header=" << header << ")" << std::endl;
  110|      0|        } else {
  111|      0|            std::cerr << "[FakeMemory] free: Invalid pointer (wrong magic 0x" << std::hex
  112|      0|                      << header->magic << ") at " << ptr << " (header=" << header << ")"
  113|      0|                      << std::endl;
  114|      0|        }
  115|      0|        std::abort();
  116|      0|    }
  117|       |
  118|    674|    size_t size = header->size;
  119|    674|    on_deallocation(size);
  120|    674|    header->magic = kFreeMagic;  // Mark as free
  121|    674|    std::free(header);
  122|    674|}
_ZN3tox4test10FakeMemory20set_failure_injectorENSt3__18functionIFbmEEE:
  125|     43|{
  126|     43|    failure_injector_ = std::move(injector);
  127|     43|}
_ZN3tox4test10FakeMemory8c_memoryEv:
  131|     86|struct Memory FakeMemory::c_memory() { return Memory{&kFakeMemoryVtable, this}; }
_ZN3tox4test10FakeMemory13on_allocationEm:
  138|    701|{
  139|    701|    size_t current = current_allocation_.fetch_add(size) + size;
  140|    701|    size_t max = max_allocation_.load(std::memory_order_relaxed);
  141|    701|    while (current > max && !max_allocation_.compare_exchange_weak(max, current)) { }
  ------------------
  |  Branch (141:12): [True: 701, False: 0]
  |  Branch (141:29): [True: 0, False: 701]
  ------------------
  142|    701|}
_ZN3tox4test10FakeMemory15on_deallocationEm:
  144|    701|void FakeMemory::on_deallocation(size_t size) { current_allocation_.fetch_sub(size); }
fake_memory.cc:_ZNK3tox4test3$_0clEPvj:
   15|    618|                           uint32_t size) { return static_cast<FakeMemory *>(obj)->malloc(size); },
fake_memory.cc:_ZNK3tox4test3$_1clEPvS2_j:
   18|    104|          uint32_t size) { return static_cast<FakeMemory *>(obj)->realloc(ptr, size); },
fake_memory.cc:_ZNK3tox4test3$_2clEPvS2_:
   20|    771|    = [](void *_Nonnull obj, void *_Nullable ptr) { static_cast<FakeMemory *>(obj)->free(ptr); },

_ZN3tox4test10FakeRandomC2Em:
   21|     86|    : rng_(seed)
   22|     86|{
   23|     86|}
_ZN3tox4test10FakeRandom5bytesEPhm:
   48|    194|{
   49|    194|    if (entropy_source_) {
  ------------------
  |  Branch (49:9): [True: 0, False: 194]
  ------------------
   50|      0|        entropy_source_(out, count);
   51|    194|    } else {
   52|    194|        std::uniform_int_distribution<uint16_t> dist(0, 255);
   53|    194|        std::generate_n(out, count, [&]() { return static_cast<uint8_t>(dist(rng_)); });
   54|    194|    }
   55|       |
   56|    194|    if (observer_) {
  ------------------
  |  Branch (56:9): [True: 0, False: 194]
  ------------------
   57|      0|        observer_(out, count);
   58|      0|    }
   59|    194|}
_ZN3tox4test10FakeRandom8c_randomEv:
   61|     86|struct Random FakeRandom::c_random() { return Random{&kFakeRandomVtable, this}; }
fake_random.cc:_ZZN3tox4test10FakeRandom5bytesEPhmENK3$_0clEv:
   53|  4.88k|        std::generate_n(out, count, [&]() { return static_cast<uint8_t>(dist(rng_)); });
fake_random.cc:_ZNK3tox4test3$_1clEPvPhj:
   14|    194|          uint32_t length) { static_cast<FakeRandom *>(obj)->bytes(bytes, length); },

_ZN3tox4test28configure_fuzz_memory_sourceERNS0_10FakeMemoryERNS0_9Fuzz_DataE:
   44|     43|{
   45|     43|    memory.set_failure_injector([&input](size_t size) -> bool {
   46|     43|        if (input.size() < 1) {
   47|       |            // Legacy behavior: if input runs out, allocation succeeds.
   48|     43|            return false;
   49|     43|        }
   50|       |
   51|     43|        const uint8_t *b = input.consume("malloc_decision", 1);
   52|     43|        bool succeed = (b && *b);
   53|     43|        return !succeed;  // Return true to fail
   54|     43|    });
   55|     43|}
fuzz_helpers.cc:_ZZN3tox4test28configure_fuzz_memory_sourceERNS0_10FakeMemoryERNS0_9Fuzz_DataEENK3$_0clEm:
   45|    722|    memory.set_failure_injector([&input](size_t size) -> bool {
   46|    722|        if (input.size() < 1) {
  ------------------
  |  Branch (46:13): [True: 402, False: 320]
  ------------------
   47|       |            // Legacy behavior: if input runs out, allocation succeeds.
   48|    402|            return false;
   49|    402|        }
   50|       |
   51|    320|        const uint8_t *b = input.consume("malloc_decision", 1);
   52|    320|        bool succeed = (b && *b);
  ------------------
  |  Branch (52:25): [True: 320, False: 0]
  |  Branch (52:30): [True: 299, False: 21]
  ------------------
   53|    320|        return !succeed;  // Return true to fail
   54|    722|    });

_ZN3tox4test12MemorySystemD2Ev:
    5|     86|MemorySystem::~MemorySystem() = default;

_ZN3tox4test13NetworkSystemD2Ev:
    5|     43|NetworkSystem::~NetworkSystem() = default;
_ZN3tox4test7make_ipEj:
    8|     86|{
    9|     86|    IP ip;
   10|     86|    ip_init(&ip, false);
   11|     86|    ip.ip.v4.uint32 = net_htonl(ipv4);
   12|     86|    return ip;
   13|     86|}
_ZN3tox4test12make_node_ipEj:
   16|     86|{
   17|       |    // Use 20.x.y.z range: 20. (id >> 16) . (id >> 8) . (id & 0xFF)
   18|     86|    return make_ip(0x14000000 | (node_id & 0x00FFFFFF));
   19|     86|}

_ZN3tox4test12RandomSystemD2Ev:
    5|     86|RandomSystem::~RandomSystem() = default;

_ZN3tox4test20SimulatedEnvironmentC2Ev:
    8|     43|    : sim_(std::make_unique<Simulation>())
    9|     43|    , global_random_(std::make_unique<FakeRandom>(12345))
   10|     43|    , global_memory_(std::make_unique<FakeMemory>())
   11|     43|{
   12|     43|}
_ZN3tox4test20SimulatedEnvironmentD2Ev:
   14|     43|SimulatedEnvironment::~SimulatedEnvironment() = default;
_ZN3tox4test20SimulatedEnvironment10fake_clockEv:
   32|     83|FakeClock &SimulatedEnvironment::fake_clock() { return sim_->clock(); }
_ZN3tox4test20SimulatedEnvironment11fake_memoryEv:
   34|     43|FakeMemory &SimulatedEnvironment::fake_memory() { return *global_memory_; }
_ZN3tox4test20SimulatedEnvironment11create_nodeEt:
   37|     43|{
   38|     43|    auto scoped = std::make_unique<ScopedToxSystem>();
   39|     43|    scoped->node = sim_->create_node();
   40|       |
   41|       |    // Bind port
   42|     43|    if (port != 0) {
  ------------------
  |  Branch (42:9): [True: 43, False: 0]
  ------------------
   43|     43|        Socket s = scoped->node->fake_network().socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
   44|     43|        IP_Port addr;
   45|     43|        ip_init(&addr.ip, false);
   46|     43|        addr.ip.ip.v4.uint32 = 0;
   47|     43|        addr.port = net_htons(port);
   48|     43|        scoped->node->fake_network().bind(s, &addr);
   49|     43|    }
   50|       |
   51|       |    // Get Primary Endpoint for Fuzzer
   52|     43|    scoped->endpoint = scoped->node->get_primary_socket();
   53|       |
   54|       |    // Use global Random and Memory for legacy compatibility.
   55|     43|    scoped->c_random = global_random_->c_random();
   56|     43|    scoped->c_memory = global_memory_->c_memory();
   57|       |
   58|       |    // Use Node's Network
   59|     43|    scoped->c_network = scoped->node->c_network;
   60|       |
   61|       |    // Setup System
   62|     43|    scoped->system.mem = &scoped->c_memory;
   63|     43|    scoped->system.ns = &scoped->c_network;
   64|     43|    scoped->system.rng = &scoped->c_random;
   65|       |
   66|     43|    scoped->system.mono_time_user_data = &sim_->clock();
   67|     43|    scoped->system.mono_time_callback = [](void *_Nullable user_data) -> uint64_t {
   68|     43|        return static_cast<FakeClock *>(user_data)->current_time_ms();
   69|     43|    };
   70|       |
   71|     43|    return scoped;
   72|     43|}
_ZN3tox4test20SimulatedEnvironment12advance_timeEm:
   74|  2.33k|void SimulatedEnvironment::advance_time(uint64_t ms) { sim_->advance_time(ms); }

_ZN3tox4test10SimulationC2Ev:
   97|     43|    : clock_(std::make_unique<FakeClock>())
   98|     43|    , net_(std::make_unique<NetworkUniverse>())
   99|     43|{
  100|     43|}
_ZN3tox4test10SimulationD2Ev:
  102|     43|Simulation::~Simulation() = default;
_ZN3tox4test10Simulation12advance_timeEm:
  105|  2.33k|{
  106|  2.33k|    clock_->advance(ms);
  107|  2.33k|    net_->process_events(clock_->current_time_ms());
  108|  2.33k|}
_ZN3tox4test10Simulation11create_nodeEv:
  236|     43|{
  237|     43|    auto node = std::make_unique<SimulatedNode>(*this, ++node_count_);
  238|     43|    if (net_->is_verbose()) {
  ------------------
  |  Branch (238:9): [True: 0, False: 43]
  ------------------
  239|      0|        uint32_t ip4 = net_ntohl(node->ip.ip.v4.uint32);
  240|      0|        std::cerr << "[Simulation] Created node " << node_count_ << " with IP "
  241|      0|                  << ((ip4 >> 24) & 0xFF) << "." << ((ip4 >> 16) & 0xFF) << "."
  242|      0|                  << ((ip4 >> 8) & 0xFF) << "." << (ip4 & 0xFF) << std::endl;
  243|      0|    }
  244|     43|    return node;
  245|     43|}
_ZN3tox4test13SimulatedNodeC2ERNS0_10SimulationEj:
  250|     43|    : sim_(sim)
  251|     43|    , network_(std::make_unique<FakeNetworkStack>(sim.net(), make_node_ip(node_id)))
  252|     43|    , random_(std::make_unique<FakeRandom>(12345 + node_id))  // Unique seed
  253|     43|    , memory_(std::make_unique<FakeMemory>())
  254|     43|    , c_network(network_->c_network())
  255|     43|    , c_random(random_->c_random())
  256|     43|    , c_memory(memory_->c_memory())
  257|     43|    , ip(make_node_ip(node_id))
  258|     43|{
  259|     43|}
_ZN3tox4test13SimulatedNodeD2Ev:
  261|     43|SimulatedNode::~SimulatedNode() = default;
_ZN3tox4test13SimulatedNode18get_primary_socketEv:
  331|     43|{
  332|     43|    auto sockets = network_->get_bound_udp_sockets();
  333|     43|    if (sockets.empty())
  ------------------
  |  Branch (333:9): [True: 0, False: 43]
  ------------------
  334|      0|        return nullptr;
  335|     43|    return sockets.front();  // Return the first one bound
  336|     43|}

dht_get_self_secret_key:
  163|     25|{
  164|     25|    return dht->self_secret_key;
  165|     25|}
get_close_nodes:
  752|     55|{
  753|     55|    return get_somewhat_close_nodes(
  754|     55|               dht->cur_time, public_key, nodes_list,
  755|     55|               sa_family, dht->close_clientlist,
  756|     55|               dht->friends_list, dht->num_friends,
  757|     55|               is_lan, want_announce);
  758|     55|}
dht_addfriend:
 1590|     57|{
 1591|     57|    const uint32_t friend_num = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);
 1592|       |
 1593|     57|    if (friend_num != UINT32_MAX) { /* Is friend already in DHT? */
  ------------------
  |  Branch (1593:9): [True: 0, False: 57]
  ------------------
 1594|      0|        DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
 1595|      0|        const uint32_t tmp_lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1596|       |
 1597|      0|        if (tmp_lock_token == 0) {
  ------------------
  |  Branch (1597:13): [True: 0, False: 0]
  ------------------
 1598|      0|            return -1;
 1599|      0|        }
 1600|       |
 1601|      0|        return 0;
 1602|      0|    }
 1603|       |
 1604|     57|    DHT_Friend *const temp = (DHT_Friend *)mem_vrealloc(dht->mem, dht->friends_list, dht->num_friends + 1, sizeof(DHT_Friend));
 1605|       |
 1606|     57|    if (temp == nullptr) {
  ------------------
  |  |   63|     57|#define nullptr NULL
  ------------------
  |  Branch (1606:9): [True: 2, False: 55]
  ------------------
 1607|      2|        return -1;
 1608|      2|    }
 1609|       |
 1610|     55|    dht->friends_list = temp;
 1611|     55|    DHT_Friend *const dht_friend = &dht->friends_list[dht->num_friends];
 1612|     55|    *dht_friend = empty_dht_friend;
 1613|     55|    memcpy(dht_friend->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     55|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1614|       |
 1615|     55|    dht_friend->nat.nat_ping_id = random_u64(dht->rng);
 1616|     55|    ++dht->num_friends;
 1617|       |
 1618|     55|    *lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1619|     55|    assert(*lock_token != 0); // Friend was newly allocated
  ------------------
  |  Branch (1619:5): [True: 55, False: 0]
  ------------------
 1620|       |
 1621|     55|    dht_friend->num_to_bootstrap = get_close_nodes(dht, dht_friend->public_key, dht_friend->to_bootstrap, net_family_unspec(),
 1622|     55|                                   true, false);
 1623|       |
 1624|     55|    return 0;
 1625|     55|}
cryptopacket_registerhandler:
 2431|     71|{
 2432|     71|    dht->cryptopackethandlers[byte].function = cb;
 2433|     71|    dht->cryptopackethandlers[byte].object = object;
 2434|     71|}
new_dht:
 2508|     38|{
 2509|     38|    if (net == nullptr) {
  ------------------
  |  |   63|     38|#define nullptr NULL
  ------------------
  |  Branch (2509:9): [True: 0, False: 38]
  ------------------
 2510|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2511|      0|    }
 2512|       |
 2513|     38|    DHT *const dht = (DHT *)mem_alloc(mem, sizeof(DHT));
 2514|       |
 2515|     38|    if (dht == nullptr) {
  ------------------
  |  |   63|     38|#define nullptr NULL
  ------------------
  |  Branch (2515:9): [True: 1, False: 37]
  ------------------
 2516|      1|        LOGGER_ERROR(log, "failed to allocate DHT struct (%lu bytes)", (unsigned long)sizeof(DHT));
  ------------------
  |  |   80|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2517|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 2518|      1|    }
 2519|       |
 2520|     37|    dht->ns = ns;
 2521|     37|    dht->mono_time = mono_time;
 2522|     37|    dht->cur_time = mono_time_get(mono_time);
 2523|     37|    dht->log = log;
 2524|     37|    dht->net = net;
 2525|     37|    dht->rng = rng;
 2526|     37|    dht->mem = mem;
 2527|       |
 2528|     37|    dht->hole_punching_enabled = hole_punching_enabled;
 2529|     37|    dht->lan_discovery_enabled = lan_discovery_enabled;
 2530|       |
 2531|     37|    struct Ping *temp_ping = ping_new(mem, mono_time, rng, dht, net);
 2532|       |
 2533|     37|    if (temp_ping == nullptr) {
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
  |  Branch (2533:9): [True: 3, False: 34]
  ------------------
 2534|      3|        LOGGER_ERROR(log, "failed to initialise ping");
  ------------------
  |  |   80|      3|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      3|    do {                                                                         \
  |  |  |  |   70|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 3, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      3|        }                                                                        \
  |  |  |  |   73|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 3]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2535|      3|        kill_dht(dht);
 2536|      3|        return nullptr;
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
 2537|      3|    }
 2538|       |
 2539|     34|    dht->ping = temp_ping;
 2540|       |
 2541|     34|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, &handle_nodes_request, dht);
 2542|     34|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, &handle_nodes_response, dht);
 2543|     34|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, &cryptopacket_handle, dht);
 2544|     34|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, &handle_lan_discovery, dht);
 2545|     34|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, &handle_nat_ping, dht);
  ------------------
  |  |   71|     34|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
 2546|       |
 2547|     34|#ifdef CHECK_ANNOUNCE_NODE
 2548|     34|    networking_registerhandler(dht->net, NET_PACKET_DATA_SEARCH_RESPONSE, &handle_data_search_response, dht);
 2549|     34|#endif /* CHECK_ANNOUNCE_NODE */
 2550|       |
 2551|     34|    crypto_new_keypair(rng, dht->self_public_key, dht->self_secret_key);
 2552|       |
 2553|     34|    Shared_Key_Cache *const temp_shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|     34|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   55|     34|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2554|       |
 2555|     34|    if (temp_shared_keys_recv == nullptr) {
  ------------------
  |  |   63|     34|#define nullptr NULL
  ------------------
  |  Branch (2555:9): [True: 2, False: 32]
  ------------------
 2556|      2|        LOGGER_ERROR(log, "failed to initialise shared key cache");
  ------------------
  |  |   80|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      2|    do {                                                                         \
  |  |  |  |   70|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      2|        }                                                                        \
  |  |  |  |   73|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2557|      2|        kill_dht(dht);
 2558|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 2559|      2|    }
 2560|       |
 2561|     32|    dht->shared_keys_recv = temp_shared_keys_recv;
 2562|       |
 2563|     32|    Shared_Key_Cache *const temp_shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|     32|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   55|     32|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2564|       |
 2565|     32|    if (temp_shared_keys_sent == nullptr) {
  ------------------
  |  |   63|     32|#define nullptr NULL
  ------------------
  |  Branch (2565:9): [True: 2, False: 30]
  ------------------
 2566|      2|        LOGGER_ERROR(log, "failed to initialise shared key cache");
  ------------------
  |  |   80|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      2|    do {                                                                         \
  |  |  |  |   70|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      2|        }                                                                        \
  |  |  |  |   73|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2567|      2|        kill_dht(dht);
 2568|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 2569|      2|    }
 2570|       |
 2571|     30|    dht->shared_keys_sent = temp_shared_keys_sent;
 2572|       |
 2573|     30|    Ping_Array *const temp_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   49|     30|#define DHT_PING_ARRAY_SIZE 512
  ------------------
                  Ping_Array *const temp_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   46|     30|#define PING_TIMEOUT 5
  ------------------
 2574|       |
 2575|     30|    if (temp_ping_array == nullptr) {
  ------------------
  |  |   63|     30|#define nullptr NULL
  ------------------
  |  Branch (2575:9): [True: 1, False: 29]
  ------------------
 2576|      1|        LOGGER_ERROR(log, "failed to initialise ping array");
  ------------------
  |  |   80|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2577|      1|        kill_dht(dht);
 2578|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 2579|      1|    }
 2580|       |
 2581|     29|    dht->dht_ping_array = temp_ping_array;
 2582|       |
 2583|     84|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
  ------------------
  |  |   64|     84|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2583:26): [True: 57, False: 27]
  ------------------
 2584|     57|        uint8_t random_public_key_bytes[CRYPTO_PUBLIC_KEY_SIZE];
 2585|     57|        uint8_t random_secret_key_bytes[CRYPTO_SECRET_KEY_SIZE];
 2586|       |
 2587|     57|        crypto_new_keypair(rng, random_public_key_bytes, random_secret_key_bytes);
 2588|       |
 2589|     57|        uint32_t token; // We don't intend to delete these ever, but need to pass the token
 2590|     57|        if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|     57|#define nullptr NULL
  ------------------
                      if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|     57|#define nullptr NULL
  ------------------
  |  Branch (2590:13): [True: 2, False: 55]
  ------------------
 2591|      2|            LOGGER_ERROR(log, "failed to add initial random seed DHT friends");
  ------------------
  |  |   80|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      2|    do {                                                                         \
  |  |  |  |   70|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      2|        }                                                                        \
  |  |  |  |   73|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2592|      2|            kill_dht(dht);
 2593|      2|            return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 2594|      2|        }
 2595|     57|    }
 2596|       |
 2597|     27|    if (dht->num_friends != DHT_FAKE_FRIEND_NUMBER) {
  ------------------
  |  |   64|     27|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2597:9): [True: 0, False: 27]
  ------------------
 2598|      0|        LOGGER_ERROR(log, "the RNG provided seems to be broken: it generated the same keypair twice");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2599|      0|        kill_dht(dht);
 2600|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2601|      0|    }
 2602|       |
 2603|     27|    return dht;
 2604|     27|}
do_dht:
 2607|  2.33k|{
 2608|  2.33k|    const uint64_t cur_time = mono_time_get(dht->mono_time);
 2609|       |
 2610|  2.33k|    if (dht->cur_time == cur_time) {
  ------------------
  |  Branch (2610:9): [True: 2.33k, False: 0]
  ------------------
 2611|  2.33k|        return;
 2612|  2.33k|    }
 2613|       |
 2614|      0|    dht->cur_time = cur_time;
 2615|       |
 2616|       |    // Load friends/clients if first call to do_dht
 2617|      0|    if (dht->loaded_num_nodes > 0) {
  ------------------
  |  Branch (2617:9): [True: 0, False: 0]
  ------------------
 2618|      0|        dht_connect_after_load(dht);
 2619|      0|    }
 2620|       |
 2621|      0|    do_close(dht);
 2622|      0|    do_dht_friends(dht);
 2623|      0|    do_nat(dht);
 2624|      0|    ping_iterate(dht->ping);
 2625|      0|}
kill_dht:
 2628|     37|{
 2629|     37|    if (dht == nullptr) {
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
  |  Branch (2629:9): [True: 0, False: 37]
  ------------------
 2630|      0|        return;
 2631|      0|    }
 2632|       |
 2633|     37|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
 2634|     37|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
 2635|     37|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
 2636|     37|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
 2637|     37|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   71|     37|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
 2638|       |
 2639|     37|    shared_key_cache_free(dht->shared_keys_recv);
 2640|     37|    shared_key_cache_free(dht->shared_keys_sent);
 2641|     37|    ping_array_kill(dht->dht_ping_array);
 2642|     37|    ping_kill(dht->mem, dht->ping);
 2643|     37|    mem_delete(dht->mem, dht->friends_list);
 2644|     37|    mem_delete(dht->mem, dht->loaded_nodes_list);
 2645|     37|    crypto_memzero(dht->self_secret_key, sizeof(dht->self_secret_key));
 2646|     37|    mem_delete(dht->mem, dht);
 2647|     37|}
DHT.c:get_somewhat_close_nodes:
  723|     55|{
  724|    275|    for (uint16_t i = 0; i < MAX_SENT_NODES; ++i) {
  ------------------
  |  |   43|    275|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (724:26): [True: 220, False: 55]
  ------------------
  725|    220|        nodes_list[i] = empty_node_format;
  726|    220|    }
  727|       |
  728|     55|    uint32_t num_nodes = 0;
  729|     55|    get_close_nodes_inner(
  730|     55|        cur_time, public_key,
  731|     55|        nodes_list, &num_nodes,
  732|     55|        sa_family, close_clientlist, LCLIENT_LIST,
  ------------------
  |  |   38|     55|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   35|     55|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   34|     55|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   32|     55|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  733|     55|        is_lan, want_announce);
  734|       |
  735|    137|    for (uint16_t i = 0; i < friends_list_size; ++i) {
  ------------------
  |  Branch (735:26): [True: 82, False: 55]
  ------------------
  736|     82|        const DHT_Friend *dht_friend = &friends_list[i];
  737|       |
  738|     82|        get_close_nodes_inner(
  739|     82|            cur_time, public_key,
  740|     82|            nodes_list, &num_nodes,
  741|     82|            sa_family, dht_friend->client_list, MAX_FRIEND_CLIENTS,
  ------------------
  |  |   32|     82|#define MAX_FRIEND_CLIENTS 8
  ------------------
  742|     82|            is_lan, want_announce);
  743|     82|    }
  744|       |
  745|     55|    return num_nodes;
  746|     55|}
DHT.c:get_close_nodes_inner:
  657|    137|{
  658|    137|    if (!net_family_is_ipv4(sa_family) && !net_family_is_ipv6(sa_family) && !net_family_is_unspec(sa_family)) {
  ------------------
  |  Branch (658:9): [True: 137, False: 0]
  |  Branch (658:43): [True: 137, False: 0]
  |  Branch (658:77): [True: 0, False: 137]
  ------------------
  659|      0|        return;
  660|      0|    }
  661|       |
  662|    137|    uint32_t num_nodes = *num_nodes_ptr;
  663|       |
  664|  57.1k|    for (uint32_t i = 0; i < client_list_length; ++i) {
  ------------------
  |  Branch (664:26): [True: 56.9k, False: 137]
  ------------------
  665|  56.9k|        const Client_data *const client = &client_list[i];
  666|  56.9k|        const IPPTsPng *ipptp;
  667|       |
  668|  56.9k|        if (net_family_is_ipv4(sa_family)) {
  ------------------
  |  Branch (668:13): [True: 0, False: 56.9k]
  ------------------
  669|      0|            ipptp = &client->assoc4;
  670|  56.9k|        } else if (net_family_is_ipv6(sa_family)) {
  ------------------
  |  Branch (670:20): [True: 0, False: 56.9k]
  ------------------
  671|      0|            ipptp = &client->assoc6;
  672|  56.9k|        } else if (client->assoc4.timestamp >= client->assoc6.timestamp) {
  ------------------
  |  Branch (672:20): [True: 56.9k, False: 0]
  ------------------
  673|  56.9k|            ipptp = &client->assoc4;
  674|  56.9k|        } else {
  675|      0|            ipptp = &client->assoc6;
  676|      0|        }
  677|       |
  678|       |        /* node not in a good condition? */
  679|  56.9k|        if (assoc_timeout(cur_time, ipptp)) {
  ------------------
  |  Branch (679:13): [True: 56.9k, False: 0]
  ------------------
  680|  56.9k|            continue;
  681|  56.9k|        }
  682|       |
  683|       |        /* don't send LAN ips to non LAN peers */
  684|      0|        if (ip_is_lan(&ipptp->ip_port.ip) && !is_lan) {
  ------------------
  |  Branch (684:13): [True: 0, False: 0]
  |  Branch (684:46): [True: 0, False: 0]
  ------------------
  685|      0|            continue;
  686|      0|        }
  687|       |
  688|      0|#ifdef CHECK_ANNOUNCE_NODE
  689|       |
  690|      0|        if (want_announce && !client->announce_node) {
  ------------------
  |  Branch (690:13): [True: 0, False: 0]
  |  Branch (690:30): [True: 0, False: 0]
  ------------------
  691|      0|            continue;
  692|      0|        }
  693|       |
  694|      0|#endif /* CHECK_ANNOUNCE_NODE */
  695|       |
  696|       |        /* node already in list? */
  697|      0|        if (index_of_node_pk(nodes_list, num_nodes, client->public_key) != UINT32_MAX) {
  ------------------
  |  Branch (697:13): [True: 0, False: 0]
  ------------------
  698|      0|            continue;
  699|      0|        }
  700|       |
  701|      0|        if (num_nodes < MAX_SENT_NODES) {
  ------------------
  |  |   43|      0|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (701:13): [True: 0, False: 0]
  ------------------
  702|      0|            memcpy(nodes_list[num_nodes].public_key, client->public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  703|      0|            nodes_list[num_nodes].ip_port = ipptp->ip_port;
  704|      0|            ++num_nodes;
  705|      0|        } else {
  706|       |            // TODO(zugz): this could be made significantly more efficient by
  707|       |            // using a version of add_to_list which works with a sorted list.
  708|      0|            add_to_list(nodes_list, MAX_SENT_NODES, client->public_key, &ipptp->ip_port, public_key);
  ------------------
  |  |   43|      0|#define MAX_SENT_NODES 4
  ------------------
  709|      0|        }
  710|      0|    }
  711|       |
  712|    137|    *num_nodes_ptr = num_nodes;
  713|    137|}
DHT.c:index_of_friend_pk:
  486|     57|{
  487|     57|    assert(size == 0 || array != nullptr);
  ------------------
  |  Branch (487:5): [True: 29, False: 28]
  |  Branch (487:5): [True: 28, False: 0]
  ------------------
  488|     85|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (488:26): [True: 28, False: 57]
  ------------------
  489|     28|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (489:13): [True: 0, False: 28]
  ------------------
  490|      0|            return i;
  491|      0|        }
  492|     28|    }
  493|       |
  494|     57|    return UINT32_MAX;
  495|     57|}
DHT.c:dht_friend_lock:
 1536|     55|{
 1537|       |    // find first free slot
 1538|     55|    uint8_t lock_num;
 1539|     55|    uint32_t lock_token = 0;
 1540|     55|    for (lock_num = 0; lock_num < DHT_FRIEND_MAX_LOCKS; ++lock_num) {
  ------------------
  |  |   52|     55|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1540:24): [True: 55, False: 0]
  ------------------
 1541|     55|        lock_token = UINT32_C(1) << lock_num;
 1542|     55|        if ((dht_friend->lock_flags & lock_token) == 0) {
  ------------------
  |  Branch (1542:13): [True: 55, False: 0]
  ------------------
 1543|     55|            break;
 1544|     55|        }
 1545|     55|    }
 1546|       |
 1547|       |    // One of the conditions would be enough, but static analyzers don't get that
 1548|     55|    if (lock_token == 0 || lock_num == DHT_FRIEND_MAX_LOCKS) {
  ------------------
  |  |   52|     55|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1548:9): [True: 0, False: 55]
  |  Branch (1548:28): [True: 0, False: 55]
  ------------------
 1549|      0|        return 0;
 1550|      0|    }
 1551|       |
 1552|       |    // Claim that slot
 1553|     55|    dht_friend->lock_flags |= lock_token;
 1554|       |
 1555|     55|    dht_friend->callbacks[lock_num].ip_callback = ip_callback;
 1556|     55|    dht_friend->callbacks[lock_num].data = data;
 1557|     55|    dht_friend->callbacks[lock_num].number = number;
 1558|       |
 1559|     55|    return lock_token;
 1560|     55|}
DHT.c:assoc_timeout:
  206|  56.9k|{
  207|  56.9k|    return (assoc->timestamp + BAD_NODE_TIMEOUT) <= cur_time;
  ------------------
  |  |   57|  56.9k|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   52|  56.9k|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   55|  56.9k|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   52|  56.9k|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   56|  56.9k|#define PING_ROUNDTRIP 2
  |  |  ------------------
  ------------------
  208|  56.9k|}

set_packet_tcp_connection_callback:
  571|     24|{
  572|     24|    tcp_c->tcp_data_callback = tcp_data_callback;
  573|     24|    tcp_c->tcp_data_callback_object = object;
  574|     24|}
set_oob_packet_tcp_connection_callback:
  578|     24|{
  579|     24|    tcp_c->tcp_oob_callback = tcp_oob_callback;
  580|     24|    tcp_c->tcp_oob_callback_object = object;
  581|     24|}
new_tcp_connections:
 1623|     25|{
 1624|     25|    assert(logger != nullptr);
  ------------------
  |  Branch (1624:5): [True: 25, False: 0]
  ------------------
 1625|     25|    assert(mem != nullptr);
  ------------------
  |  Branch (1625:5): [True: 25, False: 0]
  ------------------
 1626|     25|    assert(rng != nullptr);
  ------------------
  |  Branch (1626:5): [True: 25, False: 0]
  ------------------
 1627|     25|    assert(ns != nullptr);
  ------------------
  |  Branch (1627:5): [True: 25, False: 0]
  ------------------
 1628|     25|    assert(mono_time != nullptr);
  ------------------
  |  Branch (1628:5): [True: 25, False: 0]
  ------------------
 1629|       |
 1630|     25|    if (secret_key == nullptr) {
  ------------------
  |  |   63|     25|#define nullptr NULL
  ------------------
  |  Branch (1630:9): [True: 0, False: 25]
  ------------------
 1631|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1632|      0|    }
 1633|       |
 1634|     25|    TCP_Connections *temp = (TCP_Connections *)mem_alloc(mem, sizeof(TCP_Connections));
 1635|       |
 1636|     25|    if (temp == nullptr) {
  ------------------
  |  |   63|     25|#define nullptr NULL
  ------------------
  |  Branch (1636:9): [True: 1, False: 24]
  ------------------
 1637|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 1638|      1|    }
 1639|       |
 1640|     24|    temp->net_profile = tcp_np;
 1641|     24|    temp->logger = logger;
 1642|     24|    temp->mem = mem;
 1643|     24|    temp->rng = rng;
 1644|     24|    temp->mono_time = mono_time;
 1645|     24|    temp->ns = ns;
 1646|       |
 1647|     24|    memcpy(temp->self_secret_key, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   49|     24|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 1648|     24|    crypto_derive_public_key(temp->self_public_key, temp->self_secret_key);
 1649|     24|    temp->proxy_info = *proxy_info;
 1650|       |
 1651|     24|    return temp;
 1652|     25|}
do_tcp_connections:
 1751|  2.33k|{
 1752|  2.33k|    do_tcp_conns(logger, tcp_c, userdata);
 1753|  2.33k|    kill_nonused_tcp(tcp_c);
 1754|  2.33k|}
kill_tcp_connections:
 1757|     24|{
 1758|     24|    if (tcp_c == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (1758:9): [True: 0, False: 24]
  ------------------
 1759|      0|        return;
 1760|      0|    }
 1761|       |
 1762|     24|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1762:26): [True: 0, False: 24]
  ------------------
 1763|      0|        kill_tcp_connection(tcp_c->tcp_connections[i].connection);
 1764|      0|    }
 1765|       |
 1766|     24|    crypto_memzero(tcp_c->self_secret_key, sizeof(tcp_c->self_secret_key));
 1767|       |
 1768|     24|    mem_delete(tcp_c->mem, tcp_c->tcp_connections);
 1769|     24|    mem_delete(tcp_c->mem, tcp_c->connections);
 1770|     24|    mem_delete(tcp_c->mem, tcp_c);
 1771|     24|}
TCP_connection.c:do_tcp_conns:
 1655|  2.33k|{
 1656|  2.33k|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1656:26): [True: 0, False: 2.33k]
  ------------------
 1657|      0|        TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1658|      0|        if (tcp_con == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1658:13): [True: 0, False: 0]
  ------------------
 1659|      0|            continue;
 1660|      0|        }
 1661|       |
 1662|      0|        if (tcp_con->status != TCP_CONN_SLEEPING) {
  ------------------
  |  |   36|      0|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (1662:13): [True: 0, False: 0]
  ------------------
 1663|      0|            if (tcp_con->connection == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1663:17): [True: 0, False: 0]
  ------------------
 1664|      0|                LOGGER_ERROR(logger, "TCP connection is null for tcp_con");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1665|      0|                continue;
 1666|      0|            }
 1667|      0|            do_tcp_connection(logger, tcp_c->mono_time, tcp_con->connection, userdata);
 1668|       |
 1669|       |            /* callbacks can change TCP connection address. */
 1670|      0|            tcp_con = get_tcp_connection(tcp_c, i);
 1671|       |
 1672|       |            // Make sure the TCP connection wasn't dropped in any of the callbacks.
 1673|      0|            assert(tcp_con != nullptr);
  ------------------
  |  Branch (1673:13): [True: 0, False: 0]
  ------------------
 1674|       |
 1675|      0|            if (tcp_con->connection == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1675:17): [True: 0, False: 0]
  ------------------
 1676|      0|                LOGGER_ERROR(logger, "TCP connection is null for tcp_con");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1677|      0|                continue;
 1678|      0|            }
 1679|      0|            if (tcp_con_status(tcp_con->connection) == TCP_CLIENT_DISCONNECTED) {
  ------------------
  |  Branch (1679:17): [True: 0, False: 0]
  ------------------
 1680|      0|                if (tcp_con->status == TCP_CONN_CONNECTED) {
  ------------------
  |  |   33|      0|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (1680:21): [True: 0, False: 0]
  ------------------
 1681|      0|                    reconnect_tcp_relay_connection(tcp_c, i);
 1682|      0|                } else {
 1683|      0|                    kill_tcp_relay_connection(tcp_c, i);
 1684|      0|                }
 1685|       |
 1686|      0|                continue;
 1687|      0|            }
 1688|       |
 1689|      0|            if (tcp_con->connection == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1689:17): [True: 0, False: 0]
  ------------------
 1690|      0|                LOGGER_ERROR(logger, "TCP connection is null for tcp_con");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1691|      0|                continue;
 1692|      0|            }
 1693|      0|            if (tcp_con->status == TCP_CONN_VALID && tcp_con_status(tcp_con->connection) == TCP_CLIENT_CONFIRMED) {
  ------------------
  |  |   30|      0|#define TCP_CONN_VALID 1
  ------------------
  |  Branch (1693:17): [True: 0, False: 0]
  |  Branch (1693:54): [True: 0, False: 0]
  ------------------
 1694|      0|                tcp_relay_on_online(tcp_c, i);
 1695|      0|            }
 1696|       |
 1697|      0|            if (tcp_con->status == TCP_CONN_CONNECTED
  ------------------
  |  |   33|      0|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (1697:17): [True: 0, False: 0]
  ------------------
 1698|      0|                    && !tcp_con->onion && tcp_con->lock_count > 0
  ------------------
  |  Branch (1698:24): [True: 0, False: 0]
  |  Branch (1698:43): [True: 0, False: 0]
  ------------------
 1699|      0|                    && tcp_con->lock_count == tcp_con->sleep_count
  ------------------
  |  Branch (1699:24): [True: 0, False: 0]
  ------------------
 1700|      0|                    && mono_time_is_timeout(tcp_c->mono_time, tcp_con->connected_time, TCP_CONNECTION_ANNOUNCE_TIMEOUT)) {
  ------------------
  |  |   45|      0|#define TCP_CONNECTION_ANNOUNCE_TIMEOUT TCP_CONNECTION_TIMEOUT
  |  |  ------------------
  |  |  |  |   29|      0|#define TCP_CONNECTION_TIMEOUT 10
  |  |  ------------------
  ------------------
  |  Branch (1700:24): [True: 0, False: 0]
  ------------------
 1701|      0|                sleep_tcp_relay_connection(tcp_c, i);
 1702|      0|            }
 1703|      0|        }
 1704|       |
 1705|      0|        if (tcp_con->status == TCP_CONN_SLEEPING && tcp_con->unsleep) {
  ------------------
  |  |   36|      0|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (1705:13): [True: 0, False: 0]
  |  Branch (1705:53): [True: 0, False: 0]
  ------------------
 1706|      0|            unsleep_tcp_relay_connection(tcp_c, i);
 1707|      0|        }
 1708|      0|    }
 1709|  2.33k|}
TCP_connection.c:kill_nonused_tcp:
 1712|  2.33k|{
 1713|  2.33k|    if (tcp_c == nullptr) {
  ------------------
  |  |   63|  2.33k|#define nullptr NULL
  ------------------
  |  Branch (1713:9): [True: 0, False: 2.33k]
  ------------------
 1714|      0|        return;
 1715|      0|    }
 1716|       |
 1717|  2.33k|    if (tcp_c->tcp_connections_length <= RECOMMENDED_FRIEND_TCP_CONNECTIONS) {
  ------------------
  |  |   50|  2.33k|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  ------------------
  |  |  |  |   42|  2.33k|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  ------------------
  ------------------
  |  Branch (1717:9): [True: 2.33k, False: 0]
  ------------------
 1718|  2.33k|        return;
 1719|  2.33k|    }
 1720|       |
 1721|      0|    const uint32_t num_online = tcp_connected_relays_count(tcp_c);
 1722|       |
 1723|      0|    if (num_online <= RECOMMENDED_FRIEND_TCP_CONNECTIONS) {
  ------------------
  |  |   50|      0|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  ------------------
  |  |  |  |   42|      0|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  ------------------
  ------------------
  |  Branch (1723:9): [True: 0, False: 0]
  ------------------
 1724|      0|        return;
 1725|      0|    }
 1726|       |
 1727|      0|    const uint32_t max_kill_count = num_online - RECOMMENDED_FRIEND_TCP_CONNECTIONS;
  ------------------
  |  |   50|      0|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  ------------------
  |  |  |  |   42|      0|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  ------------------
  ------------------
 1728|      0|    uint32_t kill_count = 0;
 1729|       |
 1730|      0|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length && kill_count < max_kill_count; ++i) {
  ------------------
  |  Branch (1730:26): [True: 0, False: 0]
  |  Branch (1730:63): [True: 0, False: 0]
  ------------------
 1731|      0|        const TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1732|       |
 1733|      0|        if (tcp_con == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1733:13): [True: 0, False: 0]
  ------------------
 1734|      0|            continue;
 1735|      0|        }
 1736|       |
 1737|      0|        if (tcp_con->status == TCP_CONN_CONNECTED) {
  ------------------
  |  |   33|      0|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (1737:13): [True: 0, False: 0]
  ------------------
 1738|      0|            if (tcp_con->onion || tcp_con->lock_count > 0) {  // connection is in use so we skip it
  ------------------
  |  Branch (1738:17): [True: 0, False: 0]
  |  Branch (1738:35): [True: 0, False: 0]
  ------------------
 1739|      0|                continue;
 1740|      0|            }
 1741|       |
 1742|      0|            if (mono_time_is_timeout(tcp_c->mono_time, tcp_con->connected_time, TCP_CONNECTION_ANNOUNCE_TIMEOUT)) {
  ------------------
  |  |   45|      0|#define TCP_CONNECTION_ANNOUNCE_TIMEOUT TCP_CONNECTION_TIMEOUT
  |  |  ------------------
  |  |  |  |   29|      0|#define TCP_CONNECTION_TIMEOUT 10
  |  |  ------------------
  ------------------
  |  Branch (1742:17): [True: 0, False: 0]
  ------------------
 1743|      0|                kill_tcp_relay_connection(tcp_c, i);
 1744|      0|                ++kill_count;
 1745|      0|            }
 1746|      0|        }
 1747|      0|    }
 1748|      0|}

crypto_memzero:
  115|    147|{
  116|    147|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  117|    147|    memzero((uint8_t *)data, length);
  118|       |#else
  119|       |    sodium_memzero(data, length);
  120|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  121|    147|}
crypto_memlock:
  124|     62|{
  125|     62|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  126|     62|    return false;
  127|       |#else
  128|       |
  129|       |    return sodium_mlock(data, length) == 0;
  130|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  131|     62|}
crypto_memunlock:
  134|     62|{
  135|     62|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  136|     62|    return false;
  137|       |#else
  138|       |
  139|       |    return sodium_munlock(data, length) == 0;
  140|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  141|     62|}
pk_equal:
  144|     28|{
  145|     28|    return memcmp(pk1, pk2, CRYPTO_PUBLIC_KEY_SIZE) == 0;
  ------------------
  |  |   44|     28|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  146|     28|}
random_u64:
  190|     55|{
  191|     55|    uint64_t randnum;
  192|     55|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  193|     55|    return randnum;
  194|     55|}
new_symmetric_key:
  421|     24|{
  422|     24|    random_bytes(rng, key, CRYPTO_SYMMETRIC_KEY_SIZE);
  ------------------
  |  |   59|     24|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  ------------------
  |  |  |  |   54|     24|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  ------------------
  ------------------
  423|     24|}
crypto_new_keypair:
  428|    115|{
  429|    115|    random_bytes(rng, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   49|    115|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
  430|    115|    memzero(public_key, CRYPTO_PUBLIC_KEY_SIZE);  // Make MSAN happy
  ------------------
  |  |   44|    115|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  431|    115|    crypto_derive_public_key(public_key, secret_key);
  432|    115|    return 0;
  433|    115|}
crypto_derive_public_key:
  437|    139|{
  438|    139|    crypto_scalarmult_curve25519_base(public_key, secret_key);
  439|    139|}
random_bytes:
  488|    194|{
  489|    194|    rng_bytes(rng, bytes, length);
  490|    194|}

bs_list_init:
  136|     24|{
  137|     24|    list->mem = mem;
  138|       |
  139|       |    // set initial values
  140|     24|    list->n = 0;
  141|     24|    list->element_size = element_size;
  142|     24|    list->capacity = 0;
  143|     24|    list->data = nullptr;
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  144|     24|    list->ids = nullptr;
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  145|     24|    list->cmp_callback = cmp_callback;
  146|       |
  147|     24|    if (initial_capacity != 0) {
  ------------------
  |  Branch (147:9): [True: 24, False: 0]
  ------------------
  148|     24|        if (!resize(list, initial_capacity)) {
  ------------------
  |  Branch (148:13): [True: 2, False: 22]
  ------------------
  149|      2|            return 0;
  150|      2|        }
  151|     24|    }
  152|       |
  153|     22|    list->capacity = initial_capacity;
  154|       |
  155|     22|    return 1;
  156|     24|}
bs_list_free:
  159|     24|{
  160|     24|    if (list == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (160:9): [True: 0, False: 24]
  ------------------
  161|      0|        return;
  162|      0|    }
  163|       |
  164|       |    // free both arrays
  165|     24|    mem_delete(list->mem, list->data);
  166|     24|    list->data = nullptr;
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  167|       |
  168|     24|    mem_delete(list->mem, list->ids);
  169|       |    list->ids = nullptr;
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  170|     24|}
list.c:resize:
  110|     24|{
  111|     24|    if (new_size == 0) {
  ------------------
  |  Branch (111:9): [True: 0, False: 24]
  ------------------
  112|      0|        bs_list_free(list);
  113|      0|        return true;
  114|      0|    }
  115|       |
  116|     24|    uint8_t *data = (uint8_t *)mem_brealloc(list->mem, list->data, new_size * list->element_size);
  117|       |
  118|     24|    if (data == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (118:9): [True: 1, False: 23]
  ------------------
  119|      1|        return false;
  120|      1|    }
  121|       |
  122|     23|    list->data = data;
  123|       |
  124|     23|    int *ids = (int *)mem_vrealloc(list->mem, list->ids, new_size, sizeof(int));
  125|       |
  126|     23|    if (ids == nullptr) {
  ------------------
  |  |   63|     23|#define nullptr NULL
  ------------------
  |  Branch (126:9): [True: 1, False: 22]
  ------------------
  127|      1|        return false;
  128|      1|    }
  129|       |
  130|     22|    list->ids = ids;
  131|       |
  132|       |    return true;
  133|     23|}

logger_new:
   33|     43|{
   34|     43|    Logger *log = (Logger *)mem_alloc(mem, sizeof(Logger));
   35|       |
   36|     43|    if (log == nullptr) {
  ------------------
  |  |   63|     43|#define nullptr NULL
  ------------------
  |  Branch (36:9): [True: 1, False: 42]
  ------------------
   37|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
   38|      1|    }
   39|       |
   40|     42|    log->mem = mem;
   41|       |
   42|     42|    return log;
   43|     43|}
logger_kill:
   46|     42|{
   47|     42|    if (log == nullptr) {
  ------------------
  |  |   63|     42|#define nullptr NULL
  ------------------
  |  Branch (47:9): [True: 0, False: 42]
  ------------------
   48|      0|        return;
   49|      0|    }
   50|       |
   51|     42|    mem_delete(log->mem, log);
   52|     42|}
logger_write:
   64|     13|{
   65|     13|    if (log == nullptr) {
  ------------------
  |  |   63|     13|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 0, False: 13]
  ------------------
   66|      0|        return;
   67|      0|    }
   68|       |
   69|     13|    if (log->callback == nullptr) {
  ------------------
  |  |   63|     13|#define nullptr NULL
  ------------------
  |  Branch (69:9): [True: 13, False: 0]
  ------------------
   70|     13|        return;
   71|     13|    }
   72|       |
   73|       |    // Only pass the file name, not the entire file path, for privacy reasons.
   74|       |    // The full path may contain PII of the person compiling toxcore (their
   75|       |    // username and directory layout).
   76|      0|    const char *filename = strrchr(file, '/');
   77|      0|    if (filename != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (77:9): [True: 0, False: 0]
  ------------------
   78|      0|        file = &filename[1];
   79|      0|    }
   80|       |#if defined(_WIN32) || defined(__CYGWIN__)
   81|       |    // On Windows, the path separator *may* be a backslash, so we look for that
   82|       |    // one too.
   83|       |    const char *windows_filename = strrchr(file, '\\');
   84|       |    file = windows_filename != nullptr ? windows_filename + 1 : file;
   85|       |#endif /* WIN32 */
   86|       |
   87|       |    // Format message
   88|      0|    char msg[1024];
   89|      0|    va_list args;
   90|      0|    va_start(args, format);
   91|      0|    vsnprintf(msg, sizeof(msg), format, args);
   92|      0|    va_end(args);
   93|       |
   94|      0|    log->callback(log->context, level, file, line, func, msg, log->userdata);
   95|      0|}

mem_balloc:
   13|    618|{
   14|    618|    void *const ptr = mem->funcs->malloc_callback(mem->user_data, size);
   15|    618|    return ptr;
   16|    618|}
mem_brealloc:
   19|    104|{
   20|    104|    void *const new_ptr = mem->funcs->realloc_callback(mem->user_data, ptr, size);
   21|    104|    return new_ptr;
   22|    104|}
mem_alloc:
   25|    618|{
   26|    618|    void *const ptr = mem_balloc(mem, size);
   27|    618|    if (ptr != nullptr) {
  ------------------
  |  |   63|    618|#define nullptr NULL
  ------------------
  |  Branch (27:9): [True: 601, False: 17]
  ------------------
   28|    601|        memset(ptr, 0, size);
   29|    601|    }
   30|    618|    return ptr;
   31|    618|}
mem_valloc:
   34|    128|{
   35|    128|    const uint32_t bytes = nmemb * size;
   36|       |
   37|    128|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (37:9): [True: 128, False: 0]
  |  Branch (37:22): [True: 0, False: 128]
  ------------------
   38|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   39|      0|    }
   40|       |
   41|    128|    void *const ptr = mem_alloc(mem, bytes);
   42|    128|    return ptr;
   43|    128|}
mem_vrealloc:
   46|     80|{
   47|     80|    const uint32_t bytes = nmemb * size;
   48|       |
   49|     80|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (49:9): [True: 80, False: 0]
  |  Branch (49:22): [True: 0, False: 80]
  ------------------
   50|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   51|      0|    }
   52|       |
   53|     80|    void *const new_ptr = mem_brealloc(mem, ptr, bytes);
   54|     80|    return new_ptr;
   55|     80|}
mem_delete:
   58|    771|{
   59|    771|    mem->funcs->dealloc_callback(mem->user_data, ptr);
   60|    771|}

mono_time_new:
  111|     40|{
  112|     40|    Mono_Time *mono_time = (Mono_Time *)mem_alloc(mem, sizeof(Mono_Time));
  113|       |
  114|     40|    if (mono_time == nullptr) {
  ------------------
  |  |   63|     40|#define nullptr NULL
  ------------------
  |  Branch (114:9): [True: 1, False: 39]
  ------------------
  115|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  116|      1|    }
  117|       |
  118|     39|#ifndef ESP_PLATFORM
  119|     39|    pthread_rwlock_t *const rwlock = (pthread_rwlock_t *)mem_alloc(mem, sizeof(pthread_rwlock_t));
  120|       |
  121|     39|    if (rwlock == nullptr) {
  ------------------
  |  |   63|     39|#define nullptr NULL
  ------------------
  |  Branch (121:9): [True: 1, False: 38]
  ------------------
  122|      1|        mem_delete(mem, mono_time);
  123|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  124|      1|    }
  125|       |
  126|     38|    if (pthread_rwlock_init(rwlock, nullptr) != 0) {
  ------------------
  |  |   63|     38|#define nullptr NULL
  ------------------
  |  Branch (126:9): [True: 0, False: 38]
  ------------------
  127|      0|        mem_delete(mem, rwlock);
  128|      0|        mem_delete(mem, mono_time);
  129|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  130|      0|    }
  131|       |
  132|     38|    mono_time->time_update_lock = rwlock;
  133|     38|#endif /* ESP_PLATFORM */
  134|       |
  135|     38|    mono_time_set_current_time_callback(mono_time, current_time_callback, user_data);
  136|       |
  137|     38|    mono_time->cur_time = 0;
  138|     38|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  139|       |    // Maximum reproducibility. Never return time = 0.
  140|     38|    mono_time->base_time = 1000000000;
  141|       |#else
  142|       |    // Never return time = 0 in case time() returns 0 (e.g. on microcontrollers
  143|       |    // without battery-powered RTC or ones where NTP didn't initialise it yet).
  144|       |    mono_time->base_time = max_u64(1, (uint64_t)time(nullptr)) * UINT64_C(1000) - current_time_monotonic(mono_time);
  145|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  146|       |
  147|     38|    mono_time_update(mono_time);
  148|       |
  149|     38|    return mono_time;
  150|     38|}
mono_time_free:
  153|     38|{
  154|     38|    if (mono_time == nullptr) {
  ------------------
  |  |   63|     38|#define nullptr NULL
  ------------------
  |  Branch (154:9): [True: 0, False: 38]
  ------------------
  155|      0|        return;
  156|      0|    }
  157|     38|#ifndef ESP_PLATFORM
  158|     38|    pthread_rwlock_destroy(mono_time->time_update_lock);
  159|     38|    mem_delete(mem, mono_time->time_update_lock);
  160|     38|#endif /* ESP_PLATFORM */
  161|     38|    mem_delete(mem, mono_time);
  162|     38|}
mono_time_update:
  165|     38|{
  166|     38|    const uint64_t cur_time =
  167|     38|        mono_time->base_time + mono_time->current_time_callback(mono_time->user_data);
  168|       |
  169|     38|#ifndef ESP_PLATFORM
  170|     38|    pthread_rwlock_wrlock(mono_time->time_update_lock);
  171|     38|#endif /* ESP_PLATFORM */
  172|     38|    mono_time->cur_time = cur_time;
  173|     38|#ifndef ESP_PLATFORM
  174|     38|    pthread_rwlock_unlock(mono_time->time_update_lock);
  175|     38|#endif /* ESP_PLATFORM */
  176|     38|}
mono_time_get_ms:
  179|  2.46k|{
  180|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  181|       |    // Fuzzing is only single thread for now, no locking needed */
  182|       |    pthread_rwlock_rdlock(mono_time->time_update_lock);
  183|       |#endif /* !ESP_PLATFORM */
  184|  2.46k|    const uint64_t cur_time = mono_time->cur_time;
  185|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  186|       |    pthread_rwlock_unlock(mono_time->time_update_lock);
  187|       |#endif /* !ESP_PLATFORM */
  188|  2.46k|    return cur_time;
  189|  2.46k|}
mono_time_get:
  192|  2.44k|{
  193|       |    return mono_time_get_ms(mono_time) / UINT64_C(1000);
  194|  2.44k|}
mono_time_set_current_time_callback:
  203|     38|{
  204|     38|    if (current_time_callback == nullptr) {
  ------------------
  |  |   63|     38|#define nullptr NULL
  ------------------
  |  Branch (204:9): [True: 0, False: 38]
  ------------------
  205|      0|        mono_time->current_time_callback = current_time_monotonic_default;
  206|      0|        mono_time->user_data = mono_time;
  207|     38|    } else {
  208|     38|        mono_time->current_time_callback = current_time_callback;
  209|     38|        mono_time->user_data = user_data;
  210|     38|    }
  211|     38|}
current_time_monotonic:
  219|  2.33k|{
  220|  2.33k|    return mono_time->current_time_callback(mono_time->user_data);
  221|  2.33k|}

net_socket_to_native:
    9|  2.74k|{
   10|  2.74k|    return (force int)sock.value;
   11|  2.74k|}
net_socket_from_native:
   14|    123|{
   15|    123|    const Socket res = {(force Socket_Value)sock};
   16|    123|    return res;
   17|    123|}
ns_close:
   20|     40|{
   21|     40|    return ns->funcs->close(ns->obj, sock);
   22|     40|}
ns_bind:
   30|     80|{
   31|     80|    return ns->funcs->bind(ns->obj, sock, addr);
   32|     80|}
ns_recvfrom:
   55|  2.33k|{
   56|  2.33k|    return ns->funcs->recvfrom(ns->obj, sock, buf, len, addr);
   57|  2.33k|}
ns_socket:
   70|     40|{
   71|     40|    return ns->funcs->socket(ns->obj, domain, type, proto);
   72|     40|}
ns_socket_nonblock:
   75|     40|{
   76|     40|    return ns->funcs->socket_nonblock(ns->obj, sock, nonblock);
   77|     40|}
ns_getsockopt:
   80|     40|{
   81|     40|    return ns->funcs->getsockopt(ns->obj, sock, level, optname, optval, optlen);
   82|     40|}
ns_setsockopt:
   85|    160|{
   86|    160|    return ns->funcs->setsockopt(ns->obj, sock, level, optname, optval, optlen);
   87|    160|}
net_family_unspec:
  175|     55|{
  176|     55|    return family_unspec;
  177|     55|}
net_family_ipv4:
  180|    212|{
  181|    212|    return family_ipv4;
  182|    212|}
net_family_ipv6:
  185|     84|{
  186|     84|    return family_ipv6;
  187|     84|}
net_family_is_unspec:
  220|  2.51k|{
  221|  2.51k|    return family.value == family_unspec.value;
  222|  2.51k|}
net_family_is_ipv4:
  225|  57.4k|{
  226|  57.4k|    return family.value == family_ipv4.value;
  227|  57.4k|}
net_family_is_ipv6:
  230|  57.3k|{
  231|  57.3k|    return family.value == family_ipv6.value;
  232|  57.3k|}

new_keys:
 2936|     24|{
 2937|     24|    crypto_new_keypair(c->rng, c->self_public_key, c->self_secret_key);
 2938|     24|}
new_net_crypto:
 2965|     26|{
 2966|     26|    if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|     52|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|     52|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|     52|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|     52|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|     26|#define nullptr NULL
  ------------------
  |  Branch (2966:9): [True: 0, False: 26]
  |  Branch (2966:27): [True: 0, False: 26]
  |  Branch (2966:51): [True: 0, False: 26]
  |  Branch (2966:96): [True: 0, False: 26]
  |  Branch (2966:141): [True: 0, False: 26]
  ------------------
 2967|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2968|      0|    }
 2969|       |
 2970|     26|    Net_Crypto *temp = (Net_Crypto *)mem_alloc(mem, sizeof(Net_Crypto));
 2971|       |
 2972|     26|    if (temp == nullptr) {
  ------------------
  |  |   63|     26|#define nullptr NULL
  ------------------
  |  Branch (2972:9): [True: 1, False: 25]
  ------------------
 2973|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 2974|      1|    }
 2975|       |
 2976|     25|    temp->log = log;
 2977|     25|    temp->mem = mem;
 2978|     25|    temp->rng = rng;
 2979|     25|    temp->mono_time = mono_time;
 2980|     25|    temp->ns = ns;
 2981|     25|    temp->net = net;
 2982|       |
 2983|     25|    temp->dht = dht;
 2984|     25|    temp->dht_funcs = dht_funcs;
 2985|       |
 2986|     25|    TCP_Connections *const tcp_c = new_tcp_connections(log, mem, rng, ns, mono_time, dht_funcs->get_self_secret_key(dht), proxy_info, tcp_np);
 2987|       |
 2988|     25|    if (tcp_c == nullptr) {
  ------------------
  |  |   63|     25|#define nullptr NULL
  ------------------
  |  Branch (2988:9): [True: 1, False: 24]
  ------------------
 2989|      1|        mem_delete(mem, temp);
 2990|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 2991|      1|    }
 2992|       |
 2993|     24|    temp->tcp_c = tcp_c;
 2994|       |
 2995|     24|    set_packet_tcp_connection_callback(temp->tcp_c, &tcp_data_callback, temp);
 2996|     24|    set_oob_packet_tcp_connection_callback(temp->tcp_c, &tcp_oob_callback, temp);
 2997|       |
 2998|     24|    new_keys(temp);
 2999|     24|    new_symmetric_key(rng, temp->secret_symmetric_key);
 3000|       |
 3001|     24|    temp->current_sleep_time = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |  111|     24|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 3002|       |
 3003|     24|    networking_registerhandler(net, NET_PACKET_COOKIE_REQUEST, &udp_handle_cookie_request, temp);
 3004|     24|    networking_registerhandler(net, NET_PACKET_COOKIE_RESPONSE, &udp_handle_packet, temp);
 3005|     24|    networking_registerhandler(net, NET_PACKET_CRYPTO_HS, &udp_handle_packet, temp);
 3006|     24|    networking_registerhandler(net, NET_PACKET_CRYPTO_DATA, &udp_handle_packet, temp);
 3007|       |
 3008|     24|    bs_list_init(&temp->ip_port_list, mem, sizeof(IP_Port), 8, ipport_cmp_handler);
 3009|       |
 3010|     24|    temp->cookie_request_tokens = COOKIE_REQUEST_MAX_TOKENS;
  ------------------
  |  |  212|     24|#define COOKIE_REQUEST_MAX_TOKENS 10
  ------------------
 3011|     24|    temp->cookie_request_last_time = mono_time_get_ms(mono_time);
 3012|       |
 3013|     24|    return temp;
 3014|     25|}
do_net_crypto:
 3052|  2.33k|{
 3053|  2.33k|    kill_timedout(c, userdata);
 3054|  2.33k|    do_tcp(c, userdata);
 3055|  2.33k|    send_crypto_packets(c);
 3056|  2.33k|}
kill_net_crypto:
 3059|     24|{
 3060|     24|    if (c == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (3060:9): [True: 0, False: 24]
  ------------------
 3061|      0|        return;
 3062|      0|    }
 3063|       |
 3064|     24|    const Memory *mem = c->mem;
 3065|       |
 3066|     24|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (3066:26): [True: 0, False: 24]
  ------------------
 3067|      0|        crypto_kill(c, i);
 3068|      0|    }
 3069|       |
 3070|     24|    kill_tcp_connections(c->tcp_c);
 3071|     24|    bs_list_free(&c->ip_port_list);
 3072|     24|    networking_registerhandler(c->net, NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
 3073|     24|    networking_registerhandler(c->net, NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
 3074|     24|    networking_registerhandler(c->net, NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
 3075|     24|    networking_registerhandler(c->net, NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
 3076|     24|    crypto_memzero(c, sizeof(Net_Crypto));
 3077|     24|    mem_delete(mem, c);
 3078|     24|}
net_crypto.c:kill_timedout:
 3017|  2.33k|{
 3018|  2.33k|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (3018:26): [True: 0, False: 2.33k]
  ------------------
 3019|      0|        const Crypto_Connection *conn = get_crypto_connection(c, i);
 3020|      0|        if (conn == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3020:13): [True: 0, False: 0]
  ------------------
 3021|      0|            continue;
 3022|      0|        }
 3023|       |
 3024|      0|        if (conn->status == CRYPTO_CONN_COOKIE_REQUESTING || conn->status == CRYPTO_CONN_HANDSHAKE_SENT
  ------------------
  |  Branch (3024:13): [True: 0, False: 0]
  |  Branch (3024:62): [True: 0, False: 0]
  ------------------
 3025|      0|                || conn->status == CRYPTO_CONN_NOT_CONFIRMED) {
  ------------------
  |  Branch (3025:20): [True: 0, False: 0]
  ------------------
 3026|      0|            if (conn->temp_packet_num_sent < MAX_NUM_SENDPACKET_TRIES) {
  ------------------
  |  |  117|      0|#define MAX_NUM_SENDPACKET_TRIES 8
  ------------------
  |  Branch (3026:17): [True: 0, False: 0]
  ------------------
 3027|      0|                continue;
 3028|      0|            }
 3029|       |
 3030|      0|            connection_kill(c, i, userdata);
 3031|      0|        }
 3032|       |
 3033|       |#if 0
 3034|       |
 3035|       |        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
 3036|       |            // TODO(irungentoo): add a timeout here?
 3037|       |            /* do_timeout_here(); */
 3038|       |        }
 3039|       |
 3040|       |#endif /* 0 */
 3041|      0|    }
 3042|  2.33k|}
net_crypto.c:do_tcp:
 2294|  2.33k|{
 2295|  2.33k|    do_tcp_connections(c->log, c->tcp_c, userdata);
 2296|       |
 2297|  2.33k|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (2297:26): [True: 0, False: 2.33k]
  ------------------
 2298|      0|        const Crypto_Connection *conn = get_crypto_connection(c, i);
 2299|       |
 2300|      0|        if (conn == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (2300:13): [True: 0, False: 0]
  ------------------
 2301|      0|            continue;
 2302|      0|        }
 2303|       |
 2304|      0|        if (conn->status != CRYPTO_CONN_ESTABLISHED) {
  ------------------
  |  Branch (2304:13): [True: 0, False: 0]
  ------------------
 2305|      0|            continue;
 2306|      0|        }
 2307|       |
 2308|      0|        bool direct_connected = false;
 2309|       |
 2310|      0|        if (!crypto_connection_status(c, i, &direct_connected, nullptr)) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (2310:13): [True: 0, False: 0]
  ------------------
 2311|      0|            continue;
 2312|      0|        }
 2313|       |
 2314|      0|        set_tcp_connection_to_status(c->tcp_c, conn->connection_number_tcp, !direct_connected);
 2315|      0|    }
 2316|  2.33k|}
net_crypto.c:send_crypto_packets:
 2496|  2.33k|{
 2497|  2.33k|    const uint64_t temp_time = current_time_monotonic(c->mono_time);
 2498|  2.33k|    double total_send_rate = 0;
 2499|  2.33k|    uint32_t peak_request_packet_interval = -1;
 2500|       |
 2501|  2.33k|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (2501:26): [True: 0, False: 2.33k]
  ------------------
 2502|      0|        Crypto_Connection *conn = get_crypto_connection(c, i);
 2503|       |
 2504|      0|        if (conn == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (2504:13): [True: 0, False: 0]
  ------------------
 2505|      0|            continue;
 2506|      0|        }
 2507|       |
 2508|      0|        if ((CRYPTO_SEND_PACKET_INTERVAL + conn->temp_packet_sent_time) < temp_time) {
  ------------------
  |  |  111|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
  |  Branch (2508:13): [True: 0, False: 0]
  ------------------
 2509|      0|            send_temp_packet(c, i);
 2510|      0|        }
 2511|       |
 2512|      0|        if ((conn->status == CRYPTO_CONN_NOT_CONFIRMED || conn->status == CRYPTO_CONN_ESTABLISHED)
  ------------------
  |  Branch (2512:14): [True: 0, False: 0]
  |  Branch (2512:59): [True: 0, False: 0]
  ------------------
 2513|      0|                && (CRYPTO_SEND_PACKET_INTERVAL + conn->last_request_packet_sent) < temp_time) {
  ------------------
  |  |  111|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
  |  Branch (2513:20): [True: 0, False: 0]
  ------------------
 2514|      0|            if (send_request_packet(c, i) == 0) {
  ------------------
  |  Branch (2514:17): [True: 0, False: 0]
  ------------------
 2515|      0|                conn->last_request_packet_sent = temp_time;
 2516|      0|            }
 2517|      0|        }
 2518|       |
 2519|      0|        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
  ------------------
  |  Branch (2519:13): [True: 0, False: 0]
  ------------------
 2520|      0|            if (conn->packet_recv_rate > CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2520:17): [True: 0, False: 0]
  ------------------
 2521|      0|                double request_packet_interval = REQUEST_PACKETS_COMPARE_CONSTANT / ((num_packets_array(
  ------------------
  |  | 2483|      0|#define REQUEST_PACKETS_COMPARE_CONSTANT (0.125 * 100.0)
  ------------------
 2522|      0|                                                     &conn->recv_array) + 1.0) / (conn->packet_recv_rate + 1.0));
 2523|       |
 2524|      0|                const double request_packet_interval2 = ((CRYPTO_PACKET_MIN_RATE / conn->packet_recv_rate) *
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
 2525|      0|                                                        (double)CRYPTO_SEND_PACKET_INTERVAL) + (double)PACKET_COUNTER_AVERAGE_INTERVAL;
  ------------------
  |  |  111|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
                                                                      (double)CRYPTO_SEND_PACKET_INTERVAL) + (double)PACKET_COUNTER_AVERAGE_INTERVAL;
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2526|       |
 2527|      0|                if (request_packet_interval2 < request_packet_interval) {
  ------------------
  |  Branch (2527:21): [True: 0, False: 0]
  ------------------
 2528|      0|                    request_packet_interval = request_packet_interval2;
 2529|      0|                }
 2530|       |
 2531|      0|                if (request_packet_interval < PACKET_COUNTER_AVERAGE_INTERVAL) {
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
  |  Branch (2531:21): [True: 0, False: 0]
  ------------------
 2532|      0|                    request_packet_interval = PACKET_COUNTER_AVERAGE_INTERVAL;
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2533|      0|                }
 2534|       |
 2535|      0|                if (request_packet_interval > CRYPTO_SEND_PACKET_INTERVAL) {
  ------------------
  |  |  111|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
  |  Branch (2535:21): [True: 0, False: 0]
  ------------------
 2536|      0|                    request_packet_interval = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |  111|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 2537|      0|                }
 2538|       |
 2539|      0|                if (temp_time - conn->last_request_packet_sent > (uint64_t)request_packet_interval) {
  ------------------
  |  Branch (2539:21): [True: 0, False: 0]
  ------------------
 2540|      0|                    if (send_request_packet(c, i) == 0) {
  ------------------
  |  Branch (2540:25): [True: 0, False: 0]
  ------------------
 2541|      0|                        conn->last_request_packet_sent = temp_time;
 2542|      0|                    }
 2543|      0|                }
 2544|       |
 2545|      0|                if (request_packet_interval < peak_request_packet_interval) {
  ------------------
  |  Branch (2545:21): [True: 0, False: 0]
  ------------------
 2546|      0|                    peak_request_packet_interval = request_packet_interval;
 2547|      0|                }
 2548|      0|            }
 2549|       |
 2550|      0|            if ((PACKET_COUNTER_AVERAGE_INTERVAL + conn->packet_counter_set) < temp_time) {
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
  |  Branch (2550:17): [True: 0, False: 0]
  ------------------
 2551|      0|                const double dt = (double)(temp_time - conn->packet_counter_set);
 2552|       |
 2553|      0|                conn->packet_recv_rate = (double)conn->packet_counter / (dt / 1000.0);
 2554|      0|                conn->packet_counter = 0;
 2555|      0|                conn->packet_counter_set = temp_time;
 2556|       |
 2557|      0|                const uint32_t packets_sent = conn->packets_sent;
 2558|      0|                conn->packets_sent = 0;
 2559|       |
 2560|      0|                const uint32_t packets_resent = conn->packets_resent;
 2561|      0|                conn->packets_resent = 0;
 2562|       |
 2563|       |                /* conjestion control
 2564|       |                 *  calculate a new value of conn->packet_send_rate based on some data
 2565|       |                 */
 2566|       |
 2567|      0|                const unsigned int pos = conn->last_sendqueue_counter % CONGESTION_QUEUE_ARRAY_SIZE;
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2568|      0|                conn->last_sendqueue_size[pos] = num_packets_array(&conn->send_array);
 2569|       |
 2570|      0|                long signed int sum = 0;
 2571|      0|                sum = (long signed int)conn->last_sendqueue_size[pos] -
 2572|      0|                      (long signed int)conn->last_sendqueue_size[(pos + 1) % CONGESTION_QUEUE_ARRAY_SIZE];
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2573|       |
 2574|      0|                const unsigned int n_p_pos = conn->last_sendqueue_counter % CONGESTION_LAST_SENT_ARRAY_SIZE;
  ------------------
  |  |  133|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
 2575|      0|                conn->last_num_packets_sent[n_p_pos] = packets_sent;
 2576|      0|                conn->last_num_packets_resent[n_p_pos] = packets_resent;
 2577|       |
 2578|      0|                conn->last_sendqueue_counter = (conn->last_sendqueue_counter + 1) %
 2579|      0|                                               (CONGESTION_QUEUE_ARRAY_SIZE * CONGESTION_LAST_SENT_ARRAY_SIZE);
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
                                                             (CONGESTION_QUEUE_ARRAY_SIZE * CONGESTION_LAST_SENT_ARRAY_SIZE);
  ------------------
  |  |  133|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
 2580|       |
 2581|      0|                bool direct_connected = false;
 2582|       |                /* return value can be ignored since the `if` above ensures the connection is established */
 2583|      0|                crypto_connection_status(c, i, &direct_connected, nullptr);
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2584|       |
 2585|       |                /* When switching from TCP to UDP, don't change the packet send rate for CONGESTION_EVENT_TIMEOUT ms. */
 2586|      0|                if (!(direct_connected && conn->last_tcp_sent + CONGESTION_EVENT_TIMEOUT > temp_time)) {
  ------------------
  |  | 2486|      0|#define CONGESTION_EVENT_TIMEOUT 1000
  ------------------
  |  Branch (2586:23): [True: 0, False: 0]
  |  Branch (2586:43): [True: 0, False: 0]
  ------------------
 2587|      0|                    long signed int total_sent = 0;
 2588|      0|                    long signed int total_resent = 0;
 2589|       |
 2590|       |                    // TODO(irungentoo): use real delay
 2591|      0|                    unsigned int delay = (unsigned int)(((double)conn->rtt_time / PACKET_COUNTER_AVERAGE_INTERVAL) + 0.5);
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2592|      0|                    const unsigned int packets_set_rem_array = CONGESTION_LAST_SENT_ARRAY_SIZE - CONGESTION_QUEUE_ARRAY_SIZE;
  ------------------
  |  |  133|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
                                  const unsigned int packets_set_rem_array = CONGESTION_LAST_SENT_ARRAY_SIZE - CONGESTION_QUEUE_ARRAY_SIZE;
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2593|       |
 2594|      0|                    if (delay > packets_set_rem_array) {
  ------------------
  |  Branch (2594:25): [True: 0, False: 0]
  ------------------
 2595|      0|                        delay = packets_set_rem_array;
 2596|      0|                    }
 2597|       |
 2598|      0|                    for (unsigned j = 0; j < CONGESTION_QUEUE_ARRAY_SIZE; ++j) {
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
  |  Branch (2598:42): [True: 0, False: 0]
  ------------------
 2599|      0|                        const unsigned int ind = (j + (packets_set_rem_array  - delay) + n_p_pos) % CONGESTION_LAST_SENT_ARRAY_SIZE;
  ------------------
  |  |  133|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
 2600|      0|                        total_sent += conn->last_num_packets_sent[ind];
 2601|      0|                        total_resent += conn->last_num_packets_resent[ind];
 2602|      0|                    }
 2603|       |
 2604|      0|                    if (sum > 0) {
  ------------------
  |  Branch (2604:25): [True: 0, False: 0]
  ------------------
 2605|      0|                        total_sent -= sum;
 2606|      0|                    } else {
 2607|      0|                        if (total_resent > -sum) {
  ------------------
  |  Branch (2607:29): [True: 0, False: 0]
  ------------------
 2608|      0|                            total_resent = -sum;
 2609|      0|                        }
 2610|      0|                    }
 2611|       |
 2612|       |                    /* if queue is too big only allow resending packets. */
 2613|      0|                    const uint32_t npackets = num_packets_array(&conn->send_array);
 2614|      0|                    double min_speed = 1000.0 * (((double)total_sent) / ((double)CONGESTION_QUEUE_ARRAY_SIZE *
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2615|      0|                                                 PACKET_COUNTER_AVERAGE_INTERVAL));
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2616|       |
 2617|      0|                    const double min_speed_request = 1000.0 * (((double)(total_sent + total_resent)) / (
 2618|      0|                                                         (double)CONGESTION_QUEUE_ARRAY_SIZE * PACKET_COUNTER_AVERAGE_INTERVAL));
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
                                                                       (double)CONGESTION_QUEUE_ARRAY_SIZE * PACKET_COUNTER_AVERAGE_INTERVAL));
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2619|       |
 2620|      0|                    if (min_speed < CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2620:25): [True: 0, False: 0]
  ------------------
 2621|      0|                        min_speed = CRYPTO_PACKET_MIN_RATE;
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
 2622|      0|                    }
 2623|       |
 2624|      0|                    const double send_array_ratio = (double)npackets / min_speed;
 2625|       |
 2626|       |                    // TODO(irungentoo): Improve formula?
 2627|      0|                    if (send_array_ratio > SEND_QUEUE_RATIO && CRYPTO_MIN_QUEUE_LENGTH < npackets) {
  ------------------
  |  | 2493|      0|#define SEND_QUEUE_RATIO 2.0
  ------------------
                                  if (send_array_ratio > SEND_QUEUE_RATIO && CRYPTO_MIN_QUEUE_LENGTH < npackets) {
  ------------------
  |  |  100|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
  |  Branch (2627:25): [True: 0, False: 0]
  |  Branch (2627:64): [True: 0, False: 0]
  ------------------
 2628|      0|                        conn->packet_send_rate = min_speed * (1.0 / (send_array_ratio / SEND_QUEUE_RATIO));
  ------------------
  |  | 2493|      0|#define SEND_QUEUE_RATIO 2.0
  ------------------
 2629|      0|                    } else if (conn->last_congestion_event + CONGESTION_EVENT_TIMEOUT < temp_time) {
  ------------------
  |  | 2486|      0|#define CONGESTION_EVENT_TIMEOUT 1000
  ------------------
  |  Branch (2629:32): [True: 0, False: 0]
  ------------------
 2630|      0|                        conn->packet_send_rate = min_speed * 1.2;
 2631|      0|                    } else {
 2632|      0|                        conn->packet_send_rate = min_speed * 0.9;
 2633|      0|                    }
 2634|       |
 2635|      0|                    conn->packet_send_rate_requested = min_speed_request * 1.2;
 2636|       |
 2637|      0|                    if (conn->packet_send_rate < CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2637:25): [True: 0, False: 0]
  ------------------
 2638|      0|                        conn->packet_send_rate = CRYPTO_PACKET_MIN_RATE;
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
 2639|      0|                    }
 2640|       |
 2641|      0|                    if (conn->packet_send_rate_requested < conn->packet_send_rate) {
  ------------------
  |  Branch (2641:25): [True: 0, False: 0]
  ------------------
 2642|      0|                        conn->packet_send_rate_requested = conn->packet_send_rate;
 2643|      0|                    }
 2644|      0|                }
 2645|      0|            }
 2646|       |
 2647|      0|            if (conn->last_packets_left_set == 0 || conn->last_packets_left_requested_set == 0) {
  ------------------
  |  Branch (2647:17): [True: 0, False: 0]
  |  Branch (2647:53): [True: 0, False: 0]
  ------------------
 2648|      0|                conn->last_packets_left_requested_set = temp_time;
 2649|      0|                conn->last_packets_left_set = temp_time;
 2650|      0|                conn->packets_left_requested = CRYPTO_MIN_QUEUE_LENGTH;
  ------------------
  |  |  100|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
 2651|      0|                conn->packets_left = CRYPTO_MIN_QUEUE_LENGTH;
  ------------------
  |  |  100|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
 2652|      0|            } else {
 2653|      0|                if (((uint64_t)((1000.0 / conn->packet_send_rate) + 0.5) + conn->last_packets_left_set) <= temp_time) {
  ------------------
  |  Branch (2653:21): [True: 0, False: 0]
  ------------------
 2654|      0|                    double n_packets = conn->packet_send_rate * (((double)(temp_time - conn->last_packets_left_set)) / 1000.0);
 2655|      0|                    n_packets += conn->last_packets_left_rem;
 2656|       |
 2657|      0|                    const uint32_t num_packets = n_packets;
 2658|      0|                    const double rem = n_packets - (double)num_packets;
 2659|       |
 2660|      0|                    if (conn->packets_left > num_packets * 4 + CRYPTO_MIN_QUEUE_LENGTH) {
  ------------------
  |  |  100|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
  |  Branch (2660:25): [True: 0, False: 0]
  ------------------
 2661|      0|                        conn->packets_left = num_packets * 4 + CRYPTO_MIN_QUEUE_LENGTH;
  ------------------
  |  |  100|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
 2662|      0|                    } else {
 2663|      0|                        conn->packets_left += num_packets;
 2664|      0|                    }
 2665|       |
 2666|      0|                    conn->last_packets_left_set = temp_time;
 2667|      0|                    conn->last_packets_left_rem = rem;
 2668|      0|                }
 2669|       |
 2670|      0|                if (((uint64_t)((1000.0 / conn->packet_send_rate_requested) + 0.5) + conn->last_packets_left_requested_set) <=
  ------------------
  |  Branch (2670:21): [True: 0, False: 0]
  ------------------
 2671|      0|                        temp_time) {
 2672|      0|                    double n_packets = conn->packet_send_rate_requested * (((double)(temp_time - conn->last_packets_left_requested_set)) /
 2673|      0|                                       1000.0);
 2674|      0|                    n_packets += conn->last_packets_left_requested_rem;
 2675|       |
 2676|      0|                    const uint32_t num_packets = n_packets;
 2677|      0|                    const double rem = n_packets - (double)num_packets;
 2678|      0|                    conn->packets_left_requested = num_packets;
 2679|       |
 2680|      0|                    conn->last_packets_left_requested_set = temp_time;
 2681|      0|                    conn->last_packets_left_requested_rem = rem;
 2682|      0|                }
 2683|       |
 2684|      0|                if (conn->packets_left > conn->packets_left_requested) {
  ------------------
  |  Branch (2684:21): [True: 0, False: 0]
  ------------------
 2685|      0|                    conn->packets_left_requested = conn->packets_left;
 2686|      0|                }
 2687|      0|            }
 2688|       |
 2689|      0|            const int ret = send_requested_packets(c, i, conn->packets_left_requested);
 2690|       |
 2691|      0|            if (ret != -1) {
  ------------------
  |  Branch (2691:17): [True: 0, False: 0]
  ------------------
 2692|      0|                conn->packets_left_requested -= ret;
 2693|      0|                conn->packets_resent += ret;
 2694|       |
 2695|      0|                if ((unsigned int)ret < conn->packets_left) {
  ------------------
  |  Branch (2695:21): [True: 0, False: 0]
  ------------------
 2696|      0|                    conn->packets_left -= ret;
 2697|      0|                } else {
 2698|      0|                    conn->last_congestion_event = temp_time;
 2699|      0|                    conn->packets_left = 0;
 2700|      0|                }
 2701|      0|            }
 2702|       |
 2703|      0|            if (conn->packet_send_rate > CRYPTO_PACKET_MIN_RATE * 1.5) {
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2703:17): [True: 0, False: 0]
  ------------------
 2704|      0|                total_send_rate += conn->packet_send_rate;
 2705|      0|            }
 2706|      0|        }
 2707|      0|    }
 2708|       |
 2709|  2.33k|    c->current_sleep_time = -1;
 2710|  2.33k|    uint32_t sleep_time = peak_request_packet_interval;
 2711|       |
 2712|  2.33k|    if (c->current_sleep_time > sleep_time) {
  ------------------
  |  Branch (2712:9): [True: 0, False: 2.33k]
  ------------------
 2713|      0|        c->current_sleep_time = sleep_time;
 2714|      0|    }
 2715|       |
 2716|  2.33k|    if (total_send_rate > CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   97|  2.33k|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2716:9): [True: 0, False: 2.33k]
  ------------------
 2717|      0|        sleep_time = 1000.0 / total_send_rate;
 2718|       |
 2719|      0|        if (c->current_sleep_time > sleep_time) {
  ------------------
  |  Branch (2719:13): [True: 0, False: 0]
  ------------------
 2720|      0|            c->current_sleep_time = sleep_time + 1;
 2721|      0|        }
 2722|      0|    }
 2723|       |
 2724|  2.33k|    sleep_time = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |  111|  2.33k|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 2725|       |
 2726|  2.33k|    if (c->current_sleep_time > sleep_time) {
  ------------------
  |  Branch (2726:9): [True: 2.33k, False: 0]
  ------------------
 2727|  2.33k|        c->current_sleep_time = sleep_time;
 2728|  2.33k|    }
 2729|  2.33k|}

LLVMFuzzerTestOneInput:
  126|     45|{
  127|     45|    tox::test::fuzz_select_target<TestNetCrypto>(data, size);
  128|     45|    return 0;
  129|     45|}
net_crypto_fuzz_test.cc:_ZN12_GLOBAL__N_113TestNetCryptoERN3tox4test9Fuzz_DataE:
   49|     44|{
   50|     44|    const auto prep = prepare(input);
   51|     44|    if (!prep.has_value()) {
  ------------------
  |  Branch (51:9): [True: 1, False: 43]
  ------------------
   52|      1|        return;
   53|      1|    }
   54|     43|    const auto [ipp, iterations] = prep.value();
   55|       |
   56|     43|    SimulatedEnvironment env;
   57|     43|    env.fake_clock().advance(1000000000);  // Start clock high to match legacy behavior
   58|     43|    auto node = env.create_node(ipp.port);
   59|     43|    configure_fuzz_memory_source(env.fake_memory(), input);
   60|       |
   61|     43|    const Ptr<Logger> logger(logger_new(&node->c_memory), logger_kill);
   62|     43|    if (logger == nullptr) {
  ------------------
  |  Branch (62:9): [True: 1, False: 42]
  ------------------
   63|      1|        return;
   64|      1|    }
   65|       |
   66|     42|    const Ptr<Networking_Core> net(
   67|     42|        new_networking_ex(logger.get(), &node->c_memory, &node->c_network, &ipp.ip, ipp.port,
   68|     42|            ipp.port + 100, nullptr),
   69|     42|        kill_networking);
   70|     42|    if (net == nullptr) {
  ------------------
  |  Branch (70:9): [True: 2, False: 40]
  ------------------
   71|      2|        return;
   72|      2|    }
   73|       |
   74|     40|    const std::unique_ptr<Mono_Time, std::function<void(Mono_Time *)>> mono_time(
   75|     40|        mono_time_new(
   76|     40|            &node->c_memory,
   77|     40|            [](void *_Nullable user_data) {
   78|     40|                return static_cast<FakeClock *>(user_data)->current_time_ms();
   79|     40|            },
   80|     40|            &env.fake_clock()),
   81|     40|        [&node](Mono_Time *ptr) { mono_time_free(&node->c_memory, ptr); });
   82|       |
   83|     40|    if (mono_time == nullptr) {
  ------------------
  |  Branch (83:9): [True: 2, False: 38]
  ------------------
   84|      2|        return;
   85|      2|    }
   86|       |
   87|     38|    const Ptr<DHT> dht(new_dht(logger.get(), &node->c_memory, &node->c_random, &node->c_network,
   88|     38|                           mono_time.get(), net.get(), false, false),
   89|     38|        kill_dht);
   90|     38|    if (dht == nullptr) {
  ------------------
  |  Branch (90:9): [True: 11, False: 27]
  ------------------
   91|     11|        return;
   92|     11|    }
   93|       |
   94|     27|    Net_Profile *tcp_np = netprof_new(logger.get(), &node->c_memory);
   95|       |
   96|     27|    if (tcp_np == nullptr) {
  ------------------
  |  Branch (96:9): [True: 1, False: 26]
  ------------------
   97|      1|        return;
   98|      1|    }
   99|       |
  100|     26|    const TCP_Proxy_Info proxy_info = {0};
  101|       |
  102|     26|    const Ptr<Net_Crypto> net_crypto(
  103|     26|        new_net_crypto(logger.get(), &node->c_memory, &node->c_random, &node->c_network,
  104|     26|            mono_time.get(), net.get(), dht.get(), &dht_funcs, &proxy_info, tcp_np),
  105|     26|        kill_net_crypto);
  106|     26|    if (net_crypto == nullptr) {
  ------------------
  |  Branch (106:9): [True: 2, False: 24]
  ------------------
  107|      2|        netprof_kill(&node->c_memory, tcp_np);
  108|      2|        return;
  109|      2|    }
  110|       |
  111|  2.36k|    for (std::uint8_t i = 0; i < iterations; ++i) {
  ------------------
  |  Branch (111:30): [True: 2.33k, False: 24]
  ------------------
  112|  2.33k|        networking_poll(net.get(), nullptr);
  113|  2.33k|        do_dht(dht.get());
  114|  2.33k|        do_net_crypto(net_crypto.get(), nullptr);
  115|       |
  116|  2.33k|        env.advance_time(200);
  117|  2.33k|    }
  118|       |
  119|     24|    netprof_kill(&node->c_memory, tcp_np);
  120|     24|}
net_crypto_fuzz_test.cc:_ZN12_GLOBAL__N_17prepareERN3tox4test9Fuzz_DataE:
   29|     44|{
   30|     44|    IP_Port ipp;
   31|     44|    ip_init(&ipp.ip, true);
   32|     44|    ipp.port = net_htons(33445);
   33|       |
   34|     44|    CONSUME_OR_RETURN_VAL(const std::uint8_t *iterations_packed, input, 1, std::nullopt);
  ------------------
  |  |  144|     44|    if ((INPUT).size() < (SIZE)) {                    \
  |  |  ------------------
  |  |  |  Branch (144:9): [True: 1, False: 43]
  |  |  ------------------
  |  |  145|      1|        return (VAL);                                 \
  |  |  146|      1|    }                                                 \
  |  |  147|     44|    DECL = (INPUT).consume(__func__, (SIZE))
  ------------------
   35|     43|    std::uint8_t iterations = *iterations_packed;
   36|       |
   37|     43|    return {{ipp, iterations}};
   38|     44|}
net_crypto_fuzz_test.cc:_ZZN12_GLOBAL__N_113TestNetCryptoERN3tox4test9Fuzz_DataEENK3$_1clEPv:
   77|  2.37k|            [](void *_Nullable user_data) {
   78|  2.37k|                return static_cast<FakeClock *>(user_data)->current_time_ms();
   79|  2.37k|            },
net_crypto_fuzz_test.cc:_ZZN12_GLOBAL__N_113TestNetCryptoERN3tox4test9Fuzz_DataEENK3$_0clEP9Mono_Time:
   81|     38|        [&node](Mono_Time *ptr) { mono_time_free(&node->c_memory, ptr); });
net_crypto_fuzz_test.cc:_ZNK12_GLOBAL__N_13$_4clEPKv:
   45|     25|    [](const void *_Nonnull dht) { return dht_get_self_secret_key(static_cast<const DHT *>(dht)); },

netprof_new:
  139|     68|{
  140|     68|    Net_Profile *np = (Net_Profile *)mem_alloc(mem, sizeof(Net_Profile));
  141|       |
  142|     68|    if (np == nullptr) {
  ------------------
  |  |   63|     68|#define nullptr NULL
  ------------------
  |  Branch (142:9): [True: 2, False: 66]
  ------------------
  143|      2|        LOGGER_ERROR(log, "failed to allocate memory for net profiler");
  ------------------
  |  |   80|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      2|    do {                                                                         \
  |  |  |  |   70|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      2|        }                                                                        \
  |  |  |  |   73|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  144|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
  145|      2|    }
  146|       |
  147|     66|    return np;
  148|     68|}
netprof_kill:
  151|     66|{
  152|     66|    if (net_profile != nullptr) {
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
  |  Branch (152:9): [True: 66, False: 0]
  ------------------
  153|     66|        mem_delete(mem, net_profile);
  154|     66|    }
  155|     66|}

sock_valid:
   56|     40|{
   57|     40|    const Socket invalid_socket = net_invalid_socket();
   58|     40|    return sock.value != invalid_socket.value;
   59|     40|}
kill_sock:
   94|     40|{
   95|     40|    ns_close(ns, sock);
   96|     40|}
set_socket_nonblock:
   99|     40|{
  100|     40|    return net_set_socket_nonblock(ns, sock);
  101|     40|}
set_socket_nosigpipe:
  104|     40|{
  105|     40|    return net_set_socket_nosigpipe(ns, sock);
  106|     40|}
set_socket_dualstack:
  114|     40|{
  115|     40|    return net_set_socket_dualstack(ns, sock);
  116|     40|}
networking_registerhandler:
  251|    646|{
  252|    646|    net->packethandlers[byte].function = cb;
  253|    646|    net->packethandlers[byte].object = object;
  254|    646|}
networking_poll:
  257|  2.33k|{
  258|  2.33k|    if (net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (258:9): [True: 0, False: 2.33k]
  ------------------
  259|       |        /* Socket not initialized */
  260|      0|        return;
  261|      0|    }
  262|       |
  263|  2.33k|    IP_Port ip_port;
  264|  2.33k|    uint8_t data[MAX_UDP_PACKET_SIZE] = {0};
  265|  2.33k|    uint32_t length;
  266|       |
  267|  2.33k|    while (receivepacket(net->ns, net->log, net->sock, &ip_port, data, &length) != -1) {
  ------------------
  |  Branch (267:12): [True: 0, False: 2.33k]
  ------------------
  268|      0|        if (length < 1) {
  ------------------
  |  Branch (268:13): [True: 0, False: 0]
  ------------------
  269|      0|            continue;
  270|      0|        }
  271|       |
  272|      0|        netprof_record_packet(net->udp_net_profile, data[0], length, PACKET_DIRECTION_RECV);
  273|       |
  274|      0|        const Packet_Handler *const handler = &net->packethandlers[data[0]];
  275|       |
  276|      0|        if (handler->function == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (276:13): [True: 0, False: 0]
  ------------------
  277|       |            // TODO(https://github.com/TokTok/c-toxcore/issues/1115): Make this
  278|       |            // a warning or error again.
  279|      0|            LOGGER_DEBUG(net->log, "[%02u] -- Packet has no handler", data[0]);
  ------------------
  |  |   77|      0|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  280|      0|            continue;
  281|      0|        }
  282|       |
  283|      0|        handler->function(handler->object, &ip_port, data, length, userdata);
  284|      0|    }
  285|  2.33k|}
new_networking_ex:
  300|     42|{
  301|       |    /* If both from and to are 0, use default port range
  302|       |     * If one is 0 and the other is non-0, use the non-0 value as only port
  303|       |     * If from > to, swap
  304|       |     */
  305|     42|    if (port_from == 0 && port_to == 0) {
  ------------------
  |  Branch (305:9): [True: 0, False: 42]
  |  Branch (305:27): [True: 0, False: 0]
  ------------------
  306|      0|        port_from = TOX_PORTRANGE_FROM;
  ------------------
  |  |   79|      0|#define TOX_PORTRANGE_FROM 33445
  ------------------
  307|      0|        port_to = TOX_PORTRANGE_TO;
  ------------------
  |  |   80|      0|#define TOX_PORTRANGE_TO   33545
  ------------------
  308|     42|    } else if (port_from == 0 && port_to != 0) {
  ------------------
  |  Branch (308:16): [True: 0, False: 42]
  |  Branch (308:34): [True: 0, False: 0]
  ------------------
  309|      0|        port_from = port_to;
  310|     42|    } else if (port_from != 0 && port_to == 0) {
  ------------------
  |  Branch (310:16): [True: 42, False: 0]
  |  Branch (310:34): [True: 0, False: 42]
  ------------------
  311|      0|        port_to = port_from;
  312|     42|    } else if (port_from > port_to) {
  ------------------
  |  Branch (312:16): [True: 0, False: 42]
  ------------------
  313|      0|        const uint16_t temp_port = port_from;
  314|      0|        port_from = port_to;
  315|      0|        port_to = temp_port;
  316|      0|    }
  317|       |
  318|     42|    if (error != nullptr) {
  ------------------
  |  |   63|     42|#define nullptr NULL
  ------------------
  |  Branch (318:9): [True: 0, False: 42]
  ------------------
  319|      0|        *error = 2;
  320|      0|    }
  321|       |
  322|       |    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
  323|     42|    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (323:9): [True: 42, False: 0]
  |  Branch (323:44): [True: 0, False: 42]
  ------------------
  324|      0|        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  325|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  326|      0|    }
  327|       |
  328|     42|    Networking_Core *temp = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
  329|       |
  330|     42|    if (temp == nullptr) {
  ------------------
  |  |   63|     42|#define nullptr NULL
  ------------------
  |  Branch (330:9): [True: 1, False: 41]
  ------------------
  331|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  332|      1|    }
  333|       |
  334|     41|    Net_Profile *np = netprof_new(log, mem);
  335|       |
  336|     41|    if (np == nullptr) {
  ------------------
  |  |   63|     41|#define nullptr NULL
  ------------------
  |  Branch (336:9): [True: 1, False: 40]
  ------------------
  337|      1|        mem_delete(mem, temp);
  338|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  339|      1|    }
  340|       |
  341|     40|    temp->udp_net_profile = np;
  342|     40|    temp->ns = ns;
  343|     40|    temp->log = log;
  344|     40|    temp->mem = mem;
  345|     40|    temp->family = ip->family;
  346|     40|    temp->port = 0;
  347|       |
  348|       |    /* Initialize our socket. */
  349|       |    /* add log message what we're creating */
  350|     40|    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |   71|     40|#define TOX_SOCK_DGRAM 2
  ------------------
                  temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |   74|     40|#define TOX_PROTO_UDP 2
  ------------------
  351|       |
  352|       |    /* Check for socket error. */
  353|     40|    if (!sock_valid(temp->sock)) {
  ------------------
  |  Branch (353:9): [True: 0, False: 40]
  ------------------
  354|      0|        const int neterror = net_error();
  355|      0|        Net_Strerror error_str;
  356|      0|        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  357|      0|        netprof_kill(mem, temp->udp_net_profile);
  358|      0|        mem_delete(mem, temp);
  359|       |
  360|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (360:13): [True: 0, False: 0]
  ------------------
  361|      0|            *error = 1;
  362|      0|        }
  363|       |
  364|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  365|      0|    }
  366|       |
  367|       |    /* Functions to increase the size of the send and receive UDP buffers.
  368|       |     */
  369|     40|    if (!net_set_socket_buffer_size(ns, temp->sock, 1024 * 1024 * 2)) {
  ------------------
  |  Branch (369:9): [True: 0, False: 40]
  ------------------
  370|      0|        LOGGER_WARNING(log, "failed to set socket buffer size");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  371|      0|    }
  372|       |
  373|       |    /* Enable broadcast on socket */
  374|     40|    if (!net_set_socket_broadcast(ns, temp->sock)) {
  ------------------
  |  Branch (374:9): [True: 0, False: 40]
  ------------------
  375|      0|        LOGGER_ERROR(log, "failed to set socket broadcast");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  376|      0|    }
  377|       |
  378|       |    /* iOS UDP sockets are weird and apparently can SIGPIPE */
  379|     40|    if (!set_socket_nosigpipe(ns, temp->sock)) {
  ------------------
  |  Branch (379:9): [True: 0, False: 40]
  ------------------
  380|      0|        kill_networking(temp);
  381|       |
  382|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (382:13): [True: 0, False: 0]
  ------------------
  383|      0|            *error = 1;
  384|      0|        }
  385|       |
  386|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  387|      0|    }
  388|       |
  389|       |    /* Set socket nonblocking. */
  390|     40|    if (!set_socket_nonblock(ns, temp->sock)) {
  ------------------
  |  Branch (390:9): [True: 0, False: 40]
  ------------------
  391|      0|        kill_networking(temp);
  392|       |
  393|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (393:13): [True: 0, False: 0]
  ------------------
  394|      0|            *error = 1;
  395|      0|        }
  396|       |
  397|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  398|      0|    }
  399|       |
  400|       |    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
  401|     40|    uint16_t *portptr = nullptr;
  ------------------
  |  |   63|     40|#define nullptr NULL
  ------------------
  402|     40|    IP_Port addr;
  403|     40|    ip_init(&addr.ip, net_family_is_ipv6(temp->family));
  404|       |
  405|     40|    if (net_family_is_ipv4(temp->family) || net_family_is_ipv6(temp->family)) {
  ------------------
  |  Branch (405:9): [True: 0, False: 40]
  |  Branch (405:45): [True: 40, False: 0]
  ------------------
  406|     40|        ip_copy(&addr.ip, ip);
  407|     40|        addr.port = 0;
  408|     40|        portptr = &addr.port;
  409|     40|    } else {
  410|      0|        mem_delete(mem, temp);
  411|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  412|      0|    }
  413|       |
  414|     40|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (414:9): [True: 40, False: 0]
  ------------------
  415|     40|        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);
  416|       |
  417|     40|        if (is_dualstack) {
  ------------------
  |  Branch (417:13): [True: 40, False: 0]
  ------------------
  418|     40|            LOGGER_TRACE(log, "Dual-stack socket: enabled");
  ------------------
  |  |   76|     40|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     40|    do {                                                                         \
  |  |  |  |   70|     40|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     80|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 40]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     40|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 40]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  419|     40|        } else {
  420|      0|            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  421|      0|        }
  422|       |
  423|     40|        if (!net_join_multicast(ns, temp->sock, ip->family)) {
  ------------------
  |  Branch (423:13): [True: 0, False: 40]
  ------------------
  424|      0|            const int neterror = net_error();
  425|      0|            Net_Strerror error_str;
  426|      0|            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   78|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  427|     40|        } else {
  428|     40|            const int neterror = net_error();
  429|     40|            Net_Strerror error_str;
  430|     40|            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   76|     40|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     40|    do {                                                                         \
  |  |  |  |   70|     40|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     80|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 40]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     40|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 40]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  431|     40|        }
  432|     40|    }
  433|       |
  434|       |    /* A hanging program or a different user might block the standard port.
  435|       |     * As long as it isn't a parameter coming from the commandline,
  436|       |     * try a few ports after it, to see if we can find a "free" one.
  437|       |     *
  438|       |     * If we go on without binding, the first sendto() automatically binds to
  439|       |     * a free port chosen by the system (i.e. anything from 1024 to 65535).
  440|       |     *
  441|       |     * Returning NULL after bind fails has both advantages and disadvantages:
  442|       |     * advantage:
  443|       |     *   we can rely on getting the port in the range 33445..33450, which
  444|       |     *   enables us to tell joe user to open their firewall to a small range
  445|       |     *
  446|       |     * disadvantage:
  447|       |     *   some clients might not test return of tox_new(), blindly assuming that
  448|       |     *   it worked ok (which it did previously without a successful bind)
  449|       |     */
  450|     40|    uint16_t port_to_try = port_from;
  451|     40|    *portptr = net_htons(port_to_try);
  452|       |
  453|     80|    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
  ------------------
  |  Branch (453:38): [True: 80, False: 0]
  ------------------
  454|     80|        const int res = ns_bind(ns, temp->sock, &addr);
  455|       |
  456|     80|        if (res == 0) {
  ------------------
  |  Branch (456:13): [True: 40, False: 40]
  ------------------
  457|     40|            temp->port = *portptr;
  458|       |
  459|     40|            Ip_Ntoa ip_str;
  460|     40|            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
  ------------------
  |  |   77|     40|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     40|    do {                                                                         \
  |  |  |  |   70|     40|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     80|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 40]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     40|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 40]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  461|     40|                         net_ntohs(temp->port));
  462|       |
  463|       |            /* errno isn't reset on success, only set on failure, the failed
  464|       |             * binds with parallel clients yield a -EPERM to the outside if
  465|       |             * errno isn't cleared here */
  466|     40|            if (tries > 0) {
  ------------------
  |  Branch (466:17): [True: 40, False: 0]
  ------------------
  467|     40|                net_clear_error();
  468|     40|            }
  469|       |
  470|     40|            if (error != nullptr) {
  ------------------
  |  |   63|     40|#define nullptr NULL
  ------------------
  |  Branch (470:17): [True: 0, False: 40]
  ------------------
  471|      0|                *error = 0;
  472|      0|            }
  473|       |
  474|     40|            return temp;
  475|     40|        }
  476|       |
  477|     40|        ++port_to_try;
  478|       |
  479|     40|        if (port_to_try > port_to) {
  ------------------
  |  Branch (479:13): [True: 0, False: 40]
  ------------------
  480|      0|            port_to_try = port_from;
  481|      0|        }
  482|       |
  483|     40|        *portptr = net_htons(port_to_try);
  484|     40|    }
  485|       |
  486|      0|    Ip_Ntoa ip_str;
  487|      0|    const int neterror = net_error();
  488|      0|    Net_Strerror error_str;
  489|      0|    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u",
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  490|      0|                 neterror, net_strerror(neterror, &error_str), net_ip_ntoa(ip, &ip_str), port_from, port_to);
  491|      0|    kill_networking(temp);
  492|       |
  493|      0|    if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (493:9): [True: 0, False: 0]
  ------------------
  494|      0|        *error = 1;
  495|      0|    }
  496|       |
  497|       |    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  498|     40|}
kill_networking:
  518|     40|{
  519|     40|    if (net == nullptr) {
  ------------------
  |  |   63|     40|#define nullptr NULL
  ------------------
  |  Branch (519:9): [True: 0, False: 40]
  ------------------
  520|      0|        return;
  521|      0|    }
  522|       |
  523|     40|    if (!net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (523:9): [True: 40, False: 0]
  ------------------
  524|       |        /* Socket is initialized, so we close it. */
  525|     40|        kill_sock(net->ns, net->sock);
  526|     40|    }
  527|       |
  528|     40|    netprof_kill(net->mem, net->udp_net_profile);
  529|     40|    mem_delete(net->mem, net);
  530|     40|}
ip_reset:
  635|    296|{
  636|    296|    if (ip == nullptr) {
  ------------------
  |  |   63|    296|#define nullptr NULL
  ------------------
  |  Branch (636:9): [True: 0, False: 296]
  ------------------
  637|      0|        return;
  638|      0|    }
  639|       |
  640|    296|    *ip = empty_ip;
  641|    296|}
ip_init:
  657|    296|{
  658|    296|    if (ip == nullptr) {
  ------------------
  |  |   63|    296|#define nullptr NULL
  ------------------
  |  Branch (658:9): [True: 0, False: 296]
  ------------------
  659|      0|        return;
  660|      0|    }
  661|       |
  662|    296|    ip_reset(ip);
  663|    296|    ip->family = ipv6enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (663:18): [True: 84, False: 212]
  ------------------
  664|    296|}
ip_copy:
  692|     40|{
  693|     40|    if (source == nullptr || target == nullptr) {
  ------------------
  |  |   63|     80|#define nullptr NULL
  ------------------
                  if (source == nullptr || target == nullptr) {
  ------------------
  |  |   63|     40|#define nullptr NULL
  ------------------
  |  Branch (693:9): [True: 0, False: 40]
  |  Branch (693:30): [True: 0, False: 40]
  ------------------
  694|      0|        return;
  695|      0|    }
  696|       |
  697|     40|    *target = *source;
  698|     40|}
net_socket:
 1153|     40|{
 1154|     40|    return ns_socket(ns, domain.value, type, protocol);
 1155|     40|}
network.c:receivepacket:
  221|  2.33k|{
  222|  2.33k|    memset(ip_port, 0, sizeof(IP_Port));
  223|  2.33k|    *length = 0;
  224|       |
  225|  2.33k|    const int fail_or_len = ns_recvfrom(ns, sock, data, MAX_UDP_PACKET_SIZE, ip_port);
  ------------------
  |  |   28|  2.33k|#define MAX_UDP_PACKET_SIZE 2048
  ------------------
  226|       |
  227|  2.33k|    if (fail_or_len < 0) {
  ------------------
  |  Branch (227:9): [True: 2.33k, False: 0]
  ------------------
  228|  2.33k|        const int error = net_error();
  229|       |
  230|  2.33k|        if (!net_should_ignore_recv_error(error)) {
  ------------------
  |  Branch (230:13): [True: 0, False: 2.33k]
  ------------------
  231|      0|            Net_Strerror error_str;
  232|      0|            LOGGER_ERROR(log, "unexpected error reading from socket: %u, %s", (unsigned int)error, net_strerror(error, &error_str));
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  233|      0|        }
  234|       |
  235|  2.33k|        return -1; /* Nothing received. */
  236|  2.33k|    }
  237|       |
  238|      0|    *length = (uint32_t)fail_or_len;
  239|       |
  240|      0|    if (net_family_is_ipv6(ip_port->ip.family) && ipv6_ipv4_in_v6(&ip_port->ip.ip.v6)) {
  ------------------
  |  Branch (240:9): [True: 0, False: 0]
  |  Branch (240:51): [True: 0, False: 0]
  ------------------
  241|      0|        ip_port->ip.family = net_family_ipv4();
  242|      0|        ip_port->ip.ip.v4.uint32 = ip_port->ip.ip.v6.uint32[3];
  243|      0|    }
  244|       |
  245|      0|    net_log_data(log, "=>O", data, MAX_UDP_PACKET_SIZE, ip_port, *length);
  ------------------
  |  |   28|      0|#define MAX_UDP_PACKET_SIZE 2048
  ------------------
  246|       |
  247|      0|    return 0;
  248|  2.33k|}

net_should_ignore_recv_error:
  343|  2.33k|{
  344|  2.33k|    return should_ignore_recv_error(err);
  345|  2.33k|}
net_invalid_socket:
  586|     40|{
  587|     40|    return net_socket_from_native(INVALID_SOCKET);
  ------------------
  |  |  152|     40|#define INVALID_SOCKET (-1)
  ------------------
  588|     40|}
net_htonl:
  591|    169|{
  592|       |    return htonl(hostlong);
  593|    169|}
net_htons:
  596|    167|{
  597|       |    return htons(hostshort);
  598|    167|}
net_ntohs:
  606|    123|{
  607|       |    return ntohs(hostshort);
  608|    123|}
net_join_multicast:
  650|     40|{
  651|     40|#ifndef ESP_PLATFORM
  652|     40|    if (net_family_is_ipv6(family)) {
  ------------------
  |  Branch (652:9): [True: 40, False: 0]
  ------------------
  653|       |        /* multicast local nodes */
  654|     40|        struct ipv6_mreq mreq = {{{{0}}}};
  655|     40|        mreq.ipv6mr_multiaddr.s6_addr[0] = 0xFF;
  656|     40|        mreq.ipv6mr_multiaddr.s6_addr[1] = 0x02;
  657|     40|        mreq.ipv6mr_multiaddr.s6_addr[15] = 0x01;
  658|     40|        mreq.ipv6mr_interface = 0;
  659|       |
  660|     40|        return ns_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) == 0;
  661|     40|    }
  662|      0|#endif /* ESP_PLATFORM */
  663|      0|    return false;
  664|     40|}
net_set_socket_nonblock:
  667|     40|{
  668|       |    return ns_socket_nonblock(ns, sock, true) == 0;
  669|     40|}
net_set_socket_nosigpipe:
  672|     40|{
  673|       |#if defined(__APPLE__)
  674|       |    int set = 1;
  675|       |    return ns_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
  676|       |#else
  677|       |    return true;
  678|     40|#endif /* __APPLE__ */
  679|     40|}
net_set_socket_dualstack:
  692|     40|{
  693|     40|    int ipv6only = 0;
  694|     40|    size_t optsize = sizeof(ipv6only);
  695|     40|    const int res = ns_getsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, &optsize);
  696|       |
  697|     40|    if ((res == 0) && (ipv6only == 0)) {
  ------------------
  |  Branch (697:9): [True: 40, False: 0]
  |  Branch (697:23): [True: 40, False: 0]
  ------------------
  698|     40|        return true;
  699|     40|    }
  700|       |
  701|      0|    ipv6only = 0;
  702|      0|    return ns_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only)) == 0;
  703|     40|}
net_set_socket_buffer_size:
  706|     40|{
  707|     40|    bool ok = true;
  708|       |
  709|     40|    if (ns_setsockopt(ns, sock, SOL_SOCKET, SO_RCVBUF, &size, sizeof(size)) != 0) {
  ------------------
  |  Branch (709:9): [True: 0, False: 40]
  ------------------
  710|      0|        ok = false;
  711|      0|    }
  712|       |
  713|     40|    if (ns_setsockopt(ns, sock, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size)) != 0) {
  ------------------
  |  Branch (713:9): [True: 0, False: 40]
  ------------------
  714|      0|        ok = false;
  715|      0|    }
  716|       |
  717|     40|    return ok;
  718|     40|}
net_set_socket_broadcast:
  721|     40|{
  722|     40|    int broadcast = 1;
  723|     40|    return ns_setsockopt(ns, sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) == 0;
  724|     40|}
net_error:
  727|  2.37k|{
  728|       |#ifdef OS_WIN32
  729|       |    return WSAGetLastError();
  730|       |#else
  731|       |    return errno;
  732|  2.37k|#endif /* OS_WIN32 */
  733|  2.37k|}
net_clear_error:
  736|     40|{
  737|       |#ifdef OS_WIN32
  738|       |    WSASetLastError(0);
  739|       |#else
  740|       |    errno = 0;
  741|     40|#endif /* OS_WIN32 */
  742|     40|}
os_network.c:should_ignore_recv_error:
  201|  2.33k|{
  202|       |    return err == EWOULDBLOCK;
  203|  2.33k|}

ping_new:
  329|     37|{
  330|     37|    Ping *ping = (Ping *)mem_alloc(mem, sizeof(Ping));
  331|       |
  332|     37|    if (ping == nullptr) {
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
  |  Branch (332:9): [True: 1, False: 36]
  ------------------
  333|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  334|      1|    }
  335|       |
  336|     36|    Ping_Array *const ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   23|     36|#define PING_NUM_MAX 512
  ------------------
                  Ping_Array *const ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   46|     36|#define PING_TIMEOUT 5
  ------------------
  337|       |
  338|     36|    if (ping_array == nullptr) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (338:9): [True: 2, False: 34]
  ------------------
  339|      2|        mem_delete(mem, ping);
  340|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
  341|      2|    }
  342|     34|    ping->ping_array = ping_array;
  343|       |
  344|     34|    ping->mono_time = mono_time;
  345|     34|    ping->rng = rng;
  346|     34|    ping->mem = mem;
  347|     34|    ping->dht = dht;
  348|     34|    ping->net = net;
  349|     34|    networking_registerhandler(ping->net, NET_PACKET_PING_REQUEST, &handle_ping_request, dht);
  350|     34|    networking_registerhandler(ping->net, NET_PACKET_PING_RESPONSE, &handle_ping_response, dht);
  351|       |
  352|     34|    return ping;
  353|     36|}
ping_kill:
  356|     37|{
  357|     37|    if (ping == nullptr) {
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
  |  Branch (357:9): [True: 3, False: 34]
  ------------------
  358|      3|        return;
  359|      3|    }
  360|       |
  361|     34|    networking_registerhandler(ping->net, NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     34|#define nullptr NULL
  ------------------
                  networking_registerhandler(ping->net, NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     34|#define nullptr NULL
  ------------------
  362|     34|    networking_registerhandler(ping->net, NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     34|#define nullptr NULL
  ------------------
                  networking_registerhandler(ping->net, NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     34|#define nullptr NULL
  ------------------
  363|     34|    ping_array_kill(ping->ping_array);
  364|       |
  365|     34|    mem_delete(mem, ping);
  366|     34|}

ping_array_new:
   37|     66|{
   38|     66|    if (size == 0 || timeout == 0) {
  ------------------
  |  Branch (38:9): [True: 0, False: 66]
  |  Branch (38:22): [True: 0, False: 66]
  ------------------
   39|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   40|      0|    }
   41|       |
   42|     66|    if ((size & (size - 1)) != 0) {
  ------------------
  |  Branch (42:9): [True: 0, False: 66]
  ------------------
   43|       |        // Not a power of 2.
   44|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   45|      0|    }
   46|       |
   47|     66|    Ping_Array *const empty_array = (Ping_Array *)mem_alloc(mem, sizeof(Ping_Array));
   48|       |
   49|     66|    if (empty_array == nullptr) {
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
  |  Branch (49:9): [True: 2, False: 64]
  ------------------
   50|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
   51|      2|    }
   52|       |
   53|     64|    Ping_Array_Entry *const entries = (Ping_Array_Entry *)mem_valloc(mem, size, sizeof(Ping_Array_Entry));
   54|       |
   55|     64|    if (entries == nullptr) {
  ------------------
  |  |   63|     64|#define nullptr NULL
  ------------------
  |  Branch (55:9): [True: 1, False: 63]
  ------------------
   56|      1|        mem_delete(mem, empty_array);
   57|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
   58|      1|    }
   59|     63|    empty_array->entries = entries;
   60|       |
   61|     63|    empty_array->mem = mem;
   62|     63|    empty_array->last_deleted = 0;
   63|     63|    empty_array->last_added = 0;
   64|     63|    empty_array->total_size = size;
   65|     63|    empty_array->timeout = timeout;
   66|     63|    return empty_array;
   67|     64|}
ping_array_kill:
   77|     71|{
   78|     71|    if (array == nullptr) {
  ------------------
  |  |   63|     71|#define nullptr NULL
  ------------------
  |  Branch (78:9): [True: 8, False: 63]
  ------------------
   79|      8|        return;
   80|      8|    }
   81|       |
   82|     63|    while (array->last_deleted != array->last_added) {
  ------------------
  |  Branch (82:12): [True: 0, False: 63]
  ------------------
   83|      0|        const uint32_t index = array->last_deleted % array->total_size;
   84|      0|        clear_entry(array, index);
   85|      0|        ++array->last_deleted;
   86|      0|    }
   87|       |
   88|     63|    mem_delete(array->mem, array->entries);
   89|     63|    mem_delete(array->mem, array);
   90|     63|}

rng_bytes:
    7|    194|{
    8|    194|    rng->funcs->bytes_callback(rng->user_data, bytes, length);
    9|    194|}

shared_key_cache_new:
   50|     66|{
   51|     66|    if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|    132|#define nullptr NULL
  ------------------
                  if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|    132|#define nullptr NULL
  ------------------
  |  Branch (51:9): [True: 0, False: 66]
  |  Branch (51:33): [True: 0, False: 66]
  |  Branch (51:63): [True: 0, False: 66]
  |  Branch (51:79): [True: 0, False: 66]
  ------------------
   52|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   53|      0|    }
   54|       |
   55|       |    // Time must not be zero, since we use that as special value for empty slots
   56|     66|    if (mono_time_get(mono_time) == 0) {
  ------------------
  |  Branch (56:9): [True: 0, False: 66]
  ------------------
   57|       |        // Fail loudly in debug environments
   58|      0|        LOGGER_FATAL(log, "time must not be zero (mono_time not initialised?)");
  ------------------
  |  |   83|      0|    do {                                \
  |  |   84|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   85|      0|        logger_abort();                 \
  |  |   86|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (86:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
   59|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   60|      0|    }
   61|       |
   62|     66|    Shared_Key_Cache *res = (Shared_Key_Cache *)mem_alloc(mem, sizeof(Shared_Key_Cache));
   63|     66|    if (res == nullptr) {
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
  |  Branch (63:9): [True: 2, False: 64]
  ------------------
   64|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
   65|      2|    }
   66|       |
   67|     64|    res->self_secret_key = self_secret_key;
   68|     64|    res->mono_time = mono_time;
   69|     64|    res->mem = mem;
   70|     64|    res->log = log;
   71|     64|    res->keys_per_slot = keys_per_slot;
   72|       |
   73|       |    // We take one byte from the public key for each bucket and store keys_per_slot elements there
   74|     64|    const size_t cache_size = 256 * keys_per_slot;
   75|     64|    Shared_Key *keys = (Shared_Key *)mem_valloc(mem, cache_size, sizeof(Shared_Key));
   76|       |
   77|     64|    if (keys == nullptr) {
  ------------------
  |  |   63|     64|#define nullptr NULL
  ------------------
  |  Branch (77:9): [True: 2, False: 62]
  ------------------
   78|      2|        mem_delete(mem, res);
   79|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
   80|      2|    }
   81|       |
   82|     62|    crypto_memlock(keys, cache_size * sizeof(Shared_Key));
   83|       |
   84|     62|    res->keys = keys;
   85|       |
   86|     62|    return res;
   87|     64|}
shared_key_cache_free:
   90|     74|{
   91|     74|    if (cache == nullptr) {
  ------------------
  |  |   63|     74|#define nullptr NULL
  ------------------
  |  Branch (91:9): [True: 12, False: 62]
  ------------------
   92|     12|        return;
   93|     12|    }
   94|       |
   95|     62|    const size_t cache_size = 256 * cache->keys_per_slot;
   96|       |    // Don't leave key material in memory
   97|     62|    crypto_memzero(cache->keys, cache_size * sizeof(Shared_Key));
   98|     62|    crypto_memunlock(cache->keys, cache_size * sizeof(Shared_Key));
   99|     62|    mem_delete(cache->mem, cache->keys);
  100|     62|    mem_delete(cache->mem, cache);
  101|     62|}

memzero:
   99|    262|{
  100|    262|    if (data == nullptr || data_size == 0) {
  ------------------
  |  |   63|    524|#define nullptr NULL
  ------------------
  |  Branch (100:9): [True: 0, False: 262]
  |  Branch (100:28): [True: 0, False: 262]
  ------------------
  101|      0|        return;
  102|      0|    }
  103|       |
  104|    262|    memset(data, 0, data_size);
  105|    262|}

