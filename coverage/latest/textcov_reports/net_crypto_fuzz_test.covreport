fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Fuzz_SystemjjEXadL_ZN3$_18__invokeES3_jjEEEcvPFT_T0_DpT1_EIS1_S1_JjjEEEvENKUlS1_DpT_E_clIJjjEEEDaS1_SG_:
   31|    177|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Fuzz_SystemjjEXadL_ZN3$_18__invokeES3_jjEEE13static_casterIS1_EcvT_IS3_EEv:
   22|    177|        {
   23|    177|            return static_cast<To>(obj);
   24|    177|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Fuzz_SystemS1_jEXadL_ZN3$_28__invokeES3_S1_jEEEcvPFT_T0_DpT1_EIS1_S1_JS1_jEEEvENKUlS1_DpT_E_clIJS1_jEEEDaS1_SG_:
   31|      8|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Fuzz_SystemS1_jEXadL_ZN3$_28__invokeES3_S1_jEEE13static_casterIS1_EcvT_IS3_EEv:
   22|      8|        {
   23|      8|            return static_cast<To>(obj);
   24|      8|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Fuzz_SystemPvEXadL_ZN3$_38__invokeES2_S3_EEEcvPFT_T0_DpT1_EIvS3_JS3_EEEvENKUlS3_DpT_E_clIJS3_EEEDaS3_SG_:
   31|    190|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Fuzz_SystemPvEXadL_ZN3$_38__invokeES2_S3_EEE13static_casterIS3_EcvT_IS2_EEv:
   22|    190|        {
   23|    190|            return static_cast<To>(obj);
   24|    190|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketEXadL_ZN3$_48__invokeES2_S3_EEEcvPFT_T0_DpT1_EIiPvJS3_EEEvENKUlSF_DpT_E_clIJS3_EEEDaSF_SH_:
   31|     15|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketEXadL_ZN3$_48__invokeES2_S3_EEE13static_casterIPvEcvT_IS2_EEv:
   22|     15|        {
   23|     15|            return static_cast<To>(obj);
   24|     15|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketPK12Network_AddrEXadL_ZN3$_68__invokeES2_S3_S6_EEEcvPFT_T0_DpT1_EIiPvJS3_S6_EEEvENKUlSI_DpT_E_clIJS3_S6_EEEDaSI_SK_:
   31|     15|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketPK12Network_AddrEXadL_ZN3$_68__invokeES2_S3_S6_EEE13static_casterIPvEcvT_IS2_EEv:
   22|     15|        {
   23|     15|            return static_cast<To>(obj);
   24|     15|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPF6SocketP11Fuzz_SystemiiiEXadL_ZN4$_148__invokeES3_iiiEEEcvPFT_T0_DpT1_EIS1_PvJiiiEEEvENKUlSF_DpT_E_clIJiiiEEEDaSF_SH_:
   31|     15|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPF6SocketP11Fuzz_SystemiiiEXadL_ZN4$_148__invokeES3_iiiEEE13static_casterIPvEcvT_IS3_EEv:
   22|     15|        {
   23|     15|            return static_cast<To>(obj);
   24|     15|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketbEXadL_ZN4$_158__invokeES2_S3_bEEEcvPFT_T0_DpT1_EIiPvJS3_bEEEvENKUlSF_DpT_E_clIJS3_bEEEDaSF_SH_:
   31|     15|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketbEXadL_ZN4$_158__invokeES2_S3_bEEE13static_casterIPvEcvT_IS2_EEv:
   22|     15|        {
   23|     15|            return static_cast<To>(obj);
   24|     15|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketiiPvPmEXadL_ZN4$_168__invokeES2_S3_iiS4_S5_EEEcvPFT_T0_DpT1_EIiS4_JS3_iiS4_S5_EEEvENKUlS4_DpT_E_clIJS3_iiS4_S5_EEEDaS4_SI_:
   31|     15|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketiiPvPmEXadL_ZN4$_168__invokeES2_S3_iiS4_S5_EEE13static_casterIS4_EcvT_IS2_EEv:
   22|     15|        {
   23|     15|            return static_cast<To>(obj);
   24|     15|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketiiPKvmEXadL_ZN4$_178__invokeES2_S3_iiS5_mEEEcvPFT_T0_DpT1_EIiPvJS3_iiS5_mEEEvENKUlSH_DpT_E_clIJS3_iiS5_mEEEDaSH_SJ_:
   31|     60|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketiiPKvmEXadL_ZN4$_178__invokeES2_S3_iiS5_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|     60|        {
   23|     60|            return static_cast<To>(obj);
   24|     60|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Fuzz_SystemPhmEXadL_ZN4$_188__invokeES2_S3_mEEEcvPFT_T0_DpT1_EIvPvJS3_mEEEvENKUlSF_DpT_E_clIJS3_mEEEDaSF_SH_:
   31|     33|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Fuzz_SystemPhmEXadL_ZN4$_188__invokeES2_S3_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|     33|        {
   23|     33|            return static_cast<To>(obj);
   24|     33|        }

_ZN6SystemC2ENSt3__110unique_ptrI10Tox_SystemNS0_14default_deleteIS2_EEEENS1_I6MemoryNS3_IS6_EEEENS1_I7NetworkNS3_IS9_EEEENS1_I6RandomNS3_ISC_EEEE:
   38|     18|    : sys(std::move(in_sys))
   39|     18|    , mem(std::move(in_mem))
   40|     18|    , ns(std::move(in_ns))
   41|     18|    , rng(std::move(in_rng))
   42|     18|{
   43|     18|}
_ZN6SystemD2Ev:
   46|     18|System::~System() { }
_ZN11Fuzz_SystemC2ER9Fuzz_Data:
  232|     18|    : System{
  233|     18|        std::make_unique<Tox_System>(),
  234|     18|        std::make_unique<Memory>(Memory{&fuzz_memory_funcs, this}),
  235|     18|        std::make_unique<Network>(Network{&fuzz_network_funcs, this}),
  236|     18|        std::make_unique<Random>(Random{&fuzz_random_funcs, this}),
  237|     18|    }
  238|     18|    , data(input)
  239|     18|{
  240|     18|    sys->mono_time_callback = [](void *self) { return static_cast<Fuzz_System *>(self)->clock; };
  241|     18|    sys->mono_time_user_data = this;
  242|     18|    sys->mem = mem.get();
  243|     18|    sys->ns = ns.get();
  244|     18|    sys->rng = rng.get();
  245|     18|}
fuzz_support.cc:_ZL12report_allocPKcS0_mPv:
   79|    175|{
   80|    175|    if (Fuzz_Data::FUZZ_DEBUG) {
  ------------------
  |  Branch (80:9): [Folded - Ignored]
  ------------------
   81|      0|        printf("%s: %s(%zu): %s\n", name, func, size, ptr == nullptr ? "false" : "true");
  ------------------
  |  Branch (81:55): [True: 0, False: 0]
  ------------------
   82|      0|    }
   83|    175|    return ptr;
   84|    175|}
fuzz_support.cc:_ZNK3$_1clEP11Fuzz_Systemjj:
  103|    177|    ![](Fuzz_System *self, uint32_t nmemb, uint32_t size) {
  104|    177|        return alloc_common<decltype(std::calloc), std::calloc>(
  105|    177|            "calloc", nmemb * size, self->data, nmemb, size);
  106|    177|    },
fuzz_support.cc:_ZL12alloc_commonIDoFPvmmETnT_XadL_Z6callocEEJjjEES0_PKcmR9Fuzz_DataDpT1_:
   88|    177|{
   89|    177|    CONSUME1_OR_RETURN_VAL(
  ------------------
  |  |  122|    177|    if (INPUT.size() < sizeof(TYPE)) {                 \
  |  |  ------------------
  |  |  |  Branch (122:9): [True: 86, False: 91]
  |  |  ------------------
  |  |  123|     86|        return VAL;                                    \
  |  |  124|     86|    }                                                  \
  |  |  125|    177|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
   90|     91|        const bool, want_alloc, data, report_alloc("tox1", func, size, Func(args...)));
   91|     91|    if (!want_alloc) {
  ------------------
  |  Branch (91:9): [True: 10, False: 81]
  ------------------
   92|     10|        return nullptr;
   93|     10|    }
   94|     81|    return report_alloc("tox1", func, size, Func(args...));
   95|     91|}
fuzz_support.cc:_ZNK3$_2clEP11Fuzz_SystemPvj:
  108|      8|    ![](Fuzz_System *self, void *ptr, uint32_t size) {
  109|      8|        return alloc_common<decltype(std::realloc), std::realloc>(
  110|      8|            "realloc", size, self->data, ptr, size);
  111|      8|    },
fuzz_support.cc:_ZL12alloc_commonIDoFPvS0_mETnT_XadL_Z7reallocEEJS0_jEES0_PKcmR9Fuzz_DataDpT1_:
   88|      8|{
   89|      8|    CONSUME1_OR_RETURN_VAL(
  ------------------
  |  |  122|      8|    if (INPUT.size() < sizeof(TYPE)) {                 \
  |  |  ------------------
  |  |  |  Branch (122:9): [True: 8, False: 0]
  |  |  ------------------
  |  |  123|      8|        return VAL;                                    \
  |  |  124|      8|    }                                                  \
  |  |  125|      8|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
   90|      0|        const bool, want_alloc, data, report_alloc("tox1", func, size, Func(args...)));
   91|      0|    if (!want_alloc) {
  ------------------
  |  Branch (91:9): [True: 0, False: 0]
  ------------------
   92|      0|        return nullptr;
   93|      0|    }
   94|      0|    return report_alloc("tox1", func, size, Func(args...));
   95|      0|}
fuzz_support.cc:_ZNK3$_3clEP11Fuzz_SystemPv:
  113|    190|    ![](Fuzz_System *self, void *ptr) { std::free(ptr); },
fuzz_support.cc:_ZNK3$_4clEP11Fuzz_System6Socket:
  117|     15|    /* .close = */ ![](Fuzz_System *self, Socket sock) { return 0; },
fuzz_support.cc:_ZNK3$_6clEP11Fuzz_System6SocketPK12Network_Addr:
  119|     15|    /* .bind = */ ![](Fuzz_System *self, Socket sock, const Network_Addr *addr) { return 0; },
fuzz_support.cc:_ZNK4$_14clEP11Fuzz_Systemiii:
  162|     15|    /* .socket = */ ![](Fuzz_System *self, int domain, int type, int proto) { return Socket{42}; },
fuzz_support.cc:_ZNK4$_15clEP11Fuzz_System6Socketb:
  163|     15|    /* .socket_nonblock = */ ![](Fuzz_System *self, Socket sock, bool nonblock) { return 0; },
fuzz_support.cc:_ZNK4$_16clEP11Fuzz_System6SocketiiPvPm:
  165|     15|    ![](Fuzz_System *self, Socket sock, int level, int optname, void *optval, size_t *optlen) {
  166|     15|        std::memset(optval, 0, *optlen);
  167|     15|        return 0;
  168|     15|    },
fuzz_support.cc:_ZNK4$_17clEP11Fuzz_System6SocketiiPKvm:
  170|     60|    ![](Fuzz_System *self, Socket sock, int level, int optname, const void *optval, size_t optlen) {
  171|     60|        return 0;
  172|     60|    },
fuzz_support.cc:_ZNK4$_18clEP11Fuzz_SystemPhm:
  177|     33|    ![](Fuzz_System *self, uint8_t *bytes, size_t length) {
  178|       |        // Initialize the buffer with zeros in case there's no randomness left.
  179|     33|        std::fill_n(bytes, length, 0);
  180|       |
  181|       |        // For integers, we copy bytes directly, because we want to control the
  182|       |        // exact values.
  183|     33|        if (length == sizeof(uint8_t) || length == sizeof(uint16_t) || length == sizeof(uint32_t)
  ------------------
  |  Branch (183:13): [True: 0, False: 33]
  |  Branch (183:42): [True: 0, False: 33]
  |  Branch (183:72): [True: 0, False: 33]
  ------------------
  184|     33|            || length == sizeof(uint64_t)) {
  ------------------
  |  Branch (184:16): [True: 8, False: 25]
  ------------------
  185|      8|            CONSUME_OR_RETURN(const uint8_t *data, self->data, length);
  ------------------
  |  |  139|      8|    if (INPUT.size() < SIZE) {               \
  |  |  ------------------
  |  |  |  Branch (139:9): [True: 8, False: 0]
  |  |  ------------------
  |  |  140|      8|        return;                              \
  |  |  141|      8|    }                                        \
  |  |  142|      8|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
  186|      0|            std::copy(data, data + length, bytes);
  187|      0|            if (Fuzz_Data::FUZZ_DEBUG) {
  ------------------
  |  Branch (187:17): [Folded - Ignored]
  ------------------
  188|      0|                if (length == 1) {
  ------------------
  |  Branch (188:21): [True: 0, False: 0]
  ------------------
  189|      0|                    std::printf("rng: %d (0x%02x)\n", bytes[0], bytes[0]);
  190|      0|                } else {
  191|      0|                    std::printf("rng: %02x..%02x[%zu]\n", bytes[0], bytes[length - 1], length);
  192|      0|                }
  193|      0|            }
  194|      0|            return;
  195|      8|        }
  196|       |
  197|       |        // For nonces and keys, we fill the buffer with the same 1-2 bytes
  198|       |        // repeated. We only need these to be different enough to not often be
  199|       |        // the same.
  200|     25|        assert(length == 24 || length == 32);
  201|       |        // We must cover the case of having only 1 byte left in the input. In
  202|       |        // that case, we will use the same byte for all the bytes in the output.
  203|     25|        const size_t chunk_size = std::max(self->data.size(), static_cast<std::size_t>(2));
  204|     25|        CONSUME_OR_RETURN(const uint8_t *chunk, self->data, chunk_size);
  ------------------
  |  |  139|     25|    if (INPUT.size() < SIZE) {               \
  |  |  ------------------
  |  |  |  Branch (139:9): [True: 23, False: 2]
  |  |  ------------------
  |  |  140|     23|        return;                              \
  |  |  141|     23|    }                                        \
  |  |  142|     25|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
  205|      2|        if (chunk_size == 2) {
  ------------------
  |  Branch (205:13): [True: 1, False: 1]
  ------------------
  206|      1|            std::fill_n(bytes, length / 2, chunk[0]);
  207|      1|            std::fill_n(bytes + length / 2, length / 2, chunk[1]);
  208|      1|        } else {
  209|      1|            std::fill_n(bytes, length, chunk[0]);
  210|      1|        }
  211|      2|        if (Fuzz_Data::FUZZ_DEBUG) {
  ------------------
  |  Branch (211:13): [Folded - Ignored]
  ------------------
  212|      0|            if (length == 1) {
  ------------------
  |  Branch (212:17): [True: 0, False: 0]
  ------------------
  213|      0|                std::printf("rng: %d (0x%02x)\n", bytes[0], bytes[0]);
  214|      0|            } else {
  215|      0|                std::printf("rng: %02x..%02x[%zu]\n", bytes[0], bytes[length - 1], length);
  216|      0|            }
  217|      0|        }
  218|      2|    },

_ZNK9Fuzz_Data4sizeEv:
   69|    282|    std::size_t size() const { return size_; }
_ZN9Fuzz_Data7consumeEPKcm:
   75|     40|    {
   76|     40|        const uint8_t *val = data_;
   77|     40|        if (FUZZ_DEBUG) {
  ------------------
  |  Branch (77:13): [Folded - Ignored]
  ------------------
   78|      0|            if (pos() == TRACE_TRAP) {
  ------------------
  |  Branch (78:17): [True: 0, False: 0]
  ------------------
   79|      0|                __asm__("int $3");
   80|      0|            }
   81|      0|            if (count == 1) {
  ------------------
  |  Branch (81:17): [True: 0, False: 0]
  ------------------
   82|      0|                std::printf("consume@%zu(%s): %d (0x%02x)\n", pos(), func, val[0], val[0]);
   83|      0|            } else if (count != 0) {
  ------------------
  |  Branch (83:24): [True: 0, False: 0]
  ------------------
   84|      0|                std::printf("consume@%zu(%s): %02x..%02x[%zu]\n", pos(), func, val[0],
   85|      0|                    val[count - 1], count);
   86|      0|            }
   87|      0|        }
   88|     40|        data_ += count;
   89|     40|        size_ -= count;
   90|     40|        return val;
   91|     40|    }
net_crypto_fuzz_test.cc:_Z18fuzz_select_targetIJXadL_ZN12_GLOBAL__N_113TestNetCryptoER9Fuzz_DataEEEEvPKhm:
  183|     20|{
  184|     20|    Fuzz_Data input{data, size};
  185|       |
  186|     20|    CONSUME1_OR_RETURN(const uint8_t, selector, input);
  ------------------
  |  |  105|     20|    if (INPUT.size() < sizeof(TYPE)) {        \
  |  |  ------------------
  |  |  |  Branch (105:9): [True: 0, False: 20]
  |  |  ------------------
  |  |  106|      0|        return;                               \
  |  |  107|      0|    }                                         \
  |  |  108|     20|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
  187|     20|    return Fuzz_Target_Selector<Args...>::select(selector, input);
  188|     20|}
_ZN9Fuzz_DataC2EPKhm:
   32|     20|        : data_(input_data)
   33|     20|        , base_(input_data)
   34|     20|        , size_(input_size)
   35|     20|    {
   36|     20|    }
_ZN9Fuzz_Data8consume1EPKc:
   68|    111|    Consumer consume1(const char *func) { return Consumer{func, *this}; }
_ZN9Fuzz_Data8ConsumercvT_IhEEv:
   60|     20|        {
   61|     20|            const uint8_t *bytes = fd.consume(func, sizeof(T));
   62|     20|            T val;
   63|     20|            std::memcpy(&val, bytes, sizeof(T));
   64|     20|            return val;
   65|     20|        }
net_crypto_fuzz_test.cc:_ZN20Fuzz_Target_SelectorIJXadL_ZN12_GLOBAL__N_113TestNetCryptoER9Fuzz_DataEEEE6selectEhS2_:
  164|     20|    {
  165|     20|        if (selector == sizeof...(Args)) {
  ------------------
  |  Branch (165:13): [True: 19, False: 1]
  ------------------
  166|     19|            return Arg(input);
  167|     19|        }
  168|      1|        return Fuzz_Target_Selector<Args...>::select(selector, input);
  169|     20|    }
_ZN20Fuzz_Target_SelectorIJEE6selectEhR9Fuzz_Data:
  175|      1|    {
  176|       |        // The selector selected no function, so we do nothing and rely on the
  177|       |        // fuzzer to come up with a better selector.
  178|      1|    }
_ZN9Fuzz_Data8ConsumercvbEv:
   46|     91|        {
   47|       |            // Special case because memcpy causes UB for bool (which can't be
   48|       |            // anything other than 0 or 1).
   49|     91|            const bool val = fd.data_[0];
   50|     91|            if (FUZZ_DEBUG) {
  ------------------
  |  Branch (50:17): [Folded - Ignored]
  ------------------
   51|      0|                std::printf("consume@%zu(%s): bool %s\n", fd.pos(), func, val ? "true" : "false");
  ------------------
  |  Branch (51:75): [True: 0, False: 0]
  ------------------
   52|      0|            }
   53|     91|            ++fd.data_;
   54|     91|            --fd.size_;
   55|     91|            return val;
   56|     91|        }

dht_get_net:
  165|     36|{
  166|     36|    return dht->net;
  167|     36|}
get_close_nodes:
  755|      8|{
  756|      8|    return get_somewhat_close_nodes(
  757|      8|               dht->cur_time, public_key, nodes_list,
  758|      8|               sa_family, dht->close_clientlist,
  759|      8|               dht->friends_list, dht->num_friends,
  760|      8|               is_lan, want_announce);
  761|      8|}
dht_addfriend:
 1630|     16|{
 1631|     16|    const uint32_t friend_num = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);
 1632|       |
 1633|     16|    if (friend_num != UINT32_MAX) { /* Is friend already in DHT? */
  ------------------
  |  Branch (1633:9): [True: 8, False: 8]
  ------------------
 1634|      8|        DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
 1635|      8|        const uint32_t tmp_lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1636|       |
 1637|      8|        if (tmp_lock_token == 0) {
  ------------------
  |  Branch (1637:13): [True: 0, False: 8]
  ------------------
 1638|      0|            return -1;
 1639|      0|        }
 1640|       |
 1641|      8|        return 0;
 1642|      8|    }
 1643|       |
 1644|      8|    DHT_Friend *const temp = (DHT_Friend *)mem_vrealloc(dht->mem, dht->friends_list, dht->num_friends + 1, sizeof(DHT_Friend));
 1645|       |
 1646|      8|    if (temp == nullptr) {
  ------------------
  |  |   63|      8|#define nullptr NULL
  ------------------
  |  Branch (1646:9): [True: 0, False: 8]
  ------------------
 1647|      0|        return -1;
 1648|      0|    }
 1649|       |
 1650|      8|    dht->friends_list = temp;
 1651|      8|    DHT_Friend *const dht_friend = &dht->friends_list[dht->num_friends];
 1652|      8|    *dht_friend = empty_dht_friend;
 1653|      8|    memcpy(dht_friend->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|      8|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1654|       |
 1655|      8|    dht_friend->nat.nat_ping_id = random_u64(dht->rng);
 1656|      8|    ++dht->num_friends;
 1657|       |
 1658|      8|    *lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1659|      8|    assert(*lock_token != 0); // Friend was newly allocated
 1660|       |
 1661|      8|    dht_friend->num_to_bootstrap = get_close_nodes(dht, dht_friend->public_key, dht_friend->to_bootstrap, net_family_unspec(),
 1662|      8|                                   true, false);
 1663|       |
 1664|      8|    return 0;
 1665|      8|}
cryptopacket_registerhandler:
 2488|     21|{
 2489|     21|    dht->cryptopackethandlers[byte].function = cb;
 2490|     21|    dht->cryptopackethandlers[byte].object = object;
 2491|     21|}
new_dht:
 2569|     13|{
 2570|     13|    if (net == nullptr) {
  ------------------
  |  |   63|     13|#define nullptr NULL
  ------------------
  |  Branch (2570:9): [True: 0, False: 13]
  ------------------
 2571|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2572|      0|    }
 2573|       |
 2574|     13|    DHT *const dht = (DHT *)mem_alloc(mem, sizeof(DHT));
 2575|       |
 2576|     13|    if (dht == nullptr) {
  ------------------
  |  |   63|     13|#define nullptr NULL
  ------------------
  |  Branch (2576:9): [True: 1, False: 12]
  ------------------
 2577|      1|        LOGGER_ERROR(log, "failed to allocate DHT struct (%ld bytes)", (unsigned long)sizeof(DHT));
  ------------------
  |  |   87|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      1|    do {                                                                         \
  |  |  |  |   77|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      1|        }                                                                        \
  |  |  |  |   80|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2578|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 2579|      1|    }
 2580|       |
 2581|     12|    dht->ns = ns;
 2582|     12|    dht->mono_time = mono_time;
 2583|     12|    dht->cur_time = mono_time_get(mono_time);
 2584|     12|    dht->log = log;
 2585|     12|    dht->net = net;
 2586|     12|    dht->rng = rng;
 2587|     12|    dht->mem = mem;
 2588|       |
 2589|     12|    dht->hole_punching_enabled = hole_punching_enabled;
 2590|     12|    dht->lan_discovery_enabled = lan_discovery_enabled;
 2591|       |
 2592|     12|    dht->ping = ping_new(mem, mono_time, rng, dht);
 2593|       |
 2594|     12|    if (dht->ping == nullptr) {
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
  |  Branch (2594:9): [True: 3, False: 9]
  ------------------
 2595|      3|        LOGGER_ERROR(log, "failed to initialise ping");
  ------------------
  |  |   87|      3|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      3|    do {                                                                         \
  |  |  |  |   77|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      3|        }                                                                        \
  |  |  |  |   80|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2596|      3|        kill_dht(dht);
 2597|      3|        return nullptr;
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
 2598|      3|    }
 2599|       |
 2600|      9|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, &handle_nodes_request, dht);
 2601|      9|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, &handle_nodes_response, dht);
 2602|      9|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, &cryptopacket_handle, dht);
 2603|      9|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, &handle_lan_discovery, dht);
 2604|      9|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, &handle_nat_ping, dht);
  ------------------
  |  |   68|      9|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
 2605|       |
 2606|      9|#ifdef CHECK_ANNOUNCE_NODE
 2607|      9|    networking_registerhandler(dht->net, NET_PACKET_DATA_SEARCH_RESPONSE, &handle_data_search_response, dht);
 2608|      9|#endif /* CHECK_ANNOUNCE_NODE */
 2609|       |
 2610|      9|    crypto_new_keypair(rng, dht->self_public_key, dht->self_secret_key);
 2611|       |
 2612|      9|    dht->shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   57|      9|#define KEYS_TIMEOUT 600
  ------------------
                  dht->shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|      9|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2613|      9|    dht->shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   57|      9|#define KEYS_TIMEOUT 600
  ------------------
                  dht->shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|      9|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2614|       |
 2615|      9|    if (dht->shared_keys_recv == nullptr || dht->shared_keys_sent == nullptr) {
  ------------------
  |  |   63|     18|#define nullptr NULL
  ------------------
                  if (dht->shared_keys_recv == nullptr || dht->shared_keys_sent == nullptr) {
  ------------------
  |  |   63|      8|#define nullptr NULL
  ------------------
  |  Branch (2615:9): [True: 1, False: 8]
  |  Branch (2615:45): [True: 0, False: 8]
  ------------------
 2616|      1|        LOGGER_ERROR(log, "failed to initialise shared key cache");
  ------------------
  |  |   87|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      1|    do {                                                                         \
  |  |  |  |   77|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      1|        }                                                                        \
  |  |  |  |   80|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2617|      1|        kill_dht(dht);
 2618|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 2619|      1|    }
 2620|       |
 2621|      8|    dht->dht_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   46|      8|#define DHT_PING_ARRAY_SIZE 512
  ------------------
                  dht->dht_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   43|      8|#define PING_TIMEOUT 5
  ------------------
 2622|       |
 2623|      8|    if (dht->dht_ping_array == nullptr) {
  ------------------
  |  |   63|      8|#define nullptr NULL
  ------------------
  |  Branch (2623:9): [True: 0, False: 8]
  ------------------
 2624|      0|        LOGGER_ERROR(log, "failed to initialise ping array");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2625|      0|        kill_dht(dht);
 2626|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2627|      0|    }
 2628|       |
 2629|     24|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
  ------------------
  |  |   61|     24|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2629:26): [True: 16, False: 8]
  ------------------
 2630|     16|        uint8_t random_public_key_bytes[CRYPTO_PUBLIC_KEY_SIZE];
 2631|     16|        uint8_t random_secret_key_bytes[CRYPTO_SECRET_KEY_SIZE];
 2632|       |
 2633|     16|        crypto_new_keypair(rng, random_public_key_bytes, random_secret_key_bytes);
 2634|       |
 2635|     16|        uint32_t token; // We don't intend to delete these ever, but need to pass the token
 2636|     16|        if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|     16|#define nullptr NULL
  ------------------
                      if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|     16|#define nullptr NULL
  ------------------
  |  Branch (2636:13): [True: 0, False: 16]
  ------------------
 2637|      0|            LOGGER_ERROR(log, "failed to add initial random seed DHT friends");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2638|      0|            kill_dht(dht);
 2639|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2640|      0|        }
 2641|     16|    }
 2642|       |
 2643|      8|    if (dht->num_friends != DHT_FAKE_FRIEND_NUMBER) {
  ------------------
  |  |   61|      8|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2643:9): [True: 8, False: 0]
  ------------------
 2644|      8|        LOGGER_ERROR(log, "the RNG provided seems to be broken: it generated the same keypair twice");
  ------------------
  |  |   87|      8|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      8|    do {                                                                         \
  |  |  |  |   77|      8|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     16|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      8|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      8|        }                                                                        \
  |  |  |  |   80|      8|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2645|      8|        kill_dht(dht);
 2646|      8|        return nullptr;
  ------------------
  |  |   63|      8|#define nullptr NULL
  ------------------
 2647|      8|    }
 2648|       |
 2649|      0|    return dht;
 2650|      8|}
kill_dht:
 2674|     12|{
 2675|     12|    if (dht == nullptr) {
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
  |  Branch (2675:9): [True: 0, False: 12]
  ------------------
 2676|      0|        return;
 2677|      0|    }
 2678|       |
 2679|     12|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
 2680|     12|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
 2681|     12|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
 2682|     12|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
 2683|     12|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   68|     12|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
 2684|       |
 2685|     12|    shared_key_cache_free(dht->shared_keys_recv);
 2686|     12|    shared_key_cache_free(dht->shared_keys_sent);
 2687|     12|    ping_array_kill(dht->dht_ping_array);
 2688|     12|    ping_kill(dht->mem, dht->ping);
 2689|     12|    mem_delete(dht->mem, dht->friends_list);
 2690|     12|    mem_delete(dht->mem, dht->loaded_nodes_list);
 2691|     12|    crypto_memzero(dht->self_secret_key, sizeof(dht->self_secret_key));
 2692|     12|    mem_delete(dht->mem, dht);
 2693|     12|}
DHT.c:get_somewhat_close_nodes:
  726|      8|{
  727|     40|    for (uint16_t i = 0; i < MAX_SENT_NODES; ++i) {
  ------------------
  |  |   40|     40|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (727:26): [True: 32, False: 8]
  ------------------
  728|     32|        nodes_list[i] = empty_node_format;
  729|     32|    }
  730|       |
  731|      8|    uint32_t num_nodes = 0;
  732|      8|    get_close_nodes_inner(
  733|      8|        cur_time, public_key,
  734|      8|        nodes_list, &num_nodes,
  735|      8|        sa_family, close_clientlist, LCLIENT_LIST,
  ------------------
  |  |   35|      8|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   32|      8|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   31|      8|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   29|      8|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  736|      8|        is_lan, want_announce);
  737|       |
  738|     16|    for (uint16_t i = 0; i < friends_list_size; ++i) {
  ------------------
  |  Branch (738:26): [True: 8, False: 8]
  ------------------
  739|      8|        const DHT_Friend *dht_friend = &friends_list[i];
  740|       |
  741|      8|        get_close_nodes_inner(
  742|      8|            cur_time, public_key,
  743|      8|            nodes_list, &num_nodes,
  744|      8|            sa_family, dht_friend->client_list, MAX_FRIEND_CLIENTS,
  ------------------
  |  |   29|      8|#define MAX_FRIEND_CLIENTS 8
  ------------------
  745|      8|            is_lan, want_announce);
  746|      8|    }
  747|       |
  748|      8|    return num_nodes;
  749|      8|}
DHT.c:get_close_nodes_inner:
  655|     16|{
  656|     16|    if (!net_family_is_ipv4(sa_family) && !net_family_is_ipv6(sa_family) && !net_family_is_unspec(sa_family)) {
  ------------------
  |  Branch (656:9): [True: 16, False: 0]
  |  Branch (656:43): [True: 16, False: 0]
  |  Branch (656:77): [True: 0, False: 16]
  ------------------
  657|      0|        return;
  658|      0|    }
  659|       |
  660|     16|    uint32_t num_nodes = *num_nodes_ptr;
  661|       |
  662|  8.27k|    for (uint32_t i = 0; i < client_list_length; ++i) {
  ------------------
  |  Branch (662:26): [True: 8.25k, False: 16]
  ------------------
  663|  8.25k|        const Client_data *const client = &client_list[i];
  664|       |
  665|       |        /* node already in list? */
  666|  8.25k|        if (index_of_node_pk(nodes_list, MAX_SENT_NODES, client->public_key) != UINT32_MAX) {
  ------------------
  |  |   40|  8.25k|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (666:13): [True: 8.25k, False: 0]
  ------------------
  667|  8.25k|            continue;
  668|  8.25k|        }
  669|       |
  670|      0|        const IPPTsPng *ipptp;
  671|       |
  672|      0|        if (net_family_is_ipv4(sa_family)) {
  ------------------
  |  Branch (672:13): [True: 0, False: 0]
  ------------------
  673|      0|            ipptp = &client->assoc4;
  674|      0|        } else if (net_family_is_ipv6(sa_family)) {
  ------------------
  |  Branch (674:20): [True: 0, False: 0]
  ------------------
  675|      0|            ipptp = &client->assoc6;
  676|      0|        } else if (client->assoc4.timestamp >= client->assoc6.timestamp) {
  ------------------
  |  Branch (676:20): [True: 0, False: 0]
  ------------------
  677|      0|            ipptp = &client->assoc4;
  678|      0|        } else {
  679|      0|            ipptp = &client->assoc6;
  680|      0|        }
  681|       |
  682|       |        /* node not in a good condition? */
  683|      0|        if (assoc_timeout(cur_time, ipptp)) {
  ------------------
  |  Branch (683:13): [True: 0, False: 0]
  ------------------
  684|      0|            continue;
  685|      0|        }
  686|       |
  687|       |        /* don't send LAN ips to non LAN peers */
  688|      0|        if (ip_is_lan(&ipptp->ip_port.ip) && !is_lan) {
  ------------------
  |  Branch (688:13): [True: 0, False: 0]
  |  Branch (688:46): [True: 0, False: 0]
  ------------------
  689|      0|            continue;
  690|      0|        }
  691|       |
  692|      0|#ifdef CHECK_ANNOUNCE_NODE
  693|       |
  694|      0|        if (want_announce && !client->announce_node) {
  ------------------
  |  Branch (694:13): [True: 0, False: 0]
  |  Branch (694:30): [True: 0, False: 0]
  ------------------
  695|      0|            continue;
  696|      0|        }
  697|       |
  698|      0|#endif /* CHECK_ANNOUNCE_NODE */
  699|       |
  700|      0|        if (num_nodes < MAX_SENT_NODES) {
  ------------------
  |  |   40|      0|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (700:13): [True: 0, False: 0]
  ------------------
  701|      0|            memcpy(nodes_list[num_nodes].public_key, client->public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  702|      0|            nodes_list[num_nodes].ip_port = ipptp->ip_port;
  703|      0|            ++num_nodes;
  704|      0|        } else {
  705|       |            // TODO(zugz): this could be made significantly more efficient by
  706|       |            // using a version of add_to_list which works with a sorted list.
  707|      0|            add_to_list(nodes_list, MAX_SENT_NODES, client->public_key, &ipptp->ip_port, public_key);
  ------------------
  |  |   40|      0|#define MAX_SENT_NODES 4
  ------------------
  708|      0|        }
  709|      0|    }
  710|       |
  711|     16|    *num_nodes_ptr = num_nodes;
  712|     16|}
DHT.c:index_of_node_pk:
  498|  8.25k|{
  499|  8.25k|    assert(size == 0 || array != nullptr);
  500|       |
  501|  8.25k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (501:26): [True: 8.25k, False: 0]
  ------------------
  502|  8.25k|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (502:13): [True: 8.25k, False: 0]
  ------------------
  503|  8.25k|            return i;
  504|  8.25k|        }
  505|  8.25k|    }
  506|       |
  507|      0|    return UINT32_MAX;
  508|  8.25k|}
DHT.c:index_of_friend_pk:
  484|     16|{
  485|     16|    assert(size == 0 || array != nullptr);
  486|       |
  487|     16|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (487:26): [True: 8, False: 8]
  ------------------
  488|      8|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (488:13): [True: 8, False: 0]
  ------------------
  489|      8|            return i;
  490|      8|        }
  491|      8|    }
  492|       |
  493|      8|    return UINT32_MAX;
  494|     16|}
DHT.c:dht_friend_lock:
 1575|     16|{
 1576|       |    // find first free slot
 1577|     16|    uint8_t lock_num;
 1578|     16|    uint32_t lock_token = 0;
 1579|     24|    for (lock_num = 0; lock_num < DHT_FRIEND_MAX_LOCKS; ++lock_num) {
  ------------------
  |  |   53|     24|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1579:24): [True: 24, False: 0]
  ------------------
 1580|     24|        lock_token = UINT32_C(1) << lock_num;
 1581|     24|        if ((dht_friend->lock_flags & lock_token) == 0) {
  ------------------
  |  Branch (1581:13): [True: 16, False: 8]
  ------------------
 1582|     16|            break;
 1583|     16|        }
 1584|     24|    }
 1585|       |
 1586|       |    // One of the conditions would be enough, but static analyzers don't get that
 1587|     16|    if (lock_token == 0 || lock_num == DHT_FRIEND_MAX_LOCKS) {
  ------------------
  |  |   53|     16|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1587:9): [True: 0, False: 16]
  |  Branch (1587:28): [True: 0, False: 16]
  ------------------
 1588|      0|        return 0;
 1589|      0|    }
 1590|       |
 1591|       |    // Claim that slot
 1592|     16|    dht_friend->lock_flags |= lock_token;
 1593|       |
 1594|     16|    dht_friend->callbacks[lock_num].ip_callback = ip_callback;
 1595|     16|    dht_friend->callbacks[lock_num].data = data;
 1596|     16|    dht_friend->callbacks[lock_num].number = number;
 1597|       |
 1598|     16|    return lock_token;
 1599|     16|}

crypto_memzero:
  116|     29|{
  117|     29|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  118|     29|    memzero((uint8_t *)data, length);
  119|       |#else
  120|       |    sodium_memzero(data, length);
  121|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  122|     29|}
crypto_memlock:
  125|     17|{
  126|     17|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  127|     17|    return false;
  128|       |#else
  129|       |
  130|       |    return sodium_mlock(data, length) == 0;
  131|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  132|     17|}
crypto_memunlock:
  135|     17|{
  136|     17|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  137|     17|    return false;
  138|       |#else
  139|       |
  140|       |    return sodium_munlock(data, length) == 0;
  141|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  142|     17|}
pk_equal:
  145|  8.26k|{
  146|  8.26k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  147|       |    // Hope that this is better for the fuzzer
  148|  8.26k|    return memcmp(pk1, pk2, CRYPTO_PUBLIC_KEY_SIZE) == 0;
  ------------------
  |  |   43|  8.26k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  149|       |#else
  150|       |    return crypto_verify_32(pk1, pk2) == 0;
  151|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  152|  8.26k|}
random_u64:
  201|      8|{
  202|      8|    uint64_t randnum;
  203|      8|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  204|      8|    return randnum;
  205|      8|}
crypto_new_keypair:
  439|     25|{
  440|     25|    random_bytes(rng, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   48|     25|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
  441|     25|    memzero(public_key, CRYPTO_PUBLIC_KEY_SIZE);  // Make MSAN happy
  ------------------
  |  |   43|     25|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  442|     25|    crypto_derive_public_key(public_key, secret_key);
  443|     25|    return 0;
  444|     25|}
crypto_derive_public_key:
  448|     25|{
  449|     25|    crypto_scalarmult_curve25519_base(public_key, secret_key);
  450|     25|}
random_bytes:
  533|     33|{
  534|     33|    rng->funcs->random_bytes(rng->obj, bytes, length);
  535|     33|}

logger_new:
   33|     18|{
   34|     18|    Logger *log = (Logger *)mem_alloc(mem, sizeof(Logger));
   35|       |
   36|     18|    if (log == nullptr) {
  ------------------
  |  |   63|     18|#define nullptr NULL
  ------------------
  |  Branch (36:9): [True: 1, False: 17]
  ------------------
   37|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
   38|      1|    }
   39|       |
   40|     17|    log->mem = mem;
   41|       |
   42|     17|    return log;
   43|     18|}
logger_kill:
   46|     17|{
   47|     17|    if (log == nullptr) {
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
  |  Branch (47:9): [True: 0, False: 17]
  ------------------
   48|      0|        return;
   49|      0|    }
   50|       |
   51|     17|    mem_delete(log->mem, log);
   52|     17|}
logger_write:
   64|     14|{
   65|     14|    if (log == nullptr) {
  ------------------
  |  |   63|     14|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 0, False: 14]
  ------------------
   66|      0|        return;
   67|      0|    }
   68|       |
   69|     14|    if (log->callback == nullptr) {
  ------------------
  |  |   63|     14|#define nullptr NULL
  ------------------
  |  Branch (69:9): [True: 14, False: 0]
  ------------------
   70|     14|        return;
   71|     14|    }
   72|       |
   73|       |    // Only pass the file name, not the entire file path, for privacy reasons.
   74|       |    // The full path may contain PII of the person compiling toxcore (their
   75|       |    // username and directory layout).
   76|      0|    const char *filename = strrchr(file, '/');
   77|      0|    file = filename != nullptr ? filename + 1 : file;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (77:12): [True: 0, False: 0]
  ------------------
   78|       |#if defined(_WIN32) || defined(__CYGWIN__)
   79|       |    // On Windows, the path separator *may* be a backslash, so we look for that
   80|       |    // one too.
   81|       |    const char *windows_filename = strrchr(file, '\\');
   82|       |    file = windows_filename != nullptr ? windows_filename + 1 : file;
   83|       |#endif /* WIN32 */
   84|       |
   85|       |    // Format message
   86|      0|    char msg[1024];
   87|      0|    va_list args;
   88|      0|    va_start(args, format);
   89|      0|    vsnprintf(msg, sizeof(msg), format, args);
   90|      0|    va_end(args);
   91|       |
   92|      0|    log->callback(log->context, level, file, line, func, msg, log->userdata);
   93|      0|}

mem_alloc:
   63|    142|{
   64|    142|    void *const ptr = mem->funcs->calloc(mem->obj, 1, size);
   65|    142|    return ptr;
   66|    142|}
mem_valloc:
   69|     35|{
   70|     35|    const uint32_t bytes = nmemb * size;
   71|       |
   72|     35|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (72:9): [True: 35, False: 0]
  |  Branch (72:22): [True: 0, False: 35]
  ------------------
   73|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   74|      0|    }
   75|       |
   76|     35|    void *const ptr = mem->funcs->calloc(mem->obj, nmemb, size);
   77|     35|    return ptr;
   78|     35|}
mem_vrealloc:
   81|      8|{
   82|      8|    const uint32_t bytes = nmemb * size;
   83|       |
   84|      8|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (84:9): [True: 8, False: 0]
  |  Branch (84:22): [True: 0, False: 8]
  ------------------
   85|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   86|      0|    }
   87|       |
   88|      8|    void *const new_ptr = mem->funcs->realloc(mem->obj, ptr, bytes);
   89|      8|    return new_ptr;
   90|      8|}
mem_delete:
   93|    190|{
   94|    190|    mem->funcs->free(mem->obj, ptr);
   95|    190|}

mono_time_new:
  114|     15|{
  115|     15|    Mono_Time *mono_time = (Mono_Time *)mem_alloc(mem, sizeof(Mono_Time));
  116|       |
  117|     15|    if (mono_time == nullptr) {
  ------------------
  |  |   63|     15|#define nullptr NULL
  ------------------
  |  Branch (117:9): [True: 1, False: 14]
  ------------------
  118|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  119|      1|    }
  120|       |
  121|     14|#ifndef ESP_PLATFORM
  122|     14|    pthread_rwlock_t *rwlock = (pthread_rwlock_t *)mem_alloc(mem, sizeof(pthread_rwlock_t));
  123|       |
  124|     14|    if (rwlock == nullptr) {
  ------------------
  |  |   63|     14|#define nullptr NULL
  ------------------
  |  Branch (124:9): [True: 1, False: 13]
  ------------------
  125|      1|        mem_delete(mem, mono_time);
  126|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  127|      1|    }
  128|       |
  129|     13|    if (pthread_rwlock_init(rwlock, nullptr) != 0) {
  ------------------
  |  |   63|     13|#define nullptr NULL
  ------------------
  |  Branch (129:9): [True: 0, False: 13]
  ------------------
  130|      0|        mem_delete(mem, rwlock);
  131|      0|        mem_delete(mem, mono_time);
  132|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  133|      0|    }
  134|       |
  135|     13|    mono_time->time_update_lock = rwlock;
  136|     13|#endif /* ESP_PLATFORM */
  137|       |
  138|     13|    mono_time_set_current_time_callback(mono_time, current_time_callback, user_data);
  139|       |
  140|     13|    mono_time->cur_time = 0;
  141|     13|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  142|       |    // Maximum reproducibility. Never return time = 0.
  143|     13|    mono_time->base_time = 1000000000;
  144|       |#else
  145|       |    // Never return time = 0 in case time() returns 0 (e.g. on microcontrollers
  146|       |    // without battery-powered RTC or ones where NTP didn't initialise it yet).
  147|       |    mono_time->base_time = max_u64(1, (uint64_t)time(nullptr)) * UINT64_C(1000) - current_time_monotonic(mono_time);
  148|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  149|       |
  150|     13|    mono_time_update(mono_time);
  151|       |
  152|     13|    return mono_time;
  153|     13|}
mono_time_free:
  156|     13|{
  157|     13|    if (mono_time == nullptr) {
  ------------------
  |  |   63|     13|#define nullptr NULL
  ------------------
  |  Branch (157:9): [True: 0, False: 13]
  ------------------
  158|      0|        return;
  159|      0|    }
  160|     13|#ifndef ESP_PLATFORM
  161|     13|    pthread_rwlock_destroy(mono_time->time_update_lock);
  162|     13|    mem_delete(mem, mono_time->time_update_lock);
  163|     13|#endif /* ESP_PLATFORM */
  164|     13|    mem_delete(mem, mono_time);
  165|     13|}
mono_time_update:
  168|     13|{
  169|     13|    const uint64_t cur_time =
  170|     13|        mono_time->base_time + mono_time->current_time_callback(mono_time->user_data);
  171|       |
  172|     13|#ifndef ESP_PLATFORM
  173|     13|    pthread_rwlock_wrlock(mono_time->time_update_lock);
  174|     13|#endif /* ESP_PLATFORM */
  175|     13|    mono_time->cur_time = cur_time;
  176|     13|#ifndef ESP_PLATFORM
  177|     13|    pthread_rwlock_unlock(mono_time->time_update_lock);
  178|     13|#endif /* ESP_PLATFORM */
  179|     13|}
mono_time_get_ms:
  182|     30|{
  183|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  184|       |    // Fuzzing is only single thread for now, no locking needed */
  185|       |    pthread_rwlock_rdlock(mono_time->time_update_lock);
  186|       |#endif /* !ESP_PLATFORM */
  187|     30|    const uint64_t cur_time = mono_time->cur_time;
  188|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  189|       |    pthread_rwlock_unlock(mono_time->time_update_lock);
  190|       |#endif /* !ESP_PLATFORM */
  191|     30|    return cur_time;
  192|     30|}
mono_time_get:
  195|     30|{
  196|     30|    return mono_time_get_ms(mono_time) / UINT64_C(1000);
  197|     30|}
mono_time_set_current_time_callback:
  206|     13|{
  207|     13|    if (current_time_callback == nullptr) {
  ------------------
  |  |   63|     13|#define nullptr NULL
  ------------------
  |  Branch (207:9): [True: 0, False: 13]
  ------------------
  208|      0|        mono_time->current_time_callback = current_time_monotonic_default;
  209|      0|        mono_time->user_data = mono_time;
  210|     13|    } else {
  211|     13|        mono_time->current_time_callback = current_time_callback;
  212|     13|        mono_time->user_data = user_data;
  213|     13|    }
  214|     13|}

LLVMFuzzerTestOneInput:
  101|     20|{
  102|     20|    fuzz_select_target<TestNetCrypto>(data, size);
  103|     20|    return 0;
  104|     20|}
net_crypto_fuzz_test.cc:_ZN12_GLOBAL__N_113TestNetCryptoER9Fuzz_Data:
   31|     19|{
   32|     19|    const auto prep = prepare(input);
   33|     19|    if (!prep.has_value()) {
  ------------------
  |  Branch (33:9): [True: 1, False: 18]
  ------------------
   34|      1|        return;
   35|      1|    }
   36|     18|    const auto [ipp, iterations] = prep.value();
   37|       |
   38|       |    // rest of the fuzz data is input for malloc and network
   39|     18|    Fuzz_System sys(input);
   40|       |
   41|     18|    const Ptr<Logger> logger(logger_new(sys.mem.get()), logger_kill);
   42|     18|    if (logger == nullptr) {
  ------------------
  |  Branch (42:9): [True: 1, False: 17]
  ------------------
   43|      1|        return;
   44|      1|    }
   45|       |
   46|     17|    const Ptr<Networking_Core> net(new_networking_ex(logger.get(), sys.mem.get(), sys.ns.get(),
   47|     17|                                       &ipp.ip, ipp.port, ipp.port + 100, nullptr),
   48|     17|        kill_networking);
   49|     17|    if (net == nullptr) {
  ------------------
  |  Branch (49:9): [True: 2, False: 15]
  ------------------
   50|      2|        return;
   51|      2|    }
   52|       |
   53|     15|    const std::unique_ptr<Mono_Time, std::function<void(Mono_Time *)>> mono_time(
   54|     15|        mono_time_new(
   55|     15|            sys.mem.get(), [](void *user_data) { return *static_cast<uint64_t *>(user_data); },
   56|     15|            &sys.clock),
   57|     15|        [mem = sys.mem.get()](Mono_Time *ptr) { mono_time_free(mem, ptr); });
   58|     15|    if (mono_time == nullptr) {
  ------------------
  |  Branch (58:9): [True: 2, False: 13]
  ------------------
   59|      2|        return;
   60|      2|    }
   61|       |
   62|     13|    const Ptr<DHT> dht(new_dht(logger.get(), sys.mem.get(), sys.rng.get(), sys.ns.get(),
   63|     13|                           mono_time.get(), net.get(), false, false),
   64|     13|        kill_dht);
   65|     13|    if (dht == nullptr) {
  ------------------
  |  Branch (65:9): [True: 13, False: 0]
  ------------------
   66|     13|        return;
   67|     13|    }
   68|       |
   69|      0|    Net_Profile *tcp_np = netprof_new(logger.get(), sys.mem.get());
   70|       |
   71|      0|    if (tcp_np == nullptr) {
  ------------------
  |  Branch (71:9): [True: 0, False: 0]
  ------------------
   72|      0|        return;
   73|      0|    }
   74|       |
   75|      0|    const TCP_Proxy_Info proxy_info = {0};
   76|       |
   77|      0|    const Ptr<Net_Crypto> net_crypto(
   78|      0|        new_net_crypto(logger.get(), sys.mem.get(), sys.rng.get(), sys.ns.get(), mono_time.get(),
   79|      0|            dht.get(), &proxy_info, tcp_np),
   80|      0|        kill_net_crypto);
   81|      0|    if (net_crypto == nullptr) {
  ------------------
  |  Branch (81:9): [True: 0, False: 0]
  ------------------
   82|      0|        netprof_kill(sys.mem.get(), tcp_np);
   83|      0|        return;
   84|      0|    }
   85|       |
   86|      0|    for (uint8_t i = 0; i < iterations; ++i) {
  ------------------
  |  Branch (86:25): [True: 0, False: 0]
  ------------------
   87|      0|        networking_poll(net.get(), nullptr);
   88|      0|        do_dht(dht.get());
   89|      0|        do_net_crypto(net_crypto.get(), nullptr);
   90|       |        // "Sleep"
   91|      0|        sys.clock += System::BOOTSTRAP_ITERATION_INTERVAL;
   92|      0|    }
   93|       |
   94|      0|    netprof_kill(sys.mem.get(), tcp_np);
   95|      0|}
net_crypto_fuzz_test.cc:_ZN12_GLOBAL__N_17prepareER9Fuzz_Data:
   19|     19|{
   20|     19|    IP_Port ipp;
   21|     19|    ip_init(&ipp.ip, true);
   22|     19|    ipp.port = 33445;
   23|       |
   24|     19|    CONSUME_OR_RETURN_VAL(const uint8_t *iterations_packed, input, 1, std::nullopt);
  ------------------
  |  |  145|     19|    if (INPUT.size() < SIZE) {                        \
  |  |  ------------------
  |  |  |  Branch (145:9): [True: 1, False: 18]
  |  |  ------------------
  |  |  146|      1|        return VAL;                                   \
  |  |  147|      1|    }                                                 \
  |  |  148|     19|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   25|     18|    uint8_t iterations = *iterations_packed;
   26|       |
   27|     18|    return {{ipp, iterations}};
   28|     19|}
net_crypto_fuzz_test.cc:_ZZN12_GLOBAL__N_113TestNetCryptoER9Fuzz_DataENK3$_1clEPv:
   55|     13|            sys.mem.get(), [](void *user_data) { return *static_cast<uint64_t *>(user_data); },
net_crypto_fuzz_test.cc:_ZZN12_GLOBAL__N_113TestNetCryptoER9Fuzz_DataENK3$_0clEP9Mono_Time:
   57|     13|        [mem = sys.mem.get()](Mono_Time *ptr) { mono_time_free(mem, ptr); });

netprof_new:
  141|     16|{
  142|     16|    Net_Profile *np = (Net_Profile *)mem_alloc(mem, sizeof(Net_Profile));
  143|       |
  144|     16|    if (np == nullptr) {
  ------------------
  |  |   63|     16|#define nullptr NULL
  ------------------
  |  Branch (144:9): [True: 1, False: 15]
  ------------------
  145|      1|        LOGGER_ERROR(log, "failed to allocate memory for net profiler");
  ------------------
  |  |   87|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      1|    do {                                                                         \
  |  |  |  |   77|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      1|        }                                                                        \
  |  |  |  |   80|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  146|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  147|      1|    }
  148|       |
  149|     15|    return np;
  150|     16|}
netprof_kill:
  153|     15|{
  154|     15|    if (net_profile != nullptr) {
  ------------------
  |  |   63|     15|#define nullptr NULL
  ------------------
  |  Branch (154:9): [True: 15, False: 0]
  ------------------
  155|     15|        mem_delete(mem, net_profile);
  156|     15|    }
  157|     15|}

net_socket_from_native:
  380|     15|{
  381|     15|    const Socket res = {(force Socket_Value)sock};
  382|     15|    return res;
  383|     15|}
net_invalid_socket:
  386|     15|{
  387|     15|    return net_socket_from_native(INVALID_SOCKET);
  ------------------
  |  |  371|     15|#define INVALID_SOCKET (-1)
  ------------------
  388|     15|}
net_family_unspec:
  391|      8|{
  392|      8|    return family_unspec;
  393|      8|}
net_family_ipv6:
  401|     19|{
  402|     19|    return family_ipv6;
  403|     19|}
net_family_is_unspec:
  436|     31|{
  437|     31|    return family.value == family_unspec.value;
  438|     31|}
net_family_is_ipv4:
  441|     48|{
  442|     48|    return family.value == family_ipv4.value;
  443|     48|}
net_family_is_ipv6:
  446|     63|{
  447|     63|    return family.value == family_ipv6.value;
  448|     63|}
sock_valid:
  481|     15|{
  482|     15|    const Socket invalid_socket = net_invalid_socket();
  483|     15|    return sock.value != invalid_socket.value;
  484|     15|}
kill_sock:
  969|     15|{
  970|     15|    ns->funcs->close(ns->obj, sock);
  971|     15|}
set_socket_nonblock:
  974|     15|{
  975|     15|    return ns->funcs->socket_nonblock(ns->obj, sock, true) == 0;
  976|     15|}
set_socket_nosigpipe:
  979|     15|{
  980|       |#if defined(__APPLE__)
  981|       |    int set = 1;
  982|       |    return net_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
  983|       |#else
  984|     15|    return true;
  985|     15|#endif /* __APPLE__ */
  986|     15|}
set_socket_dualstack:
  999|     15|{
 1000|     15|    int ipv6only = 0;
 1001|     15|    size_t optsize = sizeof(ipv6only);
 1002|     15|    const int res = net_getsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, &optsize);
 1003|       |
 1004|     15|    if ((res == 0) && (ipv6only == 0)) {
  ------------------
  |  Branch (1004:9): [True: 15, False: 0]
  |  Branch (1004:23): [True: 15, False: 0]
  ------------------
 1005|     15|        return true;
 1006|     15|    }
 1007|       |
 1008|      0|    ipv6only = 0;
 1009|      0|    return net_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only)) == 0;
 1010|     15|}
networking_registerhandler:
 1201|    129|{
 1202|    129|    net->packethandlers[byte].function = cb;
 1203|    129|    net->packethandlers[byte].object = object;
 1204|    129|}
new_networking_ex:
 1250|     17|{
 1251|       |    /* If both from and to are 0, use default port range
 1252|       |     * If one is 0 and the other is non-0, use the non-0 value as only port
 1253|       |     * If from > to, swap
 1254|       |     */
 1255|     17|    if (port_from == 0 && port_to == 0) {
  ------------------
  |  Branch (1255:9): [True: 0, False: 17]
  |  Branch (1255:27): [True: 0, False: 0]
  ------------------
 1256|      0|        port_from = TOX_PORTRANGE_FROM;
  ------------------
  |  |  162|      0|#define TOX_PORTRANGE_FROM 33445
  ------------------
 1257|      0|        port_to = TOX_PORTRANGE_TO;
  ------------------
  |  |  163|      0|#define TOX_PORTRANGE_TO   33545
  ------------------
 1258|     17|    } else if (port_from == 0 && port_to != 0) {
  ------------------
  |  Branch (1258:16): [True: 0, False: 17]
  |  Branch (1258:34): [True: 0, False: 0]
  ------------------
 1259|      0|        port_from = port_to;
 1260|     17|    } else if (port_from != 0 && port_to == 0) {
  ------------------
  |  Branch (1260:16): [True: 17, False: 0]
  |  Branch (1260:34): [True: 0, False: 17]
  ------------------
 1261|      0|        port_to = port_from;
 1262|     17|    } else if (port_from > port_to) {
  ------------------
  |  Branch (1262:16): [True: 0, False: 17]
  ------------------
 1263|      0|        const uint16_t temp_port = port_from;
 1264|      0|        port_from = port_to;
 1265|      0|        port_to = temp_port;
 1266|      0|    }
 1267|       |
 1268|     17|    if (error != nullptr) {
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
  |  Branch (1268:9): [True: 0, False: 17]
  ------------------
 1269|      0|        *error = 2;
 1270|      0|    }
 1271|       |
 1272|       |    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
 1273|     17|    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1273:9): [True: 17, False: 0]
  |  Branch (1273:44): [True: 0, False: 17]
  ------------------
 1274|      0|        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1275|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1276|      0|    }
 1277|       |
 1278|     17|    Networking_Core *temp = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
 1279|       |
 1280|     17|    if (temp == nullptr) {
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
  |  Branch (1280:9): [True: 1, False: 16]
  ------------------
 1281|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 1282|      1|    }
 1283|       |
 1284|     16|    Net_Profile *np = netprof_new(log, mem);
 1285|       |
 1286|     16|    if (np == nullptr) {
  ------------------
  |  |   63|     16|#define nullptr NULL
  ------------------
  |  Branch (1286:9): [True: 1, False: 15]
  ------------------
 1287|      1|        free(temp);
 1288|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 1289|      1|    }
 1290|       |
 1291|     15|    temp->udp_net_profile = np;
 1292|     15|    temp->ns = ns;
 1293|     15|    temp->log = log;
 1294|     15|    temp->mem = mem;
 1295|     15|    temp->family = ip->family;
 1296|     15|    temp->port = 0;
 1297|       |
 1298|       |    /* Initialize our socket. */
 1299|       |    /* add log message what we're creating */
 1300|     15|    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  174|     15|#define TOX_SOCK_DGRAM 2
  ------------------
                  temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  177|     15|#define TOX_PROTO_UDP 2
  ------------------
 1301|       |
 1302|       |    /* Check for socket error. */
 1303|     15|    if (!sock_valid(temp->sock)) {
  ------------------
  |  Branch (1303:9): [True: 0, False: 15]
  ------------------
 1304|      0|        const int neterror = net_error();
 1305|      0|        Net_Strerror error_str;
 1306|      0|        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1307|      0|        netprof_kill(mem, temp->udp_net_profile);
 1308|      0|        mem_delete(mem, temp);
 1309|       |
 1310|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1310:13): [True: 0, False: 0]
  ------------------
 1311|      0|            *error = 1;
 1312|      0|        }
 1313|       |
 1314|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1315|      0|    }
 1316|       |
 1317|       |    /* Functions to increase the size of the send and receive UDP buffers.
 1318|       |     */
 1319|     15|    int n = 1024 * 1024 * 2;
 1320|       |
 1321|     15|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1321:9): [True: 0, False: 15]
  ------------------
 1322|      0|        LOGGER_WARNING(log, "failed to set socket option %d", SO_RCVBUF);
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1323|      0|    }
 1324|       |
 1325|     15|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_SNDBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1325:9): [True: 0, False: 15]
  ------------------
 1326|      0|        LOGGER_WARNING(log, "failed to set socket option %d", SO_SNDBUF);
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1327|      0|    }
 1328|       |
 1329|       |    /* Enable broadcast on socket */
 1330|     15|    int broadcast = 1;
 1331|       |
 1332|     15|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) != 0) {
  ------------------
  |  Branch (1332:9): [True: 0, False: 15]
  ------------------
 1333|      0|        LOGGER_ERROR(log, "failed to set socket option %d", SO_BROADCAST);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1334|      0|    }
 1335|       |
 1336|       |    /* iOS UDP sockets are weird and apparently can SIGPIPE */
 1337|     15|    if (!set_socket_nosigpipe(ns, temp->sock)) {
  ------------------
  |  Branch (1337:9): [True: 0, False: 15]
  ------------------
 1338|      0|        kill_networking(temp);
 1339|       |
 1340|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1340:13): [True: 0, False: 0]
  ------------------
 1341|      0|            *error = 1;
 1342|      0|        }
 1343|       |
 1344|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1345|      0|    }
 1346|       |
 1347|       |    /* Set socket nonblocking. */
 1348|     15|    if (!set_socket_nonblock(ns, temp->sock)) {
  ------------------
  |  Branch (1348:9): [True: 0, False: 15]
  ------------------
 1349|      0|        kill_networking(temp);
 1350|       |
 1351|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1351:13): [True: 0, False: 0]
  ------------------
 1352|      0|            *error = 1;
 1353|      0|        }
 1354|       |
 1355|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1356|      0|    }
 1357|       |
 1358|       |    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
 1359|     15|    uint16_t *portptr = nullptr;
  ------------------
  |  |   63|     15|#define nullptr NULL
  ------------------
 1360|     15|    Network_Addr addr = {{0}};
 1361|       |
 1362|     15|    if (net_family_is_ipv4(temp->family)) {
  ------------------
  |  Branch (1362:9): [True: 0, False: 15]
  ------------------
 1363|      0|        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr.addr;
 1364|       |
 1365|      0|        addr.size = sizeof(struct sockaddr_in);
 1366|      0|        addr4->sin_family = AF_INET;
 1367|      0|        addr4->sin_port = 0;
 1368|      0|        fill_addr4(&ip->ip.v4, &addr4->sin_addr);
 1369|       |
 1370|      0|        portptr = &addr4->sin_port;
 1371|     15|    } else if (net_family_is_ipv6(temp->family)) {
  ------------------
  |  Branch (1371:16): [True: 15, False: 0]
  ------------------
 1372|     15|        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr.addr;
 1373|       |
 1374|     15|        addr.size = sizeof(struct sockaddr_in6);
 1375|     15|        addr6->sin6_family = AF_INET6;
 1376|     15|        addr6->sin6_port = 0;
 1377|     15|        fill_addr6(&ip->ip.v6, &addr6->sin6_addr);
 1378|       |
 1379|     15|        addr6->sin6_flowinfo = 0;
 1380|     15|        addr6->sin6_scope_id = 0;
 1381|       |
 1382|     15|        portptr = &addr6->sin6_port;
 1383|     15|    } else {
 1384|      0|        mem_delete(mem, temp);
 1385|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1386|      0|    }
 1387|       |
 1388|     15|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1388:9): [True: 15, False: 0]
  ------------------
 1389|     15|        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);
 1390|       |
 1391|     15|        if (is_dualstack) {
  ------------------
  |  Branch (1391:13): [True: 15, False: 0]
  ------------------
 1392|     15|            LOGGER_TRACE(log, "Dual-stack socket: enabled");
  ------------------
  |  |   83|     15|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     15|    do {                                                                         \
  |  |  |  |   77|     15|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     30|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|     15|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1393|     15|        } else {
 1394|      0|            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1395|      0|        }
 1396|       |
 1397|     15|#ifndef ESP_PLATFORM
 1398|       |        /* multicast local nodes */
 1399|     15|        struct ipv6_mreq mreq = {{{{0}}}};
 1400|     15|        mreq.ipv6mr_multiaddr.s6_addr[0] = 0xFF;
 1401|     15|        mreq.ipv6mr_multiaddr.s6_addr[1] = 0x02;
 1402|     15|        mreq.ipv6mr_multiaddr.s6_addr[15] = 0x01;
 1403|     15|        mreq.ipv6mr_interface = 0;
 1404|       |
 1405|     15|        const int res = net_setsockopt(ns, temp->sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
 1406|       |
 1407|     15|        const int neterror = net_error();
 1408|     15|        Net_Strerror error_str;
 1409|       |
 1410|     15|        if (res < 0) {
  ------------------
  |  Branch (1410:13): [True: 0, False: 15]
  ------------------
 1411|      0|            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   85|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1412|     15|        } else {
 1413|     15|            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   83|     15|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     15|    do {                                                                         \
  |  |  |  |   77|     15|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     30|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|     15|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1414|     15|        }
 1415|     15|#endif /* ESP_PLATFORM */
 1416|     15|    }
 1417|       |
 1418|       |    /* A hanging program or a different user might block the standard port.
 1419|       |     * As long as it isn't a parameter coming from the commandline,
 1420|       |     * try a few ports after it, to see if we can find a "free" one.
 1421|       |     *
 1422|       |     * If we go on without binding, the first sendto() automatically binds to
 1423|       |     * a free port chosen by the system (i.e. anything from 1024 to 65535).
 1424|       |     *
 1425|       |     * Returning NULL after bind fails has both advantages and disadvantages:
 1426|       |     * advantage:
 1427|       |     *   we can rely on getting the port in the range 33445..33450, which
 1428|       |     *   enables us to tell joe user to open their firewall to a small range
 1429|       |     *
 1430|       |     * disadvantage:
 1431|       |     *   some clients might not test return of tox_new(), blindly assuming that
 1432|       |     *   it worked ok (which it did previously without a successful bind)
 1433|       |     */
 1434|     15|    uint16_t port_to_try = port_from;
 1435|     15|    *portptr = net_htons(port_to_try);
 1436|       |
 1437|     15|    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
  ------------------
  |  Branch (1437:38): [True: 15, False: 0]
  ------------------
 1438|     15|        const int res = net_bind(ns, temp->sock, &addr);
 1439|       |
 1440|     15|        if (res == 0) {
  ------------------
  |  Branch (1440:13): [True: 15, False: 0]
  ------------------
 1441|     15|            temp->port = *portptr;
 1442|       |
 1443|     15|            Ip_Ntoa ip_str;
 1444|     15|            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
  ------------------
  |  |   84|     15|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     15|    do {                                                                         \
  |  |  |  |   77|     15|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     30|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|     15|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1445|     15|                         net_ntohs(temp->port));
 1446|       |
 1447|       |            /* errno isn't reset on success, only set on failure, the failed
 1448|       |             * binds with parallel clients yield a -EPERM to the outside if
 1449|       |             * errno isn't cleared here */
 1450|     15|            if (tries > 0) {
  ------------------
  |  Branch (1450:17): [True: 15, False: 0]
  ------------------
 1451|     15|                errno = 0;
 1452|     15|            }
 1453|       |
 1454|     15|            if (error != nullptr) {
  ------------------
  |  |   63|     15|#define nullptr NULL
  ------------------
  |  Branch (1454:17): [True: 0, False: 15]
  ------------------
 1455|      0|                *error = 0;
 1456|      0|            }
 1457|       |
 1458|     15|            return temp;
 1459|     15|        }
 1460|       |
 1461|      0|        ++port_to_try;
 1462|       |
 1463|      0|        if (port_to_try > port_to) {
  ------------------
  |  Branch (1463:13): [True: 0, False: 0]
  ------------------
 1464|      0|            port_to_try = port_from;
 1465|      0|        }
 1466|       |
 1467|      0|        *portptr = net_htons(port_to_try);
 1468|      0|    }
 1469|       |
 1470|      0|    Ip_Ntoa ip_str;
 1471|      0|    const int neterror = net_error();
 1472|      0|    Net_Strerror error_str;
 1473|      0|    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u",
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1474|      0|                 neterror, net_strerror(neterror, &error_str), net_ip_ntoa(ip, &ip_str), port_from, port_to);
 1475|      0|    kill_networking(temp);
 1476|       |
 1477|      0|    if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1477:9): [True: 0, False: 0]
  ------------------
 1478|      0|        *error = 1;
 1479|      0|    }
 1480|       |
 1481|      0|    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1482|     15|}
kill_networking:
 1502|     15|{
 1503|     15|    if (net == nullptr) {
  ------------------
  |  |   63|     15|#define nullptr NULL
  ------------------
  |  Branch (1503:9): [True: 0, False: 15]
  ------------------
 1504|      0|        return;
 1505|      0|    }
 1506|       |
 1507|     15|    if (!net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (1507:9): [True: 15, False: 0]
  ------------------
 1508|       |        /* Socket is initialized, so we close it. */
 1509|     15|        kill_sock(net->ns, net->sock);
 1510|     15|    }
 1511|       |
 1512|     15|    netprof_kill(net->mem, net->udp_net_profile);
 1513|     15|    mem_delete(net->mem, net);
 1514|     15|}
ip_reset:
 1630|     19|{
 1631|     19|    if (ip == nullptr) {
  ------------------
  |  |   63|     19|#define nullptr NULL
  ------------------
  |  Branch (1631:9): [True: 0, False: 19]
  ------------------
 1632|      0|        return;
 1633|      0|    }
 1634|       |
 1635|     19|    *ip = empty_ip;
 1636|     19|}
ip_init:
 1652|     19|{
 1653|     19|    if (ip == nullptr) {
  ------------------
  |  |   63|     19|#define nullptr NULL
  ------------------
  |  Branch (1653:9): [True: 0, False: 19]
  ------------------
 1654|      0|        return;
 1655|      0|    }
 1656|       |
 1657|     19|    ip_reset(ip);
 1658|     19|    ip->family = ipv6enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (1658:18): [True: 19, False: 0]
  ------------------
 1659|     19|}
net_socket:
 2256|     15|{
 2257|     15|    const int platform_domain = make_family(domain);
 2258|     15|    const int platform_type = make_socktype(type);
 2259|     15|    const int platform_prot = make_proto(protocol);
 2260|     15|    return ns->funcs->socket(ns->obj, platform_domain, platform_type, platform_prot);
 2261|     15|}
net_htons:
 2275|     15|{
 2276|     15|    return htons(hostshort);
 2277|     15|}
net_error:
 2360|     15|{
 2361|       |#ifdef OS_WIN32
 2362|       |    return WSAGetLastError();
 2363|       |#else
 2364|     15|    return errno;
 2365|     15|#endif /* OS_WIN32 */
 2366|     15|}
network.c:net_setsockopt:
  737|     60|{
  738|     60|    return ns->funcs->setsockopt(ns->obj, sock, level, optname, optval, optlen);
  739|     60|}
network.c:net_getsockopt:
  743|     15|{
  744|     15|    return ns->funcs->getsockopt(ns->obj, sock, level, optname, optval, optlen);
  745|     15|}
network.c:fill_addr6:
  333|     15|{
  334|     15|    memcpy(addr->s6_addr, ip->uint8, sizeof(ip->uint8));
  335|     15|}
network.c:net_bind:
  958|     15|{
  959|     15|    return ns->funcs->bind(ns->obj, sock, addr);
  960|     15|}
network.c:make_family:
  264|     15|{
  265|     15|    switch (tox_family.value) {
  266|      0|        case TOX_AF_INET:
  ------------------
  |  |  168|      0|#define TOX_AF_INET 2
  ------------------
  |  Branch (266:9): [True: 0, False: 15]
  ------------------
  267|      0|        case TCP_INET:
  ------------------
  |  |  181|      0|#define TCP_INET (TOX_AF_INET6 + 2)
  |  |  ------------------
  |  |  |  |  169|      0|#define TOX_AF_INET6 10
  |  |  ------------------
  ------------------
  |  Branch (267:9): [True: 0, False: 15]
  ------------------
  268|      0|            return AF_INET;
  269|       |
  270|     15|        case TOX_AF_INET6:
  ------------------
  |  |  169|     15|#define TOX_AF_INET6 10
  ------------------
  |  Branch (270:9): [True: 15, False: 0]
  ------------------
  271|     15|        case TCP_INET6:
  ------------------
  |  |  182|     15|#define TCP_INET6 (TOX_AF_INET6 + 3)
  |  |  ------------------
  |  |  |  |  169|     15|#define TOX_AF_INET6 10
  |  |  ------------------
  ------------------
  |  Branch (271:9): [True: 0, False: 15]
  ------------------
  272|     15|            return AF_INET6;
  273|       |
  274|      0|        case TOX_AF_UNSPEC:
  ------------------
  |  |  167|      0|#define TOX_AF_UNSPEC 0
  ------------------
  |  Branch (274:9): [True: 0, False: 15]
  ------------------
  275|      0|            return AF_UNSPEC;
  276|       |
  277|      0|        default:
  ------------------
  |  Branch (277:9): [True: 0, False: 15]
  ------------------
  278|      0|            return tox_family.value;
  279|     15|    }
  280|     15|}
network.c:make_socktype:
  250|     15|{
  251|     15|    switch (type) {
  252|      0|        case TOX_SOCK_STREAM:
  ------------------
  |  |  173|      0|#define TOX_SOCK_STREAM 1
  ------------------
  |  Branch (252:9): [True: 0, False: 15]
  ------------------
  253|      0|            return SOCK_STREAM;
  254|       |
  255|     15|        case TOX_SOCK_DGRAM:
  ------------------
  |  |  174|     15|#define TOX_SOCK_DGRAM 2
  ------------------
  |  Branch (255:9): [True: 15, False: 0]
  ------------------
  256|     15|            return SOCK_DGRAM;
  257|       |
  258|      0|        default:
  ------------------
  |  Branch (258:9): [True: 0, False: 15]
  ------------------
  259|      0|            return type;
  260|     15|    }
  261|     15|}
network.c:make_proto:
  236|     15|{
  237|     15|    switch (proto) {
  238|      0|        case TOX_PROTO_TCP:
  ------------------
  |  |  176|      0|#define TOX_PROTO_TCP 1
  ------------------
  |  Branch (238:9): [True: 0, False: 15]
  ------------------
  239|      0|            return IPPROTO_TCP;
  240|       |
  241|     15|        case TOX_PROTO_UDP:
  ------------------
  |  |  177|     15|#define TOX_PROTO_UDP 2
  ------------------
  |  Branch (241:9): [True: 15, False: 0]
  ------------------
  242|     15|            return IPPROTO_UDP;
  243|       |
  244|      0|        default:
  ------------------
  |  Branch (244:9): [True: 0, False: 15]
  ------------------
  245|      0|            return proto;
  246|     15|    }
  247|     15|}

ping_new:
  336|     12|{
  337|     12|    Ping *ping = (Ping *)mem_alloc(mem, sizeof(Ping));
  338|       |
  339|     12|    if (ping == nullptr) {
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
  |  Branch (339:9): [True: 1, False: 11]
  ------------------
  340|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  341|      1|    }
  342|       |
  343|     11|    ping->ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   23|     11|#define PING_NUM_MAX 512
  ------------------
                  ping->ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   43|     11|#define PING_TIMEOUT 5
  ------------------
  344|       |
  345|     11|    if (ping->ping_array == nullptr) {
  ------------------
  |  |   63|     11|#define nullptr NULL
  ------------------
  |  Branch (345:9): [True: 2, False: 9]
  ------------------
  346|      2|        mem_delete(mem, ping);
  347|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
  348|      2|    }
  349|       |
  350|      9|    ping->mono_time = mono_time;
  351|      9|    ping->rng = rng;
  352|      9|    ping->mem = mem;
  353|      9|    ping->dht = dht;
  354|      9|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, &handle_ping_request, dht);
  355|      9|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, &handle_ping_response, dht);
  356|       |
  357|      9|    return ping;
  358|     11|}
ping_kill:
  361|     12|{
  362|     12|    if (ping == nullptr) {
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
  |  Branch (362:9): [True: 3, False: 9]
  ------------------
  363|      3|        return;
  364|      3|    }
  365|       |
  366|      9|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|      9|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|      9|#define nullptr NULL
  ------------------
  367|      9|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|      9|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|      9|#define nullptr NULL
  ------------------
  368|      9|    ping_array_kill(ping->ping_array);
  369|       |
  370|      9|    mem_delete(mem, ping);
  371|      9|}

ping_array_new:
   37|     19|{
   38|     19|    if (size == 0 || timeout == 0) {
  ------------------
  |  Branch (38:9): [True: 0, False: 19]
  |  Branch (38:22): [True: 0, False: 19]
  ------------------
   39|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   40|      0|    }
   41|       |
   42|     19|    if ((size & (size - 1)) != 0) {
  ------------------
  |  Branch (42:9): [True: 0, False: 19]
  ------------------
   43|       |        // Not a power of 2.
   44|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   45|      0|    }
   46|       |
   47|     19|    Ping_Array *const empty_array = (Ping_Array *)mem_alloc(mem, sizeof(Ping_Array));
   48|       |
   49|     19|    if (empty_array == nullptr) {
  ------------------
  |  |   63|     19|#define nullptr NULL
  ------------------
  |  Branch (49:9): [True: 1, False: 18]
  ------------------
   50|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
   51|      1|    }
   52|       |
   53|     18|    Ping_Array_Entry *entries = (Ping_Array_Entry *)mem_valloc(mem, size, sizeof(Ping_Array_Entry));
   54|       |
   55|     18|    if (entries == nullptr) {
  ------------------
  |  |   63|     18|#define nullptr NULL
  ------------------
  |  Branch (55:9): [True: 1, False: 17]
  ------------------
   56|      1|        mem_delete(mem, empty_array);
   57|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
   58|      1|    }
   59|       |
   60|     17|    empty_array->mem = mem;
   61|     17|    empty_array->entries = entries;
   62|     17|    empty_array->last_deleted = 0;
   63|     17|    empty_array->last_added = 0;
   64|     17|    empty_array->total_size = size;
   65|     17|    empty_array->timeout = timeout;
   66|     17|    return empty_array;
   67|     18|}
ping_array_kill:
   78|     21|{
   79|     21|    if (array == nullptr) {
  ------------------
  |  |   63|     21|#define nullptr NULL
  ------------------
  |  Branch (79:9): [True: 4, False: 17]
  ------------------
   80|      4|        return;
   81|      4|    }
   82|       |
   83|     17|    while (array->last_deleted != array->last_added) {
  ------------------
  |  Branch (83:12): [True: 0, False: 17]
  ------------------
   84|      0|        const uint32_t index = array->last_deleted % array->total_size;
   85|      0|        clear_entry(array, index);
   86|      0|        ++array->last_deleted;
   87|      0|    }
   88|       |
   89|     17|    mem_delete(array->mem, array->entries);
   90|     17|    mem_delete(array->mem, array);
   91|     17|}

shared_key_cache_new:
   52|     18|{
   53|     18|    if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
                  if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (53:9): [True: 0, False: 18]
  |  Branch (53:33): [True: 0, False: 18]
  |  Branch (53:63): [True: 0, False: 18]
  |  Branch (53:79): [True: 0, False: 18]
  ------------------
   54|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   55|      0|    }
   56|       |
   57|       |    // Time must not be zero, since we use that as special value for empty slots
   58|     18|    if (mono_time_get(mono_time) == 0) {
  ------------------
  |  Branch (58:9): [True: 0, False: 18]
  ------------------
   59|       |        // Fail loudly in debug environments
   60|      0|        LOGGER_FATAL(log, "time must not be zero (mono_time not initialised?)");
  ------------------
  |  |   90|      0|    do {                                \
  |  |   91|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   92|      0|        logger_abort();                 \
  |  |   93|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (93:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   61|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   62|      0|    }
   63|       |
   64|     18|    Shared_Key_Cache *res = (Shared_Key_Cache *)mem_alloc(mem, sizeof(Shared_Key_Cache));
   65|     18|    if (res == nullptr) {
  ------------------
  |  |   63|     18|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 1, False: 17]
  ------------------
   66|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
   67|      1|    }
   68|       |
   69|     17|    res->self_secret_key = self_secret_key;
   70|     17|    res->mono_time = mono_time;
   71|     17|    res->mem = mem;
   72|     17|    res->log = log;
   73|     17|    res->keys_per_slot = keys_per_slot;
   74|       |
   75|       |    // We take one byte from the public key for each bucket and store keys_per_slot elements there
   76|     17|    const size_t cache_size = 256 * keys_per_slot;
   77|     17|    Shared_Key *keys = (Shared_Key *)mem_valloc(mem, cache_size, sizeof(Shared_Key));
   78|       |
   79|     17|    if (keys == nullptr) {
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
  |  Branch (79:9): [True: 0, False: 17]
  ------------------
   80|      0|        mem_delete(mem, res);
   81|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   82|      0|    }
   83|       |
   84|     17|    crypto_memlock(keys, cache_size * sizeof(Shared_Key));
   85|       |
   86|     17|    res->keys = keys;
   87|       |
   88|     17|    return res;
   89|     17|}
shared_key_cache_free:
   92|     24|{
   93|     24|    if (cache == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (93:9): [True: 7, False: 17]
  ------------------
   94|      7|        return;
   95|      7|    }
   96|       |
   97|     17|    const size_t cache_size = 256 * cache->keys_per_slot;
   98|       |    // Don't leave key material in memory
   99|     17|    crypto_memzero(cache->keys, cache_size * sizeof(Shared_Key));
  100|     17|    crypto_memunlock(cache->keys, cache_size * sizeof(Shared_Key));
  101|     17|    mem_delete(cache->mem, cache->keys);
  102|     17|    mem_delete(cache->mem, cache);
  103|     17|}

memzero:
   99|     54|{
  100|     54|    if (data == nullptr || data_size == 0) {
  ------------------
  |  |   63|    108|#define nullptr NULL
  ------------------
  |  Branch (100:9): [True: 0, False: 54]
  |  Branch (100:28): [True: 0, False: 54]
  ------------------
  101|      0|        return;
  102|      0|    }
  103|       |
  104|     54|    memset(data, 0, data_size);
  105|     54|}

