LLVMFuzzerTestOneInput:
  189|    971|{
  190|    971|    Fuzz_Data input{data, size};
  191|    971|    TestBootstrap(input);
  192|    971|    return 0;  // Non-zero return values are reserved for future use.
  193|    971|}
bootstrap_harness.cc:_ZN12_GLOBAL__N_113TestBootstrapER9Fuzz_Data:
  109|    971|{
  110|       |    // Null system for regularly working memory allocations needed in
  111|       |    // tox_events_equal.
  112|    971|    Null_System null_sys;
  113|    971|    Fuzz_System sys(input);
  114|       |
  115|    971|    Ptr<Tox_Options> opts(tox_options_new(nullptr), tox_options_free);
  116|    971|    assert(opts != nullptr);
  117|      0|    tox_options_set_operating_system(opts.get(), sys.sys.get());
  118|       |
  119|    971|    tox_options_set_log_callback(opts.get(),
  120|    971|        [](Tox *tox, Tox_Log_Level level, const char *file, uint32_t line, const char *func,
  121|    971|            const char *message, void *user_data) {
  122|       |            // Log to stdout.
  123|    971|            if (DEBUG) {
  124|    971|                std::printf("[tox1] %c %s:%d(%s): %s\n", tox_log_level_name(level), file, line,
  125|    971|                    func, message);
  126|    971|            }
  127|    971|        });
  128|       |
  129|    971|    CONSUME1_OR_RETURN(const uint8_t proxy_type, input);
  ------------------
  |  |   57|    971|    if (INPUT.size < 1) {               \
  |  |  ------------------
  |  |  |  Branch (57:9): [True: 0, False: 971]
  |  |  ------------------
  |  |   58|      0|        return;                         \
  |  |   59|      0|    }                                   \
  |  |   60|    971|    DECL = INPUT.consume1()
  ------------------
  130|    971|    if (proxy_type == 0) {
  ------------------
  |  Branch (130:9): [True: 41, False: 930]
  ------------------
  131|     41|        tox_options_set_proxy_type(opts.get(), TOX_PROXY_TYPE_NONE);
  132|    930|    } else if (proxy_type == 1) {
  ------------------
  |  Branch (132:16): [True: 34, False: 896]
  ------------------
  133|     34|        tox_options_set_proxy_type(opts.get(), TOX_PROXY_TYPE_SOCKS5);
  134|     34|        tox_options_set_proxy_host(opts.get(), "127.0.0.1");
  135|     34|        tox_options_set_proxy_port(opts.get(), 8080);
  136|    896|    } else if (proxy_type == 2) {
  ------------------
  |  Branch (136:16): [True: 245, False: 651]
  ------------------
  137|    245|        tox_options_set_proxy_type(opts.get(), TOX_PROXY_TYPE_HTTP);
  138|    245|        tox_options_set_proxy_host(opts.get(), "127.0.0.1");
  139|    245|        tox_options_set_proxy_port(opts.get(), 8080);
  140|    245|    }
  141|       |
  142|    971|    CONSUME1_OR_RETURN(const uint8_t tcp_relay_enabled, input);
  ------------------
  |  |   57|    971|    if (INPUT.size < 1) {               \
  |  |  ------------------
  |  |  |  Branch (57:9): [True: 3, False: 968]
  |  |  ------------------
  |  |   58|      3|        return;                         \
  |  |   59|      3|    }                                   \
  |  |   60|    971|    DECL = INPUT.consume1()
  ------------------
  143|    968|    if (tcp_relay_enabled >= (UINT8_MAX / 2)) {
  ------------------
  |  Branch (143:9): [True: 166, False: 802]
  ------------------
  144|    166|        tox_options_set_tcp_port(opts.get(), 33445);
  145|    166|    }
  146|       |
  147|    968|    Tox_Err_New error_new;
  148|    968|    Tox *tox = tox_new(opts.get(), &error_new);
  149|       |
  150|    968|    if (tox == nullptr) {
  ------------------
  |  Branch (150:9): [True: 35, False: 933]
  ------------------
  151|       |        // It might fail, because some I/O happens in tox_new, and the fuzzer
  152|       |        // might do things that make that I/O fail.
  153|     35|        return;
  154|     35|    }
  155|       |
  156|    933|    assert(error_new == TOX_ERR_NEW_OK);
  157|       |
  158|      0|    uint8_t pub_key[TOX_PUBLIC_KEY_SIZE] = {0};
  159|       |
  160|       |    // These may fail, but that's ok. We ignore their return values.
  161|    933|    tox_bootstrap(tox, "127.0.0.2", 33446, pub_key, nullptr);
  162|    933|    tox_add_tcp_relay(tox, "127.0.0.2", 33446, pub_key, nullptr);
  163|       |
  164|    933|    tox_events_init(tox);
  165|       |
  166|    933|    Tox_Dispatch *dispatch = tox_dispatch_new(nullptr);
  167|    933|    assert(dispatch != nullptr);
  168|      0|    setup_callbacks(dispatch);
  169|       |
  170|  73.6k|    while (input.size > 0) {
  ------------------
  |  Branch (170:12): [True: 72.6k, False: 933]
  ------------------
  171|  72.6k|        Tox_Err_Events_Iterate error_iterate;
  172|  72.6k|        Tox_Events *events = tox_events_iterate(tox, true, &error_iterate);
  173|  72.6k|        assert(tox_events_equal(null_sys.sys.get(), events, events));
  174|      0|        tox_dispatch_invoke(dispatch, events, tox, nullptr);
  175|  72.6k|        tox_events_free(events);
  176|       |        // Move the clock forward a decent amount so all the time-based checks
  177|       |        // trigger more quickly.
  178|  72.6k|        sys.clock += 200;
  179|  72.6k|    }
  180|       |
  181|    933|    tox_dispatch_free(dispatch);
  182|    933|    tox_kill(tox);
  183|    933|}
bootstrap_harness.cc:_ZZN12_GLOBAL__N_113TestBootstrapER9Fuzz_DataENK3$_0clEP3Tox13Tox_Log_LevelPKcjS7_S7_Pv:
  121|  16.9k|            const char *message, void *user_data) {
  122|       |            // Log to stdout.
  123|  16.9k|            if (DEBUG) {
  ------------------
  |  Branch (123:17): [True: 0, False: 16.9k]
  ------------------
  124|      0|                std::printf("[tox1] %c %s:%d(%s): %s\n", tox_log_level_name(level), file, line,
  125|      0|                    func, message);
  126|      0|            }
  127|  16.9k|        });
bootstrap_harness.cc:_ZN12_GLOBAL__N_115setup_callbacksEP12Tox_Dispatch:
   13|    933|{
   14|    933|    tox_events_callback_conference_connected(
   15|    933|        dispatch, [](Tox *tox, const Tox_Event_Conference_Connected *event, void *user_data) {
   16|    933|            assert(event == nullptr);
   17|    933|        });
   18|    933|    tox_events_callback_conference_connected(
   19|    933|        dispatch, [](Tox *tox, const Tox_Event_Conference_Connected *event, void *user_data) {
   20|    933|            assert(event == nullptr);
   21|    933|        });
   22|    933|    tox_events_callback_conference_invite(
   23|    933|        dispatch, [](Tox *tox, const Tox_Event_Conference_Invite *event, void *user_data) {
   24|    933|            assert(event == nullptr);
   25|    933|        });
   26|    933|    tox_events_callback_conference_message(
   27|    933|        dispatch, [](Tox *tox, const Tox_Event_Conference_Message *event, void *user_data) {
   28|    933|            assert(event == nullptr);
   29|    933|        });
   30|    933|    tox_events_callback_conference_peer_list_changed(dispatch,
   31|    933|        [](Tox *tox, const Tox_Event_Conference_Peer_List_Changed *event, void *user_data) {
   32|    933|            assert(event == nullptr);
   33|    933|        });
   34|    933|    tox_events_callback_conference_peer_name(
   35|    933|        dispatch, [](Tox *tox, const Tox_Event_Conference_Peer_Name *event, void *user_data) {
   36|    933|            assert(event == nullptr);
   37|    933|        });
   38|    933|    tox_events_callback_conference_title(
   39|    933|        dispatch, [](Tox *tox, const Tox_Event_Conference_Title *event, void *user_data) {
   40|    933|            assert(event == nullptr);
   41|    933|        });
   42|    933|    tox_events_callback_file_chunk_request(
   43|    933|        dispatch, [](Tox *tox, const Tox_Event_File_Chunk_Request *event, void *user_data) {
   44|    933|            assert(event == nullptr);
   45|    933|        });
   46|    933|    tox_events_callback_file_recv(
   47|    933|        dispatch, [](Tox *tox, const Tox_Event_File_Recv *event, void *user_data) {
   48|    933|            assert(event == nullptr);
   49|    933|        });
   50|    933|    tox_events_callback_file_recv_chunk(
   51|    933|        dispatch, [](Tox *tox, const Tox_Event_File_Recv_Chunk *event, void *user_data) {
   52|    933|            assert(event == nullptr);
   53|    933|        });
   54|    933|    tox_events_callback_file_recv_control(
   55|    933|        dispatch, [](Tox *tox, const Tox_Event_File_Recv_Control *event, void *user_data) {
   56|    933|            assert(event == nullptr);
   57|    933|        });
   58|    933|    tox_events_callback_friend_connection_status(
   59|    933|        dispatch, [](Tox *tox, const Tox_Event_Friend_Connection_Status *event, void *user_data) {
   60|    933|            assert(event == nullptr);
   61|    933|        });
   62|    933|    tox_events_callback_friend_lossless_packet(
   63|    933|        dispatch, [](Tox *tox, const Tox_Event_Friend_Lossless_Packet *event, void *user_data) {
   64|    933|            assert(event == nullptr);
   65|    933|        });
   66|    933|    tox_events_callback_friend_lossy_packet(
   67|    933|        dispatch, [](Tox *tox, const Tox_Event_Friend_Lossy_Packet *event, void *user_data) {
   68|    933|            assert(event == nullptr);
   69|    933|        });
   70|    933|    tox_events_callback_friend_message(
   71|    933|        dispatch, [](Tox *tox, const Tox_Event_Friend_Message *event, void *user_data) {
   72|    933|            assert(event == nullptr);
   73|    933|        });
   74|    933|    tox_events_callback_friend_name(
   75|    933|        dispatch, [](Tox *tox, const Tox_Event_Friend_Name *event, void *user_data) {
   76|    933|            assert(event == nullptr);
   77|    933|        });
   78|    933|    tox_events_callback_friend_read_receipt(
   79|    933|        dispatch, [](Tox *tox, const Tox_Event_Friend_Read_Receipt *event, void *user_data) {
   80|    933|            assert(event == nullptr);
   81|    933|        });
   82|    933|    tox_events_callback_friend_request(
   83|    933|        dispatch, [](Tox *tox, const Tox_Event_Friend_Request *event, void *user_data) {
   84|    933|            Tox_Err_Friend_Add err;
   85|    933|            tox_friend_add_norequest(tox, tox_event_friend_request_get_public_key(event), &err);
   86|    933|            assert(err == TOX_ERR_FRIEND_ADD_OK || err == TOX_ERR_FRIEND_ADD_OWN_KEY
   87|    933|                || err == TOX_ERR_FRIEND_ADD_ALREADY_SENT
   88|    933|                || err == TOX_ERR_FRIEND_ADD_BAD_CHECKSUM);
   89|    933|        });
   90|    933|    tox_events_callback_friend_status(
   91|    933|        dispatch, [](Tox *tox, const Tox_Event_Friend_Status *event, void *user_data) {
   92|    933|            assert(event == nullptr);
   93|    933|        });
   94|    933|    tox_events_callback_friend_status_message(
   95|    933|        dispatch, [](Tox *tox, const Tox_Event_Friend_Status_Message *event, void *user_data) {
   96|    933|            assert(event == nullptr);
   97|    933|        });
   98|    933|    tox_events_callback_friend_typing(
   99|    933|        dispatch, [](Tox *tox, const Tox_Event_Friend_Typing *event, void *user_data) {
  100|    933|            assert(event == nullptr);
  101|    933|        });
  102|    933|    tox_events_callback_self_connection_status(
  103|    933|        dispatch, [](Tox *tox, const Tox_Event_Self_Connection_Status *event, void *user_data) {
  104|    933|            assert(event == nullptr);
  105|    933|        });
  106|    933|}
bootstrap_harness.cc:_ZZN12_GLOBAL__N_115setup_callbacksEP12Tox_DispatchENK4$_18clEP3ToxPK24Tox_Event_Friend_RequestPv:
   83|    128|        dispatch, [](Tox *tox, const Tox_Event_Friend_Request *event, void *user_data) {
   84|    128|            Tox_Err_Friend_Add err;
   85|    128|            tox_friend_add_norequest(tox, tox_event_friend_request_get_public_key(event), &err);
   86|    128|            assert(err == TOX_ERR_FRIEND_ADD_OK || err == TOX_ERR_FRIEND_ADD_OWN_KEY
   87|    128|                || err == TOX_ERR_FRIEND_ADD_ALREADY_SENT
   88|    128|                || err == TOX_ERR_FRIEND_ADD_BAD_CHECKSUM);
   89|    128|        });

fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Fuzz_SystemjEXadL_ZN3$_18__invokeES3_jEEEcvPFT_T0_DpT1_EIS1_S1_JjEEEvENKUlS1_DpT_E_clIJjEEEDaS1_SG_:
   31|  1.73k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Fuzz_SystemjEXadL_ZN3$_18__invokeES3_jEEE13static_casterIS1_EcvT_IS3_EEv:
   22|  1.73k|        {
   23|  1.73k|            return static_cast<To>(obj);
   24|  1.73k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Fuzz_SystemjjEXadL_ZN3$_28__invokeES3_jjEEEcvPFT_T0_DpT1_EIS1_S1_JjjEEEvENKUlS1_DpT_E_clIJjjEEEDaS1_SG_:
   31|  51.1k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Fuzz_SystemjjEXadL_ZN3$_28__invokeES3_jjEEE13static_casterIS1_EcvT_IS3_EEv:
   22|  51.1k|        {
   23|  51.1k|            return static_cast<To>(obj);
   24|  51.1k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Fuzz_SystemS1_jEXadL_ZN3$_38__invokeES3_S1_jEEEcvPFT_T0_DpT1_EIS1_S1_JS1_jEEEvENKUlS1_DpT_E_clIJS1_jEEEDaS1_SG_:
   31|  11.1k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Fuzz_SystemS1_jEXadL_ZN3$_38__invokeES3_S1_jEEE13static_casterIS1_EcvT_IS3_EEv:
   22|  11.1k|        {
   23|  11.1k|            return static_cast<To>(obj);
   24|  11.1k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Fuzz_SystemPvEXadL_ZN3$_48__invokeES2_S3_EEEcvPFT_T0_DpT1_EIvS3_JS3_EEEvENKUlS3_DpT_E_clIJS3_EEEDaS3_SG_:
   31|  59.2k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Fuzz_SystemPvEXadL_ZN3$_48__invokeES2_S3_EEE13static_casterIS3_EcvT_IS2_EEv:
   22|  59.2k|        {
   23|  59.2k|            return static_cast<To>(obj);
   24|  59.2k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiEXadL_ZN3$_58__invokeES2_iEEEcvPFT_T0_DpT1_EIiPvJiEEEvENKUlSE_DpT_E_clIJiEEEDaSE_SG_:
   31|  10.8k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiEXadL_ZN3$_58__invokeES2_iEEE13static_casterIPvEcvT_IS2_EEv:
   22|  10.8k|        {
   23|  10.8k|            return static_cast<To>(obj);
   24|  10.8k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiEXadL_ZN3$_68__invokeES2_iEEEcvPFT_T0_DpT1_EIiPvJiEEEvENKUlSE_DpT_E_clIJiEEEDaSE_SG_:
   31|  44.5k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiEXadL_ZN3$_68__invokeES2_iEEE13static_casterIPvEcvT_IS2_EEv:
   22|  44.5k|        {
   23|  44.5k|            return static_cast<To>(obj);
   24|  44.5k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiPK12Network_AddrEXadL_ZN3$_78__invokeES2_iS5_EEEcvPFT_T0_DpT1_EIiPvJiS5_EEEvENKUlSH_DpT_E_clIJiS5_EEEDaSH_SJ_:
   31|    831|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiPK12Network_AddrEXadL_ZN3$_78__invokeES2_iS5_EEE13static_casterIPvEcvT_IS2_EEv:
   22|    831|        {
   23|    831|            return static_cast<To>(obj);
   24|    831|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiiEXadL_ZN3$_88__invokeES2_iiEEEcvPFT_T0_DpT1_EIiPvJiiEEEvENKUlSE_DpT_E_clIJiiEEEDaSE_SG_:
   31|    145|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiiEXadL_ZN3$_88__invokeES2_iiEEE13static_casterIPvEcvT_IS2_EEv:
   22|    145|        {
   23|    145|            return static_cast<To>(obj);
   24|    145|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiEXadL_ZN3$_98__invokeES2_iEEEcvPFT_T0_DpT1_EIiPvJiEEEvENKUlSE_DpT_E_clIJiEEEDaSE_SG_:
   31|  50.4k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiEXadL_ZN3$_98__invokeES2_iEEE13static_casterIPvEcvT_IS2_EEv:
   22|  50.4k|        {
   23|  50.4k|            return static_cast<To>(obj);
   24|  50.4k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiPhmEXadL_ZN4$_108__invokeES2_iS3_mEEEcvPFT_T0_DpT1_EIiPvJiS3_mEEEvENKUlSF_DpT_E_clIJiS3_mEEEDaSF_SH_:
   31|  16.9k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiPhmEXadL_ZN4$_108__invokeES2_iS3_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|  16.9k|        {
   23|  16.9k|            return static_cast<To>(obj);
   24|  16.9k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiPhmP12Network_AddrEXadL_ZN4$_118__invokeES2_iS3_mS5_EEEcvPFT_T0_DpT1_EIiPvJiS3_mS5_EEEvENKUlSH_DpT_E_clIJiS3_mS5_EEEDaSH_SJ_:
   31|  21.5k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiPhmP12Network_AddrEXadL_ZN4$_118__invokeES2_iS3_mS5_EEE13static_casterIPvEcvT_IS2_EEv:
   22|  21.5k|        {
   23|  21.5k|            return static_cast<To>(obj);
   24|  21.5k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiPKhmEXadL_ZN4$_128__invokeES2_iS4_mEEEcvPFT_T0_DpT1_EIiPvJiS4_mEEEvENKUlSG_DpT_E_clIJiS4_mEEEDaSG_SI_:
   31|  1.26k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiPKhmEXadL_ZN4$_128__invokeES2_iS4_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|  1.26k|        {
   23|  1.26k|            return static_cast<To>(obj);
   24|  1.26k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiPKhmPK12Network_AddrEXadL_ZN4$_138__invokeES2_iS4_mS7_EEEcvPFT_T0_DpT1_EIiPvJiS4_mS7_EEEvENKUlSJ_DpT_E_clIJiS4_mS7_EEEDaSJ_SL_:
   31|  18.8k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiPKhmPK12Network_AddrEXadL_ZN4$_138__invokeES2_iS4_mS7_EEE13static_casterIPvEcvT_IS2_EEv:
   22|  18.8k|        {
   23|  18.8k|            return static_cast<To>(obj);
   24|  18.8k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiiiEXadL_ZN4$_148__invokeES2_iiiEEEcvPFT_T0_DpT1_EIiPvJiiiEEEvENKUlSE_DpT_E_clIJiiiEEEDaSE_SG_:
   31|  1.37k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiiiEXadL_ZN4$_148__invokeES2_iiiEEE13static_casterIPvEcvT_IS2_EEv:
   22|  1.37k|        {
   23|  1.37k|            return static_cast<To>(obj);
   24|  1.37k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemibEXadL_ZN4$_158__invokeES2_ibEEEcvPFT_T0_DpT1_EIiPvJibEEEvENKUlSE_DpT_E_clIJibEEEDaSE_SG_:
   31|  45.9k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemibEXadL_ZN4$_158__invokeES2_ibEEE13static_casterIPvEcvT_IS2_EEv:
   22|  45.9k|        {
   23|  45.9k|            return static_cast<To>(obj);
   24|  45.9k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiiiPvPmEXadL_ZN4$_168__invokeES2_iiiS3_S4_EEEcvPFT_T0_DpT1_EIiS3_JiiiS3_S4_EEEvENKUlS3_DpT_E_clIJiiiS3_S4_EEEDaS3_SH_:
   31|    831|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiiiPvPmEXadL_ZN4$_168__invokeES2_iiiS3_S4_EEE13static_casterIS3_EcvT_IS2_EEv:
   22|    831|        {
   23|    831|            return static_cast<To>(obj);
   24|    831|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_SystemiiiPKvmEXadL_ZN4$_178__invokeES2_iiiS4_mEEEcvPFT_T0_DpT1_EIiPvJiiiS4_mEEEvENKUlSG_DpT_E_clIJiiiS4_mEEEDaSG_SI_:
   31|  2.88k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_SystemiiiPKvmEXadL_ZN4$_178__invokeES2_iiiS4_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|  2.88k|        {
   23|  2.88k|            return static_cast<To>(obj);
   24|  2.88k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Fuzz_SystemPhmEXadL_ZN4$_188__invokeES2_S3_mEEEcvPFT_T0_DpT1_EIvPvJS3_mEEEvENKUlSF_DpT_E_clIJS3_mEEEDaSF_SH_:
   31|  82.8k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Fuzz_SystemPhmEXadL_ZN4$_188__invokeES2_S3_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|  82.8k|        {
   23|  82.8k|            return static_cast<To>(obj);
   24|  82.8k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFmP11Fuzz_SystemEXadL_ZN3$_08__invokeES2_EEEcvPFT_T0_DpT1_EImPvJEEEvENKUlSE_DpT_E_clIJEEEDaSE_SG_:
   31|   146k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFmP11Fuzz_SystemEXadL_ZN3$_08__invokeES2_EEE13static_casterIPvEcvT_IS2_EEv:
   22|   146k|        {
   23|   146k|            return static_cast<To>(obj);
   24|   146k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Null_SystemjEXadL_ZN4$_208__invokeES3_jEEEcvPFT_T0_DpT1_EIS1_S1_JjEEEvENKUlS1_DpT_E_clIJjEEEDaS1_SG_:
   31|   145k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Null_SystemjEXadL_ZN4$_208__invokeES3_jEEE13static_casterIS1_EcvT_IS3_EEv:
   22|   145k|        {
   23|   145k|            return static_cast<To>(obj);
   24|   145k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Null_SystemPvEXadL_ZN4$_238__invokeES2_S3_EEEcvPFT_T0_DpT1_EIvS3_JS3_EEEvENKUlS3_DpT_E_clIJS3_EEEDaS3_SG_:
   31|   145k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Null_SystemPvEXadL_ZN4$_238__invokeES2_S3_EEE13static_casterIS3_EcvT_IS2_EEv:
   22|   145k|        {
   23|   145k|            return static_cast<To>(obj);
   24|   145k|        }

_ZN6SystemD2Ev:
   33|  1.94k|System::~System() { }
_ZN11Fuzz_SystemC2ER9Fuzz_Data:
  186|    971|{
  187|    971|    sys->mono_time_callback = get_self_clock;
  188|    971|    sys->mono_time_user_data = this;
  189|    971|    sys->mem = mem.get();
  190|    971|    sys->ns = ns.get();
  191|    971|    sys->rng = rng.get();
  192|    971|}
_ZN11Null_SystemC2Ev:
  273|    971|{
  274|    971|    sys->mono_time_callback = get_self_clock;
  275|    971|    sys->mono_time_user_data = this;
  276|    971|    sys->mem = mem.get();
  277|    971|    sys->ns = ns.get();
  278|    971|    sys->rng = rng.get();
  279|    971|}
fuzz_support.cc:_ZNK3$_1clEP11Fuzz_Systemj:
   79|  1.73k|    ![](Fuzz_System *self, uint32_t size) {
   80|  1.73k|        return alloc_common(self->data, [=]() { return std::malloc(size); });
   81|  1.73k|    },
fuzz_support.cc:_ZL12alloc_commonIZNK3$_1clEP11Fuzz_SystemjEUlvE_EPvR9Fuzz_DataT_:
   69|  1.73k|{
   70|  1.73k|    CONSUME1_OR_RETURN_VAL(const uint8_t want_alloc, data, func());
  ------------------
  |  |   74|  1.73k|    if (INPUT.size < 1) {                        \
  |  |  ------------------
  |  |  |  Branch (74:9): [True: 139, False: 1.59k]
  |  |  ------------------
  |  |   75|    139|        return VAL;                              \
  |  |   76|    139|    }                                            \
  |  |   77|  1.73k|    DECL = INPUT.consume1()
  ------------------
   71|  1.59k|    if (!want_alloc) {
  ------------------
  |  Branch (71:9): [True: 396, False: 1.20k]
  ------------------
   72|    396|        return nullptr;
   73|    396|    }
   74|  1.20k|    return func();
   75|  1.59k|}
fuzz_support.cc:_ZZNK3$_1clEP11Fuzz_SystemjENKUlvE_clEv:
   80|  1.34k|        return alloc_common(self->data, [=]() { return std::malloc(size); });
fuzz_support.cc:_ZNK3$_2clEP11Fuzz_Systemjj:
   83|  51.1k|    ![](Fuzz_System *self, uint32_t nmemb, uint32_t size) {
   84|  51.1k|        return alloc_common(self->data, [=]() { return std::calloc(nmemb, size); });
   85|  51.1k|    },
fuzz_support.cc:_ZL12alloc_commonIZNK3$_2clEP11Fuzz_SystemjjEUlvE_EPvR9Fuzz_DataT_:
   69|  51.1k|{
   70|  51.1k|    CONSUME1_OR_RETURN_VAL(const uint8_t want_alloc, data, func());
  ------------------
  |  |   74|  51.1k|    if (INPUT.size < 1) {                        \
  |  |  ------------------
  |  |  |  Branch (74:9): [True: 677, False: 50.4k]
  |  |  ------------------
  |  |   75|    677|        return VAL;                              \
  |  |   76|    677|    }                                            \
  |  |   77|  51.1k|    DECL = INPUT.consume1()
  ------------------
   71|  50.4k|    if (!want_alloc) {
  ------------------
  |  Branch (71:9): [True: 1.38k, False: 49.1k]
  ------------------
   72|  1.38k|        return nullptr;
   73|  1.38k|    }
   74|  49.1k|    return func();
   75|  50.4k|}
fuzz_support.cc:_ZZNK3$_2clEP11Fuzz_SystemjjENKUlvE_clEv:
   84|  49.7k|        return alloc_common(self->data, [=]() { return std::calloc(nmemb, size); });
fuzz_support.cc:_ZNK3$_3clEP11Fuzz_SystemPvj:
   87|  11.1k|    ![](Fuzz_System *self, void *ptr, uint32_t size) {
   88|  11.1k|        return alloc_common(self->data, [=]() { return std::realloc(ptr, size); });
   89|  11.1k|    },
fuzz_support.cc:_ZL12alloc_commonIZNK3$_3clEP11Fuzz_SystemPvjEUlvE_ES3_R9Fuzz_DataT_:
   69|  11.1k|{
   70|  11.1k|    CONSUME1_OR_RETURN_VAL(const uint8_t want_alloc, data, func());
  ------------------
  |  |   74|  11.1k|    if (INPUT.size < 1) {                        \
  |  |  ------------------
  |  |  |  Branch (74:9): [True: 182, False: 10.9k]
  |  |  ------------------
  |  |   75|    182|        return VAL;                              \
  |  |   76|    182|    }                                            \
  |  |   77|  11.1k|    DECL = INPUT.consume1()
  ------------------
   71|  10.9k|    if (!want_alloc) {
  ------------------
  |  Branch (71:9): [True: 3.54k, False: 7.43k]
  ------------------
   72|  3.54k|        return nullptr;
   73|  3.54k|    }
   74|  7.43k|    return func();
   75|  10.9k|}
fuzz_support.cc:_ZZNK3$_3clEP11Fuzz_SystemPvjENKUlvE_clEv:
   88|  7.61k|        return alloc_common(self->data, [=]() { return std::realloc(ptr, size); });
fuzz_support.cc:_ZNK3$_4clEP11Fuzz_SystemPv:
   91|  59.2k|    ![](Fuzz_System *self, void *ptr) { std::free(ptr); },
fuzz_support.cc:_ZNK3$_5clEP11Fuzz_Systemi:
   95|  10.8k|    /* .close = */ ![](Fuzz_System *self, int sock) { return 0; },
fuzz_support.cc:_ZNK3$_6clEP11Fuzz_Systemi:
   96|  44.5k|    /* .accept = */ ![](Fuzz_System *self, int sock) { return 1337; },
fuzz_support.cc:_ZNK3$_7clEP11Fuzz_SystemiPK12Network_Addr:
   97|    831|    /* .bind = */ ![](Fuzz_System *self, int sock, const Network_Addr *addr) { return 0; },
fuzz_support.cc:_ZNK3$_8clEP11Fuzz_Systemii:
   98|    145|    /* .listen = */ ![](Fuzz_System *self, int sock, int backlog) { return 0; },
fuzz_support.cc:_ZNK3$_9clEP11Fuzz_Systemi:
  100|  50.4k|    ![](Fuzz_System *self, int sock) {
  101|  50.4k|        assert(sock == 42 || sock == 1337);
  102|      0|        const size_t count = random_u16(self->rng.get());
  103|  50.4k|        return static_cast<int>(std::min(count, self->data.size));
  104|  50.4k|    },
fuzz_support.cc:_ZNK4$_10clEP11Fuzz_SystemiPhm:
  106|  16.9k|    ![](Fuzz_System *self, int sock, uint8_t *buf, size_t len) {
  107|  16.9k|        assert(sock == 42 || sock == 1337);
  108|       |        // Receive data from the fuzzer.
  109|      0|        return recv_common(self->data, buf, len);
  110|  16.9k|    },
fuzz_support.cc:_ZL11recv_commonR9Fuzz_DataPhm:
   36|  38.5k|{
   37|  38.5k|    if (input.size < 2) {
  ------------------
  |  Branch (37:9): [True: 672, False: 37.8k]
  ------------------
   38|    672|        errno = ENOMEM;
   39|    672|        return -1;
   40|    672|    }
   41|       |
   42|  37.8k|    const size_t fuzz_len = (input.data[0] << 8) | input.data[1];
   43|  37.8k|    input.data += 2;
   44|  37.8k|    input.size -= 2;
   45|       |
   46|  37.8k|    if (fuzz_len == 0xffff) {
  ------------------
  |  Branch (46:9): [True: 26.2k, False: 11.6k]
  ------------------
   47|  26.2k|        errno = EWOULDBLOCK;
   48|  26.2k|        if (DEBUG) {
  ------------------
  |  Branch (48:13): [Folded - Ignored]
  ------------------
   49|      0|            std::printf("recvfrom: no data for tox1\n");
   50|      0|        }
   51|  26.2k|        return -1;
   52|  26.2k|    }
   53|       |
   54|  11.6k|    if (DEBUG) {
  ------------------
  |  Branch (54:9): [Folded - Ignored]
  ------------------
   55|      0|        std::printf(
   56|      0|            "recvfrom: %zu (%02x, %02x) for tox1\n", fuzz_len, input.data[-2], input.data[-1]);
   57|      0|    }
   58|  11.6k|    const size_t res = std::min(buf_len, std::min(fuzz_len, input.size));
   59|       |
   60|  11.6k|    std::copy(input.data, input.data + res, buf);
   61|  11.6k|    input.data += res;
   62|  11.6k|    input.size -= res;
   63|       |
   64|  11.6k|    return res;
   65|  37.8k|}
fuzz_support.cc:_ZNK4$_11clEP11Fuzz_SystemiPhmP12Network_Addr:
  112|  21.5k|    ![](Fuzz_System *self, int sock, uint8_t *buf, size_t len, Network_Addr *addr) {
  113|  21.5k|        assert(sock == 42 || sock == 1337);
  114|       |
  115|      0|        addr->addr = sockaddr_storage{};
  116|       |        // Dummy Addr
  117|  21.5k|        addr->addr.ss_family = AF_INET;
  118|       |
  119|       |        // We want an AF_INET address with dummy values
  120|  21.5k|        sockaddr_in *addr_in = reinterpret_cast<sockaddr_in *>(&addr->addr);
  121|  21.5k|        addr_in->sin_port = htons(33446);
  122|  21.5k|        addr_in->sin_addr.s_addr = htonl(0x7f000002);  // 127.0.0.2
  123|  21.5k|        addr->size = sizeof(struct sockaddr);
  124|       |
  125|  21.5k|        return recv_common(self->data, buf, len);
  126|  21.5k|    },
fuzz_support.cc:_ZNK4$_12clEP11Fuzz_SystemiPKhm:
  128|  1.26k|    ![](Fuzz_System *self, int sock, const uint8_t *buf, size_t len) {
  129|  1.26k|        assert(sock == 42 || sock == 1337);
  130|       |        // Always succeed.
  131|      0|        return static_cast<int>(len);
  132|  1.26k|    },
fuzz_support.cc:_ZNK4$_13clEP11Fuzz_SystemiPKhmPK12Network_Addr:
  134|  18.8k|    ![](Fuzz_System *self, int sock, const uint8_t *buf, size_t len, const Network_Addr *addr) {
  135|  18.8k|        assert(sock == 42 || sock == 1337);
  136|       |        // Always succeed.
  137|      0|        return static_cast<int>(len);
  138|  18.8k|    },
fuzz_support.cc:_ZNK4$_14clEP11Fuzz_Systemiii:
  139|  1.37k|    /* .socket = */ ![](Fuzz_System *self, int domain, int type, int proto) { return 42; },
fuzz_support.cc:_ZNK4$_15clEP11Fuzz_Systemib:
  140|  45.9k|    /* .socket_nonblock = */ ![](Fuzz_System *self, int sock, bool nonblock) { return 0; },
fuzz_support.cc:_ZNK4$_16clEP11Fuzz_SystemiiiPvPm:
  142|    831|    ![](Fuzz_System *self, int sock, int level, int optname, void *optval, size_t *optlen) {
  143|    831|        std::memset(optval, 0, *optlen);
  144|    831|        return 0;
  145|    831|    },
fuzz_support.cc:_ZNK4$_17clEP11Fuzz_SystemiiiPKvm:
  147|  2.88k|    ![](Fuzz_System *self, int sock, int level, int optname, const void *optval, size_t optlen) {
  148|  2.88k|        return 0;
  149|  2.88k|    },
fuzz_support.cc:_ZNK4$_18clEP11Fuzz_SystemPhm:
  154|  82.8k|    ![](Fuzz_System *self, uint8_t *bytes, size_t length) {
  155|       |        // Amount of data is limited
  156|  82.8k|        const size_t bytes_read = std::min(length, self->data.size);
  157|       |        // Initialize everything to make MSAN and others happy
  158|  82.8k|        std::memset(bytes, 0, length);
  159|  82.8k|        std::copy(self->data.data, self->data.data + bytes_read, bytes);
  160|  82.8k|        self->data.data += bytes_read;
  161|  82.8k|        self->data.size -= bytes_read;
  162|  82.8k|        if (DEBUG) {
  ------------------
  |  Branch (162:13): [Folded - Ignored]
  ------------------
  163|      0|            std::printf("rng: %02x..%02x[%zu] -> tox1\n", bytes[0], bytes[length - 1], length);
  164|      0|        }
  165|  82.8k|    },
fuzz_support.cc:_ZNK3$_0clEP11Fuzz_System:
   25|   146k|static constexpr tox_mono_time_cb *get_self_clock = ![](Fuzz_System *self) { return self->clock; };
fuzz_support.cc:_ZNK4$_20clEP11Null_Systemj:
  196|   145k|    ![](Null_System *self, uint32_t size) { return std::malloc(size); },
fuzz_support.cc:_ZNK4$_23clEP11Null_SystemPv:
  202|   145k|    ![](Null_System *self, void *ptr) { std::free(ptr); },

_ZN9Fuzz_DataC2EPKhm:
   24|    971|    {}
_ZN9Fuzz_Data8consume1Ev:
   30|  65.0k|    {
   31|  65.0k|        const uint8_t val = data[0];
   32|  65.0k|        ++data;
   33|  65.0k|        --size;
   34|  65.0k|        return val;
   35|  65.0k|    }

cmp_init:
  791|   290k|                                         cmp_writer write) {
  792|   290k|  ctx->error = ERROR_NONE;
  793|   290k|  ctx->buf = buf;
  794|   290k|  ctx->read = read;
  795|   290k|  ctx->skip = skip;
  796|   290k|  ctx->write = write;
  797|   290k|}
cmp_write_pfix:
  814|    512|bool cmp_write_pfix(cmp_ctx_t *ctx, uint8_t c) {
  815|    512|  if (c <= 0x7F)
  ------------------
  |  Branch (815:7): [True: 512, False: 0]
  ------------------
  816|    512|    return write_fixed_value(ctx, c);
  817|       |
  818|      0|  ctx->error = INPUT_VALUE_TOO_LARGE_ERROR;
  819|      0|  return false;
  820|    512|}
cmp_write_uinteger:
  927|    512|bool cmp_write_uinteger(cmp_ctx_t *ctx, uint64_t u) {
  928|    512|  if (u <= 0x7F)
  ------------------
  |  Branch (928:7): [True: 512, False: 0]
  ------------------
  929|    512|    return cmp_write_pfix(ctx, (uint8_t)u);
  930|      0|  if (u <= 0xFF)
  ------------------
  |  Branch (930:7): [True: 0, False: 0]
  ------------------
  931|      0|    return cmp_write_u8(ctx, (uint8_t)u);
  932|      0|  if (u <= 0xFFFF)
  ------------------
  |  Branch (932:7): [True: 0, False: 0]
  ------------------
  933|      0|    return cmp_write_u16(ctx, (uint16_t)u);
  934|      0|  if (u <= 0xFFFFFFFF)
  ------------------
  |  Branch (934:7): [True: 0, False: 0]
  ------------------
  935|      0|    return cmp_write_u32(ctx, (uint32_t)u);
  936|       |
  937|      0|  return cmp_write_u64(ctx, u);
  938|      0|}
cmp_write_bin8_marker:
 1161|  1.01k|bool cmp_write_bin8_marker(cmp_ctx_t *ctx, uint8_t size) {
 1162|  1.01k|  if (!write_type_marker(ctx, BIN8_MARKER))
  ------------------
  |  Branch (1162:7): [True: 0, False: 1.01k]
  ------------------
 1163|      0|    return false;
 1164|       |
 1165|  1.01k|  if (ctx->write(ctx, &size, sizeof(uint8_t)))
  ------------------
  |  Branch (1165:7): [True: 1.01k, False: 0]
  ------------------
 1166|  1.01k|    return true;
 1167|       |
 1168|      0|  ctx->error = LENGTH_WRITING_ERROR;
 1169|      0|  return false;
 1170|  1.01k|}
cmp_write_bin8:
 1172|  1.01k|bool cmp_write_bin8(cmp_ctx_t *ctx, const void *data, uint8_t size) {
 1173|  1.01k|  if (!cmp_write_bin8_marker(ctx, size))
  ------------------
  |  Branch (1173:7): [True: 0, False: 1.01k]
  ------------------
 1174|      0|    return false;
 1175|       |
 1176|  1.01k|  if (size == 0)
  ------------------
  |  Branch (1176:7): [True: 0, False: 1.01k]
  ------------------
 1177|      0|    return true;
 1178|       |
 1179|  1.01k|  if (ctx->write(ctx, data, size))
  ------------------
  |  Branch (1179:7): [True: 1.01k, False: 0]
  ------------------
 1180|  1.01k|    return true;
 1181|       |
 1182|      0|  ctx->error = DATA_WRITING_ERROR;
 1183|      0|  return false;
 1184|  1.01k|}
cmp_write_bin16_marker:
 1186|      8|bool cmp_write_bin16_marker(cmp_ctx_t *ctx, uint16_t size) {
 1187|      8|  if (!write_type_marker(ctx, BIN16_MARKER))
  ------------------
  |  Branch (1187:7): [True: 0, False: 8]
  ------------------
 1188|      0|    return false;
 1189|       |
 1190|      8|  size = be16(size);
 1191|       |
 1192|      8|  if (ctx->write(ctx, &size, sizeof(uint16_t)))
  ------------------
  |  Branch (1192:7): [True: 8, False: 0]
  ------------------
 1193|      8|    return true;
 1194|       |
 1195|      0|  ctx->error = LENGTH_WRITING_ERROR;
 1196|      0|  return false;
 1197|      8|}
cmp_write_bin16:
 1199|      8|bool cmp_write_bin16(cmp_ctx_t *ctx, const void *data, uint16_t size) {
 1200|      8|  if (!cmp_write_bin16_marker(ctx, size))
  ------------------
  |  Branch (1200:7): [True: 0, False: 8]
  ------------------
 1201|      0|    return false;
 1202|       |
 1203|      8|  if (size == 0)
  ------------------
  |  Branch (1203:7): [True: 0, False: 8]
  ------------------
 1204|      0|    return true;
 1205|       |
 1206|      8|  if (ctx->write(ctx, data, size))
  ------------------
  |  Branch (1206:7): [True: 8, False: 0]
  ------------------
 1207|      8|    return true;
 1208|       |
 1209|      0|  ctx->error = DATA_WRITING_ERROR;
 1210|      0|  return false;
 1211|      8|}
cmp_write_bin:
 1249|  1.02k|bool cmp_write_bin(cmp_ctx_t *ctx, const void *data, uint32_t size) {
 1250|  1.02k|  if (size <= 0xFF)
  ------------------
  |  Branch (1250:7): [True: 1.01k, False: 8]
  ------------------
 1251|  1.01k|    return cmp_write_bin8(ctx, data, (uint8_t)size);
 1252|      8|  if (size <= 0xFFFF)
  ------------------
  |  Branch (1252:7): [True: 8, False: 0]
  ------------------
 1253|      8|    return cmp_write_bin16(ctx, data, (uint16_t)size);
 1254|       |
 1255|      0|  return cmp_write_bin32(ctx, data, size);
 1256|      8|}
cmp_write_fixarray:
 1258|   291k|bool cmp_write_fixarray(cmp_ctx_t *ctx, uint8_t size) {
 1259|   291k|  if (size <= FIXARRAY_SIZE)
  ------------------
  |  Branch (1259:7): [True: 291k, False: 0]
  ------------------
 1260|   291k|    return write_fixed_value(ctx, FIXARRAY_MARKER | size);
 1261|       |
 1262|      0|  ctx->error = INPUT_VALUE_TOO_LARGE_ERROR;
 1263|      0|  return false;
 1264|   291k|}
cmp_write_array:
 1292|   291k|bool cmp_write_array(cmp_ctx_t *ctx, uint32_t size) {
 1293|   291k|  if (size <= FIXARRAY_SIZE)
  ------------------
  |  Branch (1293:7): [True: 291k, False: 0]
  ------------------
 1294|   291k|    return cmp_write_fixarray(ctx, (uint8_t)size);
 1295|      0|  if (size <= 0xFFFF)
  ------------------
  |  Branch (1295:7): [True: 0, False: 0]
  ------------------
 1296|      0|    return cmp_write_array16(ctx, (uint16_t)size);
 1297|       |
 1298|      0|  return cmp_write_array32(ctx, size);
 1299|      0|}
cmp.c:write_fixed_value:
  287|   292k|static bool write_fixed_value(cmp_ctx_t *ctx, uint8_t value) {
  288|   292k|  if (write_byte(ctx, value))
  ------------------
  |  Branch (288:7): [True: 292k, False: 0]
  ------------------
  289|   292k|    return true;
  290|       |
  291|      0|  ctx->error = FIXED_VALUE_WRITING_ERROR;
  292|      0|  return false;
  293|   292k|}
cmp.c:write_byte:
  248|   293k|static bool write_byte(cmp_ctx_t *ctx, uint8_t x) {
  249|   293k|  return (ctx->write(ctx, &x, sizeof(uint8_t)) == (sizeof(uint8_t)));
  250|   293k|}
cmp.c:write_type_marker:
  279|  1.02k|static bool write_type_marker(cmp_ctx_t *ctx, uint8_t marker) {
  280|  1.02k|  if (write_byte(ctx, marker))
  ------------------
  |  Branch (280:7): [True: 1.02k, False: 0]
  ------------------
  281|  1.02k|    return true;
  282|       |
  283|      0|  ctx->error = TYPE_MARKER_WRITING_ERROR;
  284|      0|  return false;
  285|  1.02k|}
cmp.c:be16:
  128|      8|static uint16_t be16(uint16_t x) {
  129|      8|  char *b = (char *)&x;
  130|       |
  131|      8|  if (!is_bigendian()) {
  ------------------
  |  |  125|      8|#define is_bigendian() ((*(const char *)&i_) == 0)
  ------------------
  |  Branch (131:7): [True: 8, False: 0]
  ------------------
  132|      8|    char swap = b[0];
  133|      8|    b[0] = b[1];
  134|      8|    b[1] = swap;
  135|      8|  }
  136|       |
  137|      8|  return x;
  138|      8|}

dht_friend_client:
  137|  17.5k|{
  138|  17.5k|    return &dht_friend->client_list[index];
  139|  17.5k|}
dht_get_self_public_key:
  142|  25.4k|{
  143|  25.4k|    return dht->self_public_key;
  144|  25.4k|}
dht_get_self_secret_key:
  146|  3.92k|{
  147|  3.92k|    return dht->self_secret_key;
  148|  3.92k|}
dht_get_net:
  160|  39.8k|{
  161|  39.8k|    return dht->net;
  162|  39.8k|}
dht_get_ping:
  164|    348|{
  165|    348|    return dht->ping;
  166|    348|}
dht_get_close_clientlist:
  168|    295|{
  169|    295|    return dht->close_clientlist;
  170|    295|}
dht_get_close_client:
  172|  1.12M|{
  173|  1.12M|    assert(client_num < sizeof(dht->close_clientlist) / sizeof(dht->close_clientlist[0]));
  174|      0|    return &dht->close_clientlist[client_num];
  175|  1.12M|}
dht_get_num_friends:
  177|  2.19k|{
  178|  2.19k|    return dht->num_friends;
  179|  2.19k|}
dht_get_friend:
  182|  2.19k|{
  183|  2.19k|    assert(friend_num < dht->num_friends);
  184|      0|    return &dht->friends_list[friend_num];
  185|  2.19k|}
dht_get_friend_public_key:
  187|      2|{
  188|      2|    assert(friend_num < dht->num_friends);
  189|      0|    return dht->friends_list[friend_num].public_key;
  190|      2|}
bit_by_bit_cmp:
  235|    438|{
  236|    438|    unsigned int i;
  237|    438|    unsigned int j = 0;
  238|       |
  239|    685|    for (i = 0; i < CRYPTO_PUBLIC_KEY_SIZE; ++i) {
  ------------------
  |  |   40|    685|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (239:17): [True: 685, False: 0]
  ------------------
  240|    685|        if (pk1[i] == pk2[i]) {
  ------------------
  |  Branch (240:13): [True: 247, False: 438]
  ------------------
  241|    247|            continue;
  242|    247|        }
  243|       |
  244|  1.11k|        for (j = 0; j < 8; ++j) {
  ------------------
  |  Branch (244:21): [True: 1.11k, False: 0]
  ------------------
  245|  1.11k|            const uint8_t mask = 1 << (7 - j);
  246|       |
  247|  1.11k|            if ((pk1[i] & mask) != (pk2[i] & mask)) {
  ------------------
  |  Branch (247:17): [True: 438, False: 674]
  ------------------
  248|    438|                break;
  249|    438|            }
  250|  1.11k|        }
  251|       |
  252|    438|        break;
  253|    685|    }
  254|       |
  255|    438|    return i * 8 + j;
  256|    438|}
dht_get_shared_key_recv:
  263|    423|{
  264|    423|    return shared_key_cache_lookup(dht->shared_keys_recv, public_key);
  265|    423|}
dht_get_shared_key_sent:
  272|    833|{
  273|    833|    return shared_key_cache_lookup(dht->shared_keys_sent, public_key);
  274|    833|}
handle_request:
  313|     16|{
  314|     16|    if (self_public_key == nullptr || public_key == nullptr || data == nullptr || request_id == nullptr
  ------------------
  |  |   66|     32|#define nullptr NULL
  ------------------
                  if (self_public_key == nullptr || public_key == nullptr || data == nullptr || request_id == nullptr
  ------------------
  |  |   66|     32|#define nullptr NULL
  ------------------
                  if (self_public_key == nullptr || public_key == nullptr || data == nullptr || request_id == nullptr
  ------------------
  |  |   66|     32|#define nullptr NULL
  ------------------
                  if (self_public_key == nullptr || public_key == nullptr || data == nullptr || request_id == nullptr
  ------------------
  |  |   66|     32|#define nullptr NULL
  ------------------
  |  Branch (314:9): [True: 0, False: 16]
  |  Branch (314:39): [True: 0, False: 16]
  |  Branch (314:64): [True: 0, False: 16]
  |  Branch (314:83): [True: 0, False: 16]
  ------------------
  315|     16|            || packet == nullptr) {
  ------------------
  |  |   66|     16|#define nullptr NULL
  ------------------
  |  Branch (315:16): [True: 0, False: 16]
  ------------------
  316|      0|        return -1;
  317|      0|    }
  318|       |
  319|     16|    if (packet_length <= CRYPTO_SIZE + CRYPTO_MAC_SIZE || packet_length > MAX_CRYPTO_REQUEST_SIZE) {
  ------------------
  |  |  276|     16|#define CRYPTO_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   40|     16|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define CRYPTO_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   66|     16|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  ------------------
                  if (packet_length <= CRYPTO_SIZE + CRYPTO_MAC_SIZE || packet_length > MAX_CRYPTO_REQUEST_SIZE) {
  ------------------
  |  |   61|     32|#define CRYPTO_MAC_SIZE                16
  ------------------
                  if (packet_length <= CRYPTO_SIZE + CRYPTO_MAC_SIZE || packet_length > MAX_CRYPTO_REQUEST_SIZE) {
  ------------------
  |  |   78|     16|#define MAX_CRYPTO_REQUEST_SIZE 1024
  ------------------
  |  Branch (319:9): [True: 0, False: 16]
  |  Branch (319:59): [True: 1, False: 15]
  ------------------
  320|      1|        return -1;
  321|      1|    }
  322|       |
  323|     15|    if (!pk_equal(packet + 1, self_public_key)) {
  ------------------
  |  Branch (323:9): [True: 0, False: 15]
  ------------------
  324|      0|        return -1;
  325|      0|    }
  326|       |
  327|     15|    memcpy(public_key, packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(public_key, packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  328|     15|    const uint8_t *const nonce = packet + 1 + CRYPTO_PUBLIC_KEY_SIZE * 2;
  ------------------
  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  329|     15|    uint8_t temp[MAX_CRYPTO_REQUEST_SIZE];
  330|     15|    int32_t len1 = decrypt_data(public_key, self_secret_key, nonce,
  331|     15|                                packet + CRYPTO_SIZE, packet_length - CRYPTO_SIZE, temp);
  ------------------
  |  |  276|     15|#define CRYPTO_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define CRYPTO_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   66|     15|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  ------------------
                                              packet + CRYPTO_SIZE, packet_length - CRYPTO_SIZE, temp);
  ------------------
  |  |  276|     15|#define CRYPTO_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define CRYPTO_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   66|     15|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  ------------------
  332|       |
  333|     15|    if (len1 == -1 || len1 == 0) {
  ------------------
  |  Branch (333:9): [True: 0, False: 15]
  |  Branch (333:23): [True: 0, False: 15]
  ------------------
  334|      0|        crypto_memzero(temp, MAX_CRYPTO_REQUEST_SIZE);
  ------------------
  |  |   78|      0|#define MAX_CRYPTO_REQUEST_SIZE 1024
  ------------------
  335|      0|        return -1;
  336|      0|    }
  337|       |
  338|     15|    assert(len1 == packet_length - CRYPTO_SIZE - CRYPTO_MAC_SIZE);
  339|       |    // Because coverity can't figure out this equation:
  340|      0|    assert(len1 <= MAX_CRYPTO_REQUEST_SIZE - CRYPTO_SIZE - CRYPTO_MAC_SIZE);
  341|       |
  342|      0|    request_id[0] = temp[0];
  343|     15|    --len1;
  344|     15|    memcpy(data, temp + 1, len1);
  345|     15|    crypto_memzero(temp, MAX_CRYPTO_REQUEST_SIZE);
  ------------------
  |  |   78|     15|#define MAX_CRYPTO_REQUEST_SIZE 1024
  ------------------
  346|     15|    return len1;
  347|     15|}
pack_ip_port:
  364|    944|{
  365|    944|    if (data == nullptr) {
  ------------------
  |  |   66|    944|#define nullptr NULL
  ------------------
  |  Branch (365:9): [True: 0, False: 944]
  ------------------
  366|      0|        return -1;
  367|      0|    }
  368|       |
  369|    944|    bool is_ipv4;
  370|    944|    uint8_t family;
  371|       |
  372|    944|    if (net_family_is_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (372:9): [True: 944, False: 0]
  ------------------
  373|       |        // TODO(irungentoo): use functions to convert endianness
  374|    944|        is_ipv4 = true;
  375|    944|        family = TOX_AF_INET;
  ------------------
  |  |  207|    944|#define TOX_AF_INET 2
  ------------------
  376|    944|    } else if (net_family_is_tcp_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (376:16): [True: 0, False: 0]
  ------------------
  377|      0|        is_ipv4 = true;
  378|      0|        family = TOX_TCP_INET;
  ------------------
  |  |  209|      0|#define TOX_TCP_INET 130
  ------------------
  379|      0|    } else if (net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (379:16): [True: 0, False: 0]
  ------------------
  380|      0|        is_ipv4 = false;
  381|      0|        family = TOX_AF_INET6;
  ------------------
  |  |  208|      0|#define TOX_AF_INET6 10
  ------------------
  382|      0|    } else if (net_family_is_tcp_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (382:16): [True: 0, False: 0]
  ------------------
  383|      0|        is_ipv4 = false;
  384|      0|        family = TOX_TCP_INET6;
  ------------------
  |  |  210|      0|#define TOX_TCP_INET6 138
  ------------------
  385|      0|    } else {
  386|      0|        Ip_Ntoa ip_str;
  387|       |        // TODO(iphydf): Find out why we're trying to pack invalid IPs, stop
  388|       |        // doing that, and turn this into an error.
  389|      0|        LOGGER_TRACE(logger, "cannot pack invalid IP: %s", net_ip_ntoa(&ip_port->ip, &ip_str));
  ------------------
  |  |   79|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  390|      0|        return -1;
  391|      0|    }
  392|       |
  393|    944|    if (is_ipv4) {
  ------------------
  |  Branch (393:9): [True: 944, False: 0]
  ------------------
  394|    944|        const uint32_t size = 1 + SIZE_IP4 + sizeof(uint16_t);
  ------------------
  |  |  224|    944|#define SIZE_IP4 4
  ------------------
  395|       |
  396|    944|        if (size > length) {
  ------------------
  |  Branch (396:13): [True: 0, False: 944]
  ------------------
  397|      0|            return -1;
  398|      0|        }
  399|       |
  400|    944|        data[0] = family;
  401|    944|        memcpy(data + 1, &ip_port->ip.ip.v4, SIZE_IP4);
  ------------------
  |  |  224|    944|#define SIZE_IP4 4
  ------------------
  402|    944|        memcpy(data + 1 + SIZE_IP4, &ip_port->port, sizeof(uint16_t));
  ------------------
  |  |  224|    944|#define SIZE_IP4 4
  ------------------
  403|    944|        return size;
  404|    944|    } else {
  405|      0|        const uint32_t size = 1 + SIZE_IP6 + sizeof(uint16_t);
  ------------------
  |  |  225|      0|#define SIZE_IP6 16
  ------------------
  406|       |
  407|      0|        if (size > length) {
  ------------------
  |  Branch (407:13): [True: 0, False: 0]
  ------------------
  408|      0|            return -1;
  409|      0|        }
  410|       |
  411|      0|        data[0] = family;
  412|      0|        memcpy(data + 1, &ip_port->ip.ip.v6, SIZE_IP6);
  ------------------
  |  |  225|      0|#define SIZE_IP6 16
  ------------------
  413|      0|        memcpy(data + 1 + SIZE_IP6, &ip_port->port, sizeof(uint16_t));
  ------------------
  |  |  225|      0|#define SIZE_IP6 16
  ------------------
  414|      0|        return size;
  415|      0|    }
  416|    944|}
dht_create_packet:
  423|    694|{
  424|    694|    uint8_t *encrypted = (uint8_t *)mem_balloc(mem, plain_length + CRYPTO_MAC_SIZE);
  ------------------
  |  |   61|    694|#define CRYPTO_MAC_SIZE                16
  ------------------
  425|    694|    uint8_t nonce[CRYPTO_NONCE_SIZE];
  426|       |
  427|    694|    if (encrypted == nullptr) {
  ------------------
  |  |   66|    694|#define nullptr NULL
  ------------------
  |  Branch (427:9): [True: 180, False: 514]
  ------------------
  428|    180|        return -1;
  429|    180|    }
  430|       |
  431|    514|    random_nonce(rng, nonce);
  432|       |
  433|    514|    const int encrypted_length = encrypt_data_symmetric(shared_key, nonce, plain, plain_length, encrypted);
  434|       |
  435|    514|    if (encrypted_length == -1) {
  ------------------
  |  Branch (435:9): [True: 0, False: 514]
  ------------------
  436|      0|        mem_delete(mem, encrypted);
  437|      0|        return -1;
  438|      0|    }
  439|       |
  440|    514|    if (length < 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + encrypted_length) {
  ------------------
  |  |   40|    514|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  if (length < 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + encrypted_length) {
  ------------------
  |  |   66|    514|#define CRYPTO_NONCE_SIZE              24
  ------------------
  |  Branch (440:9): [True: 0, False: 514]
  ------------------
  441|      0|        mem_delete(mem, encrypted);
  442|      0|        return -1;
  443|      0|    }
  444|       |
  445|    514|    packet[0] = type;
  446|    514|    memcpy(packet + 1, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    514|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  447|    514|    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   40|    514|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|    514|#define CRYPTO_NONCE_SIZE              24
  ------------------
  448|    514|    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, encrypted, encrypted_length);
  ------------------
  |  |   40|    514|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, encrypted, encrypted_length);
  ------------------
  |  |   66|    514|#define CRYPTO_NONCE_SIZE              24
  ------------------
  449|       |
  450|    514|    mem_delete(mem, encrypted);
  451|    514|    return 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + encrypted_length;
  ------------------
  |  |   40|    514|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  return 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + encrypted_length;
  ------------------
  |  |   66|    514|#define CRYPTO_NONCE_SIZE              24
  ------------------
  452|    514|}
unpack_ip_port:
  455|     30|{
  456|     30|    if (data == nullptr) {
  ------------------
  |  |   66|     30|#define nullptr NULL
  ------------------
  |  Branch (456:9): [True: 0, False: 30]
  ------------------
  457|      0|        return -1;
  458|      0|    }
  459|       |
  460|     30|    bool is_ipv4;
  461|     30|    Family host_family;
  462|       |
  463|     30|    if (data[0] == TOX_AF_INET) {
  ------------------
  |  |  207|     30|#define TOX_AF_INET 2
  ------------------
  |  Branch (463:9): [True: 14, False: 16]
  ------------------
  464|     14|        is_ipv4 = true;
  465|     14|        host_family = net_family_ipv4();
  466|     16|    } else if (data[0] == TOX_TCP_INET) {
  ------------------
  |  |  209|     16|#define TOX_TCP_INET 130
  ------------------
  |  Branch (466:16): [True: 3, False: 13]
  ------------------
  467|      3|        if (!tcp_enabled) {
  ------------------
  |  Branch (467:13): [True: 1, False: 2]
  ------------------
  468|      1|            return -1;
  469|      1|        }
  470|       |
  471|      2|        is_ipv4 = true;
  472|      2|        host_family = net_family_tcp_ipv4();
  473|     13|    } else if (data[0] == TOX_AF_INET6) {
  ------------------
  |  |  208|     13|#define TOX_AF_INET6 10
  ------------------
  |  Branch (473:16): [True: 6, False: 7]
  ------------------
  474|      6|        is_ipv4 = false;
  475|      6|        host_family = net_family_ipv6();
  476|      7|    } else if (data[0] == TOX_TCP_INET6) {
  ------------------
  |  |  210|      7|#define TOX_TCP_INET6 138
  ------------------
  |  Branch (476:16): [True: 2, False: 5]
  ------------------
  477|      2|        if (!tcp_enabled) {
  ------------------
  |  Branch (477:13): [True: 1, False: 1]
  ------------------
  478|      1|            return -1;
  479|      1|        }
  480|       |
  481|      1|        is_ipv4 = false;
  482|      1|        host_family = net_family_tcp_ipv6();
  483|      5|    } else {
  484|      5|        return -1;
  485|      5|    }
  486|       |
  487|     23|    *ip_port = empty_ip_port;
  488|       |
  489|     23|    if (is_ipv4) {
  ------------------
  |  Branch (489:9): [True: 16, False: 7]
  ------------------
  490|     16|        const uint32_t size = 1 + SIZE_IP4 + sizeof(uint16_t);
  ------------------
  |  |  224|     16|#define SIZE_IP4 4
  ------------------
  491|       |
  492|     16|        if (size > length) {
  ------------------
  |  Branch (492:13): [True: 2, False: 14]
  ------------------
  493|      2|            return -1;
  494|      2|        }
  495|       |
  496|     14|        ip_port->ip.family = host_family;
  497|     14|        memcpy(&ip_port->ip.ip.v4, data + 1, SIZE_IP4);
  ------------------
  |  |  224|     14|#define SIZE_IP4 4
  ------------------
  498|     14|        memcpy(&ip_port->port, data + 1 + SIZE_IP4, sizeof(uint16_t));
  ------------------
  |  |  224|     14|#define SIZE_IP4 4
  ------------------
  499|     14|        return size;
  500|     16|    } else {
  501|      7|        const uint32_t size = 1 + SIZE_IP6 + sizeof(uint16_t);
  ------------------
  |  |  225|      7|#define SIZE_IP6 16
  ------------------
  502|       |
  503|      7|        if (size > length) {
  ------------------
  |  Branch (503:13): [True: 3, False: 4]
  ------------------
  504|      3|            return -1;
  505|      3|        }
  506|       |
  507|      4|        ip_port->ip.family = host_family;
  508|      4|        memcpy(&ip_port->ip.ip.v6, data + 1, SIZE_IP6);
  ------------------
  |  |  225|      4|#define SIZE_IP6 16
  ------------------
  509|      4|        memcpy(&ip_port->port, data + 1 + SIZE_IP6, sizeof(uint16_t));
  ------------------
  |  |  225|      4|#define SIZE_IP6 16
  ------------------
  510|      4|        return size;
  511|      7|    }
  512|     23|}
pack_nodes:
  515|    842|{
  516|    842|    uint32_t packed_length = 0;
  517|       |
  518|  1.67k|    for (uint32_t i = 0; i < number && packed_length < length; ++i) {
  ------------------
  |  Branch (518:26): [True: 836, False: 842]
  |  Branch (518:40): [True: 836, False: 0]
  ------------------
  519|    836|        const int ipp_size = pack_ip_port(logger, data + packed_length, length - packed_length, &nodes[i].ip_port);
  520|       |
  521|    836|        if (ipp_size == -1) {
  ------------------
  |  Branch (521:13): [True: 0, False: 836]
  ------------------
  522|      0|            return -1;
  523|      0|        }
  524|       |
  525|    836|        packed_length += ipp_size;
  526|       |
  527|    836|        if (packed_length + CRYPTO_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |   40|    836|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (527:13): [True: 0, False: 836]
  ------------------
  528|      0|            return -1;
  529|      0|        }
  530|       |
  531|    836|        memcpy(data + packed_length, nodes[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    836|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  532|    836|        packed_length += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|    836|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  533|       |
  534|    836|#ifndef NDEBUG
  535|    836|        const uint32_t increment = ipp_size + CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|    836|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  536|    836|        assert(increment == PACKED_NODE_SIZE_IP4 || increment == PACKED_NODE_SIZE_IP6);
  537|    836|#endif
  538|    836|    }
  539|       |
  540|    842|    return packed_length;
  541|    842|}
unpack_nodes:
  545|     18|{
  546|     18|    uint32_t num = 0;
  547|     18|    uint32_t len_processed = 0;
  548|       |
  549|     26|    while (num < max_num_nodes && len_processed < length) {
  ------------------
  |  Branch (549:12): [True: 17, False: 9]
  |  Branch (549:35): [True: 16, False: 1]
  ------------------
  550|     16|        const int ipp_size = unpack_ip_port(&nodes[num].ip_port, data + len_processed, length - len_processed, tcp_enabled);
  551|       |
  552|     16|        if (ipp_size == -1) {
  ------------------
  |  Branch (552:13): [True: 6, False: 10]
  ------------------
  553|      6|            return -1;
  554|      6|        }
  555|       |
  556|     10|        len_processed += ipp_size;
  557|       |
  558|     10|        if (len_processed + CRYPTO_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |   40|     10|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (558:13): [True: 2, False: 8]
  ------------------
  559|      2|            return -1;
  560|      2|        }
  561|       |
  562|      8|        memcpy(nodes[num].public_key, data + len_processed, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      8|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  563|      8|        len_processed += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|      8|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  564|      8|        ++num;
  565|       |
  566|      8|#ifndef NDEBUG
  567|      8|        const uint32_t increment = ipp_size + CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|      8|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  568|      8|        assert(increment == PACKED_NODE_SIZE_IP4 || increment == PACKED_NODE_SIZE_IP6);
  569|      8|#endif
  570|      8|    }
  571|       |
  572|     10|    if (processed_data_len != nullptr) {
  ------------------
  |  |   66|     10|#define nullptr NULL
  ------------------
  |  Branch (572:9): [True: 5, False: 5]
  ------------------
  573|      5|        *processed_data_len = len_processed;
  574|      5|    }
  575|       |
  576|     10|    return num;
  577|     18|}
get_close_nodes:
  848|  1.92k|{
  849|  1.92k|    memset(nodes_list, 0, MAX_SENT_NODES * sizeof(Node_format));
  ------------------
  |  |   54|  1.92k|#define MAX_SENT_NODES 4
  ------------------
  850|  1.92k|    return get_somewhat_close_nodes(dht, public_key, nodes_list, sa_family,
  851|  1.92k|                                    is_lan, want_announce);
  852|  1.92k|}
node_addable_to_close_list:
 1151|    414|{
 1152|    414|    return add_to_close(dht, public_key, ip_port, true);
 1153|    414|}
dht_getnodes:
 1365|    836|{
 1366|       |    /* Check if packet is going to be sent to ourself. */
 1367|    836|    if (pk_equal(public_key, dht->self_public_key)) {
  ------------------
  |  Branch (1367:9): [True: 0, False: 836]
  ------------------
 1368|      0|        return false;
 1369|      0|    }
 1370|       |
 1371|    836|    uint8_t plain_message[sizeof(Node_format) * 2] = {0};
 1372|       |
 1373|    836|    Node_format receiver;
 1374|    836|    memcpy(receiver.public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    836|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1375|    836|    receiver.ip_port = *ip_port;
 1376|       |
 1377|    836|    if (pack_nodes(dht->log, plain_message, sizeof(plain_message), &receiver, 1) == -1) {
  ------------------
  |  Branch (1377:9): [True: 0, False: 836]
  ------------------
 1378|      0|        return false;
 1379|      0|    }
 1380|       |
 1381|    836|    uint64_t ping_id = 0;
 1382|       |
 1383|    836|    ping_id = ping_array_add(dht->dht_ping_array, dht->mono_time, dht->rng, plain_message, sizeof(receiver));
 1384|       |
 1385|    836|    if (ping_id == 0) {
  ------------------
  |  Branch (1385:9): [True: 151, False: 685]
  ------------------
 1386|    151|        LOGGER_ERROR(dht->log, "adding ping id failed");
  ------------------
  |  |   83|    151|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    151|    do {                                                                         \
  |  |  |  |   73|    151|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    302|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    151|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    151|        }                                                                        \
  |  |  |  |   76|    151|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1387|    151|        return false;
 1388|    151|    }
 1389|       |
 1390|    685|    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + sizeof(ping_id)];
 1391|    685|    uint8_t data[1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE];
 1392|       |
 1393|    685|    memcpy(plain, client_id, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    685|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1394|    685|    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, &ping_id, sizeof(ping_id));
  ------------------
  |  |   40|    685|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1395|       |
 1396|    685|    const uint8_t *shared_key = dht_get_shared_key_sent(dht, public_key);
 1397|       |
 1398|    685|    const int len = dht_create_packet(dht->mem, dht->rng,
 1399|    685|                                      dht->self_public_key, shared_key, NET_PACKET_GET_NODES,
 1400|    685|                                      plain, sizeof(plain), data, sizeof(data));
 1401|       |
 1402|    685|    if (len != sizeof(data)) {
  ------------------
  |  Branch (1402:9): [True: 180, False: 505]
  ------------------
 1403|    180|        LOGGER_ERROR(dht->log, "getnodes packet encryption failed");
  ------------------
  |  |   83|    180|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    180|    do {                                                                         \
  |  |  |  |   73|    180|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    360|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    180|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    180|        }                                                                        \
  |  |  |  |   76|    180|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1404|    180|        return false;
 1405|    180|    }
 1406|       |
 1407|    505|    return sendpacket(dht->net, ip_port, data, len) > 0;
 1408|    685|}
dht_addfriend:
 1673|  1.90k|{
 1674|  1.90k|    const uint32_t friend_num = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);
 1675|       |
 1676|  1.90k|    if (friend_num != UINT32_MAX) { /* Is friend already in DHT? */
  ------------------
  |  Branch (1676:9): [True: 4, False: 1.90k]
  ------------------
 1677|      4|        DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
 1678|      4|        const uint32_t tmp_lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1679|       |
 1680|      4|        if (tmp_lock_token == 0) {
  ------------------
  |  Branch (1680:13): [True: 0, False: 4]
  ------------------
 1681|      0|            return -1;
 1682|      0|        }
 1683|       |
 1684|      4|        return 0;
 1685|      4|    }
 1686|       |
 1687|  1.90k|    DHT_Friend *const temp = (DHT_Friend *)mem_vrealloc(dht->mem, dht->friends_list, dht->num_friends + 1, sizeof(DHT_Friend));
 1688|       |
 1689|  1.90k|    if (temp == nullptr) {
  ------------------
  |  |   66|  1.90k|#define nullptr NULL
  ------------------
  |  Branch (1689:9): [True: 2, False: 1.90k]
  ------------------
 1690|      2|        return -1;
 1691|      2|    }
 1692|       |
 1693|  1.90k|    dht->friends_list = temp;
 1694|  1.90k|    DHT_Friend *const dht_friend = &dht->friends_list[dht->num_friends];
 1695|  1.90k|    *dht_friend = empty_dht_friend;
 1696|  1.90k|    memcpy(dht_friend->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|  1.90k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1697|       |
 1698|  1.90k|    dht_friend->nat.nat_ping_id = random_u64(dht->rng);
 1699|  1.90k|    ++dht->num_friends;
 1700|       |
 1701|  1.90k|    *lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1702|  1.90k|    assert(*lock_token != 0); // Friend was newly allocated
 1703|       |
 1704|      0|    dht_friend->num_to_bootstrap = get_close_nodes(dht, dht_friend->public_key, dht_friend->to_bootstrap, net_family_unspec(),
 1705|  1.90k|                                   true, false);
 1706|       |
 1707|  1.90k|    return 0;
 1708|  1.90k|}
dht_delfriend:
 1711|      1|{
 1712|      1|    const uint32_t friend_num = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);
 1713|       |
 1714|      1|    if (friend_num == UINT32_MAX) {
  ------------------
  |  Branch (1714:9): [True: 0, False: 1]
  ------------------
 1715|      0|        return -1;
 1716|      0|    }
 1717|       |
 1718|      1|    DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
 1719|      1|    dht_friend_unlock(dht_friend, lock_token);
 1720|      1|    if (dht_friend->lock_flags > 0) {
  ------------------
  |  Branch (1720:9): [True: 0, False: 1]
  ------------------
 1721|       |        /* DHT friend is still in use.*/
 1722|      0|        return 0;
 1723|      0|    }
 1724|       |
 1725|      1|    --dht->num_friends;
 1726|       |
 1727|      1|    if (dht->num_friends != friend_num) {
  ------------------
  |  Branch (1727:9): [True: 0, False: 1]
  ------------------
 1728|      0|        dht->friends_list[friend_num] = dht->friends_list[dht->num_friends];
 1729|      0|    }
 1730|       |
 1731|      1|    if (dht->num_friends == 0) {
  ------------------
  |  Branch (1731:9): [True: 0, False: 1]
  ------------------
 1732|      0|        mem_delete(dht->mem, dht->friends_list);
 1733|      0|        dht->friends_list = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1734|      0|        return 0;
 1735|      0|    }
 1736|       |
 1737|      1|    DHT_Friend *const temp = (DHT_Friend *)mem_vrealloc(dht->mem, dht->friends_list, dht->num_friends, sizeof(DHT_Friend));
 1738|       |
 1739|      1|    if (temp == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1739:9): [True: 0, False: 1]
  ------------------
 1740|      0|        return -1;
 1741|      0|    }
 1742|       |
 1743|      1|    dht->friends_list = temp;
 1744|      1|    return 0;
 1745|      1|}
dht_getfriendip:
 1749|    295|{
 1750|    295|    ip_reset(&ip_port->ip);
 1751|    295|    ip_port->port = 0;
 1752|       |
 1753|    295|    const uint32_t friend_index = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);
 1754|       |
 1755|    295|    if (friend_index == UINT32_MAX) {
  ------------------
  |  Branch (1755:9): [True: 293, False: 2]
  ------------------
 1756|    293|        return -1;
 1757|    293|    }
 1758|       |
 1759|      2|    const DHT_Friend *const frnd = &dht->friends_list[friend_index];
 1760|      2|    const uint32_t client_index = index_of_client_pk(frnd->client_list, MAX_FRIEND_CLIENTS, public_key);
  ------------------
  |  |   43|      2|#define MAX_FRIEND_CLIENTS 8
  ------------------
 1761|       |
 1762|      2|    if (client_index == UINT32_MAX) {
  ------------------
  |  Branch (1762:9): [True: 2, False: 0]
  ------------------
 1763|      2|        return 0;
 1764|      2|    }
 1765|       |
 1766|      0|    const Client_data *const client = &frnd->client_list[client_index];
 1767|      0|    const IPPTsPng *const assocs[] = { &client->assoc6, &client->assoc4, nullptr };
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1768|       |
 1769|      0|    for (const IPPTsPng * const *it = assocs; *it != nullptr; ++it) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1769:47): [True: 0, False: 0]
  ------------------
 1770|      0|        const IPPTsPng *const assoc = *it;
 1771|       |
 1772|      0|        if (!assoc_timeout(dht->cur_time, assoc)) {
  ------------------
  |  Branch (1772:13): [True: 0, False: 0]
  ------------------
 1773|      0|            *ip_port = assoc->ip_port;
 1774|      0|            return 1;
 1775|      0|        }
 1776|      0|    }
 1777|       |
 1778|      0|    return -1;
 1779|      0|}
dht_bootstrap:
 1927|    837|{
 1928|    837|    if (pk_equal(public_key, dht->self_public_key)) {
  ------------------
  |  Branch (1928:9): [True: 1, False: 836]
  ------------------
 1929|       |        // Bootstrapping off ourselves is ok (onion paths are still set up).
 1930|      1|        return true;
 1931|      1|    }
 1932|       |
 1933|    836|    return dht_getnodes(dht, ip_port, public_key, dht->self_public_key);
 1934|    837|}
route_packet:
 1967|     69|{
 1968|  68.6k|    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
  ------------------
  |  |   49|  68.6k|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   46|  68.6k|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   45|  68.6k|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|  68.6k|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1968:26): [True: 68.6k, False: 67]
  ------------------
 1969|  68.6k|        if (pk_equal(public_key, dht->close_clientlist[i].public_key)) {
  ------------------
  |  Branch (1969:13): [True: 2, False: 68.6k]
  ------------------
 1970|      2|            const Client_data *const client = &dht->close_clientlist[i];
 1971|      2|            const IPPTsPng *const assocs[] = { &client->assoc6, &client->assoc4, nullptr };
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
 1972|       |
 1973|      6|            for (const IPPTsPng * const *it = assocs; *it != nullptr; ++it) {
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  |  Branch (1973:55): [True: 4, False: 2]
  ------------------
 1974|      4|                const IPPTsPng *const assoc = *it;
 1975|       |
 1976|      4|                if (ip_isset(&assoc->ip_port.ip)) {
  ------------------
  |  Branch (1976:21): [True: 0, False: 4]
  ------------------
 1977|      0|                    return sendpacket(dht->net, &assoc->ip_port, packet, length);
 1978|      0|                }
 1979|      4|            }
 1980|       |
 1981|      2|            break;
 1982|      2|        }
 1983|  68.6k|    }
 1984|       |
 1985|     69|    return -1;
 1986|     69|}
randfriends_nodes:
 2496|  14.7k|{
 2497|  14.7k|    if (max_num == 0) {
  ------------------
  |  Branch (2497:9): [True: 0, False: 14.7k]
  ------------------
 2498|      0|        return 0;
 2499|      0|    }
 2500|       |
 2501|  14.7k|    uint16_t count = 0;
 2502|  14.7k|    const uint32_t r = random_u32(dht->rng);
 2503|       |
 2504|  14.7k|    assert(DHT_FAKE_FRIEND_NUMBER <= dht->num_friends);
 2505|       |
 2506|       |    // Only gather nodes from the initial 2 fake friends.
 2507|  44.2k|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
  ------------------
  |  |   75|  44.2k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2507:26): [True: 29.5k, False: 14.7k]
  ------------------
 2508|  29.5k|        count += list_nodes(dht->rng, dht->friends_list[(i + r) % DHT_FAKE_FRIEND_NUMBER].client_list,
  ------------------
  |  |   75|  29.5k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
 2509|  29.5k|                            MAX_FRIEND_CLIENTS, dht->cur_time,
  ------------------
  |  |   43|  29.5k|#define MAX_FRIEND_CLIENTS 8
  ------------------
 2510|  29.5k|                            nodes + count, max_num - count);
 2511|       |
 2512|  29.5k|        if (count >= max_num) {
  ------------------
  |  Branch (2512:13): [True: 0, False: 29.5k]
  ------------------
 2513|      0|            break;
 2514|      0|        }
 2515|  29.5k|    }
 2516|       |
 2517|  14.7k|    return count;
 2518|  14.7k|}
cryptopacket_registerhandler:
 2532|  3.80k|{
 2533|  3.80k|    dht->cryptopackethandlers[byte].function = cb;
 2534|  3.80k|    dht->cryptopackethandlers[byte].object = object;
 2535|  3.80k|}
dht_callback_get_nodes_response:
 2582|    933|{
 2583|    933|    dht->get_nodes_response = function;
 2584|    933|}
new_dht:
 2613|    962|{
 2614|    962|    if (net == nullptr) {
  ------------------
  |  |   66|    962|#define nullptr NULL
  ------------------
  |  Branch (2614:9): [True: 0, False: 962]
  ------------------
 2615|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2616|      0|    }
 2617|       |
 2618|    962|    DHT *const dht = (DHT *)mem_alloc(mem, sizeof(DHT));
 2619|       |
 2620|    962|    if (dht == nullptr) {
  ------------------
  |  |   66|    962|#define nullptr NULL
  ------------------
  |  Branch (2620:9): [True: 1, False: 961]
  ------------------
 2621|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 2622|      1|    }
 2623|       |
 2624|    961|    dht->ns = ns;
 2625|    961|    dht->mono_time = mono_time;
 2626|    961|    dht->cur_time = mono_time_get(mono_time);
 2627|    961|    dht->log = log;
 2628|    961|    dht->net = net;
 2629|    961|    dht->rng = rng;
 2630|    961|    dht->mem = mem;
 2631|       |
 2632|    961|    dht->hole_punching_enabled = hole_punching_enabled;
 2633|    961|    dht->lan_discovery_enabled = lan_discovery_enabled;
 2634|       |
 2635|    961|    dht->ping = ping_new(mem, mono_time, rng, dht);
 2636|       |
 2637|    961|    if (dht->ping == nullptr) {
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
  |  Branch (2637:9): [True: 2, False: 959]
  ------------------
 2638|      2|        kill_dht(dht);
 2639|      2|        return nullptr;
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
 2640|      2|    }
 2641|       |
 2642|    959|    networking_registerhandler(dht->net, NET_PACKET_GET_NODES, &handle_getnodes, dht);
 2643|    959|    networking_registerhandler(dht->net, NET_PACKET_SEND_NODES_IPV6, &handle_sendnodes_ipv6, dht);
 2644|    959|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, &cryptopacket_handle, dht);
 2645|    959|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, &handle_lan_discovery, dht);
 2646|    959|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, &handle_nat_ping, dht);
  ------------------
  |  |   82|    959|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
 2647|       |
 2648|    959|#ifdef CHECK_ANNOUNCE_NODE
 2649|    959|    networking_registerhandler(dht->net, NET_PACKET_DATA_SEARCH_RESPONSE, &handle_data_search_response, dht);
 2650|    959|#endif
 2651|       |
 2652|    959|    crypto_new_keypair(rng, dht->self_public_key, dht->self_secret_key);
 2653|       |
 2654|    959|    dht->shared_keys_recv = shared_key_cache_new(mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   52|    959|#define KEYS_TIMEOUT 600
  ------------------
                  dht->shared_keys_recv = shared_key_cache_new(mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   51|    959|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2655|    959|    dht->shared_keys_sent = shared_key_cache_new(mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   52|    959|#define KEYS_TIMEOUT 600
  ------------------
                  dht->shared_keys_sent = shared_key_cache_new(mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   51|    959|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2656|       |
 2657|    959|    if (dht->shared_keys_recv == nullptr || dht->shared_keys_sent == nullptr) {
  ------------------
  |  |   66|  1.91k|#define nullptr NULL
  ------------------
                  if (dht->shared_keys_recv == nullptr || dht->shared_keys_sent == nullptr) {
  ------------------
  |  |   66|    956|#define nullptr NULL
  ------------------
  |  Branch (2657:9): [True: 3, False: 956]
  |  Branch (2657:45): [True: 1, False: 955]
  ------------------
 2658|      4|        kill_dht(dht);
 2659|      4|        return nullptr;
  ------------------
  |  |   66|      4|#define nullptr NULL
  ------------------
 2660|      4|    }
 2661|       |
 2662|       |
 2663|    955|    dht->dht_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   60|    955|#define DHT_PING_ARRAY_SIZE 512
  ------------------
                  dht->dht_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   57|    955|#define PING_TIMEOUT 5
  ------------------
 2664|       |
 2665|    955|    if (dht->dht_ping_array == nullptr) {
  ------------------
  |  |   66|    955|#define nullptr NULL
  ------------------
  |  Branch (2665:9): [True: 1, False: 954]
  ------------------
 2666|      1|        kill_dht(dht);
 2667|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 2668|      1|    }
 2669|       |
 2670|  2.85k|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
  ------------------
  |  |   75|  2.85k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2670:26): [True: 1.90k, False: 952]
  ------------------
 2671|  1.90k|        uint8_t random_public_key_bytes[CRYPTO_PUBLIC_KEY_SIZE];
 2672|  1.90k|        uint8_t random_secret_key_bytes[CRYPTO_SECRET_KEY_SIZE];
 2673|       |
 2674|  1.90k|        crypto_new_keypair(rng, random_public_key_bytes, random_secret_key_bytes);
 2675|       |
 2676|  1.90k|        uint32_t token; // We don't intend to delete these ever, but need to pass the token
 2677|  1.90k|        if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   66|  1.90k|#define nullptr NULL
  ------------------
                      if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   66|  1.90k|#define nullptr NULL
  ------------------
  |  Branch (2677:13): [True: 2, False: 1.90k]
  ------------------
 2678|      2|            kill_dht(dht);
 2679|      2|            return nullptr;
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
 2680|      2|        }
 2681|  1.90k|    }
 2682|       |
 2683|    952|    if (dht->num_friends != DHT_FAKE_FRIEND_NUMBER) {
  ------------------
  |  |   75|    952|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2683:9): [True: 4, False: 948]
  ------------------
 2684|      4|        LOGGER_ERROR(log, "the RNG provided seems to be broken: it generated the same keypair twice");
  ------------------
  |  |   83|      4|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      4|    do {                                                                         \
  |  |  |  |   73|      4|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      8|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      4|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      4|        }                                                                        \
  |  |  |  |   76|      4|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2685|      4|        kill_dht(dht);
 2686|      4|        return nullptr;
  ------------------
  |  |   66|      4|#define nullptr NULL
  ------------------
 2687|      4|    }
 2688|       |
 2689|    948|    return dht;
 2690|    952|}
do_dht:
 2693|  12.0k|{
 2694|  12.0k|    const uint64_t cur_time = mono_time_get(dht->mono_time);
 2695|       |
 2696|  12.0k|    if (dht->cur_time == cur_time) {
  ------------------
  |  Branch (2696:9): [True: 9.77k, False: 2.26k]
  ------------------
 2697|  9.77k|        return;
 2698|  9.77k|    }
 2699|       |
 2700|  2.26k|    dht->cur_time = cur_time;
 2701|       |
 2702|       |    // Load friends/clients if first call to do_dht
 2703|  2.26k|    if (dht->loaded_num_nodes > 0) {
  ------------------
  |  Branch (2703:9): [True: 0, False: 2.26k]
  ------------------
 2704|      0|        dht_connect_after_load(dht);
 2705|      0|    }
 2706|       |
 2707|  2.26k|    do_close(dht);
 2708|  2.26k|    do_dht_friends(dht);
 2709|  2.26k|    do_nat(dht);
 2710|  2.26k|    ping_iterate(dht->ping);
 2711|  2.26k|}
kill_dht:
 2714|    961|{
 2715|    961|    if (dht == nullptr) {
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
  |  Branch (2715:9): [True: 0, False: 961]
  ------------------
 2716|      0|        return;
 2717|      0|    }
 2718|       |
 2719|    961|    networking_registerhandler(dht->net, NET_PACKET_GET_NODES, nullptr, nullptr);
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_GET_NODES, nullptr, nullptr);
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
 2720|    961|    networking_registerhandler(dht->net, NET_PACKET_SEND_NODES_IPV6, nullptr, nullptr);
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_SEND_NODES_IPV6, nullptr, nullptr);
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
 2721|    961|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
 2722|    961|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
 2723|    961|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   82|    961|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
 2724|       |
 2725|    961|    shared_key_cache_free(dht->shared_keys_recv);
 2726|    961|    shared_key_cache_free(dht->shared_keys_sent);
 2727|    961|    ping_array_kill(dht->dht_ping_array);
 2728|    961|    ping_kill(dht->mem, dht->ping);
 2729|    961|    mem_delete(dht->mem, dht->friends_list);
 2730|    961|    mem_delete(dht->mem, dht->loaded_nodes_list);
 2731|    961|    crypto_memzero(dht->self_secret_key, sizeof(dht->self_secret_key));
 2732|    961|    mem_delete(dht->mem, dht);
 2733|    961|}
dht_non_lan_connected:
 2950|  15.2k|{
 2951|  15.6M|    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
  ------------------
  |  |   49|  15.6M|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   46|  15.6M|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   45|  15.6M|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|  15.6M|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2951:26): [True: 15.6M, False: 15.2k]
  ------------------
 2952|  15.6M|        const Client_data *const client = &dht->close_clientlist[i];
 2953|       |
 2954|  15.6M|        if (!assoc_timeout(dht->cur_time, &client->assoc4)
  ------------------
  |  Branch (2954:13): [True: 0, False: 15.6M]
  ------------------
 2955|  15.6M|                && !ip_is_lan(&client->assoc4.ip_port.ip)) {
  ------------------
  |  Branch (2955:20): [True: 0, False: 0]
  ------------------
 2956|      0|            return true;
 2957|      0|        }
 2958|       |
 2959|  15.6M|        if (!assoc_timeout(dht->cur_time, &client->assoc6)
  ------------------
  |  Branch (2959:13): [True: 0, False: 15.6M]
  ------------------
 2960|  15.6M|                && !ip_is_lan(&client->assoc6.ip_port.ip)) {
  ------------------
  |  Branch (2960:20): [True: 0, False: 0]
  ------------------
 2961|      0|            return true;
 2962|      0|        }
 2963|  15.6M|    }
 2964|       |
 2965|  15.2k|    return false;
 2966|  15.2k|}
DHT.c:get_somewhat_close_nodes:
  832|  1.92k|{
  833|  1.92k|    uint32_t num_nodes = 0;
  834|  1.92k|    get_close_nodes_inner(dht->cur_time, public_key, nodes_list, sa_family,
  835|  1.92k|                          dht->close_clientlist, LCLIENT_LIST, &num_nodes, is_lan, want_announce);
  ------------------
  |  |   49|  1.92k|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   46|  1.92k|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   45|  1.92k|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|  1.92k|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  836|       |
  837|  4.83k|    for (uint32_t i = 0; i < dht->num_friends; ++i) {
  ------------------
  |  Branch (837:26): [True: 2.90k, False: 1.92k]
  ------------------
  838|  2.90k|        get_close_nodes_inner(dht->cur_time, public_key, nodes_list, sa_family,
  839|  2.90k|                              dht->friends_list[i].client_list, MAX_FRIEND_CLIENTS,
  ------------------
  |  |   43|  2.90k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  840|  2.90k|                              &num_nodes, is_lan, want_announce);
  841|  2.90k|    }
  842|       |
  843|  1.92k|    return num_nodes;
  844|  1.92k|}
DHT.c:get_close_nodes_inner:
  764|  4.83k|{
  765|  4.83k|    if (!net_family_is_ipv4(sa_family) && !net_family_is_ipv6(sa_family) && !net_family_is_unspec(sa_family)) {
  ------------------
  |  Branch (765:9): [True: 4.83k, False: 0]
  |  Branch (765:43): [True: 4.83k, False: 0]
  |  Branch (765:77): [True: 0, False: 4.83k]
  ------------------
  766|      0|        return;
  767|      0|    }
  768|       |
  769|  4.83k|    uint32_t num_nodes = *num_nodes_ptr;
  770|       |
  771|  2.00M|    for (uint32_t i = 0; i < client_list_length; ++i) {
  ------------------
  |  Branch (771:26): [True: 1.99M, False: 4.83k]
  ------------------
  772|  1.99M|        const Client_data *const client = &client_list[i];
  773|       |
  774|       |        /* node already in list? */
  775|  1.99M|        if (index_of_node_pk(nodes_list, MAX_SENT_NODES, client->public_key) != UINT32_MAX) {
  ------------------
  |  |   54|  1.99M|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (775:13): [True: 1.99M, False: 0]
  ------------------
  776|  1.99M|            continue;
  777|  1.99M|        }
  778|       |
  779|      0|        const IPPTsPng *ipptp;
  780|       |
  781|      0|        if (net_family_is_ipv4(sa_family)) {
  ------------------
  |  Branch (781:13): [True: 0, False: 0]
  ------------------
  782|      0|            ipptp = &client->assoc4;
  783|      0|        } else if (net_family_is_ipv6(sa_family)) {
  ------------------
  |  Branch (783:20): [True: 0, False: 0]
  ------------------
  784|      0|            ipptp = &client->assoc6;
  785|      0|        } else if (client->assoc4.timestamp >= client->assoc6.timestamp) {
  ------------------
  |  Branch (785:20): [True: 0, False: 0]
  ------------------
  786|      0|            ipptp = &client->assoc4;
  787|      0|        } else {
  788|      0|            ipptp = &client->assoc6;
  789|      0|        }
  790|       |
  791|       |        /* node not in a good condition? */
  792|      0|        if (assoc_timeout(cur_time, ipptp)) {
  ------------------
  |  Branch (792:13): [True: 0, False: 0]
  ------------------
  793|      0|            continue;
  794|      0|        }
  795|       |
  796|       |        /* don't send LAN ips to non LAN peers */
  797|      0|        if (ip_is_lan(&ipptp->ip_port.ip) && !is_lan) {
  ------------------
  |  Branch (797:13): [True: 0, False: 0]
  |  Branch (797:46): [True: 0, False: 0]
  ------------------
  798|      0|            continue;
  799|      0|        }
  800|       |
  801|      0|#ifdef CHECK_ANNOUNCE_NODE
  802|       |
  803|      0|        if (want_announce && !client->announce_node) {
  ------------------
  |  Branch (803:13): [True: 0, False: 0]
  |  Branch (803:30): [True: 0, False: 0]
  ------------------
  804|      0|            continue;
  805|      0|        }
  806|       |
  807|      0|#endif
  808|       |
  809|      0|        if (num_nodes < MAX_SENT_NODES) {
  ------------------
  |  |   54|      0|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (809:13): [True: 0, False: 0]
  ------------------
  810|      0|            memcpy(nodes_list[num_nodes].public_key, client->public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  811|      0|            nodes_list[num_nodes].ip_port = ipptp->ip_port;
  812|      0|            ++num_nodes;
  813|      0|        } else {
  814|       |            // TODO(zugz): this could be made significantly more efficient by
  815|       |            // using a version of add_to_list which works with a sorted list.
  816|      0|            add_to_list(nodes_list, MAX_SENT_NODES, client->public_key, &ipptp->ip_port, public_key);
  ------------------
  |  |   54|      0|#define MAX_SENT_NODES 4
  ------------------
  817|      0|        }
  818|      0|    }
  819|       |
  820|  4.83k|    *num_nodes_ptr = num_nodes;
  821|  4.83k|}
DHT.c:index_of_node_pk:
  613|  1.99M|{
  614|  1.99M|    assert(size == 0 || array != nullptr);
  615|       |
  616|  1.99M|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (616:26): [True: 1.99M, False: 0]
  ------------------
  617|  1.99M|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (617:13): [True: 1.99M, False: 0]
  ------------------
  618|  1.99M|            return i;
  619|  1.99M|        }
  620|  1.99M|    }
  621|       |
  622|      0|    return UINT32_MAX;
  623|  1.99M|}
DHT.c:add_to_close:
 1116|    414|{
 1117|    414|    unsigned int index = bit_by_bit_cmp(public_key, dht->self_public_key);
 1118|       |
 1119|    414|    if (index >= LCLIENT_LENGTH) {
  ------------------
  |  |   46|    414|#define LCLIENT_LENGTH 128
  ------------------
  |  Branch (1119:9): [True: 10, False: 404]
  ------------------
 1120|     10|        index = LCLIENT_LENGTH - 1;
  ------------------
  |  |   46|     10|#define LCLIENT_LENGTH 128
  ------------------
 1121|     10|    }
 1122|       |
 1123|    414|    for (uint32_t i = 0; i < LCLIENT_NODES; ++i) {
  ------------------
  |  |   45|    414|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  ------------------
  |  |  |  |   43|    414|#define MAX_FRIEND_CLIENTS 8
  |  |  ------------------
  ------------------
  |  Branch (1123:26): [True: 414, False: 0]
  ------------------
 1124|       |        /* TODO(iphydf): write bounds checking test to catch the case that
 1125|       |         * index is left as >= LCLIENT_LENGTH */
 1126|    414|        Client_data *const client = &dht->close_clientlist[(index * LCLIENT_NODES) + i];
  ------------------
  |  |   45|    414|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  ------------------
  |  |  |  |   43|    414|#define MAX_FRIEND_CLIENTS 8
  |  |  ------------------
  ------------------
 1127|       |
 1128|    414|        if (!assoc_timeout(dht->cur_time, &client->assoc4) ||
  ------------------
  |  Branch (1128:13): [True: 0, False: 414]
  ------------------
 1129|    414|                !assoc_timeout(dht->cur_time, &client->assoc6)) {
  ------------------
  |  Branch (1129:17): [True: 0, False: 414]
  ------------------
 1130|      0|            continue;
 1131|      0|        }
 1132|       |
 1133|    414|        if (simulate) {
  ------------------
  |  Branch (1133:13): [True: 414, False: 0]
  ------------------
 1134|    414|            return true;
 1135|    414|        }
 1136|       |
 1137|      0|        pk_copy(client->public_key, public_key);
 1138|      0|        update_client_with_reset(dht->mono_time, client, ip_port);
 1139|      0|#ifdef CHECK_ANNOUNCE_NODE
 1140|      0|        client->announce_node = false;
 1141|      0|        send_announce_ping(dht, public_key, ip_port);
 1142|      0|#endif
 1143|      0|        return true;
 1144|    414|    }
 1145|       |
 1146|      0|    return false;
 1147|    414|}
DHT.c:sort_client_list:
 1016|  4.39k|{
 1017|       |    // Pass comp_public_key to qsort with each Client_data entry, so the
 1018|       |    // comparison function can use it as the base of comparison.
 1019|  4.39k|    DHT_Cmp_Data *cmp_list = (DHT_Cmp_Data *)mem_valloc(mem, length, sizeof(DHT_Cmp_Data));
 1020|       |
 1021|  4.39k|    if (cmp_list == nullptr) {
  ------------------
  |  |   66|  4.39k|#define nullptr NULL
  ------------------
  |  Branch (1021:9): [True: 26, False: 4.37k]
  ------------------
 1022|     26|        return;
 1023|     26|    }
 1024|       |
 1025|  39.3k|    for (uint32_t i = 0; i < length; ++i) {
  ------------------
  |  Branch (1025:26): [True: 34.9k, False: 4.37k]
  ------------------
 1026|  34.9k|        cmp_list[i].cur_time = cur_time;
 1027|  34.9k|        cmp_list[i].base_public_key = comp_public_key;
 1028|  34.9k|        cmp_list[i].entry = list[i];
 1029|  34.9k|    }
 1030|       |
 1031|  4.37k|    qsort(cmp_list, length, sizeof(DHT_Cmp_Data), dht_cmp_entry);
 1032|       |
 1033|  39.3k|    for (uint32_t i = 0; i < length; ++i) {
  ------------------
  |  Branch (1033:26): [True: 34.9k, False: 4.37k]
  ------------------
 1034|  34.9k|        list[i] = cmp_list[i].entry;
 1035|  34.9k|    }
 1036|       |
 1037|  4.37k|    mem_delete(mem, cmp_list);
 1038|  4.37k|}
DHT.c:dht_cmp_entry:
  862|  52.4k|{
  863|  52.4k|    const DHT_Cmp_Data *cmp1 = (const DHT_Cmp_Data *)a;
  864|  52.4k|    const DHT_Cmp_Data *cmp2 = (const DHT_Cmp_Data *)b;
  865|  52.4k|    const Client_data entry1 = cmp1->entry;
  866|  52.4k|    const Client_data entry2 = cmp2->entry;
  867|  52.4k|    const uint8_t *cmp_public_key = cmp1->base_public_key;
  868|       |
  869|  52.4k|    const bool t1 = assoc_timeout(cmp1->cur_time, &entry1.assoc4) && assoc_timeout(cmp1->cur_time, &entry1.assoc6);
  ------------------
  |  Branch (869:21): [True: 52.4k, False: 0]
  |  Branch (869:70): [True: 52.4k, False: 0]
  ------------------
  870|  52.4k|    const bool t2 = assoc_timeout(cmp2->cur_time, &entry2.assoc4) && assoc_timeout(cmp2->cur_time, &entry2.assoc6);
  ------------------
  |  Branch (870:21): [True: 52.4k, False: 0]
  |  Branch (870:70): [True: 52.4k, False: 0]
  ------------------
  871|       |
  872|  52.4k|    if (t1 && t2) {
  ------------------
  |  Branch (872:9): [True: 52.4k, False: 0]
  |  Branch (872:15): [True: 52.4k, False: 0]
  ------------------
  873|  52.4k|        return 0;
  874|  52.4k|    }
  875|       |
  876|      0|    if (t1) {
  ------------------
  |  Branch (876:9): [True: 0, False: 0]
  ------------------
  877|      0|        return -1;
  878|      0|    }
  879|       |
  880|      0|    if (t2) {
  ------------------
  |  Branch (880:9): [True: 0, False: 0]
  ------------------
  881|      0|        return 1;
  882|      0|    }
  883|       |
  884|      0|    const int closest = id_closest(cmp_public_key, entry1.public_key, entry2.public_key);
  885|       |
  886|      0|    if (closest == 1) {
  ------------------
  |  Branch (886:9): [True: 0, False: 0]
  ------------------
  887|      0|        return 1;
  888|      0|    }
  889|       |
  890|      0|    if (closest == 2) {
  ------------------
  |  Branch (890:9): [True: 0, False: 0]
  ------------------
  891|      0|        return -1;
  892|      0|    }
  893|       |
  894|      0|    return 0;
  895|      0|}
DHT.c:index_of_friend_pk:
  599|  2.20k|{
  600|  2.20k|    assert(size == 0 || array != nullptr);
  601|       |
  602|  3.75k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (602:26): [True: 1.55k, False: 2.19k]
  ------------------
  603|  1.55k|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (603:13): [True: 9, False: 1.54k]
  ------------------
  604|      9|            return i;
  605|      9|        }
  606|  1.55k|    }
  607|       |
  608|  2.19k|    return UINT32_MAX;
  609|  2.20k|}
DHT.c:dht_friend_lock:
 1618|  1.90k|{
 1619|       |    // find first free slot
 1620|  1.90k|    uint8_t lock_num;
 1621|  1.90k|    uint32_t lock_token = 0;
 1622|  1.91k|    for (lock_num = 0; lock_num < DHT_FRIEND_MAX_LOCKS; ++lock_num) {
  ------------------
  |  |   48|  1.91k|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1622:24): [True: 1.91k, False: 0]
  ------------------
 1623|  1.91k|        lock_token = UINT32_C(1) << lock_num;
 1624|  1.91k|        if ((dht_friend->lock_flags & lock_token) == 0) {
  ------------------
  |  Branch (1624:13): [True: 1.90k, False: 4]
  ------------------
 1625|  1.90k|            break;
 1626|  1.90k|        }
 1627|  1.91k|    }
 1628|       |
 1629|       |    // One of the conditions would be enough, but static analyzers don't get that
 1630|  1.90k|    if (lock_token == 0 || lock_num == DHT_FRIEND_MAX_LOCKS) {
  ------------------
  |  |   48|  1.90k|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1630:9): [True: 0, False: 1.90k]
  |  Branch (1630:28): [True: 0, False: 1.90k]
  ------------------
 1631|      0|        return 0;
 1632|      0|    }
 1633|       |
 1634|       |    // Claim that slot
 1635|  1.90k|    dht_friend->lock_flags |= lock_token;
 1636|       |
 1637|  1.90k|    dht_friend->callbacks[lock_num].ip_callback = ip_callback;
 1638|  1.90k|    dht_friend->callbacks[lock_num].data = data;
 1639|  1.90k|    dht_friend->callbacks[lock_num].number = number;
 1640|       |
 1641|  1.90k|    return lock_token;
 1642|  1.90k|}
DHT.c:dht_friend_unlock:
 1646|      1|{
 1647|       |    // If this triggers, there was a double free
 1648|      1|    assert((lock_token & dht_friend->lock_flags) > 0);
 1649|       |
 1650|       |    // find used slot
 1651|      0|    uint8_t lock_num;
 1652|      1|    for (lock_num = 0; lock_num < DHT_FRIEND_MAX_LOCKS; ++lock_num) {
  ------------------
  |  |   48|      1|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1652:24): [True: 1, False: 0]
  ------------------
 1653|      1|        if (((UINT32_C(1) << lock_num) & lock_token) > 0) {
  ------------------
  |  Branch (1653:13): [True: 1, False: 0]
  ------------------
 1654|      1|            break;
 1655|      1|        }
 1656|      1|    }
 1657|       |
 1658|      1|    if (lock_num == DHT_FRIEND_MAX_LOCKS) {
  ------------------
  |  |   48|      1|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1658:9): [True: 0, False: 1]
  ------------------
 1659|       |        // Gracefully handle double unlock
 1660|      0|        return;
 1661|      0|    }
 1662|       |
 1663|       |    // Clear the slot
 1664|      1|    dht_friend->lock_flags &= ~lock_token;
 1665|       |
 1666|      1|    dht_friend->callbacks[lock_num].ip_callback = nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 1667|      1|    dht_friend->callbacks[lock_num].data = nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 1668|      1|    dht_friend->callbacks[lock_num].number = 0;
 1669|      1|}
DHT.c:index_of_client_pk:
  585|      2|{
  586|      2|    assert(size == 0 || array != nullptr);
  587|       |
  588|     18|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (588:26): [True: 16, False: 2]
  ------------------
  589|     16|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (589:13): [True: 0, False: 16]
  ------------------
  590|      0|            return i;
  591|      0|        }
  592|     16|    }
  593|       |
  594|      2|    return UINT32_MAX;
  595|      2|}
DHT.c:assoc_timeout:
  194|  31.9M|{
  195|  31.9M|    return (assoc->timestamp + BAD_NODE_TIMEOUT) <= cur_time;
  ------------------
  |  |   68|  31.9M|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   63|  31.9M|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   66|  31.9M|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   63|  31.9M|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   67|  31.9M|#define PING_ROUNDTRIP 2
  |  |  ------------------
  ------------------
  196|  31.9M|}
DHT.c:friend_iplist:
 1998|  4.53k|{
 1999|  4.53k|    if (friend_num >= dht->num_friends) {
  ------------------
  |  Branch (1999:9): [True: 0, False: 4.53k]
  ------------------
 2000|      0|        return -1;
 2001|      0|    }
 2002|       |
 2003|  4.53k|    const DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
 2004|  4.53k|    IP_Port ipv4s[MAX_FRIEND_CLIENTS];
 2005|  4.53k|    int num_ipv4s = 0;
 2006|  4.53k|    IP_Port ipv6s[MAX_FRIEND_CLIENTS];
 2007|  4.53k|    int num_ipv6s = 0;
 2008|       |
 2009|  40.8k|    for (size_t i = 0; i < MAX_FRIEND_CLIENTS; ++i) {
  ------------------
  |  |   43|  40.8k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  |  Branch (2009:24): [True: 36.2k, False: 4.53k]
  ------------------
 2010|  36.2k|        const Client_data *const client = &dht_friend->client_list[i];
 2011|       |
 2012|       |        /* If ip is not zero and node is good. */
 2013|  36.2k|        if (ip_isset(&client->assoc4.ret_ip_port.ip)
  ------------------
  |  Branch (2013:13): [True: 0, False: 36.2k]
  ------------------
 2014|  36.2k|                && !mono_time_is_timeout(dht->mono_time, client->assoc4.ret_timestamp, BAD_NODE_TIMEOUT)) {
  ------------------
  |  |   68|      0|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   63|      0|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   66|      0|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   63|      0|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   67|      0|#define PING_ROUNDTRIP 2
  |  |  ------------------
  ------------------
  |  Branch (2014:20): [True: 0, False: 0]
  ------------------
 2015|      0|            ipv4s[num_ipv4s] = client->assoc4.ret_ip_port;
 2016|      0|            ++num_ipv4s;
 2017|      0|        }
 2018|       |
 2019|  36.2k|        if (ip_isset(&client->assoc6.ret_ip_port.ip)
  ------------------
  |  Branch (2019:13): [True: 0, False: 36.2k]
  ------------------
 2020|  36.2k|                && !mono_time_is_timeout(dht->mono_time, client->assoc6.ret_timestamp, BAD_NODE_TIMEOUT)) {
  ------------------
  |  |   68|      0|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   63|      0|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   66|      0|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   63|      0|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   67|      0|#define PING_ROUNDTRIP 2
  |  |  ------------------
  ------------------
  |  Branch (2020:20): [True: 0, False: 0]
  ------------------
 2021|      0|            ipv6s[num_ipv6s] = client->assoc6.ret_ip_port;
 2022|      0|            ++num_ipv6s;
 2023|      0|        }
 2024|       |
 2025|  36.2k|        if (pk_equal(client->public_key, dht_friend->public_key)) {
  ------------------
  |  Branch (2025:13): [True: 0, False: 36.2k]
  ------------------
 2026|      0|            if (!assoc_timeout(dht->cur_time, &client->assoc6)
  ------------------
  |  Branch (2026:17): [True: 0, False: 0]
  ------------------
 2027|      0|                    || !assoc_timeout(dht->cur_time, &client->assoc4)) {
  ------------------
  |  Branch (2027:24): [True: 0, False: 0]
  ------------------
 2028|      0|                return 0; /* direct connectivity */
 2029|      0|            }
 2030|      0|        }
 2031|  36.2k|    }
 2032|       |
 2033|       |#ifdef FRIEND_IPLIST_PAD
 2034|       |    memcpy(ip_portlist, ipv6s, num_ipv6s * sizeof(IP_Port));
 2035|       |
 2036|       |    if (num_ipv6s == MAX_FRIEND_CLIENTS) {
 2037|       |        return MAX_FRIEND_CLIENTS;
 2038|       |    }
 2039|       |
 2040|       |    int num_ipv4s_used = MAX_FRIEND_CLIENTS - num_ipv6s;
 2041|       |
 2042|       |    if (num_ipv4s_used > num_ipv4s) {
 2043|       |        num_ipv4s_used = num_ipv4s;
 2044|       |    }
 2045|       |
 2046|       |    memcpy(&ip_portlist[num_ipv6s], ipv4s, num_ipv4s_used * sizeof(IP_Port));
 2047|       |    return num_ipv6s + num_ipv4s_used;
 2048|       |
 2049|       |#else /* !FRIEND_IPLIST_PAD */
 2050|       |
 2051|       |    /* there must be some secret reason why we can't pad the longer list
 2052|       |     * with the shorter one...
 2053|       |     */
 2054|  4.53k|    if (num_ipv6s >= num_ipv4s) {
  ------------------
  |  Branch (2054:9): [True: 4.53k, False: 0]
  ------------------
 2055|  4.53k|        memcpy(ip_portlist, ipv6s, num_ipv6s * sizeof(IP_Port));
 2056|  4.53k|        return num_ipv6s;
 2057|  4.53k|    }
 2058|       |
 2059|      0|    memcpy(ip_portlist, ipv4s, num_ipv4s * sizeof(IP_Port));
 2060|      0|    return num_ipv4s;
 2061|       |
 2062|  4.53k|#endif /* !FRIEND_IPLIST_PAD */
 2063|  4.53k|}
DHT.c:list_nodes:
 2454|  29.5k|{
 2455|  29.5k|    if (max_num == 0) {
  ------------------
  |  Branch (2455:9): [True: 0, False: 29.5k]
  ------------------
 2456|      0|        return 0;
 2457|      0|    }
 2458|       |
 2459|  29.5k|    uint16_t count = 0;
 2460|       |
 2461|   265k|    for (size_t i = length; i != 0; --i) {
  ------------------
  |  Branch (2461:29): [True: 236k, False: 29.5k]
  ------------------
 2462|   236k|        const IPPTsPng *assoc = nullptr;
  ------------------
  |  |   66|   236k|#define nullptr NULL
  ------------------
 2463|       |
 2464|   236k|        if (!assoc_timeout(cur_time, &list[i - 1].assoc4)) {
  ------------------
  |  Branch (2464:13): [True: 0, False: 236k]
  ------------------
 2465|      0|            assoc = &list[i - 1].assoc4;
 2466|      0|        }
 2467|       |
 2468|   236k|        if (!assoc_timeout(cur_time, &list[i - 1].assoc6)) {
  ------------------
  |  Branch (2468:13): [True: 0, False: 236k]
  ------------------
 2469|      0|            if (assoc == nullptr || (random_u08(rng) % 2) != 0) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (2469:17): [True: 0, False: 0]
  |  Branch (2469:37): [True: 0, False: 0]
  ------------------
 2470|      0|                assoc = &list[i - 1].assoc6;
 2471|      0|            }
 2472|      0|        }
 2473|       |
 2474|   236k|        if (assoc != nullptr) {
  ------------------
  |  |   66|   236k|#define nullptr NULL
  ------------------
  |  Branch (2474:13): [True: 0, False: 236k]
  ------------------
 2475|      0|            memcpy(nodes[count].public_key, list[i - 1].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2476|      0|            nodes[count].ip_port = assoc->ip_port;
 2477|      0|            ++count;
 2478|       |
 2479|      0|            if (count >= max_num) {
  ------------------
  |  Branch (2479:17): [True: 0, False: 0]
  ------------------
 2480|      0|                return count;
 2481|      0|            }
 2482|      0|        }
 2483|   236k|    }
 2484|       |
 2485|  29.5k|    return count;
 2486|  29.5k|}
DHT.c:handle_getnodes:
 1463|     13|{
 1464|     13|    if (length != (CRYPTO_SIZE + CRYPTO_MAC_SIZE + sizeof(uint64_t))) {
  ------------------
  |  |  276|     13|#define CRYPTO_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   40|     13|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define CRYPTO_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   66|     13|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  ------------------
                  if (length != (CRYPTO_SIZE + CRYPTO_MAC_SIZE + sizeof(uint64_t))) {
  ------------------
  |  |   61|     13|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (1464:9): [True: 12, False: 1]
  ------------------
 1465|     12|        return 1;
 1466|     12|    }
 1467|       |
 1468|      1|    DHT *const dht = (DHT *)object;
 1469|       |
 1470|       |    /* Check if packet is from ourself. */
 1471|      1|    if (pk_equal(packet + 1, dht->self_public_key)) {
  ------------------
  |  Branch (1471:9): [True: 0, False: 1]
  ------------------
 1472|      0|        return 1;
 1473|      0|    }
 1474|       |
 1475|      1|    uint8_t plain[CRYPTO_NODE_SIZE];
 1476|      1|    const uint8_t *shared_key = dht_get_shared_key_recv(dht, packet + 1);
 1477|      1|    const int len = decrypt_data_symmetric(
 1478|      1|                        shared_key,
 1479|      1|                        packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1480|      1|                        packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                      packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
 1481|      1|                        CRYPTO_NODE_SIZE + CRYPTO_MAC_SIZE,
  ------------------
  |  | 1459|      1|#define CRYPTO_NODE_SIZE (CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint64_t))
  |  |  ------------------
  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
                                      CRYPTO_NODE_SIZE + CRYPTO_MAC_SIZE,
  ------------------
  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  ------------------
 1482|      1|                        plain);
 1483|       |
 1484|      1|    if (len != CRYPTO_NODE_SIZE) {
  ------------------
  |  | 1459|      1|#define CRYPTO_NODE_SIZE (CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint64_t))
  |  |  ------------------
  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (1484:9): [True: 0, False: 1]
  ------------------
 1485|      0|        return 1;
 1486|      0|    }
 1487|       |
 1488|      1|    sendnodes_ipv6(dht, source, packet + 1, plain, plain + CRYPTO_PUBLIC_KEY_SIZE, sizeof(uint64_t), shared_key);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1489|       |
 1490|      1|    ping_add(dht->ping, packet + 1, source);
 1491|       |
 1492|      1|    return 0;
 1493|      1|}
DHT.c:sendnodes_ipv6:
 1414|      1|{
 1415|       |    /* Check if packet is going to be sent to ourself. */
 1416|      1|    if (pk_equal(public_key, dht->self_public_key)) {
  ------------------
  |  Branch (1416:9): [True: 0, False: 1]
  ------------------
 1417|      0|        return -1;
 1418|      0|    }
 1419|       |
 1420|      1|    if (length != sizeof(uint64_t)) {
  ------------------
  |  Branch (1420:9): [True: 0, False: 1]
  ------------------
 1421|      0|        return -1;
 1422|      0|    }
 1423|       |
 1424|      1|    const size_t node_format_size = sizeof(Node_format);
 1425|       |
 1426|      1|    Node_format nodes_list[MAX_SENT_NODES];
 1427|      1|    const uint32_t num_nodes =
 1428|      1|        get_close_nodes(dht, client_id, nodes_list, net_family_unspec(), ip_is_lan(&ip_port->ip), false);
 1429|       |
 1430|      1|    VLA(uint8_t, plain, 1 + node_format_size * MAX_SENT_NODES + length);
  ------------------
  |  |   62|      1|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      1|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 1431|       |
 1432|      1|    int nodes_length = 0;
 1433|       |
 1434|      1|    if (num_nodes > 0) {
  ------------------
  |  Branch (1434:9): [True: 0, False: 1]
  ------------------
 1435|      0|        nodes_length = pack_nodes(dht->log, plain + 1, node_format_size * MAX_SENT_NODES, nodes_list, num_nodes);
  ------------------
  |  |   54|      0|#define MAX_SENT_NODES 4
  ------------------
 1436|       |
 1437|      0|        if (nodes_length <= 0) {
  ------------------
  |  Branch (1437:13): [True: 0, False: 0]
  ------------------
 1438|      0|            return -1;
 1439|      0|        }
 1440|      0|    }
 1441|       |
 1442|      1|    plain[0] = num_nodes;
 1443|      1|    memcpy(plain + 1 + nodes_length, sendback_data, length);
 1444|       |
 1445|      1|    const uint32_t crypto_size = 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE;
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  const uint32_t crypto_size = 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE;
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  const uint32_t crypto_size = 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE;
  ------------------
  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  ------------------
 1446|      1|    VLA(uint8_t, data, 1 + nodes_length + length + crypto_size);
  ------------------
  |  |   62|      1|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      1|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 1447|       |
 1448|      1|    const int len = dht_create_packet(dht->mem, dht->rng,
 1449|      1|                                      dht->self_public_key, shared_encryption_key, NET_PACKET_SEND_NODES_IPV6,
 1450|      1|                                      plain, 1 + nodes_length + length, data, SIZEOF_VLA(data));
  ------------------
  |  |   29|      1|#define SIZEOF_VLA sizeof
  ------------------
 1451|       |
 1452|      1|    if (len != SIZEOF_VLA(data)) {
  ------------------
  |  |   29|      1|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (1452:9): [True: 0, False: 1]
  ------------------
 1453|      0|        return -1;
 1454|      0|    }
 1455|       |
 1456|      1|    return sendpacket(dht->net, ip_port, data, len);
 1457|      1|}
DHT.c:handle_sendnodes_ipv6:
 1585|     55|{
 1586|     55|    DHT *const dht = (DHT *)object;
 1587|     55|    Node_format plain_nodes[MAX_SENT_NODES];
 1588|     55|    uint32_t num_nodes;
 1589|       |
 1590|     55|    if (!handle_sendnodes_core(object, source, packet, length, plain_nodes, MAX_SENT_NODES, &num_nodes)) {
  ------------------
  |  |   54|     55|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (1590:9): [True: 55, False: 0]
  ------------------
 1591|     55|        return 1;
 1592|     55|    }
 1593|       |
 1594|      0|    if (num_nodes == 0) {
  ------------------
  |  Branch (1594:9): [True: 0, False: 0]
  ------------------
 1595|      0|        return 0;
 1596|      0|    }
 1597|       |
 1598|      0|    for (uint32_t i = 0; i < num_nodes; ++i) {
  ------------------
  |  Branch (1598:26): [True: 0, False: 0]
  ------------------
 1599|      0|        if (ipport_isset(&plain_nodes[i].ip_port)) {
  ------------------
  |  Branch (1599:13): [True: 0, False: 0]
  ------------------
 1600|      0|            ping_node_from_getnodes_ok(dht, plain_nodes[i].public_key, &plain_nodes[i].ip_port);
 1601|      0|            returnedip_ports(dht, &plain_nodes[i].ip_port, plain_nodes[i].public_key, packet + 1);
 1602|       |
 1603|      0|            if (dht->get_nodes_response != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1603:17): [True: 0, False: 0]
  ------------------
 1604|      0|                dht->get_nodes_response(dht, &plain_nodes[i], userdata);
 1605|      0|            }
 1606|      0|        }
 1607|      0|    }
 1608|       |
 1609|      0|    return 0;
 1610|      0|}
DHT.c:handle_sendnodes_core:
 1517|     55|{
 1518|     55|    DHT *const dht = (DHT *)object;
 1519|     55|    const uint32_t cid_size = 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + 1 + sizeof(uint64_t) + CRYPTO_MAC_SIZE;
  ------------------
  |  |   40|     55|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  const uint32_t cid_size = 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + 1 + sizeof(uint64_t) + CRYPTO_MAC_SIZE;
  ------------------
  |  |   66|     55|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  const uint32_t cid_size = 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + 1 + sizeof(uint64_t) + CRYPTO_MAC_SIZE;
  ------------------
  |  |   61|     55|#define CRYPTO_MAC_SIZE                16
  ------------------
 1520|       |
 1521|     55|    if (length < cid_size) { /* too short */
  ------------------
  |  Branch (1521:9): [True: 17, False: 38]
  ------------------
 1522|     17|        return false;
 1523|     17|    }
 1524|       |
 1525|     38|    const uint32_t data_size = length - cid_size;
 1526|       |
 1527|     38|    if (data_size == 0) {
  ------------------
  |  Branch (1527:9): [True: 3, False: 35]
  ------------------
 1528|      3|        return false;
 1529|      3|    }
 1530|       |
 1531|     35|    if (data_size > sizeof(Node_format) * MAX_SENT_NODES) { /* invalid length */
  ------------------
  |  |   54|     35|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (1531:9): [True: 12, False: 23]
  ------------------
 1532|     12|        return false;
 1533|     12|    }
 1534|       |
 1535|     23|    VLA(uint8_t, plain, 1 + data_size + sizeof(uint64_t));
  ------------------
  |  |   62|     23|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     23|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 1536|     23|    const uint8_t *shared_key = dht_get_shared_key_sent(dht, packet + 1);
 1537|     23|    const int len = decrypt_data_symmetric(
 1538|     23|                        shared_key,
 1539|     23|                        packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|     23|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1540|     23|                        packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   40|     23|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                      packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|     23|#define CRYPTO_NONCE_SIZE              24
  ------------------
 1541|     23|                        1 + data_size + sizeof(uint64_t) + CRYPTO_MAC_SIZE,
  ------------------
  |  |   61|     23|#define CRYPTO_MAC_SIZE                16
  ------------------
 1542|     23|                        plain);
 1543|       |
 1544|     23|    if ((unsigned int)len != SIZEOF_VLA(plain)) {
  ------------------
  |  |   29|     23|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (1544:9): [True: 0, False: 23]
  ------------------
 1545|      0|        return false;
 1546|      0|    }
 1547|       |
 1548|     23|    if (plain[0] > size_plain_nodes) {
  ------------------
  |  Branch (1548:9): [True: 11, False: 12]
  ------------------
 1549|     11|        return false;
 1550|     11|    }
 1551|       |
 1552|     12|    uint64_t ping_id;
 1553|     12|    memcpy(&ping_id, plain + 1 + data_size, sizeof(ping_id));
 1554|       |
 1555|     12|    if (!sent_getnode_to_node(dht, packet + 1, source, ping_id)) {
  ------------------
  |  Branch (1555:9): [True: 8, False: 4]
  ------------------
 1556|      8|        return false;
 1557|      8|    }
 1558|       |
 1559|      4|    uint16_t length_nodes = 0;
 1560|      4|    const int num_nodes = unpack_nodes(plain_nodes, plain[0], &length_nodes, plain + 1, data_size, false);
 1561|       |
 1562|      4|    if (length_nodes != data_size) {
  ------------------
  |  Branch (1562:9): [True: 4, False: 0]
  ------------------
 1563|      4|        return false;
 1564|      4|    }
 1565|       |
 1566|      0|    if (num_nodes != plain[0]) {
  ------------------
  |  Branch (1566:9): [True: 0, False: 0]
  ------------------
 1567|      0|        return false;
 1568|      0|    }
 1569|       |
 1570|      0|    if (num_nodes < 0) {
  ------------------
  |  Branch (1570:9): [True: 0, False: 0]
  ------------------
 1571|      0|        return false;
 1572|      0|    }
 1573|       |
 1574|       |    /* store the address the *request* was sent to */
 1575|      0|    addto_lists(dht, source, packet + 1);
 1576|       |
 1577|      0|    *num_nodes_out = num_nodes;
 1578|       |
 1579|      0|    return true;
 1580|      0|}
DHT.c:sent_getnode_to_node:
 1498|     12|{
 1499|     12|    uint8_t data[sizeof(Node_format) * 2];
 1500|       |
 1501|     12|    if (ping_array_check(dht->dht_ping_array, dht->mono_time, data, sizeof(data), ping_id) != sizeof(Node_format)) {
  ------------------
  |  Branch (1501:9): [True: 7, False: 5]
  ------------------
 1502|      7|        return false;
 1503|      7|    }
 1504|       |
 1505|      5|    Node_format test;
 1506|       |
 1507|      5|    if (unpack_nodes(&test, 1, nullptr, data, sizeof(data), false) != 1) {
  ------------------
  |  |   66|      5|#define nullptr NULL
  ------------------
  |  Branch (1507:9): [True: 0, False: 5]
  ------------------
 1508|      0|        return false;
 1509|      0|    }
 1510|       |
 1511|      5|    return ipport_equal(&test.ip_port, node_ip_port) && pk_equal(test.public_key, public_key);
  ------------------
  |  Branch (1511:12): [True: 5, False: 0]
  |  Branch (1511:57): [True: 4, False: 1]
  ------------------
 1512|      5|}
DHT.c:cryptopacket_handle:
 2540|     84|{
 2541|     84|    DHT *const dht = (DHT *)object;
 2542|       |
 2543|     84|    assert(packet[0] == NET_PACKET_CRYPTO);
 2544|       |
 2545|     84|    if (length <= CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE + 1 + CRYPTO_MAC_SIZE ||
  ------------------
  |  |   40|     84|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  if (length <= CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE + 1 + CRYPTO_MAC_SIZE ||
  ------------------
  |  |   66|     84|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  if (length <= CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE + 1 + CRYPTO_MAC_SIZE ||
  ------------------
  |  |   61|    168|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (2545:9): [True: 24, False: 60]
  ------------------
 2546|     84|            length > MAX_CRYPTO_REQUEST_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   78|     60|#define MAX_CRYPTO_REQUEST_SIZE 1024
  ------------------
                          length > MAX_CRYPTO_REQUEST_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   61|     60|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (2546:13): [True: 4, False: 56]
  ------------------
 2547|     28|        return 1;
 2548|     28|    }
 2549|       |
 2550|       |    // Check if request is for us.
 2551|     56|    if (pk_equal(packet + 1, dht->self_public_key)) {
  ------------------
  |  Branch (2551:9): [True: 16, False: 40]
  ------------------
 2552|     16|        uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
 2553|     16|        uint8_t data[MAX_CRYPTO_REQUEST_SIZE];
 2554|     16|        uint8_t number;
 2555|     16|        const int len = handle_request(dht->self_public_key, dht->self_secret_key, public_key,
 2556|     16|                                       data, &number, packet, length);
 2557|       |
 2558|     16|        if (len == -1 || len == 0) {
  ------------------
  |  Branch (2558:13): [True: 1, False: 15]
  |  Branch (2558:26): [True: 1, False: 14]
  ------------------
 2559|      2|            return 1;
 2560|      2|        }
 2561|       |
 2562|     14|        if (dht->cryptopackethandlers[number].function == nullptr) {
  ------------------
  |  |   66|     14|#define nullptr NULL
  ------------------
  |  Branch (2562:13): [True: 4, False: 10]
  ------------------
 2563|      4|            return 1;
 2564|      4|        }
 2565|       |
 2566|     10|        return dht->cryptopackethandlers[number].function(
 2567|     10|                   dht->cryptopackethandlers[number].object, source, public_key,
 2568|     10|                   data, len, userdata);
 2569|     14|    }
 2570|       |
 2571|       |    /* If request is not for us, try routing it. */
 2572|     40|    const int retval = route_packet(dht, packet + 1, packet, length);
 2573|       |
 2574|     40|    if ((unsigned int)retval == length) {
  ------------------
  |  Branch (2574:9): [True: 0, False: 40]
  ------------------
 2575|      0|        return 0;
 2576|      0|    }
 2577|       |
 2578|     40|    return 1;
 2579|     40|}
DHT.c:handle_lan_discovery:
 2589|    590|{
 2590|    590|    DHT *dht = (DHT *)object;
 2591|       |
 2592|    590|    if (!dht->lan_discovery_enabled) {
  ------------------
  |  Branch (2592:9): [True: 0, False: 590]
  ------------------
 2593|      0|        return 1;
 2594|      0|    }
 2595|       |
 2596|    590|    if (!ip_is_lan(&source->ip)) {
  ------------------
  |  Branch (2596:9): [True: 0, False: 590]
  ------------------
 2597|      0|        return 1;
 2598|      0|    }
 2599|       |
 2600|    590|    if (length != CRYPTO_PUBLIC_KEY_SIZE + 1) {
  ------------------
  |  |   40|    590|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (2600:9): [True: 14, False: 576]
  ------------------
 2601|     14|        return 1;
 2602|     14|    }
 2603|       |
 2604|    576|    dht_bootstrap(dht, source, packet + 1);
 2605|    576|    return 0;
 2606|    590|}
DHT.c:handle_nat_ping:
 2249|      4|{
 2250|      4|    if (length != sizeof(uint64_t) + 1) {
  ------------------
  |  Branch (2250:9): [True: 1, False: 3]
  ------------------
 2251|      1|        return 1;
 2252|      1|    }
 2253|       |
 2254|      3|    DHT *const dht = (DHT *)object;
 2255|      3|    uint64_t ping_id;
 2256|      3|    memcpy(&ping_id, packet + 1, sizeof(uint64_t));
 2257|       |
 2258|      3|    const uint32_t friendnumber = index_of_friend_pk(dht->friends_list, dht->num_friends, source_pubkey);
 2259|       |
 2260|      3|    if (friendnumber == UINT32_MAX) {
  ------------------
  |  Branch (2260:9): [True: 1, False: 2]
  ------------------
 2261|      1|        return 1;
 2262|      1|    }
 2263|       |
 2264|      2|    DHT_Friend *const dht_friend = &dht->friends_list[friendnumber];
 2265|       |
 2266|      2|    if (packet[0] == NAT_PING_REQUEST) {
  ------------------
  |  |   41|      2|#define NAT_PING_REQUEST    0
  ------------------
  |  Branch (2266:9): [True: 0, False: 2]
  ------------------
 2267|       |        /* 1 is reply */
 2268|      0|        send_nat_ping(dht, source_pubkey, ping_id, NAT_PING_RESPONSE);
  ------------------
  |  |   42|      0|#define NAT_PING_RESPONSE   1
  ------------------
 2269|      0|        dht_friend->nat.recv_nat_ping_timestamp = mono_time_get(dht->mono_time);
 2270|      0|        return 0;
 2271|      0|    }
 2272|       |
 2273|      2|    if (packet[0] == NAT_PING_RESPONSE) {
  ------------------
  |  |   42|      2|#define NAT_PING_RESPONSE   1
  ------------------
  |  Branch (2273:9): [True: 0, False: 2]
  ------------------
 2274|      0|        if (dht_friend->nat.nat_ping_id == ping_id) {
  ------------------
  |  Branch (2274:13): [True: 0, False: 0]
  ------------------
 2275|      0|            dht_friend->nat.nat_ping_id = random_u64(dht->rng);
 2276|      0|            dht_friend->nat.hole_punching = true;
 2277|      0|            return 0;
 2278|      0|        }
 2279|      0|    }
 2280|       |
 2281|      2|    return 1;
 2282|      2|}
DHT.c:handle_data_search_response:
  956|     15|{
  957|     15|    DHT *dht = (DHT *) object;
  958|       |
  959|     15|    const int32_t plain_len = (int32_t)length - (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  const int32_t plain_len = (int32_t)length - (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   66|     15|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  const int32_t plain_len = (int32_t)length - (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   61|     15|#define CRYPTO_MAC_SIZE                16
  ------------------
  960|       |
  961|     15|    if (plain_len < (int32_t)(CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint64_t))) {
  ------------------
  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (961:9): [True: 10, False: 5]
  ------------------
  962|     10|        return 1;
  963|     10|    }
  964|       |
  965|      5|    VLA(uint8_t, plain, plain_len);
  ------------------
  |  |   62|      5|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      5|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  966|      5|    const uint8_t *public_key = packet + 1;
  967|      5|    const uint8_t *shared_key = dht_get_shared_key_recv(dht, public_key);
  968|       |
  969|      5|    if (decrypt_data_symmetric(shared_key,
  ------------------
  |  Branch (969:9): [True: 0, False: 5]
  ------------------
  970|      5|                               packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      5|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  971|      5|                               packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   40|      5|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                             packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      5|#define CRYPTO_NONCE_SIZE              24
  ------------------
  972|      5|                               plain_len + CRYPTO_MAC_SIZE,
  ------------------
  |  |   61|      5|#define CRYPTO_MAC_SIZE                16
  ------------------
  973|      5|                               plain) != plain_len) {
  974|      0|        return 1;
  975|      0|    }
  976|       |
  977|      5|    uint64_t ping_id;
  978|      5|    memcpy(&ping_id, plain + (plain_len - sizeof(uint64_t)), sizeof(ping_id));
  979|       |
  980|      5|    uint8_t ping_data[CRYPTO_PUBLIC_KEY_SIZE];
  981|       |
  982|      5|    if (ping_array_check(dht->dht_ping_array,
  ------------------
  |  Branch (982:9): [True: 5, False: 0]
  ------------------
  983|      5|                         dht->mono_time, ping_data,
  984|      5|                         sizeof(ping_data), ping_id) != sizeof(ping_data)) {
  985|      5|        return 1;
  986|      5|    }
  987|       |
  988|      0|    if (!pk_equal(ping_data, public_key)) {
  ------------------
  |  Branch (988:9): [True: 0, False: 0]
  ------------------
  989|      0|        return 1;
  990|      0|    }
  991|       |
  992|      0|    set_announce_node(dht, public_key);
  993|       |
  994|      0|    return 0;
  995|       |
  996|      0|}
DHT.c:do_close:
 1888|  2.26k|{
 1889|  2.26k|    for (size_t i = 0; i < dht->num_to_bootstrap; ++i) {
  ------------------
  |  Branch (1889:24): [True: 0, False: 2.26k]
  ------------------
 1890|      0|        dht_getnodes(dht, &dht->to_bootstrap[i].ip_port, dht->to_bootstrap[i].public_key, dht->self_public_key);
 1891|      0|    }
 1892|       |
 1893|  2.26k|    dht->num_to_bootstrap = 0;
 1894|       |
 1895|  2.26k|    const uint8_t not_killed = do_ping_and_sendnode_requests(
 1896|  2.26k|                                   dht, &dht->close_lastgetnodes, dht->self_public_key, dht->close_clientlist, LCLIENT_LIST, &dht->close_bootstrap_times,
  ------------------
  |  |   49|  2.26k|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   46|  2.26k|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   45|  2.26k|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|  2.26k|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1897|  2.26k|                                   false);
 1898|       |
 1899|  2.26k|    if (not_killed != 0) {
  ------------------
  |  Branch (1899:9): [True: 0, False: 2.26k]
  ------------------
 1900|      0|        return;
 1901|      0|    }
 1902|       |
 1903|       |    /* all existing nodes are at least KILL_NODE_TIMEOUT,
 1904|       |     * which means we are mute, as we only send packets to
 1905|       |     * nodes NOT in KILL_NODE_TIMEOUT
 1906|       |     *
 1907|       |     * so: reset all nodes to be BAD_NODE_TIMEOUT, but not
 1908|       |     * KILL_NODE_TIMEOUT, so we at least keep trying pings */
 1909|  2.26k|    const uint64_t badonly = mono_time_get(dht->mono_time) - BAD_NODE_TIMEOUT;
  ------------------
  |  |   68|  2.26k|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   63|  2.26k|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   66|  2.26k|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   63|  2.26k|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   67|  2.26k|#define PING_ROUNDTRIP 2
  |  |  ------------------
  ------------------
 1910|       |
 1911|  2.32M|    for (size_t i = 0; i < LCLIENT_LIST; ++i) {
  ------------------
  |  |   49|  2.32M|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   46|  2.32M|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   45|  2.32M|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|  2.32M|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1911:24): [True: 2.32M, False: 2.26k]
  ------------------
 1912|  2.32M|        Client_data *const client = &dht->close_clientlist[i];
 1913|       |
 1914|  2.32M|        IPPTsPng *const assocs[] = { &client->assoc6, &client->assoc4, nullptr };
  ------------------
  |  |   66|  2.32M|#define nullptr NULL
  ------------------
 1915|       |
 1916|  6.96M|        for (IPPTsPng * const *it = assocs; *it != nullptr; ++it) {
  ------------------
  |  |   66|  6.96M|#define nullptr NULL
  ------------------
  |  Branch (1916:45): [True: 4.64M, False: 2.32M]
  ------------------
 1917|  4.64M|            IPPTsPng *const assoc = *it;
 1918|       |
 1919|  4.64M|            if (assoc->timestamp != 0) {
  ------------------
  |  Branch (1919:17): [True: 0, False: 4.64M]
  ------------------
 1920|      0|                assoc->timestamp = badonly;
 1921|      0|            }
 1922|  4.64M|        }
 1923|  2.32M|    }
 1924|  2.26k|}
DHT.c:do_ping_and_sendnode_requests:
 1785|  6.80k|{
 1786|  6.80k|    uint8_t not_kill = 0;
 1787|  6.80k|    const uint64_t temp_time = mono_time_get(dht->mono_time);
 1788|       |
 1789|  6.80k|    uint32_t num_nodes = 0;
 1790|  6.80k|    Client_data **client_list = (Client_data **)mem_valloc(dht->mem, list_count * 2, sizeof(Client_data *));
 1791|  6.80k|    IPPTsPng **assoc_list = (IPPTsPng **)mem_valloc(dht->mem, list_count * 2, sizeof(IPPTsPng *));
 1792|  6.80k|    unsigned int sort = 0;
 1793|  6.80k|    bool sort_ok = false;
 1794|       |
 1795|  6.80k|    if (client_list == nullptr || assoc_list == nullptr) {
  ------------------
  |  |   66|  13.6k|#define nullptr NULL
  ------------------
                  if (client_list == nullptr || assoc_list == nullptr) {
  ------------------
  |  |   66|  6.67k|#define nullptr NULL
  ------------------
  |  Branch (1795:9): [True: 130, False: 6.67k]
  |  Branch (1795:35): [True: 39, False: 6.63k]
  ------------------
 1796|    169|        mem_delete(dht->mem, assoc_list);
 1797|    169|        mem_delete(dht->mem, client_list);
 1798|    169|        return 0;
 1799|    169|    }
 1800|       |
 1801|  2.33M|    for (uint32_t i = 0; i < list_count; ++i) {
  ------------------
  |  Branch (1801:26): [True: 2.32M, False: 6.63k]
  ------------------
 1802|       |        /* If node is not dead. */
 1803|  2.32M|        Client_data *client = &list[i];
 1804|       |
 1805|  2.32M|        IPPTsPng *const assocs[] = { &client->assoc6, &client->assoc4 };
 1806|       |
 1807|  6.97M|        for (uint32_t j = 0; j < sizeof(assocs) / sizeof(assocs[0]); ++j) {
  ------------------
  |  Branch (1807:30): [True: 4.65M, False: 2.32M]
  ------------------
 1808|  4.65M|            IPPTsPng *const assoc = assocs[j];
 1809|       |
 1810|  4.65M|            if (!mono_time_is_timeout(dht->mono_time, assoc->timestamp, KILL_NODE_TIMEOUT)) {
  ------------------
  |  |   26|  4.65M|#define KILL_NODE_TIMEOUT (BAD_NODE_TIMEOUT + PING_INTERVAL)
  |  |  ------------------
  |  |  |  |   68|  4.65M|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  4.65M|#define PING_INTERVAL 60
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|  4.65M|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  4.65M|#define PING_INTERVAL 60
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   67|  4.65M|#define PING_ROUNDTRIP 2
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define KILL_NODE_TIMEOUT (BAD_NODE_TIMEOUT + PING_INTERVAL)
  |  |  ------------------
  |  |  |  |   63|  4.65M|#define PING_INTERVAL 60
  |  |  ------------------
  ------------------
  |  Branch (1810:17): [True: 0, False: 4.65M]
  ------------------
 1811|      0|                sort = 0;
 1812|      0|                ++not_kill;
 1813|       |
 1814|      0|                if (mono_time_is_timeout(dht->mono_time, assoc->last_pinged, PING_INTERVAL)) {
  ------------------
  |  |   63|      0|#define PING_INTERVAL 60
  ------------------
  |  Branch (1814:21): [True: 0, False: 0]
  ------------------
 1815|      0|                    dht_getnodes(dht, &assoc->ip_port, client->public_key, public_key);
 1816|      0|                    assoc->last_pinged = temp_time;
 1817|      0|                }
 1818|       |
 1819|       |                /* If node is good. */
 1820|      0|                if (!assoc_timeout(dht->cur_time, assoc)) {
  ------------------
  |  Branch (1820:21): [True: 0, False: 0]
  ------------------
 1821|      0|                    client_list[num_nodes] = client;
 1822|      0|                    assoc_list[num_nodes] = assoc;
 1823|      0|                    ++num_nodes;
 1824|      0|                }
 1825|  4.65M|            } else {
 1826|  4.65M|                ++sort;
 1827|       |
 1828|       |                /* Timed out should be at beginning, if they are not, sort the list. */
 1829|  4.65M|                if (sort > 1 && sort < (((j + 1) * 2) - 1)) {
  ------------------
  |  Branch (1829:21): [True: 4.64M, False: 6.63k]
  |  Branch (1829:33): [True: 6.63k, False: 4.63M]
  ------------------
 1830|  6.63k|                    sort_ok = true;
 1831|  6.63k|                }
 1832|  4.65M|            }
 1833|  4.65M|        }
 1834|  2.32M|    }
 1835|       |
 1836|  6.63k|    if (sortable && sort_ok) {
  ------------------
  |  Branch (1836:9): [True: 4.39k, False: 2.23k]
  |  Branch (1836:21): [True: 4.39k, False: 0]
  ------------------
 1837|  4.39k|        sort_client_list(dht->mem, list, dht->cur_time, list_count, public_key);
 1838|  4.39k|    }
 1839|       |
 1840|  6.63k|    if (num_nodes > 0 && (mono_time_is_timeout(dht->mono_time, *lastgetnode, GET_NODE_INTERVAL)
  ------------------
  |  |   29|      0|#define GET_NODE_INTERVAL 20
  ------------------
  |  Branch (1840:9): [True: 0, False: 6.63k]
  |  Branch (1840:27): [True: 0, False: 0]
  ------------------
 1841|      0|                          || *bootstrap_times < MAX_BOOTSTRAP_TIMES)) {
  ------------------
  |  |   45|      0|#define MAX_BOOTSTRAP_TIMES 5
  ------------------
  |  Branch (1841:30): [True: 0, False: 0]
  ------------------
 1842|      0|        uint32_t rand_node = random_range_u32(dht->rng, num_nodes);
 1843|       |
 1844|      0|        if ((num_nodes - 1) != rand_node) {
  ------------------
  |  Branch (1844:13): [True: 0, False: 0]
  ------------------
 1845|      0|            rand_node += random_range_u32(dht->rng, num_nodes - (rand_node + 1));
 1846|      0|        }
 1847|       |
 1848|      0|        dht_getnodes(dht, &assoc_list[rand_node]->ip_port, client_list[rand_node]->public_key, public_key);
 1849|       |
 1850|      0|        *lastgetnode = temp_time;
 1851|      0|        ++*bootstrap_times;
 1852|      0|    }
 1853|       |
 1854|  6.63k|    mem_delete(dht->mem, assoc_list);
 1855|  6.63k|    mem_delete(dht->mem, client_list);
 1856|  6.63k|    return not_kill;
 1857|  6.80k|}
DHT.c:do_dht_friends:
 1866|  2.26k|{
 1867|  6.80k|    for (size_t i = 0; i < dht->num_friends; ++i) {
  ------------------
  |  Branch (1867:24): [True: 4.53k, False: 2.26k]
  ------------------
 1868|  4.53k|        DHT_Friend *const dht_friend = &dht->friends_list[i];
 1869|       |
 1870|  4.53k|        for (size_t j = 0; j < dht_friend->num_to_bootstrap; ++j) {
  ------------------
  |  Branch (1870:28): [True: 0, False: 4.53k]
  ------------------
 1871|      0|            dht_getnodes(dht, &dht_friend->to_bootstrap[j].ip_port, dht_friend->to_bootstrap[j].public_key, dht_friend->public_key);
 1872|      0|        }
 1873|       |
 1874|  4.53k|        dht_friend->num_to_bootstrap = 0;
 1875|       |
 1876|  4.53k|        do_ping_and_sendnode_requests(dht, &dht_friend->lastgetnode, dht_friend->public_key, dht_friend->client_list,
 1877|  4.53k|                                      MAX_FRIEND_CLIENTS,
  ------------------
  |  |   43|  4.53k|#define MAX_FRIEND_CLIENTS 8
  ------------------
 1878|  4.53k|                                      &dht_friend->bootstrap_times, true);
 1879|  4.53k|    }
 1880|  2.26k|}
DHT.c:do_nat:
 2401|  2.26k|{
 2402|  2.26k|    const uint64_t temp_time = mono_time_get(dht->mono_time);
 2403|       |
 2404|  6.80k|    for (uint32_t i = 0; i < dht->num_friends; ++i) {
  ------------------
  |  Branch (2404:26): [True: 4.53k, False: 2.26k]
  ------------------
 2405|  4.53k|        IP_Port ip_list[MAX_FRIEND_CLIENTS];
 2406|  4.53k|        const int num = friend_iplist(dht, ip_list, i);
 2407|       |
 2408|       |        /* If already connected or friend is not online don't try to hole punch. */
 2409|  4.53k|        if (num < MAX_FRIEND_CLIENTS / 2) {
  ------------------
  |  |   43|  4.53k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  |  Branch (2409:13): [True: 4.53k, False: 0]
  ------------------
 2410|  4.53k|            continue;
 2411|  4.53k|        }
 2412|       |
 2413|      0|        if (dht->friends_list[i].nat.nat_ping_timestamp + PUNCH_INTERVAL < temp_time) {
  ------------------
  |  |   34|      0|#define PUNCH_INTERVAL 3
  ------------------
  |  Branch (2413:13): [True: 0, False: 0]
  ------------------
 2414|      0|            send_nat_ping(dht, dht->friends_list[i].public_key, dht->friends_list[i].nat.nat_ping_id, NAT_PING_REQUEST);
  ------------------
  |  |   41|      0|#define NAT_PING_REQUEST    0
  ------------------
 2415|      0|            dht->friends_list[i].nat.nat_ping_timestamp = temp_time;
 2416|      0|        }
 2417|       |
 2418|      0|        if (dht->friends_list[i].nat.hole_punching &&
  ------------------
  |  Branch (2418:13): [True: 0, False: 0]
  ------------------
 2419|      0|                dht->friends_list[i].nat.punching_timestamp + PUNCH_INTERVAL < temp_time &&
  ------------------
  |  |   34|      0|#define PUNCH_INTERVAL 3
  ------------------
  |  Branch (2419:17): [True: 0, False: 0]
  ------------------
 2420|      0|                dht->friends_list[i].nat.recv_nat_ping_timestamp + PUNCH_INTERVAL * 2 >= temp_time) {
  ------------------
  |  |   34|      0|#define PUNCH_INTERVAL 3
  ------------------
  |  Branch (2420:17): [True: 0, False: 0]
  ------------------
 2421|       |
 2422|      0|            const IP ip = nat_commonip(ip_list, num, MAX_FRIEND_CLIENTS / 2);
  ------------------
  |  |   43|      0|#define MAX_FRIEND_CLIENTS 8
  ------------------
 2423|       |
 2424|      0|            if (!ip_isset(&ip)) {
  ------------------
  |  Branch (2424:17): [True: 0, False: 0]
  ------------------
 2425|      0|                continue;
 2426|      0|            }
 2427|       |
 2428|      0|            if (dht->friends_list[i].nat.punching_timestamp + PUNCH_RESET_TIME < temp_time) {
  ------------------
  |  |   37|      0|#define PUNCH_RESET_TIME 40
  ------------------
  |  Branch (2428:17): [True: 0, False: 0]
  ------------------
 2429|      0|                dht->friends_list[i].nat.tries = 0;
 2430|      0|                dht->friends_list[i].nat.punching_index = 0;
 2431|      0|                dht->friends_list[i].nat.punching_index2 = 0;
 2432|      0|            }
 2433|       |
 2434|      0|            uint16_t port_list[MAX_FRIEND_CLIENTS];
 2435|      0|            const uint16_t numports = nat_getports(port_list, ip_list, num, &ip);
 2436|      0|            punch_holes(dht, &ip, port_list, numports, i);
 2437|       |
 2438|      0|            dht->friends_list[i].nat.punching_timestamp = temp_time;
 2439|      0|            dht->friends_list[i].nat.hole_punching = false;
 2440|      0|        }
 2441|      0|    }
 2442|  2.26k|}

ip_is_local:
  267|    618|{
  268|    618|    if (net_family_is_ipv4(ip->family)) {
  ------------------
  |  Branch (268:9): [True: 617, False: 1]
  ------------------
  269|    617|        return ip4_is_local(&ip->ip.v4);
  270|    617|    }
  271|       |
  272|       |    /* embedded IPv4-in-IPv6 */
  273|      1|    if (ipv6_ipv4_in_v6(&ip->ip.v6)) {
  ------------------
  |  Branch (273:9): [True: 0, False: 1]
  ------------------
  274|      0|        IP4 ip4;
  275|      0|        ip4.uint32 = ip->ip.v6.uint32[3];
  276|      0|        return ip4_is_local(&ip4);
  277|      0|    }
  278|       |
  279|       |    /* localhost in IPv6 (::1) */
  280|      1|    return ip->ip.v6.uint64[0] == 0 && ip->ip.v6.uint32[2] == 0 && ip->ip.v6.uint32[3] == net_htonl(1);
  ------------------
  |  Branch (280:12): [True: 1, False: 0]
  |  Branch (280:40): [True: 1, False: 0]
  |  Branch (280:68): [True: 0, False: 1]
  ------------------
  281|      1|}
ip_is_lan:
  313|    618|{
  314|    618|    if (ip_is_local(ip)) {
  ------------------
  |  Branch (314:9): [True: 617, False: 1]
  ------------------
  315|    617|        return true;
  316|    617|    }
  317|       |
  318|      1|    if (net_family_is_ipv4(ip->family)) {
  ------------------
  |  Branch (318:9): [True: 0, False: 1]
  ------------------
  319|      0|        return ip4_is_lan(&ip->ip.v4);
  320|      0|    }
  321|       |
  322|      1|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (322:9): [True: 0, False: 1]
  ------------------
  323|       |        /* autogenerated for each interface: `FE80::*` (up to `FEBF::*`)
  324|       |         * `FF02::1` is - according to RFC 4291 - multicast all-nodes link-local */
  325|      0|        if (((ip->ip.v6.uint8[0] == 0xFF) && (ip->ip.v6.uint8[1] < 3) && (ip->ip.v6.uint8[15] == 1)) ||
  ------------------
  |  Branch (325:14): [True: 0, False: 0]
  |  Branch (325:46): [True: 0, False: 0]
  |  Branch (325:74): [True: 0, False: 0]
  ------------------
  326|      0|                ((ip->ip.v6.uint8[0] == 0xFE) && ((ip->ip.v6.uint8[1] & 0xC0) == 0x80))) {
  ------------------
  |  Branch (326:18): [True: 0, False: 0]
  |  Branch (326:50): [True: 0, False: 0]
  ------------------
  327|      0|            return true;
  328|      0|        }
  329|       |
  330|       |        /* embedded IPv4-in-IPv6 */
  331|      0|        if (ipv6_ipv4_in_v6(&ip->ip.v6)) {
  ------------------
  |  Branch (331:13): [True: 0, False: 0]
  ------------------
  332|      0|            IP4 ip4;
  333|      0|            ip4.uint32 = ip->ip.v6.uint32[3];
  334|      0|            return ip4_is_lan(&ip4);
  335|      0|        }
  336|      0|    }
  337|       |
  338|      1|    return false;
  339|      1|}
lan_discovery_send:
  344|  23.3k|{
  345|  23.3k|    if (broadcast == nullptr) {
  ------------------
  |  |   66|  23.3k|#define nullptr NULL
  ------------------
  |  Branch (345:9): [True: 0, False: 23.3k]
  ------------------
  346|      0|        return false;
  347|      0|    }
  348|       |
  349|  23.3k|    uint8_t data[CRYPTO_PUBLIC_KEY_SIZE + 1];
  350|  23.3k|    data[0] = NET_PACKET_LAN_DISCOVERY;
  351|  23.3k|    pk_copy(data + 1, dht_pk);
  352|       |
  353|  23.3k|    send_broadcasts(net, broadcast, port, data, 1 + CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|  23.3k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  354|       |
  355|  23.3k|    bool res = false;
  356|  23.3k|    IP_Port ip_port;
  357|  23.3k|    ip_port.port = port;
  358|       |
  359|       |    /* IPv6 multicast */
  360|  23.3k|    if (net_family_is_ipv6(net_family(net))) {
  ------------------
  |  Branch (360:9): [True: 8.96k, False: 14.3k]
  ------------------
  361|  8.96k|        ip_port.ip = broadcast_ip(net_family_ipv6(), net_family_ipv6());
  362|       |
  363|  8.96k|        if (ip_isset(&ip_port.ip) && sendpacket(net, &ip_port, data, 1 + CRYPTO_PUBLIC_KEY_SIZE) > 0) {
  ------------------
  |  |   40|  8.96k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (363:13): [True: 8.96k, False: 0]
  |  Branch (363:38): [True: 8.96k, False: 0]
  ------------------
  364|  8.96k|            res = true;
  365|  8.96k|        }
  366|  8.96k|    }
  367|       |
  368|       |    /* IPv4 broadcast (has to be IPv4-in-IPv6 mapping if socket is IPv6 */
  369|  23.3k|    ip_port.ip = broadcast_ip(net_family(net), net_family_ipv4());
  370|       |
  371|  23.3k|    if (ip_isset(&ip_port.ip) && sendpacket(net, &ip_port, data, 1 + CRYPTO_PUBLIC_KEY_SIZE) > 0) {
  ------------------
  |  |   40|  8.96k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (371:9): [True: 8.96k, False: 14.3k]
  |  Branch (371:34): [True: 8.96k, False: 0]
  ------------------
  372|  8.96k|        res = true;
  373|  8.96k|    }
  374|       |
  375|  23.3k|    return res;
  376|  23.3k|}
lan_discovery_init:
  380|    943|{
  381|    943|    return fetch_broadcast_info(ns);
  382|    943|}
lan_discovery_kill:
  385|    943|{
  386|    943|    free(broadcast);
  387|    943|}
LAN_discovery.c:ip4_is_local:
  258|    617|{
  259|       |    /* Loopback. */
  260|    617|    return ip4->uint8[0] == 127;
  261|    617|}
LAN_discovery.c:send_broadcasts:
  214|  23.3k|{
  215|  23.3k|    if (broadcast->count == 0) {
  ------------------
  |  Branch (215:9): [True: 23.3k, False: 0]
  ------------------
  216|  23.3k|        return false;
  217|  23.3k|    }
  218|       |
  219|      0|    for (uint32_t i = 0; i < broadcast->count; ++i) {
  ------------------
  |  Branch (219:26): [True: 0, False: 0]
  ------------------
  220|      0|        IP_Port ip_port;
  221|      0|        ip_port.ip = broadcast->ips[i];
  222|      0|        ip_port.port = port;
  223|      0|        sendpacket(net, &ip_port, data, length);
  224|      0|    }
  225|       |
  226|      0|    return true;
  227|  23.3k|}
LAN_discovery.c:broadcast_ip:
  231|  32.2k|{
  232|  32.2k|    IP ip;
  233|  32.2k|    ip_reset(&ip);
  234|       |
  235|  32.2k|    if (net_family_is_ipv6(family_socket)) {
  ------------------
  |  Branch (235:9): [True: 17.9k, False: 14.3k]
  ------------------
  236|  17.9k|        if (net_family_is_ipv6(family_broadcast)) {
  ------------------
  |  Branch (236:13): [True: 8.96k, False: 8.96k]
  ------------------
  237|  8.96k|            ip.family = net_family_ipv6();
  238|       |            /* `FF02::1` is - according to RFC 4291 - multicast all-nodes link-local */
  239|       |            /* `FE80::*:` MUST be exact, for that we would need to look over all
  240|       |             * interfaces and check in which status they are */
  241|  8.96k|            ip.ip.v6.uint8[ 0] = 0xFF;
  242|  8.96k|            ip.ip.v6.uint8[ 1] = 0x02;
  243|  8.96k|            ip.ip.v6.uint8[15] = 0x01;
  244|  8.96k|        } else if (net_family_is_ipv4(family_broadcast)) {
  ------------------
  |  Branch (244:20): [True: 8.96k, False: 0]
  ------------------
  245|  8.96k|            ip.family = net_family_ipv6();
  246|  8.96k|            ip.ip.v6 = ip6_broadcast;
  247|  8.96k|        }
  248|  17.9k|    } else if (net_family_is_ipv4(family_socket) && net_family_is_ipv4(family_broadcast)) {
  ------------------
  |  Branch (248:16): [True: 0, False: 14.3k]
  |  Branch (248:53): [True: 0, False: 0]
  ------------------
  249|      0|        ip.family = net_family_ipv4();
  250|      0|        ip.ip.v4 = ip4_broadcast;
  251|      0|    }
  252|       |
  253|  32.2k|    return ip;
  254|  32.2k|}
LAN_discovery.c:fetch_broadcast_info:
  200|    943|{
  201|    943|    return (Broadcast_Info *)calloc(1, sizeof(Broadcast_Info));
  202|    943|}

getfriend_id:
   69|    249|{
   70|    511|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (70:26): [True: 262, False: 249]
  ------------------
   71|    262|        if (m->friendlist[i].status > 0 && pk_equal(real_pk, m->friendlist[i].real_pk)) {
  ------------------
  |  Branch (71:13): [True: 262, False: 0]
  |  Branch (71:44): [True: 0, False: 262]
  ------------------
   72|      0|            return i;
   73|      0|        }
   74|    262|    }
   75|       |
   76|    249|    return -1;
   77|    249|}
m_addfriend_norequest:
  293|    128|{
  294|    128|    if (!public_key_valid(real_pk)) {
  ------------------
  |  Branch (294:9): [True: 5, False: 123]
  ------------------
  295|      5|        return FAERR_BADCHECKSUM;
  296|      5|    }
  297|       |
  298|    123|    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (298:9): [True: 2, False: 121]
  ------------------
  299|      2|        return FAERR_OWNKEY;
  300|      2|    }
  301|       |
  302|    121|    return m_add_friend_contact_norequest(m, real_pk);
  303|    123|}
m_friend_exists:
  533|    121|{
  534|    121|    return (unsigned int)friendnumber < m->numfriends && m->friendlist[friendnumber].status != 0;
  ------------------
  |  Branch (534:12): [True: 121, False: 0]
  |  Branch (534:58): [True: 121, False: 0]
  ------------------
  535|    121|}
m_callback_friendrequest:
  937|    933|{
  938|    933|    m->friend_request = function;
  939|    933|}
m_callback_friendmessage:
  943|    933|{
  944|    933|    m->friend_message = function;
  945|    933|}
m_callback_namechange:
  948|    933|{
  949|    933|    m->friend_namechange = function;
  950|    933|}
m_callback_statusmessage:
  953|    933|{
  954|    933|    m->friend_statusmessagechange = function;
  955|    933|}
m_callback_userstatus:
  958|    933|{
  959|    933|    m->friend_userstatuschange = function;
  960|    933|}
m_callback_typingchange:
  963|    933|{
  964|    933|    m->friend_typingchange = function;
  965|    933|}
m_callback_read_receipt:
  968|    933|{
  969|    933|    m->read_receipt = function;
  970|    933|}
m_callback_connectionstatus:
  973|    933|{
  974|    933|    m->friend_connectionstatuschange = function;
  975|    933|}
m_callback_core_connection:
  978|    933|{
  979|    933|    m->core_connection_change = function;
  980|    933|}
m_callback_conference_invite:
 1056|  1.86k|{
 1057|  1.86k|    m->conference_invite = function;
 1058|  1.86k|}
m_callback_group_invite:
 1062|    933|{
 1063|    933|    m->group_invite = function;
 1064|    933|}
callback_file_sendrequest:
 1092|    933|{
 1093|    933|    m->file_sendrequest = function;
 1094|    933|}
callback_file_control:
 1098|    933|{
 1099|    933|    m->file_filecontrol = function;
 1100|    933|}
callback_file_data:
 1104|    933|{
 1105|    933|    m->file_filedata = function;
 1106|    933|}
callback_file_reqchunk:
 1110|    933|{
 1111|    933|    m->file_reqchunk = function;
 1112|    933|}
custom_lossy_packet_registerhandler:
 1857|    933|{
 1858|    933|    m->lossy_packethandler = lossy_packethandler;
 1859|    933|}
custom_lossless_packet_registerhandler:
 1943|    933|{
 1944|    933|    m->lossless_packethandler = lossless_packethandler;
 1945|    933|}
do_messenger:
 2616|  72.6k|{
 2617|       |    // Add the TCP relays, but only if this is the first time calling do_messenger
 2618|  72.6k|    if (!m->has_added_relays) {
  ------------------
  |  Branch (2618:9): [True: 914, False: 71.7k]
  ------------------
 2619|    914|        m->has_added_relays = true;
 2620|       |
 2621|    914|        for (uint16_t i = 0; i < m->num_loaded_relays; ++i) {
  ------------------
  |  Branch (2621:30): [True: 0, False: 914]
  ------------------
 2622|      0|            add_tcp_relay(m->net_crypto, &m->loaded_relays[i].ip_port, m->loaded_relays[i].public_key);
 2623|      0|        }
 2624|       |
 2625|    914|        m->num_loaded_relays = 0;
 2626|       |
 2627|    914|        if (m->tcp_server != nullptr) {
  ------------------
  |  |   66|    914|#define nullptr NULL
  ------------------
  |  Branch (2627:13): [True: 137, False: 777]
  ------------------
 2628|       |            /* Add self tcp server. */
 2629|    137|            IP_Port local_ip_port;
 2630|    137|            local_ip_port.port = m->options.tcp_server_port;
 2631|    137|            local_ip_port.ip.family = net_family_ipv4();
 2632|    137|            local_ip_port.ip.ip.v4 = get_ip4_loopback();
 2633|    137|            add_tcp_relay(m->net_crypto, &local_ip_port, tcp_server_public_key(m->tcp_server));
 2634|    137|        }
 2635|    914|    }
 2636|       |
 2637|  72.6k|    if (!m->options.udp_disabled) {
  ------------------
  |  Branch (2637:9): [True: 12.0k, False: 60.6k]
  ------------------
 2638|  12.0k|        networking_poll(m->net, userdata);
 2639|  12.0k|        do_dht(m->dht);
 2640|  12.0k|    }
 2641|       |
 2642|  72.6k|    if (m->tcp_server != nullptr) {
  ------------------
  |  |   66|  72.6k|#define nullptr NULL
  ------------------
  |  Branch (2642:9): [True: 174, False: 72.5k]
  ------------------
 2643|    174|        do_tcp_server(m->tcp_server, m->mono_time);
 2644|    174|    }
 2645|       |
 2646|  72.6k|    do_net_crypto(m->net_crypto, userdata);
 2647|  72.6k|    do_onion_client(m->onion_c);
 2648|  72.6k|    do_friend_connections(m->fr_c, userdata);
 2649|  72.6k|    do_friends(m, userdata);
 2650|  72.6k|#ifndef VANILLA_NACL
 2651|  72.6k|    do_gc(m->group_handler, userdata);
 2652|  72.6k|    do_gca(m->mono_time, m->group_announce);
 2653|  72.6k|    do_gc_onion_friends(m);
 2654|  72.6k|#endif
 2655|  72.6k|    m_connection_status_callback(m, userdata);
 2656|       |
 2657|  72.6k|    if (mono_time_get(m->mono_time) > m->lastdump + DUMPING_CLIENTS_FRIENDS_EVERY_N_SECONDS) {
  ------------------
  |  | 2489|  72.6k|#define DUMPING_CLIENTS_FRIENDS_EVERY_N_SECONDS 60UL
  ------------------
  |  Branch (2657:9): [True: 1.09k, False: 71.5k]
  ------------------
 2658|  1.09k|        m->lastdump = mono_time_get(m->mono_time);
 2659|  1.09k|        uint32_t last_pinged;
 2660|       |
 2661|  1.12M|        for (uint32_t client = 0; client < LCLIENT_LIST; ++client) {
  ------------------
  |  |   49|  1.12M|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   46|  1.12M|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   45|  1.12M|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|  1.12M|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2661:35): [True: 1.12M, False: 1.09k]
  ------------------
 2662|  1.12M|            const Client_data *cptr = dht_get_close_client(m->dht, client);
 2663|  1.12M|            const IPPTsPng *const assocs[] = { &cptr->assoc4, &cptr->assoc6, nullptr };
  ------------------
  |  |   66|  1.12M|#define nullptr NULL
  ------------------
 2664|       |
 2665|  3.36M|            for (const IPPTsPng * const *it = assocs; *it != nullptr; ++it) {
  ------------------
  |  |   66|  3.36M|#define nullptr NULL
  ------------------
  |  Branch (2665:55): [True: 2.24M, False: 1.12M]
  ------------------
 2666|  2.24M|                const IPPTsPng *const assoc = *it;
 2667|       |
 2668|  2.24M|                if (ip_isset(&assoc->ip_port.ip)) {
  ------------------
  |  Branch (2668:21): [True: 0, False: 2.24M]
  ------------------
 2669|      0|                    last_pinged = m->lastdump - assoc->last_pinged;
 2670|       |
 2671|      0|                    if (last_pinged > 999) {
  ------------------
  |  Branch (2671:25): [True: 0, False: 0]
  ------------------
 2672|      0|                        last_pinged = 999;
 2673|      0|                    }
 2674|       |
 2675|      0|                    Ip_Ntoa ip_str;
 2676|      0|                    char id_str[IDSTRING_LEN];
 2677|      0|                    LOGGER_TRACE(m->log, "C[%2u] %s:%u [%3u] %s",
  ------------------
  |  |   79|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2678|      0|                                 client, net_ip_ntoa(&assoc->ip_port.ip, &ip_str),
 2679|      0|                                 net_ntohs(assoc->ip_port.port), last_pinged,
 2680|      0|                                 id_to_string(cptr->public_key, id_str, sizeof(id_str)));
 2681|      0|                }
 2682|  2.24M|            }
 2683|  1.12M|        }
 2684|       |
 2685|       |
 2686|       |        /* dht contains additional "friends" (requests) */
 2687|  1.09k|        const uint32_t num_dhtfriends = dht_get_num_friends(m->dht);
 2688|  1.09k|        VLA(int32_t, m2dht, num_dhtfriends);
  ------------------
  |  |   62|  1.09k|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|  1.09k|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 2689|  1.09k|        VLA(int32_t, dht2m, num_dhtfriends);
  ------------------
  |  |   62|  1.09k|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|  1.09k|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 2690|       |
 2691|  3.28k|        for (uint32_t friend_idx = 0; friend_idx < num_dhtfriends; ++friend_idx) {
  ------------------
  |  Branch (2691:39): [True: 2.19k, False: 1.09k]
  ------------------
 2692|  2.19k|            m2dht[friend_idx] = -1;
 2693|  2.19k|            dht2m[friend_idx] = -1;
 2694|       |
 2695|  2.19k|            if (friend_idx >= m->numfriends) {
  ------------------
  |  Branch (2695:17): [True: 2.19k, False: 1]
  ------------------
 2696|  2.19k|                continue;
 2697|  2.19k|            }
 2698|       |
 2699|      3|            for (uint32_t dhtfriend = 0; dhtfriend < dht_get_num_friends(m->dht); ++dhtfriend) {
  ------------------
  |  Branch (2699:42): [True: 2, False: 1]
  ------------------
 2700|      2|                if (pk_equal(m->friendlist[friend_idx].real_pk, dht_get_friend_public_key(m->dht, dhtfriend))) {
  ------------------
  |  Branch (2700:21): [True: 0, False: 2]
  ------------------
 2701|      0|                    assert(dhtfriend < INT32_MAX);
 2702|      0|                    m2dht[friend_idx] = (int32_t)dhtfriend;
 2703|      0|                    break;
 2704|      0|                }
 2705|      2|            }
 2706|      1|        }
 2707|       |
 2708|  3.28k|        for (uint32_t friend_idx = 0; friend_idx < num_dhtfriends; ++friend_idx) {
  ------------------
  |  Branch (2708:39): [True: 2.19k, False: 1.09k]
  ------------------
 2709|  2.19k|            if (m2dht[friend_idx] >= 0) {
  ------------------
  |  Branch (2709:17): [True: 0, False: 2.19k]
  ------------------
 2710|      0|                assert(friend_idx < INT32_MAX);
 2711|      0|                dht2m[m2dht[friend_idx]] = (int32_t)friend_idx;
 2712|      0|            }
 2713|  2.19k|        }
 2714|       |
 2715|  1.09k|        if (m->numfriends != dht_get_num_friends(m->dht)) {
  ------------------
  |  Branch (2715:13): [True: 1.09k, False: 0]
  ------------------
 2716|  1.09k|            LOGGER_TRACE(m->log, "Friend num in DHT %u != friend num in msger %u", dht_get_num_friends(m->dht), m->numfriends);
  ------------------
  |  |   79|  1.09k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  1.09k|    do {                                                                         \
  |  |  |  |   73|  1.09k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  2.19k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  1.09k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2717|  1.09k|        }
 2718|       |
 2719|  3.28k|        for (uint32_t friend_idx = 0; friend_idx < num_dhtfriends; ++friend_idx) {
  ------------------
  |  Branch (2719:39): [True: 2.19k, False: 1.09k]
  ------------------
 2720|  2.19k|            const Friend *const msgfptr = dht2m[friend_idx] >= 0 ?  &m->friendlist[dht2m[friend_idx]] : nullptr;
  ------------------
  |  |   66|  2.19k|#define nullptr NULL
  ------------------
  |  Branch (2720:43): [True: 0, False: 2.19k]
  ------------------
 2721|  2.19k|            const DHT_Friend *const dhtfptr = dht_get_friend(m->dht, friend_idx);
 2722|       |
 2723|  2.19k|            if (msgfptr != nullptr) {
  ------------------
  |  |   66|  2.19k|#define nullptr NULL
  ------------------
  |  Branch (2723:17): [True: 0, False: 2.19k]
  ------------------
 2724|      0|                char id_str[IDSTRING_LEN];
 2725|      0|                LOGGER_TRACE(m->log, "F[%2u:%2u] <%s> %s",
  ------------------
  |  |   79|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2726|      0|                             dht2m[friend_idx], friend_idx, msgfptr->name,
 2727|      0|                             id_to_string(msgfptr->real_pk, id_str, sizeof(id_str)));
 2728|  2.19k|            } else {
 2729|  2.19k|                char id_str[IDSTRING_LEN];
 2730|  2.19k|                LOGGER_TRACE(m->log, "F[--:%2u] %s", friend_idx,
  ------------------
  |  |   79|  2.19k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  2.19k|    do {                                                                         \
  |  |  |  |   73|  2.19k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  4.38k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  2.19k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2731|  2.19k|                             id_to_string(dht_friend_public_key(dhtfptr), id_str, sizeof(id_str)));
 2732|  2.19k|            }
 2733|       |
 2734|  19.7k|            for (uint32_t client = 0; client < MAX_FRIEND_CLIENTS; ++client) {
  ------------------
  |  |   43|  19.7k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  |  Branch (2734:39): [True: 17.5k, False: 2.19k]
  ------------------
 2735|  17.5k|                const Client_data *cptr = dht_friend_client(dhtfptr, client);
 2736|  17.5k|                const IPPTsPng *const assocs[] = {&cptr->assoc4, &cptr->assoc6};
 2737|       |
 2738|  52.6k|                for (size_t a = 0; a < sizeof(assocs) / sizeof(assocs[0]); ++a) {
  ------------------
  |  Branch (2738:36): [True: 35.0k, False: 17.5k]
  ------------------
 2739|  35.0k|                    const IPPTsPng *const assoc = assocs[a];
 2740|       |
 2741|  35.0k|                    if (ip_isset(&assoc->ip_port.ip)) {
  ------------------
  |  Branch (2741:25): [True: 0, False: 35.0k]
  ------------------
 2742|      0|                        last_pinged = m->lastdump - assoc->last_pinged;
 2743|       |
 2744|      0|                        if (last_pinged > 999) {
  ------------------
  |  Branch (2744:29): [True: 0, False: 0]
  ------------------
 2745|      0|                            last_pinged = 999;
 2746|      0|                        }
 2747|       |
 2748|      0|                        Ip_Ntoa ip_str;
 2749|      0|                        char id_str[IDSTRING_LEN];
 2750|      0|                        LOGGER_TRACE(m->log, "F[%2u] => C[%2u] %s:%u [%3u] %s",
  ------------------
  |  |   79|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2751|      0|                                     friend_idx, client, net_ip_ntoa(&assoc->ip_port.ip, &ip_str),
 2752|      0|                                     net_ntohs(assoc->ip_port.port), last_pinged,
 2753|      0|                                     id_to_string(cptr->public_key, id_str, sizeof(id_str)));
 2754|      0|                    }
 2755|  35.0k|                }
 2756|  17.5k|            }
 2757|  2.19k|        }
 2758|  1.09k|    }
 2759|  72.6k|}
m_register_state_plugin:
 2917|  8.39k|{
 2918|  8.39k|    const uint32_t new_length = m->options.state_plugins_length + 1;
 2919|  8.39k|    Messenger_State_Plugin *temp = (Messenger_State_Plugin *)mem_vrealloc(
 2920|  8.39k|            m->mem, m->options.state_plugins, new_length, sizeof(Messenger_State_Plugin));
 2921|       |
 2922|  8.39k|    if (temp == nullptr) {
  ------------------
  |  |   66|  8.39k|#define nullptr NULL
  ------------------
  |  Branch (2922:9): [True: 3.40k, False: 4.99k]
  ------------------
 2923|  3.40k|        return false;
 2924|  3.40k|    }
 2925|       |
 2926|  4.99k|    m->options.state_plugins = temp;
 2927|  4.99k|    m->options.state_plugins_length = new_length;
 2928|       |
 2929|  4.99k|    const uint8_t index = m->options.state_plugins_length - 1;
 2930|  4.99k|    m->options.state_plugins[index].type = type;
 2931|  4.99k|    m->options.state_plugins[index].size = size_callback;
 2932|  4.99k|    m->options.state_plugins[index].load = load_callback;
 2933|  4.99k|    m->options.state_plugins[index].save = save_callback;
 2934|       |
 2935|  4.99k|    return true;
 2936|  8.39k|}
new_messenger:
 3513|    965|{
 3514|    965|    if (options == nullptr) {
  ------------------
  |  |   66|    965|#define nullptr NULL
  ------------------
  |  Branch (3514:9): [True: 0, False: 965]
  ------------------
 3515|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3516|      0|    }
 3517|       |
 3518|    965|    if (error != nullptr) {
  ------------------
  |  |   66|    965|#define nullptr NULL
  ------------------
  |  Branch (3518:9): [True: 965, False: 0]
  ------------------
 3519|    965|        *error = MESSENGER_ERROR_OTHER;
 3520|    965|    }
 3521|       |
 3522|    965|    Messenger *m = (Messenger *)mem_alloc(mem, sizeof(Messenger));
 3523|       |
 3524|    965|    if (m == nullptr) {
  ------------------
  |  |   66|    965|#define nullptr NULL
  ------------------
  |  Branch (3524:9): [True: 1, False: 964]
  ------------------
 3525|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 3526|      1|    }
 3527|       |
 3528|    964|    m->mono_time = mono_time;
 3529|    964|    m->mem = mem;
 3530|    964|    m->rng = rng;
 3531|    964|    m->ns = ns;
 3532|       |
 3533|    964|    m->fr = friendreq_new();
 3534|       |
 3535|    964|    if (m->fr == nullptr) {
  ------------------
  |  |   66|    964|#define nullptr NULL
  ------------------
  |  Branch (3535:9): [True: 0, False: 964]
  ------------------
 3536|      0|        mem_delete(mem, m);
 3537|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3538|      0|    }
 3539|       |
 3540|    964|    m->log = logger_new();
 3541|       |
 3542|    964|    if (m->log == nullptr) {
  ------------------
  |  |   66|    964|#define nullptr NULL
  ------------------
  |  Branch (3542:9): [True: 0, False: 964]
  ------------------
 3543|      0|        friendreq_kill(m->fr);
 3544|      0|        mem_delete(mem, m);
 3545|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3546|      0|    }
 3547|       |
 3548|    964|    logger_callback_log(m->log, options->log_callback, options->log_context, options->log_user_data);
 3549|       |
 3550|    964|    unsigned int net_err = 0;
 3551|       |
 3552|    964|    if (!options->udp_disabled && options->proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (3552:9): [True: 964, False: 0]
  |  Branch (3552:35): [True: 277, False: 687]
  ------------------
 3553|       |        // We don't currently support UDP over proxy.
 3554|    277|        LOGGER_INFO(m->log, "UDP enabled and proxy set: disabling UDP");
  ------------------
  |  |   81|    277|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    277|    do {                                                                         \
  |  |  |  |   73|    277|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    554|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    277|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    277|        }                                                                        \
  |  |  |  |   76|    277|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3555|    277|        options->udp_disabled = true;
 3556|    277|    }
 3557|       |
 3558|    964|    if (options->udp_disabled) {
  ------------------
  |  Branch (3558:9): [True: 277, False: 687]
  ------------------
 3559|    277|        m->net = new_networking_no_udp(m->log, m->mem, m->ns);
 3560|    687|    } else {
 3561|    687|        IP ip;
 3562|    687|        ip_init(&ip, options->ipv6enabled);
 3563|    687|        m->net = new_networking_ex(m->log, m->mem, m->ns, &ip, options->port_range[0], options->port_range[1], &net_err);
 3564|    687|    }
 3565|       |
 3566|    964|    if (m->net == nullptr) {
  ------------------
  |  |   66|    964|#define nullptr NULL
  ------------------
  |  Branch (3566:9): [True: 2, False: 962]
  ------------------
 3567|      2|        friendreq_kill(m->fr);
 3568|      2|        logger_kill(m->log);
 3569|      2|        mem_delete(mem, m);
 3570|       |
 3571|      2|        if (error != nullptr && net_err == 1) {
  ------------------
  |  |   66|      4|#define nullptr NULL
  ------------------
  |  Branch (3571:13): [True: 2, False: 0]
  |  Branch (3571:33): [True: 0, False: 2]
  ------------------
 3572|      0|            *error = MESSENGER_ERROR_PORT;
 3573|      0|        }
 3574|       |
 3575|      2|        return nullptr;
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
 3576|      2|    }
 3577|       |
 3578|    962|    m->dht = new_dht(m->log, m->mem, m->rng, m->ns, m->mono_time, m->net, options->hole_punching_enabled, options->local_discovery_enabled);
 3579|       |
 3580|    962|    if (m->dht == nullptr) {
  ------------------
  |  |   66|    962|#define nullptr NULL
  ------------------
  |  Branch (3580:9): [True: 14, False: 948]
  ------------------
 3581|     14|        kill_networking(m->net);
 3582|     14|        friendreq_kill(m->fr);
 3583|     14|        logger_kill(m->log);
 3584|     14|        mem_delete(mem, m);
 3585|     14|        return nullptr;
  ------------------
  |  |   66|     14|#define nullptr NULL
  ------------------
 3586|     14|    }
 3587|       |
 3588|    948|    m->net_crypto = new_net_crypto(m->log, m->mem, m->rng, m->ns, m->mono_time, m->dht, &options->proxy_info);
 3589|       |
 3590|    948|    if (m->net_crypto == nullptr) {
  ------------------
  |  |   66|    948|#define nullptr NULL
  ------------------
  |  Branch (3590:9): [True: 2, False: 946]
  ------------------
 3591|      2|        kill_dht(m->dht);
 3592|      2|        kill_networking(m->net);
 3593|      2|        friendreq_kill(m->fr);
 3594|      2|        logger_kill(m->log);
 3595|      2|        mem_delete(mem, m);
 3596|      2|        return nullptr;
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
 3597|      2|    }
 3598|       |
 3599|    946|#ifndef VANILLA_NACL
 3600|    946|    m->group_announce = new_gca_list();
 3601|       |
 3602|    946|    if (m->group_announce == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (3602:9): [True: 0, False: 946]
  ------------------
 3603|      0|        kill_net_crypto(m->net_crypto);
 3604|      0|        kill_dht(m->dht);
 3605|      0|        kill_networking(m->net);
 3606|      0|        friendreq_kill(m->fr);
 3607|      0|        logger_kill(m->log);
 3608|      0|        mem_delete(mem, m);
 3609|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3610|      0|    }
 3611|       |
 3612|    946|#endif /* VANILLA_NACL */
 3613|       |
 3614|    946|    if (options->dht_announcements_enabled) {
  ------------------
  |  Branch (3614:9): [True: 946, False: 0]
  ------------------
 3615|    946|        m->forwarding = new_forwarding(m->log, m->rng, m->mono_time, m->dht);
 3616|    946|        m->announce = new_announcements(m->log, m->mem, m->rng, m->mono_time, m->forwarding);
 3617|    946|    } else {
 3618|      0|        m->forwarding = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3619|      0|        m->announce = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3620|      0|    }
 3621|       |
 3622|    946|    m->onion = new_onion(m->log, m->mem, m->mono_time, m->rng, m->dht);
 3623|    946|    m->onion_a = new_onion_announce(m->log, m->mem, m->rng, m->mono_time, m->dht);
 3624|    946|    m->onion_c = new_onion_client(m->log, m->mem, m->rng, m->mono_time, m->net_crypto);
 3625|    946|    m->fr_c = new_friend_connections(m->log, m->mono_time, m->ns, m->onion_c, options->local_discovery_enabled);
 3626|       |
 3627|    946|    if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   66|  1.89k|#define nullptr NULL
  ------------------
                  if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (3627:10): [True: 946, False: 0]
  |  Branch (3627:49): [True: 0, False: 946]
  |  Branch (3627:77): [True: 5, False: 941]
  ------------------
 3628|    946|            m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   66|  1.88k|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   66|  1.88k|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   66|  1.88k|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
  |  Branch (3628:13): [True: 4, False: 937]
  |  Branch (3628:36): [True: 1, False: 936]
  |  Branch (3628:61): [True: 1, False: 935]
  |  Branch (3628:86): [True: 0, False: 935]
  ------------------
 3629|     11|        kill_onion(m->onion);
 3630|     11|        kill_onion_announce(m->onion_a);
 3631|     11|        kill_onion_client(m->onion_c);
 3632|     11|#ifndef VANILLA_NACL
 3633|     11|        kill_gca(m->group_announce);
 3634|     11|#endif /* VANILLA_NACL */
 3635|     11|        kill_friend_connections(m->fr_c);
 3636|     11|        kill_announcements(m->announce);
 3637|     11|        kill_forwarding(m->forwarding);
 3638|     11|        kill_net_crypto(m->net_crypto);
 3639|     11|        kill_dht(m->dht);
 3640|     11|        kill_networking(m->net);
 3641|     11|        friendreq_kill(m->fr);
 3642|     11|        logger_kill(m->log);
 3643|     11|        mem_delete(mem, m);
 3644|     11|        return nullptr;
  ------------------
  |  |   66|     11|#define nullptr NULL
  ------------------
 3645|     11|    }
 3646|       |
 3647|    935|#ifndef VANILLA_NACL
 3648|    935|    gca_onion_init(m->group_announce, m->onion_a);
 3649|       |
 3650|    935|    m->group_handler = new_dht_groupchats(m);
 3651|       |
 3652|    935|    if (m->group_handler == nullptr) {
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
  |  Branch (3652:9): [True: 0, False: 935]
  ------------------
 3653|      0|        kill_onion(m->onion);
 3654|      0|        kill_onion_announce(m->onion_a);
 3655|      0|        kill_onion_client(m->onion_c);
 3656|      0|        kill_gca(m->group_announce);
 3657|      0|        kill_friend_connections(m->fr_c);
 3658|      0|        kill_announcements(m->announce);
 3659|      0|        kill_forwarding(m->forwarding);
 3660|      0|        kill_net_crypto(m->net_crypto);
 3661|      0|        kill_dht(m->dht);
 3662|      0|        kill_networking(m->net);
 3663|      0|        friendreq_kill(m->fr);
 3664|      0|        logger_kill(m->log);
 3665|      0|        mem_delete(mem, m);
 3666|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3667|      0|    }
 3668|       |
 3669|    935|#endif /* VANILLA_NACL */
 3670|       |
 3671|    935|    if (options->tcp_server_port != 0) {
  ------------------
  |  Branch (3671:9): [True: 147, False: 788]
  ------------------
 3672|    147|        m->tcp_server = new_tcp_server(m->log, m->mem, m->rng, m->ns, options->ipv6enabled, 1,
 3673|    147|                                       &options->tcp_server_port, dht_get_self_secret_key(m->dht),
 3674|    147|                                       m->onion, m->forwarding);
 3675|       |
 3676|    147|        if (m->tcp_server == nullptr) {
  ------------------
  |  |   66|    147|#define nullptr NULL
  ------------------
  |  Branch (3676:13): [True: 2, False: 145]
  ------------------
 3677|      2|            kill_onion(m->onion);
 3678|      2|            kill_onion_announce(m->onion_a);
 3679|      2|#ifndef VANILLA_NACL
 3680|      2|            kill_dht_groupchats(m->group_handler);
 3681|      2|#endif
 3682|      2|            kill_friend_connections(m->fr_c);
 3683|      2|            kill_onion_client(m->onion_c);
 3684|      2|#ifndef VANILLA_NACL
 3685|      2|            kill_gca(m->group_announce);
 3686|      2|#endif
 3687|      2|            kill_announcements(m->announce);
 3688|      2|            kill_forwarding(m->forwarding);
 3689|      2|            kill_net_crypto(m->net_crypto);
 3690|      2|            kill_dht(m->dht);
 3691|      2|            kill_networking(m->net);
 3692|      2|            friendreq_kill(m->fr);
 3693|      2|            logger_kill(m->log);
 3694|      2|            mem_delete(mem, m);
 3695|       |
 3696|      2|            if (error != nullptr) {
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
  |  Branch (3696:17): [True: 2, False: 0]
  ------------------
 3697|      2|                *error = MESSENGER_ERROR_TCP_SERVER;
 3698|      2|            }
 3699|       |
 3700|      2|            return nullptr;
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
 3701|      2|        }
 3702|    147|    }
 3703|       |
 3704|    933|    m->options = *options;
 3705|    933|    friendreq_init(m->fr, m->fr_c);
 3706|    933|    set_nospam(m->fr, random_u32(m->rng));
 3707|    933|    set_filter_function(m->fr, &friend_already_added, m);
 3708|       |
 3709|    933|    m->lastdump = 0;
 3710|    933|    m->is_receiving_file = 0;
 3711|       |
 3712|    933|    m_register_default_plugins(m);
 3713|    933|    callback_friendrequest(m->fr, m_handle_friend_request, m);
 3714|       |
 3715|    933|    if (error != nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (3715:9): [True: 933, False: 0]
  ------------------
 3716|    933|        *error = MESSENGER_ERROR_NONE;
 3717|    933|    }
 3718|       |
 3719|    933|    return m;
 3720|    935|}
kill_messenger:
 3727|    933|{
 3728|    933|    if (m == nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (3728:9): [True: 0, False: 933]
  ------------------
 3729|      0|        return;
 3730|      0|    }
 3731|       |
 3732|    933|    if (m->tcp_server != nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (3732:9): [True: 145, False: 788]
  ------------------
 3733|    145|        kill_tcp_server(m->tcp_server);
 3734|    145|    }
 3735|       |
 3736|    933|    kill_onion(m->onion);
 3737|    933|    kill_onion_announce(m->onion_a);
 3738|    933|#ifndef VANILLA_NACL
 3739|    933|    kill_dht_groupchats(m->group_handler);
 3740|    933|#endif
 3741|    933|    kill_friend_connections(m->fr_c);
 3742|    933|    kill_onion_client(m->onion_c);
 3743|    933|#ifndef VANILLA_NACL
 3744|    933|    kill_gca(m->group_announce);
 3745|    933|#endif
 3746|    933|    kill_announcements(m->announce);
 3747|    933|    kill_forwarding(m->forwarding);
 3748|    933|    kill_net_crypto(m->net_crypto);
 3749|    933|    kill_dht(m->dht);
 3750|    933|    kill_networking(m->net);
 3751|       |
 3752|  1.05k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (3752:26): [True: 121, False: 933]
  ------------------
 3753|    121|        clear_receipts(m, i);
 3754|    121|    }
 3755|       |
 3756|    933|    logger_kill(m->log);
 3757|    933|    mem_delete(m->mem, m->friendlist);
 3758|    933|    friendreq_kill(m->fr);
 3759|       |
 3760|    933|    mem_delete(m->mem, m->options.state_plugins);
 3761|    933|    mem_delete(m->mem, m);
 3762|    933|}
Messenger.c:init_new_friend:
  148|    121|{
  149|    121|    if (m->numfriends == UINT32_MAX) {
  ------------------
  |  Branch (149:9): [True: 0, False: 121]
  ------------------
  150|      0|        LOGGER_ERROR(m->log, "Friend list full: we have more than 4 billion friends");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  151|       |        /* This is technically incorrect, but close enough. */
  152|      0|        return FAERR_NOMEM;
  153|      0|    }
  154|       |
  155|       |    /* Resize the friend list if necessary. */
  156|    121|    if (realloc_friendlist(m, m->numfriends + 1) != 0) {
  ------------------
  |  Branch (156:9): [True: 0, False: 121]
  ------------------
  157|      0|        return FAERR_NOMEM;
  158|      0|    }
  159|       |
  160|    121|    m->friendlist[m->numfriends] = empty_friend;
  161|       |
  162|    121|    const int friendcon_id = new_friend_connection(m->fr_c, real_pk);
  163|       |
  164|    121|    if (friendcon_id == -1) {
  ------------------
  |  Branch (164:9): [True: 0, False: 121]
  ------------------
  165|      0|        return FAERR_NOMEM;
  166|      0|    }
  167|       |
  168|    289|    for (uint32_t i = 0; i <= m->numfriends; ++i) {
  ------------------
  |  Branch (168:26): [True: 289, False: 0]
  ------------------
  169|    289|        if (m->friendlist[i].status == NOFRIEND) {
  ------------------
  |  Branch (169:13): [True: 121, False: 168]
  ------------------
  170|    121|            m->friendlist[i].status = status;
  171|    121|            m->friendlist[i].friendcon_id = friendcon_id;
  172|    121|            m->friendlist[i].friendrequest_lastsent = 0;
  173|    121|            pk_copy(m->friendlist[i].real_pk, real_pk);
  174|    121|            m->friendlist[i].statusmessage_length = 0;
  175|    121|            m->friendlist[i].userstatus = USERSTATUS_NONE;
  176|    121|            m->friendlist[i].is_typing = false;
  177|    121|            m->friendlist[i].message_id = 0;
  178|    121|            friend_connection_callbacks(m->fr_c, friendcon_id, MESSENGER_CALLBACK_INDEX, &m_handle_status, &m_handle_packet,
  ------------------
  |  |   18|    121|#define MESSENGER_CALLBACK_INDEX 0
  ------------------
  179|    121|                                        &m_handle_lossy_packet, m, i);
  180|       |
  181|    121|            if (m->numfriends == i) {
  ------------------
  |  Branch (181:17): [True: 121, False: 0]
  ------------------
  182|    121|                ++m->numfriends;
  183|    121|            }
  184|       |
  185|    121|            if (friend_con_connected(m->fr_c, friendcon_id) == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (185:17): [True: 0, False: 121]
  ------------------
  186|      0|                send_online_packet(m, friendcon_id);
  187|      0|            }
  188|       |
  189|    121|            return i;
  190|    121|        }
  191|    289|    }
  192|       |
  193|      0|    return FAERR_NOMEM;
  194|    121|}
Messenger.c:m_add_friend_contact_norequest:
  198|    121|{
  199|    121|    if (getfriend_id(m, real_pk) != -1) {
  ------------------
  |  Branch (199:9): [True: 0, False: 121]
  ------------------
  200|      0|        return FAERR_ALREADYSENT;
  201|      0|    }
  202|       |
  203|    121|    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (203:9): [True: 0, False: 121]
  ------------------
  204|      0|        return FAERR_OWNKEY;
  205|      0|    }
  206|       |
  207|    121|    return init_new_friend(m, real_pk, FRIEND_CONFIRMED);
  208|    121|}
Messenger.c:clear_receipts:
  307|    121|{
  308|    121|    if (!m_friend_exists(m, friendnumber)) {
  ------------------
  |  Branch (308:9): [True: 0, False: 121]
  ------------------
  309|      0|        return -1;
  310|      0|    }
  311|       |
  312|    121|    struct Receipts *receipts = m->friendlist[friendnumber].receipts_start;
  313|       |
  314|    121|    while (receipts != nullptr) {
  ------------------
  |  |   66|    121|#define nullptr NULL
  ------------------
  |  Branch (314:12): [True: 0, False: 121]
  ------------------
  315|      0|        struct Receipts *temp_r = receipts->next;
  316|      0|        mem_delete(m->mem, receipts);
  317|      0|        receipts = temp_r;
  318|      0|    }
  319|       |
  320|    121|    m->friendlist[friendnumber].receipts_start = nullptr;
  ------------------
  |  |   66|    121|#define nullptr NULL
  ------------------
  321|    121|    m->friendlist[friendnumber].receipts_end = nullptr;
  ------------------
  |  |   66|    121|#define nullptr NULL
  ------------------
  322|    121|    return 0;
  323|    121|}
Messenger.c:realloc_friendlist:
   48|    121|{
   49|    121|    if (num == 0) {
  ------------------
  |  Branch (49:9): [True: 0, False: 121]
  ------------------
   50|      0|        mem_delete(m->mem, m->friendlist);
   51|      0|        m->friendlist = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   52|      0|        return 0;
   53|      0|    }
   54|       |
   55|    121|    Friend *newfriendlist = (Friend *)mem_vrealloc(m->mem, m->friendlist, num, sizeof(Friend));
   56|       |
   57|    121|    if (newfriendlist == nullptr) {
  ------------------
  |  |   66|    121|#define nullptr NULL
  ------------------
  |  Branch (57:9): [True: 0, False: 121]
  ------------------
   58|      0|        return -1;
   59|      0|    }
   60|       |
   61|    121|    m->friendlist = newfriendlist;
   62|    121|    return 0;
   63|    121|}
Messenger.c:do_friends:
 2415|  72.6k|{
 2416|  72.6k|    const uint64_t temp_time = mono_time_get(m->mono_time);
 2417|       |
 2418|  74.9k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (2418:26): [True: 2.26k, False: 72.6k]
  ------------------
 2419|  2.26k|        if (m->friendlist[i].status == FRIEND_ADDED) {
  ------------------
  |  Branch (2419:13): [True: 0, False: 2.26k]
  ------------------
 2420|      0|            const int fr = send_friend_request_packet(m->fr_c, m->friendlist[i].friendcon_id, m->friendlist[i].friendrequest_nospam,
 2421|      0|                                                m->friendlist[i].info,
 2422|      0|                                                m->friendlist[i].info_size);
 2423|       |
 2424|      0|            if (fr >= 0) {
  ------------------
  |  Branch (2424:17): [True: 0, False: 0]
  ------------------
 2425|      0|                set_friend_status(m, i, FRIEND_REQUESTED, userdata);
 2426|      0|                m->friendlist[i].friendrequest_lastsent = temp_time;
 2427|      0|            }
 2428|      0|        }
 2429|       |
 2430|  2.26k|        if (m->friendlist[i].status == FRIEND_REQUESTED
  ------------------
  |  Branch (2430:13): [True: 0, False: 2.26k]
  ------------------
 2431|  2.26k|                || m->friendlist[i].status == FRIEND_CONFIRMED) { /* friend is not online. */
  ------------------
  |  Branch (2431:20): [True: 2.26k, False: 0]
  ------------------
 2432|  2.26k|            if (m->friendlist[i].status == FRIEND_REQUESTED) {
  ------------------
  |  Branch (2432:17): [True: 0, False: 2.26k]
  ------------------
 2433|       |                /* If we didn't connect to friend after successfully sending him a friend request the request is deemed
 2434|       |                 * unsuccessful so we set the status back to FRIEND_ADDED and try again.
 2435|       |                 */
 2436|      0|                check_friend_request_timed_out(m, i, temp_time, userdata);
 2437|      0|            }
 2438|  2.26k|        }
 2439|       |
 2440|  2.26k|        if (m->friendlist[i].status == FRIEND_ONLINE) { /* friend is online. */
  ------------------
  |  Branch (2440:13): [True: 0, False: 2.26k]
  ------------------
 2441|      0|            if (!m->friendlist[i].name_sent) {
  ------------------
  |  Branch (2441:17): [True: 0, False: 0]
  ------------------
 2442|      0|                if (m_sendname(m, i, m->name, m->name_length)) {
  ------------------
  |  Branch (2442:21): [True: 0, False: 0]
  ------------------
 2443|      0|                    m->friendlist[i].name_sent = true;
 2444|      0|                }
 2445|      0|            }
 2446|       |
 2447|      0|            if (!m->friendlist[i].statusmessage_sent) {
  ------------------
  |  Branch (2447:17): [True: 0, False: 0]
  ------------------
 2448|      0|                if (send_statusmessage(m, i, m->statusmessage, m->statusmessage_length)) {
  ------------------
  |  Branch (2448:21): [True: 0, False: 0]
  ------------------
 2449|      0|                    m->friendlist[i].statusmessage_sent = true;
 2450|      0|                }
 2451|      0|            }
 2452|       |
 2453|      0|            if (!m->friendlist[i].userstatus_sent) {
  ------------------
  |  Branch (2453:17): [True: 0, False: 0]
  ------------------
 2454|      0|                if (send_userstatus(m, i, m->userstatus)) {
  ------------------
  |  Branch (2454:21): [True: 0, False: 0]
  ------------------
 2455|      0|                    m->friendlist[i].userstatus_sent = true;
 2456|      0|                }
 2457|      0|            }
 2458|       |
 2459|      0|            if (!m->friendlist[i].user_istyping_sent) {
  ------------------
  |  Branch (2459:17): [True: 0, False: 0]
  ------------------
 2460|      0|                if (send_user_istyping(m, i, m->friendlist[i].user_istyping)) {
  ------------------
  |  Branch (2460:21): [True: 0, False: 0]
  ------------------
 2461|      0|                    m->friendlist[i].user_istyping_sent = true;
 2462|      0|                }
 2463|      0|            }
 2464|       |
 2465|      0|            check_friend_tcp_udp(m, i, userdata);
 2466|      0|            do_receipts(m, i, userdata);
 2467|      0|            do_reqchunk_filecb(m, i, userdata);
 2468|       |
 2469|      0|            m->friendlist[i].last_seen_time = (uint64_t) time(nullptr);
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2470|      0|        }
 2471|  2.26k|    }
 2472|  72.6k|}
Messenger.c:do_gc_onion_friends:
 2591|  72.6k|{
 2592|  72.6k|    const uint16_t num_friends = onion_get_friend_count(m->onion_c);
 2593|       |
 2594|  74.9k|    for (uint16_t i = 0; i < num_friends; ++i) {
  ------------------
  |  Branch (2594:26): [True: 2.26k, False: 72.6k]
  ------------------
 2595|  2.26k|        Onion_Friend *onion_friend = onion_get_friend(m->onion_c, i);
 2596|       |
 2597|  2.26k|        if (!onion_friend_is_groupchat(onion_friend)) {
  ------------------
  |  Branch (2597:13): [True: 2.26k, False: 0]
  ------------------
 2598|  2.26k|            continue;
 2599|  2.26k|        }
 2600|       |
 2601|      0|        GC_Chat *chat = gc_get_group_by_public_key(m->group_handler, onion_friend_get_gc_public_key(onion_friend));
 2602|       |
 2603|      0|        if (chat == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (2603:13): [True: 0, False: 0]
  ------------------
 2604|      0|            continue;
 2605|      0|        }
 2606|       |
 2607|      0|        if (chat->update_self_announces) {
  ------------------
  |  Branch (2607:13): [True: 0, False: 0]
  ------------------
 2608|      0|            self_announce_group(m, chat, onion_friend);
 2609|      0|        }
 2610|      0|    }
 2611|  72.6k|}
Messenger.c:m_connection_status_callback:
 2476|  72.6k|{
 2477|  72.6k|    const Onion_Connection_Status conn_status = onion_connection_status(m->onion_c);
 2478|       |
 2479|  72.6k|    if (conn_status != m->last_connection_status) {
  ------------------
  |  Branch (2479:9): [True: 0, False: 72.6k]
  ------------------
 2480|      0|        if (m->core_connection_change != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (2480:13): [True: 0, False: 0]
  ------------------
 2481|      0|            m->core_connection_change(m, conn_status, userdata);
 2482|      0|        }
 2483|       |
 2484|      0|        m->last_connection_status = conn_status;
 2485|      0|    }
 2486|  72.6k|}
Messenger.c:friend_already_added:
 1977|    128|{
 1978|    128|    const Messenger *m = (const Messenger *)data;
 1979|       |
 1980|    128|    if (getfriend_id(m, real_pk) == -1) {
  ------------------
  |  Branch (1980:9): [True: 128, False: 0]
  ------------------
 1981|    128|        return 0;
 1982|    128|    }
 1983|       |
 1984|      0|    return -1;
 1985|    128|}
Messenger.c:m_register_default_plugins:
 3414|    933|{
 3415|    933|    m_register_state_plugin(m, STATE_TYPE_NOSPAMKEYS, nospam_keys_size, load_nospam_keys, save_nospam_keys);
 3416|    933|    m_register_state_plugin(m, STATE_TYPE_DHT, m_dht_size, m_dht_load, save_dht);
 3417|    933|    m_register_state_plugin(m, STATE_TYPE_FRIENDS, saved_friendslist_size, friends_list_load, friends_list_save);
 3418|    933|    m_register_state_plugin(m, STATE_TYPE_NAME, name_size, load_name, save_name);
 3419|    933|    m_register_state_plugin(m, STATE_TYPE_STATUSMESSAGE, status_message_size, load_status_message,
 3420|    933|                            save_status_message);
 3421|    933|    m_register_state_plugin(m, STATE_TYPE_STATUS, status_size, load_status, save_status);
 3422|    933|#ifndef VANILLA_NACL
 3423|    933|    m_register_state_plugin(m, STATE_TYPE_GROUPS, saved_groups_size, groups_load, groups_save);
 3424|    933|#endif
 3425|    933|    m_register_state_plugin(m, STATE_TYPE_TCP_RELAY, tcp_relay_size, load_tcp_relays, save_tcp_relays);
 3426|    933|    m_register_state_plugin(m, STATE_TYPE_PATH_NODE, path_node_size, load_path_nodes, save_path_nodes);
 3427|    933|}
Messenger.c:m_handle_friend_request:
 3498|    128|{
 3499|    128|    Messenger *m = (Messenger *)object;
 3500|    128|    assert(m != nullptr);
 3501|      0|    m->friend_request(m, public_key, message, length, user_data);
 3502|    128|}

tcp_con_public_key:
   70|    197|{
   71|    197|    return con->public_key;
   72|    197|}
tcp_con_ip_port:
   75|    138|{
   76|    138|    return con->ip_port;
   77|    138|}
tcp_con_status:
   80|  6.67k|{
   81|  6.67k|    return con->status;
   82|  6.67k|}
tcp_con_custom_object:
   84|     39|{
   85|     39|    return con->custom_object;
   86|     39|}
tcp_con_custom_uint:
   88|     39|{
   89|     39|    return con->custom_uint;
   90|     39|}
tcp_con_set_custom_object:
   92|    188|{
   93|    188|    con->custom_object = object;
   94|    188|}
tcp_con_set_custom_uint:
   96|    188|{
   97|    188|    con->custom_uint = value;
   98|    188|}
routing_response_handler:
  357|    188|{
  358|    188|    con->response_callback = response_callback;
  359|    188|    con->response_callback_object = object;
  360|    188|}
routing_status_handler:
  363|    188|{
  364|    188|    con->status_callback = status_callback;
  365|    188|    con->status_callback_object = object;
  366|    188|}
routing_data_handler:
  438|    188|{
  439|    188|    con->data_callback = data_callback;
  440|    188|    con->data_callback_object = object;
  441|    188|}
oob_data_handler:
  444|    188|{
  445|    188|    con->oob_data_callback = oob_data_callback;
  446|    188|    con->oob_data_callback_object = object;
  447|    188|}
onion_response_handler:
  539|    188|{
  540|    188|    con->onion_callback = onion_callback;
  541|    188|    con->onion_callback_object = object;
  542|    188|}
forwarding_handler:
  567|    188|{
  568|    188|    con->forwarded_response_callback = forwarded_response_callback;
  569|    188|    con->forwarded_response_callback_object = object;
  570|    188|}
new_tcp_connection:
  577|    548|{
  578|    548|    assert(logger != nullptr);
  579|      0|    assert(mem != nullptr);
  580|      0|    assert(mono_time != nullptr);
  581|      0|    assert(rng != nullptr);
  582|      0|    assert(ns != nullptr);
  583|       |
  584|    548|    if (!net_family_is_ipv4(ip_port->ip.family) && !net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (584:9): [True: 0, False: 548]
  |  Branch (584:52): [True: 0, False: 0]
  ------------------
  585|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  586|      0|    }
  587|       |
  588|    548|    const TCP_Proxy_Info default_proxyinfo = {{{{0}}}};
  589|       |
  590|    548|    if (proxy_info == nullptr) {
  ------------------
  |  |   66|    548|#define nullptr NULL
  ------------------
  |  Branch (590:9): [True: 0, False: 548]
  ------------------
  591|      0|        proxy_info = &default_proxyinfo;
  592|      0|    }
  593|       |
  594|    548|    Family family = ip_port->ip.family;
  595|       |
  596|    548|    if (proxy_info->proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (596:9): [True: 304, False: 244]
  ------------------
  597|    304|        family = proxy_info->ip_port.ip.family;
  598|    304|    }
  599|       |
  600|    548|    const Socket sock = net_socket(ns, family, TOX_SOCK_STREAM, TOX_PROTO_TCP);
  ------------------
  |  |  212|    548|#define TOX_SOCK_STREAM 1
  ------------------
                  const Socket sock = net_socket(ns, family, TOX_SOCK_STREAM, TOX_PROTO_TCP);
  ------------------
  |  |  215|    548|#define TOX_PROTO_TCP 1
  ------------------
  601|       |
  602|    548|    if (!sock_valid(sock)) {
  ------------------
  |  Branch (602:9): [True: 0, False: 548]
  ------------------
  603|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  604|      0|    }
  605|       |
  606|    548|    if (!set_socket_nosigpipe(ns, sock)) {
  ------------------
  |  Branch (606:9): [True: 0, False: 548]
  ------------------
  607|      0|        kill_sock(ns, sock);
  608|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  609|      0|    }
  610|       |
  611|    548|    if (!(set_socket_nonblock(ns, sock) && connect_sock_to(logger, mem, sock, ip_port, proxy_info))) {
  ------------------
  |  Branch (611:11): [True: 548, False: 0]
  |  Branch (611:44): [True: 548, False: 0]
  ------------------
  612|      0|        kill_sock(ns, sock);
  613|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  614|      0|    }
  615|       |
  616|    548|    TCP_Client_Connection *temp = (TCP_Client_Connection *)mem_alloc(mem, sizeof(TCP_Client_Connection));
  617|       |
  618|    548|    if (temp == nullptr) {
  ------------------
  |  |   66|    548|#define nullptr NULL
  ------------------
  |  Branch (618:9): [True: 33, False: 515]
  ------------------
  619|     33|        kill_sock(ns, sock);
  620|     33|        return nullptr;
  ------------------
  |  |   66|     33|#define nullptr NULL
  ------------------
  621|     33|    }
  622|       |
  623|    515|    temp->con.ns = ns;
  624|    515|    temp->con.mem = mem;
  625|    515|    temp->con.rng = rng;
  626|    515|    temp->con.sock = sock;
  627|    515|    temp->con.ip_port = *ip_port;
  628|    515|    memcpy(temp->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    515|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  629|    515|    memcpy(temp->self_public_key, self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    515|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  630|    515|    encrypt_precompute(temp->public_key, self_secret_key, temp->con.shared_key);
  631|    515|    temp->ip_port = *ip_port;
  632|    515|    temp->proxy_info = *proxy_info;
  633|       |
  634|    515|    switch (proxy_info->proxy_type) {
  ------------------
  |  Branch (634:13): [True: 0, False: 515]
  ------------------
  635|    261|        case TCP_PROXY_HTTP: {
  ------------------
  |  Branch (635:9): [True: 261, False: 254]
  ------------------
  636|    261|            temp->status = TCP_CLIENT_PROXY_HTTP_CONNECTING;
  637|    261|            proxy_http_generate_connection_request(temp);
  638|    261|            break;
  639|      0|        }
  640|       |
  641|     27|        case TCP_PROXY_SOCKS5: {
  ------------------
  |  Branch (641:9): [True: 27, False: 488]
  ------------------
  642|     27|            temp->status = TCP_CLIENT_PROXY_SOCKS5_CONNECTING;
  643|     27|            proxy_socks5_generate_greetings(temp);
  644|     27|            break;
  645|      0|        }
  646|       |
  647|    227|        case TCP_PROXY_NONE: {
  ------------------
  |  Branch (647:9): [True: 227, False: 288]
  ------------------
  648|    227|            temp->status = TCP_CLIENT_CONNECTING;
  649|       |
  650|    227|            if (generate_handshake(temp) == -1) {
  ------------------
  |  Branch (650:17): [True: 0, False: 227]
  ------------------
  651|      0|                kill_sock(ns, sock);
  652|      0|                mem_delete(mem, temp);
  653|      0|                return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  654|      0|            }
  655|       |
  656|    227|            break;
  657|    227|        }
  658|    515|    }
  659|       |
  660|    515|    temp->kill_at = mono_time_get(mono_time) + TCP_CONNECTION_TIMEOUT;
  ------------------
  |  |   17|    515|#define TCP_CONNECTION_TIMEOUT 10
  ------------------
  661|       |
  662|    515|    return temp;
  663|    515|}
do_tcp_connection:
  923|  4.36k|{
  924|  4.36k|    if (tcp_connection->status == TCP_CLIENT_DISCONNECTED) {
  ------------------
  |  Branch (924:9): [True: 0, False: 4.36k]
  ------------------
  925|      0|        return;
  926|      0|    }
  927|       |
  928|  4.36k|    if (tcp_connection->status == TCP_CLIENT_PROXY_HTTP_CONNECTING) {
  ------------------
  |  Branch (928:9): [True: 479, False: 3.88k]
  ------------------
  929|    479|        if (send_pending_data(logger, &tcp_connection->con) == 0) {
  ------------------
  |  Branch (929:13): [True: 479, False: 0]
  ------------------
  930|    479|            const int ret = proxy_http_read_connection_response(logger, tcp_connection);
  931|       |
  932|    479|            if (ret == -1) {
  ------------------
  |  Branch (932:17): [True: 11, False: 468]
  ------------------
  933|     11|                tcp_connection->kill_at = 0;
  934|     11|                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
  935|     11|            }
  936|       |
  937|    479|            if (ret == 1) {
  ------------------
  |  Branch (937:17): [True: 123, False: 356]
  ------------------
  938|    123|                generate_handshake(tcp_connection);
  939|    123|                tcp_connection->status = TCP_CLIENT_CONNECTING;
  940|    123|            }
  941|    479|        }
  942|    479|    }
  943|       |
  944|  4.36k|    if (tcp_connection->status == TCP_CLIENT_PROXY_SOCKS5_CONNECTING) {
  ------------------
  |  Branch (944:9): [True: 115, False: 4.25k]
  ------------------
  945|    115|        if (send_pending_data(logger, &tcp_connection->con) == 0) {
  ------------------
  |  Branch (945:13): [True: 115, False: 0]
  ------------------
  946|    115|            int ret = socks5_read_handshake_response(logger, tcp_connection);
  947|       |
  948|    115|            if (ret == -1) {
  ------------------
  |  Branch (948:17): [True: 7, False: 108]
  ------------------
  949|      7|                tcp_connection->kill_at = 0;
  950|      7|                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
  951|      7|            }
  952|       |
  953|    115|            if (ret == 1) {
  ------------------
  |  Branch (953:17): [True: 10, False: 105]
  ------------------
  954|     10|                proxy_socks5_generate_connection_request(tcp_connection);
  955|     10|                tcp_connection->status = TCP_CLIENT_PROXY_SOCKS5_UNCONFIRMED;
  956|     10|            }
  957|    115|        }
  958|    115|    }
  959|       |
  960|  4.36k|    if (tcp_connection->status == TCP_CLIENT_PROXY_SOCKS5_UNCONFIRMED) {
  ------------------
  |  Branch (960:9): [True: 78, False: 4.29k]
  ------------------
  961|     78|        if (send_pending_data(logger, &tcp_connection->con) == 0) {
  ------------------
  |  Branch (961:13): [True: 78, False: 0]
  ------------------
  962|     78|            int ret = proxy_socks5_read_connection_response(logger, tcp_connection);
  963|       |
  964|     78|            if (ret == -1) {
  ------------------
  |  Branch (964:17): [True: 5, False: 73]
  ------------------
  965|      5|                tcp_connection->kill_at = 0;
  966|      5|                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
  967|      5|            }
  968|       |
  969|     78|            if (ret == 1) {
  ------------------
  |  Branch (969:17): [True: 1, False: 77]
  ------------------
  970|      1|                generate_handshake(tcp_connection);
  971|      1|                tcp_connection->status = TCP_CLIENT_CONNECTING;
  972|      1|            }
  973|     78|        }
  974|     78|    }
  975|       |
  976|  4.36k|    if (tcp_connection->status == TCP_CLIENT_CONNECTING) {
  ------------------
  |  Branch (976:9): [True: 326, False: 4.04k]
  ------------------
  977|    326|        if (send_pending_data(logger, &tcp_connection->con) == 0) {
  ------------------
  |  Branch (977:13): [True: 326, False: 0]
  ------------------
  978|    326|            tcp_connection->status = TCP_CLIENT_UNCONFIRMED;
  979|    326|        }
  980|    326|    }
  981|       |
  982|  4.36k|    if (tcp_connection->status == TCP_CLIENT_UNCONFIRMED) {
  ------------------
  |  Branch (982:9): [True: 1.82k, False: 2.54k]
  ------------------
  983|  1.82k|        uint8_t data[TCP_SERVER_HANDSHAKE_SIZE];
  984|  1.82k|        const TCP_Connection *con = &tcp_connection->con;
  985|  1.82k|        const int len = read_tcp_packet(logger, con->mem, con->ns, con->sock, data, sizeof(data), &con->ip_port);
  986|       |
  987|  1.82k|        if (sizeof(data) == len) {
  ------------------
  |  Branch (987:13): [True: 205, False: 1.61k]
  ------------------
  988|    205|            if (handle_handshake(tcp_connection, data) == 0) {
  ------------------
  |  Branch (988:17): [True: 205, False: 0]
  ------------------
  989|    205|                tcp_connection->kill_at = UINT64_MAX;
  990|    205|                tcp_connection->status = TCP_CLIENT_CONFIRMED;
  991|    205|            } else {
  992|      0|                tcp_connection->kill_at = 0;
  993|      0|                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
  994|      0|            }
  995|    205|        }
  996|  1.82k|    }
  997|       |
  998|  4.36k|    if (tcp_connection->status == TCP_CLIENT_CONFIRMED) {
  ------------------
  |  Branch (998:9): [True: 2.21k, False: 2.15k]
  ------------------
  999|  2.21k|        do_confirmed_tcp(logger, tcp_connection, mono_time, userdata);
 1000|  2.21k|    }
 1001|       |
 1002|  4.36k|    if (tcp_connection->kill_at <= mono_time_get(mono_time)) {
  ------------------
  |  Branch (1002:9): [True: 37, False: 4.33k]
  ------------------
 1003|     37|        tcp_connection->status = TCP_CLIENT_DISCONNECTED;
 1004|     37|    }
 1005|  4.36k|}
kill_tcp_connection:
 1009|    544|{
 1010|    544|    if (tcp_connection == nullptr) {
  ------------------
  |  |   66|    544|#define nullptr NULL
  ------------------
  |  Branch (1010:9): [True: 29, False: 515]
  ------------------
 1011|     29|        return;
 1012|     29|    }
 1013|       |
 1014|    515|    const Memory *mem = tcp_connection->con.mem;
 1015|       |
 1016|    515|    wipe_priority_list(tcp_connection->con.mem, tcp_connection->con.priority_queue_start);
 1017|    515|    kill_sock(tcp_connection->con.ns, tcp_connection->con.sock);
 1018|    515|    crypto_memzero(tcp_connection, sizeof(TCP_Client_Connection));
 1019|    515|    mem_delete(mem, tcp_connection);
 1020|    515|}
TCP_client.c:tcp_send_ping_request:
  469|  2.41k|{
  470|  2.41k|    if (con->ping_request_id == 0) {
  ------------------
  |  Branch (470:9): [True: 2.21k, False: 205]
  ------------------
  471|  2.21k|        return 1;
  472|  2.21k|    }
  473|       |
  474|    205|    uint8_t packet[1 + sizeof(uint64_t)];
  475|    205|    packet[0] = TCP_PACKET_PING;
  ------------------
  |  |   45|    205|#define TCP_PACKET_PING 4
  ------------------
  476|    205|    memcpy(packet + 1, &con->ping_request_id, sizeof(uint64_t));
  477|    205|    const int ret = write_packet_tcp_secure_connection(logger, &con->con, packet, sizeof(packet), true);
  478|       |
  479|    205|    if (ret == 1) {
  ------------------
  |  Branch (479:9): [True: 205, False: 0]
  ------------------
  480|    205|        con->ping_request_id = 0;
  481|    205|    }
  482|       |
  483|    205|    return ret;
  484|  2.41k|}
TCP_client.c:tcp_send_ping_response:
  492|  2.21k|{
  493|  2.21k|    if (con->ping_response_id == 0) {
  ------------------
  |  Branch (493:9): [True: 2.21k, False: 1]
  ------------------
  494|  2.21k|        return 1;
  495|  2.21k|    }
  496|       |
  497|      1|    uint8_t packet[1 + sizeof(uint64_t)];
  498|      1|    packet[0] = TCP_PACKET_PONG;
  ------------------
  |  |   46|      1|#define TCP_PACKET_PONG 5
  ------------------
  499|      1|    memcpy(packet + 1, &con->ping_response_id, sizeof(uint64_t));
  500|      1|    const int ret = write_packet_tcp_secure_connection(logger, &con->con, packet, sizeof(packet), true);
  501|       |
  502|      1|    if (ret == 1) {
  ------------------
  |  Branch (502:9): [True: 1, False: 0]
  ------------------
  503|      1|        con->ping_response_id = 0;
  504|      1|    }
  505|       |
  506|      1|    return ret;
  507|  2.21k|}
TCP_client.c:connect_sock_to:
  106|    548|{
  107|    548|    if (proxy_info->proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (107:9): [True: 304, False: 244]
  ------------------
  108|    304|        return net_connect(mem, logger, sock, &proxy_info->ip_port);
  109|    304|    } else {
  110|    244|        return net_connect(mem, logger, sock, ip_port);
  111|    244|    }
  112|    548|}
TCP_client.c:proxy_http_generate_connection_request:
  120|    261|{
  121|    261|    char one[] = "CONNECT ";
  122|    261|    char two[] = " HTTP/1.1\nHost: ";
  123|    261|    char three[] = "\r\n\r\n";
  124|       |
  125|    261|    char ip[TOX_INET6_ADDRSTRLEN];
  126|       |
  127|    261|    if (!ip_parse_addr(&tcp_conn->ip_port.ip, ip, sizeof(ip))) {
  ------------------
  |  Branch (127:9): [True: 0, False: 261]
  ------------------
  128|      0|        return 0;
  129|      0|    }
  130|       |
  131|    261|    const uint16_t port = net_ntohs(tcp_conn->ip_port.port);
  132|    261|    const int written = snprintf((char *)tcp_conn->con.last_packet, MAX_PACKET_SIZE, "%s%s:%hu%s%s:%hu%s", one, ip, port,
  ------------------
  |  |   64|    261|#define MAX_PACKET_SIZE 2048
  ------------------
  133|    261|                                 two, ip, port, three);
  134|       |
  135|    261|    if (written < 0 || MAX_PACKET_SIZE < written) {
  ------------------
  |  |   64|    261|#define MAX_PACKET_SIZE 2048
  ------------------
  |  Branch (135:9): [True: 0, False: 261]
  |  Branch (135:24): [True: 0, False: 261]
  ------------------
  136|      0|        return 0;
  137|      0|    }
  138|       |
  139|    261|    tcp_conn->con.last_packet_length = written;
  140|    261|    tcp_conn->con.last_packet_sent = 0;
  141|    261|    return 1;
  142|    261|}
TCP_client.c:proxy_socks5_generate_greetings:
  199|     27|{
  200|     27|    tcp_conn->con.last_packet[0] = TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5;
  ------------------
  |  |  188|     27|#define TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 0x05
  ------------------
  201|     27|    tcp_conn->con.last_packet[1] = TCP_SOCKS5_PROXY_HS_AUTH_METHODS_SUPPORTED;
  ------------------
  |  |  191|     27|#define TCP_SOCKS5_PROXY_HS_AUTH_METHODS_SUPPORTED 0x01
  ------------------
  202|     27|    tcp_conn->con.last_packet[2] = TCP_SOCKS5_PROXY_HS_NO_AUTH;
  ------------------
  |  |  192|     27|#define TCP_SOCKS5_PROXY_HS_NO_AUTH 0x00
  ------------------
  203|       |
  204|     27|    tcp_conn->con.last_packet_length = 3;
  205|     27|    tcp_conn->con.last_packet_sent = 0;
  206|     27|}
TCP_client.c:generate_handshake:
  301|    351|{
  302|    351|    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE];
  303|    351|    crypto_new_keypair(tcp_conn->con.rng, plain, tcp_conn->temp_secret_key);
  304|    351|    random_nonce(tcp_conn->con.rng, tcp_conn->con.sent_nonce);
  305|    351|    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, tcp_conn->con.sent_nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   40|    351|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, tcp_conn->con.sent_nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|    351|#define CRYPTO_NONCE_SIZE              24
  ------------------
  306|    351|    memcpy(tcp_conn->con.last_packet, tcp_conn->self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    351|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  307|    351|    random_nonce(tcp_conn->con.rng, tcp_conn->con.last_packet + CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    351|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  308|    351|    const int len = encrypt_data_symmetric(tcp_conn->con.shared_key, tcp_conn->con.last_packet + CRYPTO_PUBLIC_KEY_SIZE, plain,
  ------------------
  |  |   40|    351|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  309|    351|                                     sizeof(plain), tcp_conn->con.last_packet + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   40|    351|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                   sizeof(plain), tcp_conn->con.last_packet + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|    351|#define CRYPTO_NONCE_SIZE              24
  ------------------
  310|       |
  311|    351|    if (len != sizeof(plain) + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   61|    351|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (311:9): [True: 0, False: 351]
  ------------------
  312|      0|        return -1;
  313|      0|    }
  314|       |
  315|    351|    tcp_conn->con.last_packet_length = CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE;
  ------------------
  |  |   40|    351|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  tcp_conn->con.last_packet_length = CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE;
  ------------------
  |  |   66|    351|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  tcp_conn->con.last_packet_length = CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE;
  ------------------
  |  |   61|    351|#define CRYPTO_MAC_SIZE                16
  ------------------
  316|    351|    tcp_conn->con.last_packet_sent = 0;
  317|    351|    return 0;
  318|    351|}
TCP_client.c:proxy_http_read_connection_response:
  151|    479|{
  152|    479|    char success[] = "200";
  153|    479|    uint8_t data[16]; // draining works the best if the length is a power of 2
  154|       |
  155|    479|    const TCP_Connection *con0 = &tcp_conn->con;
  156|    479|    const int ret = read_tcp_packet(logger, con0->mem, con0->ns, con0->sock, data, sizeof(data) - 1, &con0->ip_port);
  157|       |
  158|    479|    if (ret == -1) {
  ------------------
  |  Branch (158:9): [True: 345, False: 134]
  ------------------
  159|    345|        return 0;
  160|    345|    }
  161|       |
  162|    134|    data[sizeof(data) - 1] = 0;
  163|       |
  164|    134|    if (strstr((const char *)data, success) != nullptr) {
  ------------------
  |  |   66|    134|#define nullptr NULL
  ------------------
  |  Branch (164:9): [True: 123, False: 11]
  ------------------
  165|       |        // drain all data
  166|    123|        uint16_t data_left = net_socket_data_recv_buffer(tcp_conn->con.ns, tcp_conn->con.sock);
  167|       |
  168|    274|        while (data_left > 0) {
  ------------------
  |  Branch (168:16): [True: 246, False: 28]
  ------------------
  169|    246|            uint8_t temp_data[16];
  170|    246|            const uint16_t temp_data_size = min_u16(data_left, sizeof(temp_data));
  171|    246|            const TCP_Connection *con = &tcp_conn->con;
  172|       |
  173|    246|            if (read_tcp_packet(logger, con->mem, con->ns, con->sock, temp_data, temp_data_size,
  ------------------
  |  Branch (173:17): [True: 95, False: 151]
  ------------------
  174|    246|                                &con->ip_port) == -1) {
  175|     95|                LOGGER_ERROR(logger, "failed to drain TCP data (but ignoring failure)");
  ------------------
  |  |   83|     95|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     95|    do {                                                                         \
  |  |  |  |   73|     95|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    190|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     95|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     95|        }                                                                        \
  |  |  |  |   76|     95|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  176|     95|                return 1;
  177|     95|            }
  178|       |
  179|    151|            data_left -= temp_data_size;
  180|    151|        }
  181|       |
  182|     28|        return 1;
  183|    123|    }
  184|       |
  185|     11|    return -1;
  186|    134|}
TCP_client.c:socks5_read_handshake_response:
  215|    115|{
  216|    115|    uint8_t data[2];
  217|    115|    const TCP_Connection *con = &tcp_conn->con;
  218|    115|    const int ret = read_tcp_packet(logger, con->mem, con->ns, con->sock, data, sizeof(data), &con->ip_port);
  219|       |
  220|    115|    if (ret == -1) {
  ------------------
  |  Branch (220:9): [True: 98, False: 17]
  ------------------
  221|     98|        return 0;
  222|     98|    }
  223|       |
  224|     17|    if (data[0] == TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 && data[1] == TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED) {
  ------------------
  |  |  188|     34|#define TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 0x05
  ------------------
                  if (data[0] == TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 && data[1] == TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED) {
  ------------------
  |  |  190|     11|#define TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED 0x00
  ------------------
  |  Branch (224:9): [True: 11, False: 6]
  |  Branch (224:58): [True: 10, False: 1]
  ------------------
  225|     10|        return 1;
  226|     10|    }
  227|       |
  228|      7|    return -1;
  229|     17|}
TCP_client.c:proxy_socks5_generate_connection_request:
  233|     10|{
  234|     10|    tcp_conn->con.last_packet[0] = TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5;
  ------------------
  |  |  188|     10|#define TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 0x05
  ------------------
  235|     10|    tcp_conn->con.last_packet[1] = TCP_SOCKS5_PROXY_HS_COMM_ESTABLISH_REQUEST;
  ------------------
  |  |  189|     10|#define TCP_SOCKS5_PROXY_HS_COMM_ESTABLISH_REQUEST 0x01
  ------------------
  236|     10|    tcp_conn->con.last_packet[2] = TCP_SOCKS5_PROXY_HS_RESERVED;
  ------------------
  |  |  193|     10|#define TCP_SOCKS5_PROXY_HS_RESERVED 0x00
  ------------------
  237|     10|    uint16_t length = 3;
  238|       |
  239|     10|    if (net_family_is_ipv4(tcp_conn->ip_port.ip.family)) {
  ------------------
  |  Branch (239:9): [True: 10, False: 0]
  ------------------
  240|     10|        tcp_conn->con.last_packet[3] = TCP_SOCKS5_PROXY_HS_ADDR_TYPE_IPV4;
  ------------------
  |  |  194|     10|#define TCP_SOCKS5_PROXY_HS_ADDR_TYPE_IPV4 0x01
  ------------------
  241|     10|        ++length;
  242|     10|        memcpy(tcp_conn->con.last_packet + length, tcp_conn->ip_port.ip.ip.v4.uint8, sizeof(IP4));
  243|     10|        length += sizeof(IP4);
  244|     10|    } else {
  245|      0|        tcp_conn->con.last_packet[3] = TCP_SOCKS5_PROXY_HS_ADDR_TYPE_IPV6;
  ------------------
  |  |  195|      0|#define TCP_SOCKS5_PROXY_HS_ADDR_TYPE_IPV6 0x04
  ------------------
  246|      0|        ++length;
  247|      0|        memcpy(tcp_conn->con.last_packet + length, tcp_conn->ip_port.ip.ip.v6.uint8, sizeof(IP6));
  248|      0|        length += sizeof(IP6);
  249|      0|    }
  250|       |
  251|     10|    memcpy(tcp_conn->con.last_packet + length, &tcp_conn->ip_port.port, sizeof(uint16_t));
  252|     10|    length += sizeof(uint16_t);
  253|       |
  254|     10|    tcp_conn->con.last_packet_length = length;
  255|     10|    tcp_conn->con.last_packet_sent = 0;
  256|     10|}
TCP_client.c:proxy_socks5_read_connection_response:
  265|     78|{
  266|     78|    if (net_family_is_ipv4(tcp_conn->ip_port.ip.family)) {
  ------------------
  |  Branch (266:9): [True: 78, False: 0]
  ------------------
  267|     78|        uint8_t data[4 + sizeof(IP4) + sizeof(uint16_t)];
  268|     78|        const TCP_Connection *con = &tcp_conn->con;
  269|     78|        const int ret = read_tcp_packet(logger, con->mem, con->ns, con->sock, data, sizeof(data), &con->ip_port);
  270|       |
  271|     78|        if (ret == -1) {
  ------------------
  |  Branch (271:13): [True: 72, False: 6]
  ------------------
  272|     72|            return 0;
  273|     72|        }
  274|       |
  275|      6|        if (data[0] == TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 && data[1] == TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED) {
  ------------------
  |  |  188|     12|#define TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 0x05
  ------------------
                      if (data[0] == TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 && data[1] == TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED) {
  ------------------
  |  |  190|      2|#define TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED 0x00
  ------------------
  |  Branch (275:13): [True: 2, False: 4]
  |  Branch (275:62): [True: 1, False: 1]
  ------------------
  276|      1|            return 1;
  277|      1|        }
  278|      6|    } else {
  279|      0|        uint8_t data[4 + sizeof(IP6) + sizeof(uint16_t)];
  280|      0|        const TCP_Connection *con = &tcp_conn->con;
  281|      0|        int ret = read_tcp_packet(logger, con->mem, con->ns, con->sock, data, sizeof(data), &con->ip_port);
  282|       |
  283|      0|        if (ret == -1) {
  ------------------
  |  Branch (283:13): [True: 0, False: 0]
  ------------------
  284|      0|            return 0;
  285|      0|        }
  286|       |
  287|      0|        if (data[0] == TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 && data[1] == TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED) {
  ------------------
  |  |  188|      0|#define TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 0x05
  ------------------
                      if (data[0] == TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 && data[1] == TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED) {
  ------------------
  |  |  190|      0|#define TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED 0x00
  ------------------
  |  Branch (287:13): [True: 0, False: 0]
  |  Branch (287:62): [True: 0, False: 0]
  ------------------
  288|      0|            return 1;
  289|      0|        }
  290|      0|    }
  291|       |
  292|      5|    return -1;
  293|     78|}
TCP_client.c:handle_handshake:
  328|    205|{
  329|    205|    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE];
  330|    205|    const int len = decrypt_data_symmetric(tcp_conn->con.shared_key, data, data + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|    205|#define CRYPTO_NONCE_SIZE              24
  ------------------
  331|    205|                                     TCP_SERVER_HANDSHAKE_SIZE - CRYPTO_NONCE_SIZE, plain);
  ------------------
  |  |   56|    205|#define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|    205|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   55|    205|#define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    205|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|    205|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|    205|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                                                   TCP_SERVER_HANDSHAKE_SIZE - CRYPTO_NONCE_SIZE, plain);
  ------------------
  |  |   66|    205|#define CRYPTO_NONCE_SIZE              24
  ------------------
  332|       |
  333|    205|    if (len != sizeof(plain)) {
  ------------------
  |  Branch (333:9): [True: 0, False: 205]
  ------------------
  334|      0|        return -1;
  335|      0|    }
  336|       |
  337|    205|    memcpy(tcp_conn->recv_nonce, plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   40|    205|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(tcp_conn->recv_nonce, plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|    205|#define CRYPTO_NONCE_SIZE              24
  ------------------
  338|    205|    encrypt_precompute(plain, tcp_conn->temp_secret_key, tcp_conn->con.shared_key);
  339|    205|    crypto_memzero(tcp_conn->temp_secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   45|    205|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
  340|    205|    return 0;
  341|    205|}
TCP_client.c:do_confirmed_tcp:
  889|  2.21k|{
  890|  2.21k|    send_pending_data(logger, &conn->con);
  891|  2.21k|    tcp_send_ping_response(logger, conn);
  892|  2.21k|    tcp_send_ping_request(logger, conn);
  893|       |
  894|  2.21k|    if (mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_FREQUENCY)) {
  ------------------
  |  |   61|  2.21k|#define TCP_PING_FREQUENCY 30
  ------------------
  |  Branch (894:9): [True: 205, False: 2.00k]
  ------------------
  895|    205|        uint64_t ping_id = random_u64(conn->con.rng);
  896|       |
  897|    205|        if (ping_id == 0) {
  ------------------
  |  Branch (897:13): [True: 30, False: 175]
  ------------------
  898|     30|            ++ping_id;
  899|     30|        }
  900|       |
  901|    205|        conn->ping_request_id = ping_id;
  902|    205|        conn->ping_id = ping_id;
  903|    205|        tcp_send_ping_request(logger, conn);
  904|    205|        conn->last_pinged = mono_time_get(mono_time);
  905|    205|    }
  906|       |
  907|  2.21k|    if (conn->ping_id != 0 && mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_TIMEOUT)) {
  ------------------
  |  |   62|  2.21k|#define TCP_PING_TIMEOUT 10
  ------------------
  |  Branch (907:9): [True: 2.21k, False: 0]
  |  Branch (907:31): [True: 16, False: 2.19k]
  ------------------
  908|     16|        conn->status = TCP_CLIENT_DISCONNECTED;
  909|     16|        return 0;
  910|     16|    }
  911|       |
  912|  2.26k|    while (tcp_process_packet(logger, conn, userdata)) {
  ------------------
  |  Branch (912:12): [True: 65, False: 2.19k]
  ------------------
  913|       |        // Keep reading until error or out of data.
  914|     65|        continue;
  915|     65|    }
  916|       |
  917|  2.19k|    return 0;
  918|  2.21k|}
TCP_client.c:tcp_process_packet:
  865|  2.26k|{
  866|  2.26k|    uint8_t packet[MAX_PACKET_SIZE];
  867|  2.26k|    const int len = read_packet_tcp_secure_connection(logger, conn->con.mem, conn->con.ns, conn->con.sock, &conn->next_packet_length, conn->con.shared_key, conn->recv_nonce, packet, sizeof(packet), &conn->ip_port);
  868|       |
  869|  2.26k|    if (len == 0) {
  ------------------
  |  Branch (869:9): [True: 2.05k, False: 204]
  ------------------
  870|  2.05k|        return false;
  871|  2.05k|    }
  872|       |
  873|    204|    if (len == -1) {
  ------------------
  |  Branch (873:9): [True: 112, False: 92]
  ------------------
  874|    112|        conn->status = TCP_CLIENT_DISCONNECTED;
  875|    112|        return false;
  876|    112|    }
  877|       |
  878|     92|    if (handle_tcp_client_packet(logger, conn, packet, len, userdata) == -1) {
  ------------------
  |  Branch (878:9): [True: 27, False: 65]
  ------------------
  879|     27|        conn->status = TCP_CLIENT_DISCONNECTED;
  880|     27|        return false;
  881|     27|    }
  882|       |
  883|     65|    return true;
  884|     92|}
TCP_client.c:handle_tcp_client_packet:
  808|     92|{
  809|     92|    if (length <= 1) {
  ------------------
  |  Branch (809:9): [True: 1, False: 91]
  ------------------
  810|      1|        return -1;
  811|      1|    }
  812|       |
  813|     91|    switch (data[0]) {
  814|      6|        case TCP_PACKET_ROUTING_RESPONSE:
  ------------------
  |  |   42|      6|#define TCP_PACKET_ROUTING_RESPONSE 1
  ------------------
  |  Branch (814:9): [True: 6, False: 85]
  ------------------
  815|      6|            return handle_tcp_client_routing_response(conn, data, length);
  816|       |
  817|      1|        case TCP_PACKET_CONNECTION_NOTIFICATION:
  ------------------
  |  |   43|      1|#define TCP_PACKET_CONNECTION_NOTIFICATION 2
  ------------------
  |  Branch (817:9): [True: 1, False: 90]
  ------------------
  818|      1|            return handle_tcp_client_connection_notification(conn, data, length);
  819|       |
  820|      1|        case TCP_PACKET_DISCONNECT_NOTIFICATION:
  ------------------
  |  |   44|      1|#define TCP_PACKET_DISCONNECT_NOTIFICATION 3
  ------------------
  |  Branch (820:9): [True: 1, False: 90]
  ------------------
  821|      1|            return handle_tcp_client_disconnect_notification(conn, data, length);
  822|       |
  823|      2|        case TCP_PACKET_PING:
  ------------------
  |  |   45|      2|#define TCP_PACKET_PING 4
  ------------------
  |  Branch (823:9): [True: 2, False: 89]
  ------------------
  824|      2|            return handle_tcp_client_ping(logger, conn, data, length);
  825|       |
  826|     13|        case TCP_PACKET_PONG:
  ------------------
  |  |   46|     13|#define TCP_PACKET_PONG 5
  ------------------
  |  Branch (826:9): [True: 13, False: 78]
  ------------------
  827|     13|            return handle_tcp_client_pong(conn, data, length);
  828|       |
  829|      8|        case TCP_PACKET_OOB_RECV:
  ------------------
  |  |   48|      8|#define TCP_PACKET_OOB_RECV 7
  ------------------
  |  Branch (829:9): [True: 8, False: 83]
  ------------------
  830|      8|            return handle_tcp_client_oob_recv(conn, data, length, userdata);
  831|       |
  832|      2|        case TCP_PACKET_ONION_RESPONSE: {
  ------------------
  |  |   50|      2|#define TCP_PACKET_ONION_RESPONSE 9
  ------------------
  |  Branch (832:9): [True: 2, False: 89]
  ------------------
  833|      2|            if (conn->onion_callback != nullptr) {
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
  |  Branch (833:17): [True: 1, False: 1]
  ------------------
  834|      1|                conn->onion_callback(conn->onion_callback_object, data + 1, length - 1, userdata);
  835|      1|            }
  836|      2|            return 0;
  837|      0|        }
  838|       |
  839|     16|        case TCP_PACKET_FORWARDING: {
  ------------------
  |  |   52|     16|#define TCP_PACKET_FORWARDING 11
  ------------------
  |  Branch (839:9): [True: 16, False: 75]
  ------------------
  840|     16|            if (conn->forwarded_response_callback != nullptr) {
  ------------------
  |  |   66|     16|#define nullptr NULL
  ------------------
  |  Branch (840:17): [True: 10, False: 6]
  ------------------
  841|     10|                conn->forwarded_response_callback(conn->forwarded_response_callback_object, data + 1, length - 1, userdata);
  842|     10|            }
  843|     16|            return 0;
  844|      0|        }
  845|       |
  846|     42|        default: {
  ------------------
  |  Branch (846:9): [True: 42, False: 49]
  ------------------
  847|     42|            if (data[0] < NUM_RESERVED_PORTS) {
  ------------------
  |  |   24|     42|#define NUM_RESERVED_PORTS 16
  ------------------
  |  Branch (847:17): [True: 3, False: 39]
  ------------------
  848|      3|                return -1;
  849|      3|            }
  850|       |
  851|     39|            const uint8_t con_id = data[0] - NUM_RESERVED_PORTS;
  ------------------
  |  |   24|     39|#define NUM_RESERVED_PORTS 16
  ------------------
  852|       |
  853|     39|            if (conn->data_callback != nullptr) {
  ------------------
  |  |   66|     39|#define nullptr NULL
  ------------------
  |  Branch (853:17): [True: 33, False: 6]
  ------------------
  854|     33|                conn->data_callback(conn->data_callback_object, conn->connections[con_id].number, con_id, data + 1, length - 1,
  855|     33|                                    userdata);
  856|     33|            }
  857|     39|        }
  858|     91|    }
  859|       |
  860|     39|    return 0;
  861|     91|}
TCP_client.c:handle_tcp_client_routing_response:
  667|      6|{
  668|      6|    if (length != 1 + 1 + CRYPTO_PUBLIC_KEY_SIZE) {
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (668:9): [True: 6, False: 0]
  ------------------
  669|      6|        return -1;
  670|      6|    }
  671|       |
  672|      0|    if (data[1] < NUM_RESERVED_PORTS) {
  ------------------
  |  |   24|      0|#define NUM_RESERVED_PORTS 16
  ------------------
  |  Branch (672:9): [True: 0, False: 0]
  ------------------
  673|      0|        return 0;
  674|      0|    }
  675|       |
  676|      0|    const uint8_t con_id = data[1] - NUM_RESERVED_PORTS;
  ------------------
  |  |   24|      0|#define NUM_RESERVED_PORTS 16
  ------------------
  677|       |
  678|      0|    if (conn->connections[con_id].status != 0) {
  ------------------
  |  Branch (678:9): [True: 0, False: 0]
  ------------------
  679|      0|        return 0;
  680|      0|    }
  681|       |
  682|      0|    conn->connections[con_id].status = 1;
  683|      0|    conn->connections[con_id].number = -1;
  684|      0|    memcpy(conn->connections[con_id].public_key, data + 2, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  685|       |
  686|      0|    if (conn->response_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (686:9): [True: 0, False: 0]
  ------------------
  687|      0|        conn->response_callback(conn->response_callback_object, con_id, conn->connections[con_id].public_key);
  688|      0|    }
  689|       |
  690|      0|    return 0;
  691|      0|}
TCP_client.c:handle_tcp_client_connection_notification:
  695|      1|{
  696|      1|    if (length != 1 + 1) {
  ------------------
  |  Branch (696:9): [True: 1, False: 0]
  ------------------
  697|      1|        return -1;
  698|      1|    }
  699|       |
  700|      0|    if (data[1] < NUM_RESERVED_PORTS) {
  ------------------
  |  |   24|      0|#define NUM_RESERVED_PORTS 16
  ------------------
  |  Branch (700:9): [True: 0, False: 0]
  ------------------
  701|      0|        return -1;
  702|      0|    }
  703|       |
  704|      0|    const uint8_t con_id = data[1] - NUM_RESERVED_PORTS;
  ------------------
  |  |   24|      0|#define NUM_RESERVED_PORTS 16
  ------------------
  705|       |
  706|      0|    if (conn->connections[con_id].status != 1) {
  ------------------
  |  Branch (706:9): [True: 0, False: 0]
  ------------------
  707|      0|        return 0;
  708|      0|    }
  709|       |
  710|      0|    conn->connections[con_id].status = 2;
  711|       |
  712|      0|    if (conn->status_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (712:9): [True: 0, False: 0]
  ------------------
  713|      0|        conn->status_callback(conn->status_callback_object, conn->connections[con_id].number, con_id,
  714|      0|                              conn->connections[con_id].status);
  715|      0|    }
  716|       |
  717|      0|    return 0;
  718|      0|}
TCP_client.c:handle_tcp_client_disconnect_notification:
  722|      1|{
  723|      1|    if (length != 1 + 1) {
  ------------------
  |  Branch (723:9): [True: 1, False: 0]
  ------------------
  724|      1|        return -1;
  725|      1|    }
  726|       |
  727|      0|    if (data[1] < NUM_RESERVED_PORTS) {
  ------------------
  |  |   24|      0|#define NUM_RESERVED_PORTS 16
  ------------------
  |  Branch (727:9): [True: 0, False: 0]
  ------------------
  728|      0|        return -1;
  729|      0|    }
  730|       |
  731|      0|    const uint8_t con_id = data[1] - NUM_RESERVED_PORTS;
  ------------------
  |  |   24|      0|#define NUM_RESERVED_PORTS 16
  ------------------
  732|       |
  733|      0|    if (conn->connections[con_id].status == 0) {
  ------------------
  |  Branch (733:9): [True: 0, False: 0]
  ------------------
  734|      0|        return 0;
  735|      0|    }
  736|       |
  737|      0|    if (conn->connections[con_id].status != 2) {
  ------------------
  |  Branch (737:9): [True: 0, False: 0]
  ------------------
  738|      0|        return 0;
  739|      0|    }
  740|       |
  741|      0|    conn->connections[con_id].status = 1;
  742|       |
  743|      0|    if (conn->status_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (743:9): [True: 0, False: 0]
  ------------------
  744|      0|        conn->status_callback(conn->status_callback_object, conn->connections[con_id].number, con_id,
  745|      0|                              conn->connections[con_id].status);
  746|      0|    }
  747|       |
  748|      0|    return 0;
  749|      0|}
TCP_client.c:handle_tcp_client_ping:
  753|      2|{
  754|      2|    if (length != 1 + sizeof(uint64_t)) {
  ------------------
  |  Branch (754:9): [True: 1, False: 1]
  ------------------
  755|      1|        return -1;
  756|      1|    }
  757|       |
  758|      1|    uint64_t ping_id;
  759|      1|    memcpy(&ping_id, data + 1, sizeof(uint64_t));
  760|      1|    conn->ping_response_id = ping_id;
  761|      1|    tcp_send_ping_response(logger, conn);
  762|      1|    return 0;
  763|      2|}
TCP_client.c:handle_tcp_client_pong:
  767|     13|{
  768|     13|    if (length != 1 + sizeof(uint64_t)) {
  ------------------
  |  Branch (768:9): [True: 13, False: 0]
  ------------------
  769|     13|        return -1;
  770|     13|    }
  771|       |
  772|      0|    uint64_t ping_id;
  773|      0|    memcpy(&ping_id, data + 1, sizeof(uint64_t));
  774|       |
  775|      0|    if (ping_id != 0) {
  ------------------
  |  Branch (775:9): [True: 0, False: 0]
  ------------------
  776|      0|        if (ping_id == conn->ping_id) {
  ------------------
  |  Branch (776:13): [True: 0, False: 0]
  ------------------
  777|      0|            conn->ping_id = 0;
  778|      0|        }
  779|       |
  780|      0|        return 0;
  781|      0|    }
  782|       |
  783|      0|    return -1;
  784|      0|}
TCP_client.c:handle_tcp_client_oob_recv:
  788|      8|{
  789|      8|    if (length <= 1 + CRYPTO_PUBLIC_KEY_SIZE) {
  ------------------
  |  |   40|      8|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (789:9): [True: 1, False: 7]
  ------------------
  790|      1|        return -1;
  791|      1|    }
  792|       |
  793|      7|    if (conn->oob_data_callback != nullptr) {
  ------------------
  |  |   66|      7|#define nullptr NULL
  ------------------
  |  Branch (793:9): [True: 6, False: 1]
  ------------------
  794|      6|        conn->oob_data_callback(conn->oob_data_callback_object, data + 1, data + 1 + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  795|      6|                                length - (1 + CRYPTO_PUBLIC_KEY_SIZE), userdata);
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  796|      6|    }
  797|       |
  798|      7|    return 0;
  799|      8|}

wipe_priority_list:
   14|  45.0k|{
   15|  45.0k|    while (p != nullptr) {
  ------------------
  |  |   66|  45.0k|#define nullptr NULL
  ------------------
  |  Branch (15:12): [True: 0, False: 45.0k]
  ------------------
   16|      0|        TCP_Priority_List *pp = p;
   17|      0|        p = p->next;
   18|      0|        mem_delete(mem, pp->data);
   19|      0|        mem_delete(mem, pp);
   20|      0|    }
   21|  45.0k|}
send_pending_data_nonpriority:
   28|  3.47k|{
   29|  3.47k|    if (con->last_packet_length == 0) {
  ------------------
  |  Branch (29:9): [True: 2.85k, False: 616]
  ------------------
   30|  2.85k|        return 0;
   31|  2.85k|    }
   32|       |
   33|    616|    const uint16_t left = con->last_packet_length - con->last_packet_sent;
   34|    616|    const int len = net_send(con->ns, logger, con->sock, con->last_packet + con->last_packet_sent, left, &con->ip_port);
   35|       |
   36|    616|    if (len <= 0) {
  ------------------
  |  Branch (36:9): [True: 0, False: 616]
  ------------------
   37|      0|        return -1;
   38|      0|    }
   39|       |
   40|    616|    if (len == left) {
  ------------------
  |  Branch (40:9): [True: 616, False: 0]
  ------------------
   41|    616|        con->last_packet_length = 0;
   42|    616|        con->last_packet_sent = 0;
   43|    616|        return 0;
   44|    616|    }
   45|       |
   46|      0|    con->last_packet_sent += len;
   47|      0|    return -1;
   48|    616|}
send_pending_data:
   55|  3.47k|{
   56|       |    /* finish sending current non-priority packet */
   57|  3.47k|    if (send_pending_data_nonpriority(logger, con) == -1) {
  ------------------
  |  Branch (57:9): [True: 0, False: 3.47k]
  ------------------
   58|      0|        return -1;
   59|      0|    }
   60|       |
   61|  3.47k|    TCP_Priority_List *p = con->priority_queue_start;
   62|       |
   63|  3.47k|    while (p != nullptr) {
  ------------------
  |  |   66|  3.47k|#define nullptr NULL
  ------------------
  |  Branch (63:12): [True: 0, False: 3.47k]
  ------------------
   64|      0|        const uint16_t left = p->size - p->sent;
   65|      0|        const int len = net_send(con->ns, logger, con->sock, p->data + p->sent, left, &con->ip_port);
   66|       |
   67|      0|        if (len != left) {
  ------------------
  |  Branch (67:13): [True: 0, False: 0]
  ------------------
   68|      0|            if (len > 0) {
  ------------------
  |  Branch (68:17): [True: 0, False: 0]
  ------------------
   69|      0|                p->sent += len;
   70|      0|            }
   71|       |
   72|      0|            break;
   73|      0|        }
   74|       |
   75|      0|        TCP_Priority_List *pp = p;
   76|      0|        p = p->next;
   77|      0|        mem_delete(con->mem, pp->data);
   78|      0|        mem_delete(con->mem, pp);
   79|      0|    }
   80|       |
   81|  3.47k|    con->priority_queue_start = p;
   82|       |
   83|  3.47k|    if (p == nullptr) {
  ------------------
  |  |   66|  3.47k|#define nullptr NULL
  ------------------
  |  Branch (83:9): [True: 3.47k, False: 0]
  ------------------
   84|  3.47k|        con->priority_queue_end = nullptr;
  ------------------
  |  |   66|  3.47k|#define nullptr NULL
  ------------------
   85|  3.47k|        return 0;
   86|  3.47k|    }
   87|       |
   88|      0|    return -1;
   89|  3.47k|}
write_packet_tcp_secure_connection:
  134|    207|{
  135|    207|    if (length + CRYPTO_MAC_SIZE > MAX_PACKET_SIZE) {
  ------------------
  |  |   61|    207|#define CRYPTO_MAC_SIZE                16
  ------------------
                  if (length + CRYPTO_MAC_SIZE > MAX_PACKET_SIZE) {
  ------------------
  |  |   64|    207|#define MAX_PACKET_SIZE 2048
  ------------------
  |  Branch (135:9): [True: 0, False: 207]
  ------------------
  136|      0|        return -1;
  137|      0|    }
  138|       |
  139|    207|    bool sendpriority = true;
  140|       |
  141|    207|    if (send_pending_data(logger, con) == -1) {
  ------------------
  |  Branch (141:9): [True: 0, False: 207]
  ------------------
  142|      0|        if (priority) {
  ------------------
  |  Branch (142:13): [True: 0, False: 0]
  ------------------
  143|      0|            sendpriority = false;
  144|      0|        } else {
  145|      0|            return 0;
  146|      0|        }
  147|      0|    }
  148|       |
  149|    207|    VLA(uint8_t, packet, sizeof(uint16_t) + length + CRYPTO_MAC_SIZE);
  ------------------
  |  |   62|    207|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|    207|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  150|       |
  151|    207|    uint16_t c_length = net_htons(length + CRYPTO_MAC_SIZE);
  ------------------
  |  |   61|    207|#define CRYPTO_MAC_SIZE                16
  ------------------
  152|    207|    memcpy(packet, &c_length, sizeof(uint16_t));
  153|    207|    int len = encrypt_data_symmetric(con->shared_key, con->sent_nonce, data, length, packet + sizeof(uint16_t));
  154|       |
  155|    207|    if ((unsigned int)len != (SIZEOF_VLA(packet) - sizeof(uint16_t))) {
  ------------------
  |  |   29|    207|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (155:9): [True: 0, False: 207]
  ------------------
  156|      0|        return -1;
  157|      0|    }
  158|       |
  159|    207|    if (priority) {
  ------------------
  |  Branch (159:9): [True: 206, False: 1]
  ------------------
  160|    206|        len = sendpriority ? net_send(con->ns, logger, con->sock, packet, SIZEOF_VLA(packet), &con->ip_port) : 0;
  ------------------
  |  |   29|    206|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (160:15): [True: 206, False: 0]
  ------------------
  161|       |
  162|    206|        if (len <= 0) {
  ------------------
  |  Branch (162:13): [True: 0, False: 206]
  ------------------
  163|      0|            len = 0;
  164|      0|        }
  165|       |
  166|    206|        increment_nonce(con->sent_nonce);
  167|       |
  168|    206|        if ((unsigned int)len == SIZEOF_VLA(packet)) {
  ------------------
  |  |   29|    206|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (168:13): [True: 206, False: 0]
  ------------------
  169|    206|            return 1;
  170|    206|        }
  171|       |
  172|      0|        return add_priority(con, packet, SIZEOF_VLA(packet), len) ? 1 : 0;
  ------------------
  |  |   29|      0|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (172:16): [True: 0, False: 0]
  ------------------
  173|    206|    }
  174|       |
  175|      1|    len = net_send(con->ns, logger, con->sock, packet, SIZEOF_VLA(packet), &con->ip_port);
  ------------------
  |  |   29|      1|#define SIZEOF_VLA sizeof
  ------------------
  176|       |
  177|      1|    if (len <= 0) {
  ------------------
  |  Branch (177:9): [True: 0, False: 1]
  ------------------
  178|      0|        return 0;
  179|      0|    }
  180|       |
  181|      1|    increment_nonce(con->sent_nonce);
  182|       |
  183|      1|    if ((unsigned int)len == SIZEOF_VLA(packet)) {
  ------------------
  |  |   29|      1|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (183:9): [True: 1, False: 0]
  ------------------
  184|      1|        return 1;
  185|      1|    }
  186|       |
  187|      0|    memcpy(con->last_packet, packet, SIZEOF_VLA(packet));
  ------------------
  |  |   29|      0|#define SIZEOF_VLA sizeof
  ------------------
  188|      0|    con->last_packet_length = SIZEOF_VLA(packet);
  ------------------
  |  |   29|      0|#define SIZEOF_VLA sizeof
  ------------------
  189|      0|    con->last_packet_sent = len;
  190|      0|    return 1;
  191|      1|}
read_tcp_packet:
  200|  48.0k|{
  201|  48.0k|    const uint16_t count = net_socket_data_recv_buffer(ns, sock);
  202|       |
  203|  48.0k|    if (count < length) {
  ------------------
  |  Branch (203:9): [True: 32.7k, False: 15.2k]
  ------------------
  204|  32.7k|        LOGGER_TRACE(logger, "recv buffer has %d bytes, but requested %d bytes", count, length);
  ------------------
  |  |   79|  32.7k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  32.7k|    do {                                                                         \
  |  |  |  |   73|  32.7k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  65.5k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  32.7k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  205|  32.7k|        return -1;
  206|  32.7k|    }
  207|       |
  208|  15.2k|    const int len = net_recv(ns, logger, sock, data, length, ip_port);
  209|       |
  210|  15.2k|    if (len != length) {
  ------------------
  |  Branch (210:9): [True: 14.1k, False: 1.16k]
  ------------------
  211|  14.1k|        LOGGER_ERROR(logger, "FAIL recv packet");
  ------------------
  |  |   83|  14.1k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  14.1k|    do {                                                                         \
  |  |  |  |   73|  14.1k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  28.2k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|  14.1k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|  14.1k|        }                                                                        \
  |  |  |  |   76|  14.1k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  212|  14.1k|        return -1;
  213|  14.1k|    }
  214|       |
  215|  1.16k|    return len;
  216|  15.2k|}
read_packet_tcp_secure_connection:
  263|  2.83k|{
  264|  2.83k|    if (*next_packet_length == 0) {
  ------------------
  |  Branch (264:9): [True: 2.30k, False: 530]
  ------------------
  265|  2.30k|        const uint16_t len = read_tcp_length(logger, mem, ns, sock, ip_port);
  266|       |
  267|  2.30k|        if (len == (uint16_t) -1) {
  ------------------
  |  Branch (267:13): [True: 260, False: 2.04k]
  ------------------
  268|    260|            return -1;
  269|    260|        }
  270|       |
  271|  2.04k|        if (len == 0) {
  ------------------
  |  Branch (271:13): [True: 1.79k, False: 245]
  ------------------
  272|  1.79k|            return 0;
  273|  1.79k|        }
  274|       |
  275|    245|        *next_packet_length = len;
  276|    245|    }
  277|       |
  278|    775|    if (max_len + CRYPTO_MAC_SIZE < *next_packet_length) {
  ------------------
  |  |   61|    775|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (278:9): [True: 0, False: 775]
  ------------------
  279|      0|        LOGGER_DEBUG(logger, "packet too large");
  ------------------
  |  |   80|      0|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  280|      0|        return -1;
  281|      0|    }
  282|       |
  283|    775|    VLA(uint8_t, data_encrypted, (int) *next_packet_length);
  ------------------
  |  |   62|    775|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|    775|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  284|    775|    const int len_packet = read_tcp_packet(logger, mem, ns, sock, data_encrypted, *next_packet_length, ip_port);
  285|       |
  286|    775|    if (len_packet == -1) {
  ------------------
  |  Branch (286:9): [True: 565, False: 210]
  ------------------
  287|    565|        return 0;
  288|    565|    }
  289|       |
  290|    210|    if (len_packet != *next_packet_length) {
  ------------------
  |  Branch (290:9): [True: 0, False: 210]
  ------------------
  291|      0|        LOGGER_WARNING(logger, "invalid packet length: %d, expected %d", len_packet, *next_packet_length);
  ------------------
  |  |   82|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  292|      0|        return 0;
  293|      0|    }
  294|       |
  295|    210|    *next_packet_length = 0;
  296|       |
  297|    210|    const int len = decrypt_data_symmetric(shared_key, recv_nonce, data_encrypted, len_packet, data);
  298|       |
  299|    210|    if (len + CRYPTO_MAC_SIZE != len_packet) {
  ------------------
  |  |   61|    210|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (299:9): [True: 4, False: 206]
  ------------------
  300|      4|        LOGGER_ERROR(logger, "decrypted length %d does not match expected length %d", len + CRYPTO_MAC_SIZE, len_packet);
  ------------------
  |  |   83|      4|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      4|    do {                                                                         \
  |  |  |  |   73|      4|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      8|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      4|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      4|        }                                                                        \
  |  |  |  |   76|      4|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  301|      4|        return -1;
  302|      4|    }
  303|       |
  304|    206|    increment_nonce(recv_nonce);
  305|       |
  306|    206|    return len;
  307|    210|}
TCP_common.c:read_tcp_length:
  227|  2.30k|{
  228|  2.30k|    const uint16_t count = net_socket_data_recv_buffer(ns, sock);
  229|       |
  230|  2.30k|    if (count >= sizeof(uint16_t)) {
  ------------------
  |  Branch (230:9): [True: 1.70k, False: 600]
  ------------------
  231|  1.70k|        uint8_t length_buf[sizeof(uint16_t)];
  232|  1.70k|        const int len = net_recv(ns, logger, sock, length_buf, sizeof(length_buf), ip_port);
  233|       |
  234|  1.70k|        if (len != sizeof(uint16_t)) {
  ------------------
  |  Branch (234:13): [True: 1.16k, False: 538]
  ------------------
  235|  1.16k|            LOGGER_ERROR(logger, "FAIL recv packet");
  ------------------
  |  |   83|  1.16k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  1.16k|    do {                                                                         \
  |  |  |  |   73|  1.16k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  2.33k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|  1.16k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|  1.16k|        }                                                                        \
  |  |  |  |   76|  1.16k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  236|  1.16k|            return 0;
  237|  1.16k|        }
  238|       |
  239|    538|        uint16_t length;
  240|    538|        net_unpack_u16(length_buf, &length);
  241|       |
  242|    538|        if (length > MAX_PACKET_SIZE) {
  ------------------
  |  |   64|    538|#define MAX_PACKET_SIZE 2048
  ------------------
  |  Branch (242:13): [True: 260, False: 278]
  ------------------
  243|    260|            LOGGER_ERROR(logger, "TCP packet too large: %d > %d", length, MAX_PACKET_SIZE);
  ------------------
  |  |   83|    260|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    260|    do {                                                                         \
  |  |  |  |   73|    260|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    520|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    260|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    260|        }                                                                        \
  |  |  |  |   76|    260|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  244|    260|            return -1;
  245|    260|        }
  246|       |
  247|    278|        return length;
  248|    538|    }
  249|       |
  250|    600|    return 0;
  251|  2.30k|}

send_packet_tcp_connection:
  311|      1|{
  312|      1|    const TCP_Connection_to *con_to = get_connection(tcp_c, connections_number);
  313|       |
  314|      1|    if (con_to == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (314:9): [True: 0, False: 1]
  ------------------
  315|      0|        return -1;
  316|      0|    }
  317|       |
  318|       |    // TODO(irungentoo): detect and kill bad relays.
  319|       |    // TODO(irungentoo): thread safety?
  320|      1|    int ret = -1;
  321|       |
  322|      1|    bool limit_reached = false;
  323|       |
  324|      7|    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
  ------------------
  |  |   31|      7|#define MAX_FRIEND_TCP_CONNECTIONS 6
  ------------------
  |  Branch (324:26): [True: 6, False: 1]
  ------------------
  325|      6|        uint32_t tcp_con_num = con_to->connections[i].tcp_connection;
  326|      6|        const uint8_t status = con_to->connections[i].status;
  327|      6|        const uint8_t connection_id = con_to->connections[i].connection_id;
  328|       |
  329|      6|        if (tcp_con_num > 0 && status == TCP_CONNECTIONS_STATUS_ONLINE) {
  ------------------
  |  |   29|      0|#define TCP_CONNECTIONS_STATUS_ONLINE 2
  ------------------
  |  Branch (329:13): [True: 0, False: 6]
  |  Branch (329:32): [True: 0, False: 0]
  ------------------
  330|      0|            tcp_con_num -= 1;
  331|      0|            TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_con_num);
  332|       |
  333|      0|            if (tcp_con == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (333:17): [True: 0, False: 0]
  ------------------
  334|      0|                continue;
  335|      0|            }
  336|       |
  337|      0|            ret = send_data(tcp_c->logger, tcp_con->connection, connection_id, packet, length);
  338|       |
  339|      0|            if (ret == 0) {
  ------------------
  |  Branch (339:17): [True: 0, False: 0]
  ------------------
  340|      0|                limit_reached = true;
  341|      0|            }
  342|       |
  343|      0|            if (ret == 1) {
  ------------------
  |  Branch (343:17): [True: 0, False: 0]
  ------------------
  344|      0|                break;
  345|      0|            }
  346|      0|        }
  347|      6|    }
  348|       |
  349|      1|    if (ret == 1) {
  ------------------
  |  Branch (349:9): [True: 0, False: 1]
  ------------------
  350|      0|        return 0;
  351|      0|    }
  352|       |
  353|      1|    if (limit_reached) {
  ------------------
  |  Branch (353:9): [True: 0, False: 1]
  ------------------
  354|      0|        return -1;
  355|      0|    }
  356|       |
  357|      1|    bool sent_any = false;
  358|       |
  359|       |    /* Send oob packets to all relays tied to the connection. */
  360|      7|    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
  ------------------
  |  |   31|      7|#define MAX_FRIEND_TCP_CONNECTIONS 6
  ------------------
  |  Branch (360:26): [True: 6, False: 1]
  ------------------
  361|      6|        uint32_t tcp_con_num = con_to->connections[i].tcp_connection;
  362|      6|        const uint8_t status = con_to->connections[i].status;
  363|       |
  364|      6|        if (tcp_con_num > 0 && status == TCP_CONNECTIONS_STATUS_REGISTERED) {
  ------------------
  |  |   28|      0|#define TCP_CONNECTIONS_STATUS_REGISTERED 1
  ------------------
  |  Branch (364:13): [True: 0, False: 6]
  |  Branch (364:32): [True: 0, False: 0]
  ------------------
  365|      0|            tcp_con_num -= 1;
  366|      0|            TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_con_num);
  367|       |
  368|      0|            if (tcp_con == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (368:17): [True: 0, False: 0]
  ------------------
  369|      0|                continue;
  370|      0|            }
  371|       |
  372|      0|            if (send_oob_packet(tcp_c->logger, tcp_con->connection, con_to->public_key, packet, length) == 1) {
  ------------------
  |  Branch (372:17): [True: 0, False: 0]
  ------------------
  373|      0|                sent_any = true;
  374|      0|            }
  375|      0|        }
  376|      6|    }
  377|       |
  378|      1|    return sent_any ? 0 : -1;
  ------------------
  |  Branch (378:12): [True: 0, False: 1]
  ------------------
  379|      1|}
set_packet_tcp_connection_callback:
  544|    946|{
  545|    946|    tcp_c->tcp_data_callback = tcp_data_callback;
  546|    946|    tcp_c->tcp_data_callback_object = object;
  547|    946|}
set_oob_packet_tcp_connection_callback:
  551|    946|{
  552|    946|    tcp_c->tcp_oob_callback = tcp_oob_callback;
  553|    946|    tcp_c->tcp_oob_callback_object = object;
  554|    946|}
set_onion_packet_tcp_connection_callback:
  558|  1.88k|{
  559|  1.88k|    tcp_c->tcp_onion_callback = tcp_onion_callback;
  560|  1.88k|    tcp_c->tcp_onion_callback_object = object;
  561|  1.88k|}
tcp_connections_number_to_ip_port:
  577|      1|{
  578|      1|    IP_Port ip_port = {{{0}}};
  579|      1|    ip_port.ip.family = net_family_tcp_server();
  580|      1|    ip_port.ip.ip.v6.uint32[0] = tcp_connections_number;
  581|      1|    return ip_port;
  582|      1|}
new_tcp_connection_to:
  657|      1|{
  658|      1|    if (find_tcp_connection_to(tcp_c, public_key) != -1) {
  ------------------
  |  Branch (658:9): [True: 0, False: 1]
  ------------------
  659|      0|        return -1;
  660|      0|    }
  661|       |
  662|      1|    const int connections_number = create_connection(tcp_c);
  663|       |
  664|      1|    if (connections_number == -1) {
  ------------------
  |  Branch (664:9): [True: 0, False: 1]
  ------------------
  665|      0|        return -1;
  666|      0|    }
  667|       |
  668|      1|    TCP_Connection_to *con_to = &tcp_c->connections[connections_number];
  669|       |
  670|      1|    con_to->status = TCP_CONN_VALID;
  ------------------
  |  |   19|      1|#define TCP_CONN_VALID 1
  ------------------
  671|      1|    memcpy(con_to->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  672|      1|    con_to->id = id;
  673|       |
  674|      1|    return connections_number;
  675|      1|}
kill_tcp_connection_to:
  682|      1|{
  683|      1|    const TCP_Connection_to *con_to = get_connection(tcp_c, connections_number);
  684|       |
  685|      1|    if (con_to == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (685:9): [True: 0, False: 1]
  ------------------
  686|      0|        return -1;
  687|      0|    }
  688|       |
  689|      7|    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
  ------------------
  |  |   31|      7|#define MAX_FRIEND_TCP_CONNECTIONS 6
  ------------------
  |  Branch (689:26): [True: 6, False: 1]
  ------------------
  690|      6|        if (con_to->connections[i].tcp_connection > 0) {
  ------------------
  |  Branch (690:13): [True: 0, False: 6]
  ------------------
  691|      0|            const unsigned int tcp_connections_number = con_to->connections[i].tcp_connection - 1;
  692|      0|            TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);
  693|       |
  694|      0|            if (tcp_con == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (694:17): [True: 0, False: 0]
  ------------------
  695|      0|                continue;
  696|      0|            }
  697|       |
  698|      0|            if (tcp_con->status == TCP_CONN_CONNECTED) {
  ------------------
  |  |   22|      0|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (698:17): [True: 0, False: 0]
  ------------------
  699|      0|                send_disconnect_request(tcp_c->logger, tcp_con->connection, con_to->connections[i].connection_id);
  700|      0|            }
  701|       |
  702|      0|            if (con_to->connections[i].status == TCP_CONNECTIONS_STATUS_ONLINE) {
  ------------------
  |  |   29|      0|#define TCP_CONNECTIONS_STATUS_ONLINE 2
  ------------------
  |  Branch (702:17): [True: 0, False: 0]
  ------------------
  703|      0|                --tcp_con->lock_count;
  704|       |
  705|      0|                if (con_to->status == TCP_CONN_SLEEPING) {
  ------------------
  |  |   25|      0|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (705:21): [True: 0, False: 0]
  ------------------
  706|      0|                    --tcp_con->sleep_count;
  707|      0|                }
  708|      0|            }
  709|      0|        }
  710|      6|    }
  711|       |
  712|      1|    return wipe_connection(tcp_c, connections_number);
  713|      1|}
kill_tcp_relay_connection:
  887|     57|{
  888|     57|    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);
  889|       |
  890|     57|    if (tcp_con == nullptr) {
  ------------------
  |  |   66|     57|#define nullptr NULL
  ------------------
  |  Branch (890:9): [True: 0, False: 57]
  ------------------
  891|      0|        return -1;
  892|      0|    }
  893|       |
  894|     57|    for (uint32_t i = 0; i < tcp_c->connections_length; ++i) {
  ------------------
  |  Branch (894:26): [True: 0, False: 57]
  ------------------
  895|      0|        TCP_Connection_to *con_to = get_connection(tcp_c, i);
  896|       |
  897|      0|        if (con_to != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (897:13): [True: 0, False: 0]
  ------------------
  898|      0|            rm_tcp_connection_from_conn(con_to, tcp_connections_number);
  899|      0|        }
  900|      0|    }
  901|       |
  902|     57|    if (tcp_con->onion) {
  ------------------
  |  Branch (902:9): [True: 3, False: 54]
  ------------------
  903|      3|        --tcp_c->onion_num_conns;
  904|      3|    }
  905|       |
  906|     57|    kill_tcp_connection(tcp_con->connection);
  907|       |
  908|     57|    return wipe_tcp_connection(tcp_c, tcp_connections_number);
  909|     57|}
add_tcp_relay_global:
 1330|    545|{
 1331|    545|    const int tcp_connections_number = find_tcp_connection_relay(tcp_c, relay_pk);
 1332|       |
 1333|    545|    if (tcp_connections_number != -1) {
  ------------------
  |  Branch (1333:9): [True: 0, False: 545]
  ------------------
 1334|      0|        return -1;
 1335|      0|    }
 1336|       |
 1337|    545|    if (add_tcp_relay_instance(tcp_c, ip_port, relay_pk) == -1) {
  ------------------
  |  Branch (1337:9): [True: 165, False: 380]
  ------------------
 1338|    165|        return -1;
 1339|    165|    }
 1340|       |
 1341|    380|    return 0;
 1342|    545|}
set_tcp_onion_status:
 1523|  14.2k|{
 1524|  14.2k|    if (tcp_c->onion_status == status) {
  ------------------
  |  Branch (1524:9): [True: 13.3k, False: 914]
  ------------------
 1525|  13.3k|        return -1;
 1526|  13.3k|    }
 1527|       |
 1528|    914|    if (status) {
  ------------------
  |  Branch (1528:9): [True: 914, False: 0]
  ------------------
 1529|  1.27k|        for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1529:30): [True: 361, False: 914]
  ------------------
 1530|    361|            TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1531|       |
 1532|    361|            if (tcp_con != nullptr) {
  ------------------
  |  |   66|    361|#define nullptr NULL
  ------------------
  |  Branch (1532:17): [True: 335, False: 26]
  ------------------
 1533|    335|                if (tcp_con->status == TCP_CONN_CONNECTED && !tcp_con->onion) {
  ------------------
  |  |   22|    670|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (1533:21): [True: 53, False: 282]
  |  Branch (1533:62): [True: 53, False: 0]
  ------------------
 1534|     53|                    ++tcp_c->onion_num_conns;
 1535|     53|                    tcp_con->onion = 1;
 1536|     53|                }
 1537|    335|            }
 1538|       |
 1539|    361|            if (tcp_c->onion_num_conns >= NUM_ONION_TCP_CONNECTIONS) {
  ------------------
  |  |   42|    361|#define NUM_ONION_TCP_CONNECTIONS RECOMMENDED_FRIEND_TCP_CONNECTIONS
  |  |  ------------------
  |  |  |  |   39|    361|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   31|    361|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1539:17): [True: 0, False: 361]
  ------------------
 1540|      0|                break;
 1541|      0|            }
 1542|    361|        }
 1543|       |
 1544|    914|        if (tcp_c->onion_num_conns < NUM_ONION_TCP_CONNECTIONS) {
  ------------------
  |  |   42|    914|#define NUM_ONION_TCP_CONNECTIONS RECOMMENDED_FRIEND_TCP_CONNECTIONS
  |  |  ------------------
  |  |  |  |   39|    914|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   31|    914|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1544:13): [True: 914, False: 0]
  ------------------
 1545|    914|            const unsigned int wakeup = NUM_ONION_TCP_CONNECTIONS - tcp_c->onion_num_conns;
  ------------------
  |  |   42|    914|#define NUM_ONION_TCP_CONNECTIONS RECOMMENDED_FRIEND_TCP_CONNECTIONS
  |  |  ------------------
  |  |  |  |   39|    914|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   31|    914|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1546|       |
 1547|  1.27k|            for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1547:34): [True: 361, False: 914]
  ------------------
 1548|    361|                TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1549|       |
 1550|    361|                if (tcp_con != nullptr) {
  ------------------
  |  |   66|    361|#define nullptr NULL
  ------------------
  |  Branch (1550:21): [True: 335, False: 26]
  ------------------
 1551|    335|                    if (tcp_con->status == TCP_CONN_SLEEPING) {
  ------------------
  |  |   25|    335|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (1551:25): [True: 0, False: 335]
  ------------------
 1552|      0|                        tcp_con->unsleep = 1;
 1553|      0|                    }
 1554|    335|                }
 1555|       |
 1556|    361|                if (wakeup == 0) {
  ------------------
  |  Branch (1556:21): [True: 0, False: 361]
  ------------------
 1557|      0|                    break;
 1558|      0|                }
 1559|    361|            }
 1560|    914|        }
 1561|       |
 1562|    914|        tcp_c->onion_status = 1;
 1563|    914|    } else {
 1564|      0|        for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1564:30): [True: 0, False: 0]
  ------------------
 1565|      0|            TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1566|       |
 1567|      0|            if (tcp_con != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1567:17): [True: 0, False: 0]
  ------------------
 1568|      0|                if (tcp_con->onion) {
  ------------------
  |  Branch (1568:21): [True: 0, False: 0]
  ------------------
 1569|      0|                    --tcp_c->onion_num_conns;
 1570|      0|                    tcp_con->onion = 0;
 1571|      0|                }
 1572|      0|            }
 1573|      0|        }
 1574|       |
 1575|      0|        tcp_c->onion_status = 0;
 1576|      0|    }
 1577|       |
 1578|    914|    return 0;
 1579|  14.2k|}
new_tcp_connections:
 1590|    947|{
 1591|    947|    assert(logger != nullptr);
 1592|      0|    assert(mem != nullptr);
 1593|      0|    assert(rng != nullptr);
 1594|      0|    assert(ns != nullptr);
 1595|      0|    assert(mono_time != nullptr);
 1596|       |
 1597|    947|    if (secret_key == nullptr) {
  ------------------
  |  |   66|    947|#define nullptr NULL
  ------------------
  |  Branch (1597:9): [True: 0, False: 947]
  ------------------
 1598|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1599|      0|    }
 1600|       |
 1601|    947|    TCP_Connections *temp = (TCP_Connections *)mem_alloc(mem, sizeof(TCP_Connections));
 1602|       |
 1603|    947|    if (temp == nullptr) {
  ------------------
  |  |   66|    947|#define nullptr NULL
  ------------------
  |  Branch (1603:9): [True: 1, False: 946]
  ------------------
 1604|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 1605|      1|    }
 1606|       |
 1607|    946|    temp->logger = logger;
 1608|    946|    temp->mem = mem;
 1609|    946|    temp->rng = rng;
 1610|    946|    temp->mono_time = mono_time;
 1611|    946|    temp->ns = ns;
 1612|       |
 1613|    946|    memcpy(temp->self_secret_key, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   45|    946|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 1614|    946|    crypto_derive_public_key(temp->self_public_key, temp->self_secret_key);
 1615|    946|    temp->proxy_info = *proxy_info;
 1616|       |
 1617|    946|    return temp;
 1618|    947|}
do_tcp_connections:
 1704|  72.6k|{
 1705|  72.6k|    do_tcp_conns(logger, tcp_c, userdata);
 1706|  72.6k|    kill_nonused_tcp(tcp_c);
 1707|  72.6k|}
kill_tcp_connections:
 1710|    946|{
 1711|    946|    if (tcp_c == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (1711:9): [True: 0, False: 946]
  ------------------
 1712|      0|        return;
 1713|      0|    }
 1714|       |
 1715|  1.29k|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1715:26): [True: 349, False: 946]
  ------------------
 1716|    349|        kill_tcp_connection(tcp_c->tcp_connections[i].connection);
 1717|    349|    }
 1718|       |
 1719|    946|    crypto_memzero(tcp_c->self_secret_key, sizeof(tcp_c->self_secret_key));
 1720|       |
 1721|    946|    mem_delete(tcp_c->mem, tcp_c->tcp_connections);
 1722|    946|    mem_delete(tcp_c->mem, tcp_c->connections);
 1723|    946|    mem_delete(tcp_c->mem, tcp_c);
 1724|    946|}
TCP_connection.c:get_tcp_connection:
  277|  13.0k|{
  278|  13.0k|    if (!tcp_connections_number_is_valid(tcp_c, tcp_connections_number)) {
  ------------------
  |  Branch (278:9): [True: 2.97k, False: 10.0k]
  ------------------
  279|  2.97k|        return nullptr;
  ------------------
  |  |   66|  2.97k|#define nullptr NULL
  ------------------
  280|  2.97k|    }
  281|       |
  282|  10.0k|    return &tcp_c->tcp_connections[tcp_connections_number];
  283|  13.0k|}
TCP_connection.c:tcp_connections_number_is_valid:
  140|  13.1k|{
  141|  13.1k|    if ((uint32_t)tcp_connections_number >= tcp_c->tcp_connections_length) {
  ------------------
  |  Branch (141:9): [True: 0, False: 13.1k]
  ------------------
  142|      0|        return false;
  143|      0|    }
  144|       |
  145|  13.1k|    if (tcp_c->tcp_connections == nullptr) {
  ------------------
  |  |   66|  13.1k|#define nullptr NULL
  ------------------
  |  Branch (145:9): [True: 0, False: 13.1k]
  ------------------
  146|      0|        return false;
  147|      0|    }
  148|       |
  149|  13.1k|    return tcp_c->tcp_connections[tcp_connections_number].status != TCP_CONN_NONE;
  ------------------
  |  |   18|  13.1k|#define TCP_CONN_NONE 0
  ------------------
  150|  13.1k|}
TCP_connection.c:get_connection:
  267|     41|{
  268|     41|    if (!connections_number_is_valid(tcp_c, connections_number)) {
  ------------------
  |  Branch (268:9): [True: 39, False: 2]
  ------------------
  269|     39|        return nullptr;
  ------------------
  |  |   66|     39|#define nullptr NULL
  ------------------
  270|     39|    }
  271|       |
  272|      2|    return &tcp_c->connections[connections_number];
  273|     41|}
TCP_connection.c:connections_number_is_valid:
  123|     42|{
  124|     42|    if ((unsigned int)connections_number >= tcp_c->connections_length) {
  ------------------
  |  Branch (124:9): [True: 39, False: 3]
  ------------------
  125|     39|        return false;
  126|     39|    }
  127|       |
  128|      3|    if (tcp_c->connections == nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (128:9): [True: 0, False: 3]
  ------------------
  129|      0|        return false;
  130|      0|    }
  131|       |
  132|      3|    return tcp_c->connections[connections_number].status != TCP_CONN_NONE;
  ------------------
  |  |   18|      3|#define TCP_CONN_NONE 0
  ------------------
  133|      3|}
TCP_connection.c:find_tcp_connection_relay:
  622|    545|{
  623|    609|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (623:26): [True: 64, False: 545]
  ------------------
  624|     64|        const TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
  625|       |
  626|     64|        if (tcp_con != nullptr) {
  ------------------
  |  |   66|     64|#define nullptr NULL
  ------------------
  |  Branch (626:13): [True: 59, False: 5]
  ------------------
  627|     59|            if (tcp_con->status == TCP_CONN_SLEEPING) {
  ------------------
  |  |   25|     59|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (627:17): [True: 0, False: 59]
  ------------------
  628|      0|                if (pk_equal(tcp_con->relay_pk, relay_pk)) {
  ------------------
  |  Branch (628:21): [True: 0, False: 0]
  ------------------
  629|      0|                    return i;
  630|      0|                }
  631|     59|            } else {
  632|     59|                if (pk_equal(tcp_con_public_key(tcp_con->connection), relay_pk)) {
  ------------------
  |  Branch (632:21): [True: 0, False: 59]
  ------------------
  633|      0|                    return i;
  634|      0|                }
  635|     59|            }
  636|     59|        }
  637|     64|    }
  638|       |
  639|    545|    return -1;
  640|    545|}
TCP_connection.c:find_tcp_connection_to:
  602|      7|{
  603|      7|    for (uint32_t i = 0; i < tcp_c->connections_length; ++i) {
  ------------------
  |  Branch (603:26): [True: 0, False: 7]
  ------------------
  604|      0|        const TCP_Connection_to *con_to = get_connection(tcp_c, i);
  605|       |
  606|      0|        if (con_to != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (606:13): [True: 0, False: 0]
  ------------------
  607|      0|            if (pk_equal(con_to->public_key, public_key)) {
  ------------------
  |  Branch (607:17): [True: 0, False: 0]
  ------------------
  608|      0|                return i;
  609|      0|            }
  610|      0|        }
  611|      0|    }
  612|       |
  613|      7|    return -1;
  614|      7|}
TCP_connection.c:create_connection:
  159|      1|{
  160|      1|    for (uint32_t i = 0; i < tcp_c->connections_length; ++i) {
  ------------------
  |  Branch (160:26): [True: 0, False: 1]
  ------------------
  161|      0|        if (tcp_c->connections[i].status == TCP_CONN_NONE) {
  ------------------
  |  |   18|      0|#define TCP_CONN_NONE 0
  ------------------
  |  Branch (161:13): [True: 0, False: 0]
  ------------------
  162|      0|            return i;
  163|      0|        }
  164|      0|    }
  165|       |
  166|      1|    int id = -1;
  167|       |
  168|      1|    if (realloc_tcp_connection_to(tcp_c->mem, &tcp_c->connections, tcp_c->connections_length + 1) == 0) {
  ------------------
  |  Branch (168:9): [True: 1, False: 0]
  ------------------
  169|      1|        id = tcp_c->connections_length;
  170|      1|        ++tcp_c->connections_length;
  171|      1|        tcp_c->connections[id] = empty_tcp_connection_to;
  172|      1|    }
  173|       |
  174|      1|    return id;
  175|      1|}
TCP_connection.c:realloc_tcp_connection_to:
   78|      2|{
   79|      2|    if (num == 0) {
  ------------------
  |  Branch (79:9): [True: 1, False: 1]
  ------------------
   80|      1|        mem_delete(mem, *array);
   81|      1|        *array = nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
   82|      1|        return 0;
   83|      1|    }
   84|       |
   85|      1|    TCP_Connection_to *temp_pointer =
   86|      1|        (TCP_Connection_to *)mem_vrealloc(mem, *array, num, sizeof(TCP_Connection_to));
   87|       |
   88|      1|    if (temp_pointer == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (88:9): [True: 0, False: 1]
  ------------------
   89|      0|        return -1;
   90|      0|    }
   91|       |
   92|      1|    *array = temp_pointer;
   93|       |
   94|      1|    return 0;
   95|      1|}
TCP_connection.c:wipe_connection:
  209|      1|{
  210|      1|    if (!connections_number_is_valid(tcp_c, connections_number)) {
  ------------------
  |  Branch (210:9): [True: 0, False: 1]
  ------------------
  211|      0|        return -1;
  212|      0|    }
  213|       |
  214|      1|    uint32_t i;
  215|      1|    tcp_c->connections[connections_number] = empty_tcp_connection_to;
  216|       |
  217|      2|    for (i = tcp_c->connections_length; i != 0; --i) {
  ------------------
  |  Branch (217:41): [True: 1, False: 1]
  ------------------
  218|      1|        if (tcp_c->connections[i - 1].status != TCP_CONN_NONE) {
  ------------------
  |  |   18|      1|#define TCP_CONN_NONE 0
  ------------------
  |  Branch (218:13): [True: 0, False: 1]
  ------------------
  219|      0|            break;
  220|      0|        }
  221|      1|    }
  222|       |
  223|      1|    if (tcp_c->connections_length != i) {
  ------------------
  |  Branch (223:9): [True: 1, False: 0]
  ------------------
  224|      1|        tcp_c->connections_length = i;
  225|      1|        if (realloc_tcp_connection_to(tcp_c->mem, &tcp_c->connections, tcp_c->connections_length) != 0) {
  ------------------
  |  Branch (225:13): [True: 0, False: 1]
  ------------------
  226|      0|            return -1;
  227|      0|        }
  228|      1|    }
  229|       |
  230|      1|    return 0;
  231|      1|}
TCP_connection.c:wipe_tcp_connection:
  240|     57|{
  241|     57|    if (!tcp_connections_number_is_valid(tcp_c, tcp_connections_number)) {
  ------------------
  |  Branch (241:9): [True: 0, False: 57]
  ------------------
  242|      0|        return -1;
  243|      0|    }
  244|       |
  245|     57|    tcp_c->tcp_connections[tcp_connections_number] = empty_tcp_con;
  246|       |
  247|     57|    uint32_t i;
  248|       |
  249|    113|    for (i = tcp_c->tcp_connections_length; i != 0; --i) {
  ------------------
  |  Branch (249:45): [True: 63, False: 50]
  ------------------
  250|     63|        if (tcp_c->tcp_connections[i - 1].status != TCP_CONN_NONE) {
  ------------------
  |  |   18|     63|#define TCP_CONN_NONE 0
  ------------------
  |  Branch (250:13): [True: 7, False: 56]
  ------------------
  251|      7|            break;
  252|      7|        }
  253|     63|    }
  254|       |
  255|     57|    if (tcp_c->tcp_connections_length != i) {
  ------------------
  |  Branch (255:9): [True: 54, False: 3]
  ------------------
  256|     54|        tcp_c->tcp_connections_length = i;
  257|     54|        if (realloc_tcp_con(tcp_c->mem, &tcp_c->tcp_connections, tcp_c->tcp_connections_length) != 0) {
  ------------------
  |  Branch (257:13): [True: 1, False: 53]
  ------------------
  258|      1|            return -1;
  259|      1|        }
  260|     54|    }
  261|       |
  262|     56|    return 0;
  263|     57|}
TCP_connection.c:realloc_tcp_con:
   99|    594|{
  100|    594|    if (num == 0) {
  ------------------
  |  Branch (100:9): [True: 50, False: 544]
  ------------------
  101|     50|        mem_delete(mem, *array);
  102|     50|        *array = nullptr;
  ------------------
  |  |   66|     50|#define nullptr NULL
  ------------------
  103|     50|        return 0;
  104|     50|    }
  105|       |
  106|    544|    TCP_con *temp_pointer = (TCP_con *)mem_vrealloc(mem, *array, num, sizeof(TCP_con));
  107|       |
  108|    544|    if (temp_pointer == nullptr) {
  ------------------
  |  |   66|    544|#define nullptr NULL
  ------------------
  |  Branch (108:9): [True: 136, False: 408]
  ------------------
  109|    136|        return -1;
  110|    136|    }
  111|       |
  112|    408|    *array = temp_pointer;
  113|       |
  114|    408|    return 0;
  115|    544|}
TCP_connection.c:add_tcp_relay_instance:
 1290|    545|{
 1291|    545|    IP_Port ipp_copy = *ip_port;
 1292|       |
 1293|    545|    if (net_family_is_tcp_ipv4(ipp_copy.ip.family)) {
  ------------------
  |  Branch (1293:9): [True: 0, False: 545]
  ------------------
 1294|      0|        ipp_copy.ip.family = net_family_ipv4();
 1295|    545|    } else if (net_family_is_tcp_ipv6(ipp_copy.ip.family)) {
  ------------------
  |  Branch (1295:16): [True: 0, False: 545]
  ------------------
 1296|      0|        ipp_copy.ip.family = net_family_ipv6();
 1297|      0|    }
 1298|       |
 1299|    545|    if (!net_family_is_ipv4(ipp_copy.ip.family) && !net_family_is_ipv6(ipp_copy.ip.family)) {
  ------------------
  |  Branch (1299:9): [True: 0, False: 545]
  |  Branch (1299:52): [True: 0, False: 0]
  ------------------
 1300|      0|        return -1;
 1301|      0|    }
 1302|       |
 1303|    545|    const int tcp_connections_number = create_tcp_connection(tcp_c);
 1304|       |
 1305|    545|    if (tcp_connections_number == -1) {
  ------------------
  |  Branch (1305:9): [True: 135, False: 410]
  ------------------
 1306|    135|        return -1;
 1307|    135|    }
 1308|       |
 1309|    410|    TCP_con *tcp_con = &tcp_c->tcp_connections[tcp_connections_number];
 1310|       |
 1311|    410|    tcp_con->connection = new_tcp_connection(
 1312|    410|            tcp_c->logger, tcp_c->mem, tcp_c->mono_time, tcp_c->rng, tcp_c->ns, &ipp_copy,
 1313|    410|            relay_pk, tcp_c->self_public_key, tcp_c->self_secret_key, &tcp_c->proxy_info);
 1314|       |
 1315|    410|    if (tcp_con->connection == nullptr) {
  ------------------
  |  |   66|    410|#define nullptr NULL
  ------------------
  |  Branch (1315:9): [True: 30, False: 380]
  ------------------
 1316|     30|        return -1;
 1317|     30|    }
 1318|       |
 1319|    380|    tcp_con->status = TCP_CONN_VALID;
  ------------------
  |  |   19|    380|#define TCP_CONN_VALID 1
  ------------------
 1320|       |
 1321|    380|    return tcp_connections_number;
 1322|    410|}
TCP_connection.c:create_tcp_connection:
  184|    545|{
  185|    604|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (185:26): [True: 64, False: 540]
  ------------------
  186|     64|        if (tcp_c->tcp_connections[i].status == TCP_CONN_NONE) {
  ------------------
  |  |   18|     64|#define TCP_CONN_NONE 0
  ------------------
  |  Branch (186:13): [True: 5, False: 59]
  ------------------
  187|      5|            return i;
  188|      5|        }
  189|     64|    }
  190|       |
  191|    540|    int id = -1;
  192|       |
  193|    540|    if (realloc_tcp_con(tcp_c->mem, &tcp_c->tcp_connections, tcp_c->tcp_connections_length + 1) == 0) {
  ------------------
  |  Branch (193:9): [True: 405, False: 135]
  ------------------
  194|    405|        id = tcp_c->tcp_connections_length;
  195|    405|        ++tcp_c->tcp_connections_length;
  196|    405|        tcp_c->tcp_connections[id] = empty_tcp_con;
  197|    405|    }
  198|       |
  199|    540|    return id;
  200|    545|}
TCP_connection.c:do_tcp_conns:
 1622|  72.6k|{
 1623|  79.9k|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1623:26): [True: 7.28k, False: 72.6k]
  ------------------
 1624|  7.28k|        TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1625|       |
 1626|  7.28k|        if (tcp_con == nullptr) {
  ------------------
  |  |   66|  7.28k|#define nullptr NULL
  ------------------
  |  Branch (1626:13): [True: 2.91k, False: 4.36k]
  ------------------
 1627|  2.91k|            continue;
 1628|  2.91k|        }
 1629|       |
 1630|  4.36k|        if (tcp_con->status != TCP_CONN_SLEEPING) {
  ------------------
  |  |   25|  4.36k|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (1630:13): [True: 4.36k, False: 0]
  ------------------
 1631|  4.36k|            do_tcp_connection(logger, tcp_c->mono_time, tcp_con->connection, userdata);
 1632|       |
 1633|       |            /* callbacks can change TCP connection address. */
 1634|  4.36k|            tcp_con = get_tcp_connection(tcp_c, i);
 1635|       |
 1636|       |            // Make sure the TCP connection wasn't dropped in any of the callbacks.
 1637|  4.36k|            assert(tcp_con != nullptr);
 1638|       |
 1639|  4.36k|            if (tcp_con_status(tcp_con->connection) == TCP_CLIENT_DISCONNECTED) {
  ------------------
  |  Branch (1639:17): [True: 192, False: 4.17k]
  ------------------
 1640|    192|                if (tcp_con->status == TCP_CONN_CONNECTED) {
  ------------------
  |  |   22|    192|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (1640:21): [True: 138, False: 54]
  ------------------
 1641|    138|                    reconnect_tcp_relay_connection(tcp_c, i);
 1642|    138|                } else {
 1643|     54|                    kill_tcp_relay_connection(tcp_c, i);
 1644|     54|                }
 1645|       |
 1646|    192|                continue;
 1647|    192|            }
 1648|       |
 1649|  4.17k|            if (tcp_con->status == TCP_CONN_VALID && tcp_con_status(tcp_con->connection) == TCP_CLIENT_CONFIRMED) {
  ------------------
  |  |   19|  8.35k|#define TCP_CONN_VALID 1
  ------------------
  |  Branch (1649:17): [True: 2.30k, False: 1.87k]
  |  Branch (1649:54): [True: 188, False: 2.11k]
  ------------------
 1650|    188|                tcp_relay_on_online(tcp_c, i);
 1651|    188|            }
 1652|       |
 1653|  4.17k|            if (tcp_con->status == TCP_CONN_CONNECTED
  ------------------
  |  |   22|  8.35k|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (1653:17): [True: 2.05k, False: 2.11k]
  ------------------
 1654|  4.17k|                    && !tcp_con->onion && tcp_con->lock_count > 0
  ------------------
  |  Branch (1654:24): [True: 53, False: 2.00k]
  |  Branch (1654:43): [True: 0, False: 53]
  ------------------
 1655|  4.17k|                    && tcp_con->lock_count == tcp_con->sleep_count
  ------------------
  |  Branch (1655:24): [True: 0, False: 0]
  ------------------
 1656|  4.17k|                    && mono_time_is_timeout(tcp_c->mono_time, tcp_con->connected_time, TCP_CONNECTION_ANNOUNCE_TIMEOUT)) {
  ------------------
  |  |   34|      0|#define TCP_CONNECTION_ANNOUNCE_TIMEOUT TCP_CONNECTION_TIMEOUT
  |  |  ------------------
  |  |  |  |   17|      0|#define TCP_CONNECTION_TIMEOUT 10
  |  |  ------------------
  ------------------
  |  Branch (1656:24): [True: 0, False: 0]
  ------------------
 1657|      0|                sleep_tcp_relay_connection(tcp_c, i);
 1658|      0|            }
 1659|  4.17k|        }
 1660|       |
 1661|  4.17k|        if (tcp_con->status == TCP_CONN_SLEEPING && tcp_con->unsleep) {
  ------------------
  |  |   25|  8.35k|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (1661:13): [True: 0, False: 4.17k]
  |  Branch (1661:53): [True: 0, False: 0]
  ------------------
 1662|      0|            unsleep_tcp_relay_connection(tcp_c, i);
 1663|      0|        }
 1664|  4.17k|    }
 1665|  72.6k|}
TCP_connection.c:reconnect_tcp_relay_connection:
  913|    138|{
  914|    138|    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);
  915|       |
  916|    138|    if (tcp_con == nullptr) {
  ------------------
  |  |   66|    138|#define nullptr NULL
  ------------------
  |  Branch (916:9): [True: 0, False: 138]
  ------------------
  917|      0|        return -1;
  918|      0|    }
  919|       |
  920|    138|    if (tcp_con->status == TCP_CONN_SLEEPING) {
  ------------------
  |  |   25|    138|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (920:9): [True: 0, False: 138]
  ------------------
  921|      0|        return -1;
  922|      0|    }
  923|       |
  924|    138|    IP_Port ip_port = tcp_con_ip_port(tcp_con->connection);
  925|    138|    uint8_t relay_pk[CRYPTO_PUBLIC_KEY_SIZE];
  926|    138|    memcpy(relay_pk, tcp_con_public_key(tcp_con->connection), CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    138|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  927|    138|    kill_tcp_connection(tcp_con->connection);
  928|    138|    tcp_con->connection = new_tcp_connection(tcp_c->logger, tcp_c->mem, tcp_c->mono_time, tcp_c->rng, tcp_c->ns, &ip_port, relay_pk, tcp_c->self_public_key, tcp_c->self_secret_key, &tcp_c->proxy_info);
  929|       |
  930|    138|    if (tcp_con->connection == nullptr) {
  ------------------
  |  |   66|    138|#define nullptr NULL
  ------------------
  |  Branch (930:9): [True: 3, False: 135]
  ------------------
  931|      3|        kill_tcp_relay_connection(tcp_c, tcp_connections_number);
  932|      3|        return -1;
  933|      3|    }
  934|       |
  935|    135|    for (uint32_t i = 0; i < tcp_c->connections_length; ++i) {
  ------------------
  |  Branch (935:26): [True: 0, False: 135]
  ------------------
  936|      0|        TCP_Connection_to *con_to = get_connection(tcp_c, i);
  937|       |
  938|      0|        if (con_to != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (938:13): [True: 0, False: 0]
  ------------------
  939|      0|            set_tcp_connection_status(con_to, tcp_connections_number, TCP_CONNECTIONS_STATUS_NONE, 0);
  ------------------
  |  |   27|      0|#define TCP_CONNECTIONS_STATUS_NONE 0
  ------------------
  940|      0|        }
  941|      0|    }
  942|       |
  943|    135|    if (tcp_con->onion) {
  ------------------
  |  Branch (943:9): [True: 135, False: 0]
  ------------------
  944|    135|        --tcp_c->onion_num_conns;
  945|    135|        tcp_con->onion = 0;
  946|    135|    }
  947|       |
  948|    135|    tcp_con->lock_count = 0;
  949|    135|    tcp_con->sleep_count = 0;
  950|    135|    tcp_con->connected_time = 0;
  951|    135|    tcp_con->status = TCP_CONN_VALID;
  ------------------
  |  |   19|    135|#define TCP_CONN_VALID 1
  ------------------
  952|    135|    tcp_con->unsleep = 0;
  953|       |
  954|    135|    return 0;
  955|    138|}
TCP_connection.c:tcp_relay_on_online:
 1249|    188|{
 1250|    188|    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);
 1251|       |
 1252|    188|    if (tcp_con == nullptr) {
  ------------------
  |  |   66|    188|#define nullptr NULL
  ------------------
  |  Branch (1252:9): [True: 0, False: 188]
  ------------------
 1253|      0|        return -1;
 1254|      0|    }
 1255|       |
 1256|    188|    bool sent_any = false;
 1257|       |
 1258|    188|    for (uint32_t i = 0; i < tcp_c->connections_length; ++i) {
  ------------------
  |  Branch (1258:26): [True: 0, False: 188]
  ------------------
 1259|      0|        TCP_Connection_to *con_to = get_connection(tcp_c, i);
 1260|       |
 1261|      0|        if (con_to != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1261:13): [True: 0, False: 0]
  ------------------
 1262|      0|            if (tcp_connection_in_conn(con_to, tcp_connections_number)) {
  ------------------
  |  Branch (1262:17): [True: 0, False: 0]
  ------------------
 1263|      0|                if (send_tcp_relay_routing_request(tcp_c, tcp_connections_number, con_to->public_key) == 0) {
  ------------------
  |  Branch (1263:21): [True: 0, False: 0]
  ------------------
 1264|      0|                    sent_any = true;
 1265|      0|                }
 1266|      0|            }
 1267|      0|        }
 1268|      0|    }
 1269|       |
 1270|    188|    tcp_relay_set_callbacks(tcp_c, tcp_connections_number);
 1271|    188|    tcp_con->status = TCP_CONN_CONNECTED;
  ------------------
  |  |   22|    188|#define TCP_CONN_CONNECTED 2
  ------------------
 1272|       |
 1273|       |    /* If this connection isn't used by any connection, we don't need to wait for them to come online. */
 1274|    188|    if (sent_any) {
  ------------------
  |  Branch (1274:9): [True: 0, False: 188]
  ------------------
 1275|      0|        tcp_con->connected_time = mono_time_get(tcp_c->mono_time);
 1276|    188|    } else {
 1277|    188|        tcp_con->connected_time = 0;
 1278|    188|    }
 1279|       |
 1280|    188|    if (tcp_c->onion_status && tcp_c->onion_num_conns < NUM_ONION_TCP_CONNECTIONS) {
  ------------------
  |  |   42|    135|#define NUM_ONION_TCP_CONNECTIONS RECOMMENDED_FRIEND_TCP_CONNECTIONS
  |  |  ------------------
  |  |  |  |   39|    135|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   31|    135|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1280:9): [True: 135, False: 53]
  |  Branch (1280:32): [True: 135, False: 0]
  ------------------
 1281|    135|        tcp_con->onion = 1;
 1282|    135|        ++tcp_c->onion_num_conns;
 1283|    135|    }
 1284|       |
 1285|    188|    return 0;
 1286|    188|}
TCP_connection.c:tcp_relay_set_callbacks:
 1226|    188|{
 1227|    188|    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);
 1228|       |
 1229|    188|    if (tcp_con == nullptr) {
  ------------------
  |  |   66|    188|#define nullptr NULL
  ------------------
  |  Branch (1229:9): [True: 0, False: 188]
  ------------------
 1230|      0|        return -1;
 1231|      0|    }
 1232|       |
 1233|    188|    TCP_Client_Connection *con = tcp_con->connection;
 1234|       |
 1235|    188|    tcp_con_set_custom_object(con, tcp_c);
 1236|    188|    tcp_con_set_custom_uint(con, tcp_connections_number);
 1237|    188|    onion_response_handler(con, &tcp_onion_callback, tcp_c);
 1238|    188|    forwarding_handler(con, &tcp_forwarding_callback, tcp_c);
 1239|    188|    routing_response_handler(con, &tcp_response_callback, con);
 1240|    188|    routing_status_handler(con, &tcp_status_callback, con);
 1241|    188|    routing_data_handler(con, &tcp_conn_data_callback, con);
 1242|    188|    oob_data_handler(con, &tcp_conn_oob_callback, con);
 1243|       |
 1244|    188|    return 0;
 1245|    188|}
TCP_connection.c:tcp_onion_callback:
 1199|      1|{
 1200|      1|    TCP_Connections *tcp_c = (TCP_Connections *)object;
 1201|       |
 1202|      1|    if (tcp_c->tcp_onion_callback != nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1202:9): [True: 1, False: 0]
  ------------------
 1203|      1|        tcp_c->tcp_onion_callback(tcp_c->tcp_onion_callback_object, data, length, userdata);
 1204|      1|    }
 1205|       |
 1206|      1|    return 0;
 1207|      1|}
TCP_connection.c:tcp_forwarding_callback:
 1211|     10|{
 1212|     10|    TCP_Connections *tcp_c = (TCP_Connections *)object;
 1213|       |
 1214|     10|    if (tcp_c->tcp_forwarded_response_callback != nullptr) {
  ------------------
  |  |   66|     10|#define nullptr NULL
  ------------------
  |  Branch (1214:9): [True: 0, False: 10]
  ------------------
 1215|      0|        tcp_c->tcp_forwarded_response_callback(tcp_c->tcp_forwarded_response_callback_object, data, length, userdata);
 1216|      0|    }
 1217|     10|}
TCP_connection.c:tcp_conn_data_callback:
 1135|     33|{
 1136|     33|    if (length == 0) {
  ------------------
  |  Branch (1136:9): [True: 0, False: 33]
  ------------------
 1137|      0|        return -1;
 1138|      0|    }
 1139|       |
 1140|     33|    const TCP_Client_Connection *tcp_client_con = (TCP_Client_Connection *)object;
 1141|     33|    TCP_Connections *tcp_c = (TCP_Connections *)tcp_con_custom_object(tcp_client_con);
 1142|       |
 1143|     33|    const unsigned int tcp_connections_number = tcp_con_custom_uint(tcp_client_con);
 1144|     33|    const TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);
 1145|       |
 1146|     33|    if (tcp_con == nullptr) {
  ------------------
  |  |   66|     33|#define nullptr NULL
  ------------------
  |  Branch (1146:9): [True: 0, False: 33]
  ------------------
 1147|      0|        return -1;
 1148|      0|    }
 1149|       |
 1150|     33|    const TCP_Connection_to *con_to = get_connection(tcp_c, number);
 1151|       |
 1152|     33|    if (con_to == nullptr) {
  ------------------
  |  |   66|     33|#define nullptr NULL
  ------------------
  |  Branch (1152:9): [True: 33, False: 0]
  ------------------
 1153|     33|        return -1;
 1154|     33|    }
 1155|       |
 1156|      0|    if (tcp_c->tcp_data_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1156:9): [True: 0, False: 0]
  ------------------
 1157|      0|        tcp_c->tcp_data_callback(tcp_c->tcp_data_callback_object, con_to->id, data, length, userdata);
 1158|      0|    }
 1159|       |
 1160|      0|    return 0;
 1161|     33|}
TCP_connection.c:tcp_conn_oob_callback:
 1166|      6|{
 1167|      6|    if (length == 0) {
  ------------------
  |  Branch (1167:9): [True: 0, False: 6]
  ------------------
 1168|      0|        return -1;
 1169|      0|    }
 1170|       |
 1171|      6|    const TCP_Client_Connection *tcp_client_con = (const TCP_Client_Connection *)object;
 1172|      6|    TCP_Connections *tcp_c = (TCP_Connections *)tcp_con_custom_object(tcp_client_con);
 1173|       |
 1174|      6|    const unsigned int tcp_connections_number = tcp_con_custom_uint(tcp_client_con);
 1175|      6|    const TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);
 1176|       |
 1177|      6|    if (tcp_con == nullptr) {
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  |  Branch (1177:9): [True: 0, False: 6]
  ------------------
 1178|      0|        return -1;
 1179|      0|    }
 1180|       |
 1181|       |    /* TODO(irungentoo): optimize */
 1182|      6|    const int connections_number = find_tcp_connection_to(tcp_c, public_key);
 1183|       |
 1184|      6|    const TCP_Connection_to *con_to = get_connection(tcp_c, connections_number);
 1185|       |
 1186|      6|    if (con_to != nullptr && tcp_connection_in_conn(con_to, tcp_connections_number)) {
  ------------------
  |  |   66|     12|#define nullptr NULL
  ------------------
  |  Branch (1186:9): [True: 0, False: 6]
  |  Branch (1186:30): [True: 0, False: 0]
  ------------------
 1187|      0|        return tcp_conn_data_callback(object, connections_number, 0, data, length, userdata);
 1188|      0|    }
 1189|       |
 1190|      6|    if (tcp_c->tcp_oob_callback != nullptr) {
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  |  Branch (1190:9): [True: 6, False: 0]
  ------------------
 1191|      6|        tcp_c->tcp_oob_callback(tcp_c->tcp_oob_callback_object, public_key, tcp_connections_number, data, length, userdata);
 1192|      6|    }
 1193|       |
 1194|      6|    return 0;
 1195|      6|}
TCP_connection.c:kill_nonused_tcp:
 1669|  72.6k|{
 1670|  72.6k|    if (tcp_c->tcp_connections_length <= RECOMMENDED_FRIEND_TCP_CONNECTIONS) {
  ------------------
  |  |   39|  72.6k|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  ------------------
  |  |  |  |   31|  72.6k|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  ------------------
  ------------------
  |  Branch (1670:9): [True: 72.6k, False: 0]
  ------------------
 1671|  72.6k|        return;
 1672|  72.6k|    }
 1673|       |
 1674|      0|    const uint32_t num_online = tcp_connected_relays_count(tcp_c);
 1675|       |
 1676|      0|    if (num_online <= RECOMMENDED_FRIEND_TCP_CONNECTIONS) {
  ------------------
  |  |   39|      0|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  ------------------
  |  |  |  |   31|      0|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  ------------------
  ------------------
  |  Branch (1676:9): [True: 0, False: 0]
  ------------------
 1677|      0|        return;
 1678|      0|    }
 1679|       |
 1680|      0|    const uint32_t max_kill_count = num_online - RECOMMENDED_FRIEND_TCP_CONNECTIONS;
  ------------------
  |  |   39|      0|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  ------------------
  |  |  |  |   31|      0|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  ------------------
  ------------------
 1681|      0|    uint32_t kill_count = 0;
 1682|       |
 1683|      0|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length && kill_count < max_kill_count; ++i) {
  ------------------
  |  Branch (1683:26): [True: 0, False: 0]
  |  Branch (1683:63): [True: 0, False: 0]
  ------------------
 1684|      0|        const TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1685|       |
 1686|      0|        if (tcp_con == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1686:13): [True: 0, False: 0]
  ------------------
 1687|      0|            continue;
 1688|      0|        }
 1689|       |
 1690|      0|        if (tcp_con->status == TCP_CONN_CONNECTED) {
  ------------------
  |  |   22|      0|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (1690:13): [True: 0, False: 0]
  ------------------
 1691|      0|            if (tcp_con->onion || tcp_con->lock_count > 0) {  // connection is in use so we skip it
  ------------------
  |  Branch (1691:17): [True: 0, False: 0]
  |  Branch (1691:35): [True: 0, False: 0]
  ------------------
 1692|      0|                continue;
 1693|      0|            }
 1694|       |
 1695|      0|            if (mono_time_is_timeout(tcp_c->mono_time, tcp_con->connected_time, TCP_CONNECTION_ANNOUNCE_TIMEOUT)) {
  ------------------
  |  |   34|      0|#define TCP_CONNECTION_ANNOUNCE_TIMEOUT TCP_CONNECTION_TIMEOUT
  |  |  ------------------
  |  |  |  |   17|      0|#define TCP_CONNECTION_TIMEOUT 10
  |  |  ------------------
  ------------------
  |  Branch (1695:17): [True: 0, False: 0]
  ------------------
 1696|      0|                kill_tcp_relay_connection(tcp_c, i);
 1697|      0|                ++kill_count;
 1698|      0|            }
 1699|      0|        }
 1700|      0|    }
 1701|      0|}

tcp_server_public_key:
   91|    137|{
   92|    137|    return tcp_server->public_key;
   93|    137|}
new_tcp_server:
  943|    147|{
  944|    147|    if (num_sockets == 0 || ports == nullptr) {
  ------------------
  |  |   66|    147|#define nullptr NULL
  ------------------
  |  Branch (944:9): [True: 0, False: 147]
  |  Branch (944:29): [True: 0, False: 147]
  ------------------
  945|      0|        LOGGER_ERROR(logger, "no sockets");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  946|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  947|      0|    }
  948|       |
  949|    147|    if (ns == nullptr) {
  ------------------
  |  |   66|    147|#define nullptr NULL
  ------------------
  |  Branch (949:9): [True: 0, False: 147]
  ------------------
  950|      0|        LOGGER_ERROR(logger, "NULL network");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  951|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  952|      0|    }
  953|       |
  954|    147|    TCP_Server *temp = (TCP_Server *)mem_alloc(mem, sizeof(TCP_Server));
  955|       |
  956|    147|    if (temp == nullptr) {
  ------------------
  |  |   66|    147|#define nullptr NULL
  ------------------
  |  Branch (956:9): [True: 1, False: 146]
  ------------------
  957|      1|        LOGGER_ERROR(logger, "TCP server allocation failed");
  ------------------
  |  |   83|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      1|    do {                                                                         \
  |  |  |  |   73|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      1|        }                                                                        \
  |  |  |  |   76|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  958|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  959|      1|    }
  960|       |
  961|    146|    temp->logger = logger;
  962|    146|    temp->mem = mem;
  963|    146|    temp->ns = ns;
  964|    146|    temp->rng = rng;
  965|       |
  966|    146|    temp->socks_listening = (Socket *)mem_valloc(mem, num_sockets, sizeof(Socket));
  967|       |
  968|    146|    if (temp->socks_listening == nullptr) {
  ------------------
  |  |   66|    146|#define nullptr NULL
  ------------------
  |  Branch (968:9): [True: 1, False: 145]
  ------------------
  969|      1|        LOGGER_ERROR(logger, "socket allocation failed");
  ------------------
  |  |   83|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      1|    do {                                                                         \
  |  |  |  |   73|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      1|        }                                                                        \
  |  |  |  |   76|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  970|      1|        mem_delete(mem, temp);
  971|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  972|      1|    }
  973|       |
  974|       |#ifdef TCP_SERVER_USE_EPOLL
  975|       |    temp->efd = epoll_create(8);
  976|       |
  977|       |    if (temp->efd == -1) {
  978|       |        LOGGER_ERROR(logger, "epoll initialisation failed");
  979|       |        mem_delete(mem, temp->socks_listening);
  980|       |        mem_delete(mem, temp);
  981|       |        return nullptr;
  982|       |    }
  983|       |
  984|       |#endif
  985|       |
  986|    145|    const Family family = ipv6_enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (986:27): [True: 145, False: 0]
  ------------------
  987|       |
  988|    290|    for (uint32_t i = 0; i < num_sockets; ++i) {
  ------------------
  |  Branch (988:26): [True: 145, False: 145]
  ------------------
  989|    145|        const Socket sock = new_listening_tcp_socket(logger, ns, family, ports[i]);
  990|       |
  991|    145|        if (!sock_valid(sock)) {
  ------------------
  |  Branch (991:13): [True: 0, False: 145]
  ------------------
  992|      0|            continue;
  993|      0|        }
  994|       |
  995|       |#ifdef TCP_SERVER_USE_EPOLL
  996|       |        struct epoll_event ev;
  997|       |
  998|       |        ev.events = EPOLLIN | EPOLLET;
  999|       |        ev.data.u64 = sock.sock | ((uint64_t)TCP_SOCKET_LISTENING << 32);
 1000|       |
 1001|       |        if (epoll_ctl(temp->efd, EPOLL_CTL_ADD, sock.sock, &ev) == -1) {
 1002|       |            continue;
 1003|       |        }
 1004|       |
 1005|       |#endif
 1006|       |
 1007|    145|        temp->socks_listening[temp->num_listening_socks] = sock;
 1008|    145|        ++temp->num_listening_socks;
 1009|    145|    }
 1010|       |
 1011|    145|    if (temp->num_listening_socks == 0) {
  ------------------
  |  Branch (1011:9): [True: 0, False: 145]
  ------------------
 1012|      0|        mem_delete(mem, temp->socks_listening);
 1013|      0|        mem_delete(mem, temp);
 1014|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1015|      0|    }
 1016|       |
 1017|    145|    if (onion != nullptr) {
  ------------------
  |  |   66|    145|#define nullptr NULL
  ------------------
  |  Branch (1017:9): [True: 145, False: 0]
  ------------------
 1018|    145|        temp->onion = onion;
 1019|    145|        set_callback_handle_recv_1(onion, &handle_onion_recv_1, temp);
 1020|    145|    }
 1021|       |
 1022|    145|    if (forwarding != nullptr) {
  ------------------
  |  |   66|    145|#define nullptr NULL
  ------------------
  |  Branch (1022:9): [True: 145, False: 0]
  ------------------
 1023|    145|        temp->forwarding = forwarding;
 1024|    145|        set_callback_forward_reply(forwarding, &handle_forward_reply_tcp, temp);
 1025|    145|    }
 1026|       |
 1027|    145|    memcpy(temp->secret_key, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   45|    145|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 1028|    145|    crypto_derive_public_key(temp->public_key, temp->secret_key);
 1029|       |
 1030|    145|    bs_list_init(&temp->accepted_key_list, CRYPTO_PUBLIC_KEY_SIZE, 8);
  ------------------
  |  |   40|    145|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1031|       |
 1032|    145|    return temp;
 1033|    145|}
do_tcp_server:
 1366|    174|{
 1367|       |#ifdef TCP_SERVER_USE_EPOLL
 1368|       |    do_tcp_epoll(tcp_server, mono_time);
 1369|       |
 1370|       |#else
 1371|    174|    do_tcp_accept_new(tcp_server);
 1372|    174|    do_tcp_incoming(tcp_server);
 1373|    174|    do_tcp_unconfirmed(tcp_server, mono_time);
 1374|    174|#endif
 1375|       |
 1376|    174|    do_tcp_confirmed(tcp_server, mono_time);
 1377|    174|}
kill_tcp_server:
 1380|    145|{
 1381|    145|    if (tcp_server == nullptr) {
  ------------------
  |  |   66|    145|#define nullptr NULL
  ------------------
  |  Branch (1381:9): [True: 0, False: 145]
  ------------------
 1382|      0|        return;
 1383|      0|    }
 1384|       |
 1385|    290|    for (uint32_t i = 0; i < tcp_server->num_listening_socks; ++i) {
  ------------------
  |  Branch (1385:26): [True: 145, False: 145]
  ------------------
 1386|    145|        kill_sock(tcp_server->ns, tcp_server->socks_listening[i]);
 1387|    145|    }
 1388|       |
 1389|    145|    if (tcp_server->onion != nullptr) {
  ------------------
  |  |   66|    145|#define nullptr NULL
  ------------------
  |  Branch (1389:9): [True: 145, False: 0]
  ------------------
 1390|    145|        set_callback_handle_recv_1(tcp_server->onion, nullptr, nullptr);
  ------------------
  |  |   66|    145|#define nullptr NULL
  ------------------
                      set_callback_handle_recv_1(tcp_server->onion, nullptr, nullptr);
  ------------------
  |  |   66|    145|#define nullptr NULL
  ------------------
 1391|    145|    }
 1392|       |
 1393|    145|    if (tcp_server->forwarding != nullptr) {
  ------------------
  |  |   66|    145|#define nullptr NULL
  ------------------
  |  Branch (1393:9): [True: 145, False: 0]
  ------------------
 1394|    145|        set_callback_forward_reply(tcp_server->forwarding, nullptr, nullptr);
  ------------------
  |  |   66|    145|#define nullptr NULL
  ------------------
                      set_callback_forward_reply(tcp_server->forwarding, nullptr, nullptr);
  ------------------
  |  |   66|    145|#define nullptr NULL
  ------------------
 1395|    145|    }
 1396|       |
 1397|    145|    bs_list_free(&tcp_server->accepted_key_list);
 1398|       |
 1399|       |#ifdef TCP_SERVER_USE_EPOLL
 1400|       |    close(tcp_server->efd);
 1401|       |#endif
 1402|       |
 1403|  37.2k|    for (uint32_t i = 0; i < MAX_INCOMING_CONNECTIONS; ++i) {
  ------------------
  |  |   16|  37.2k|#define MAX_INCOMING_CONNECTIONS 256
  ------------------
  |  Branch (1403:26): [True: 37.1k, False: 145]
  ------------------
 1404|  37.1k|        wipe_secure_connection(&tcp_server->incoming_connection_queue[i]);
 1405|  37.1k|        wipe_secure_connection(&tcp_server->unconfirmed_connection_queue[i]);
 1406|  37.1k|    }
 1407|       |
 1408|    145|    free_accepted_connection_array(tcp_server);
 1409|       |
 1410|    145|    crypto_memzero(tcp_server->secret_key, sizeof(tcp_server->secret_key));
 1411|       |
 1412|    145|    mem_delete(tcp_server->mem, tcp_server->socks_listening);
 1413|    145|    mem_delete(tcp_server->mem, tcp_server);
 1414|    145|}
TCP_server.c:new_listening_tcp_socket:
  907|    145|{
  908|    145|    const Socket sock = net_socket(ns, family, TOX_SOCK_STREAM, TOX_PROTO_TCP);
  ------------------
  |  |  212|    145|#define TOX_SOCK_STREAM 1
  ------------------
                  const Socket sock = net_socket(ns, family, TOX_SOCK_STREAM, TOX_PROTO_TCP);
  ------------------
  |  |  215|    145|#define TOX_PROTO_TCP 1
  ------------------
  909|       |
  910|    145|    if (!sock_valid(sock)) {
  ------------------
  |  Branch (910:9): [True: 0, False: 145]
  ------------------
  911|      0|        LOGGER_ERROR(logger, "TCP socket creation failed (family = %d)", family.value);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  912|      0|        return net_invalid_socket;
  913|      0|    }
  914|       |
  915|    145|    bool ok = set_socket_nonblock(ns, sock);
  916|       |
  917|    145|    if (ok && net_family_is_ipv6(family)) {
  ------------------
  |  Branch (917:9): [True: 145, False: 0]
  |  Branch (917:15): [True: 145, False: 0]
  ------------------
  918|    145|        ok = set_socket_dualstack(ns, sock);
  919|    145|    }
  920|       |
  921|    145|    if (ok) {
  ------------------
  |  Branch (921:9): [True: 145, False: 0]
  ------------------
  922|    145|        ok = set_socket_reuseaddr(ns, sock);
  923|    145|    }
  924|       |
  925|    145|    ok = ok && bind_to_port(ns, sock, family, port) && (net_listen(ns, sock, TCP_MAX_BACKLOG) == 0);
  ------------------
  |  |   18|    145|#define TCP_MAX_BACKLOG MAX_INCOMING_CONNECTIONS
  |  |  ------------------
  |  |  |  |   16|    145|#define MAX_INCOMING_CONNECTIONS 256
  |  |  ------------------
  ------------------
  |  Branch (925:10): [True: 145, False: 0]
  |  Branch (925:16): [True: 145, False: 0]
  |  Branch (925:56): [True: 145, False: 0]
  ------------------
  926|       |
  927|    145|    if (!ok) {
  ------------------
  |  Branch (927:9): [True: 0, False: 145]
  ------------------
  928|      0|        char *const error = net_new_strerror(net_error());
  929|      0|        LOGGER_WARNING(logger, "could not bind to TCP port %d (family = %d): %s",
  ------------------
  |  |   82|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (74:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  930|      0|                       port, family.value, error != nullptr ? error : "(null)");
  931|      0|        net_kill_strerror(error);
  932|      0|        kill_sock(ns, sock);
  933|      0|        return net_invalid_socket;
  934|      0|    }
  935|       |
  936|    145|    LOGGER_DEBUG(logger, "successfully bound to TCP port %d", port);
  ------------------
  |  |   80|    145|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    145|    do {                                                                         \
  |  |  |  |   73|    145|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    290|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|    145|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  937|    145|    return sock;
  938|    145|}
TCP_server.c:handle_onion_recv_1:
  602|     13|{
  603|     13|    TCP_Server *tcp_server = (TCP_Server *)object;
  604|     13|    uint32_t index;
  605|       |
  606|     13|    if (!ip_port_to_con_id(tcp_server, dest, &index)) {
  ------------------
  |  Branch (606:9): [True: 13, False: 0]
  ------------------
  607|     13|        return 1;
  608|     13|    }
  609|       |
  610|      0|    TCP_Secure_Connection *con = &tcp_server->accepted_connection_array[index];
  611|       |
  612|      0|    VLA(uint8_t, packet, 1 + length);
  ------------------
  |  |   62|      0|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      0|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  613|      0|    memcpy(packet + 1, data, length);
  614|      0|    packet[0] = TCP_PACKET_ONION_RESPONSE;
  ------------------
  |  |   50|      0|#define TCP_PACKET_ONION_RESPONSE 9
  ------------------
  615|       |
  616|      0|    if (write_packet_tcp_secure_connection(tcp_server->logger, &con->con, packet, SIZEOF_VLA(packet), false) != 1) {
  ------------------
  |  |   29|      0|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (616:9): [True: 0, False: 0]
  ------------------
  617|      0|        return 1;
  618|      0|    }
  619|       |
  620|      0|    return 0;
  621|      0|}
TCP_server.c:ip_port_to_con_id:
  592|     13|{
  593|     13|    *con_id = ip_port->ip.ip.v6.uint32[0];
  594|       |
  595|     13|    return net_family_is_tcp_client(ip_port->ip.family) &&
  ------------------
  |  Branch (595:12): [True: 3, False: 10]
  ------------------
  596|     13|           *con_id < tcp_server->size_accepted_connections &&
  ------------------
  |  Branch (596:12): [True: 0, False: 3]
  ------------------
  597|     13|           tcp_server->accepted_connection_array[*con_id].identifier == ip_port->ip.ip.v6.uint64[1];
  ------------------
  |  Branch (597:12): [True: 0, False: 0]
  ------------------
  598|     13|}
TCP_server.c:do_tcp_accept_new:
 1038|    174|{
 1039|    348|    for (uint32_t sock_idx = 0; sock_idx < tcp_server->num_listening_socks; ++sock_idx) {
  ------------------
  |  Branch (1039:33): [True: 174, False: 174]
  ------------------
 1040|       |
 1041|  44.7k|        for (uint32_t connection_idx = 0; connection_idx < MAX_INCOMING_CONNECTIONS; ++connection_idx) {
  ------------------
  |  |   16|  44.7k|#define MAX_INCOMING_CONNECTIONS 256
  ------------------
  |  Branch (1041:43): [True: 44.5k, False: 174]
  ------------------
 1042|  44.5k|            const Socket sock = net_accept(tcp_server->ns, tcp_server->socks_listening[sock_idx]);
 1043|       |
 1044|  44.5k|            if (accept_connection(tcp_server, sock) == -1) {
  ------------------
  |  Branch (1044:17): [True: 0, False: 44.5k]
  ------------------
 1045|      0|                break;
 1046|      0|            }
 1047|  44.5k|        }
 1048|    174|    }
 1049|    174|}
TCP_server.c:accept_connection:
  870|  44.5k|{
  871|  44.5k|    if (!sock_valid(sock)) {
  ------------------
  |  Branch (871:9): [True: 0, False: 44.5k]
  ------------------
  872|      0|        return -1;
  873|      0|    }
  874|       |
  875|  44.5k|    if (!set_socket_nonblock(tcp_server->ns, sock)) {
  ------------------
  |  Branch (875:9): [True: 0, False: 44.5k]
  ------------------
  876|      0|        kill_sock(tcp_server->ns, sock);
  877|      0|        return -1;
  878|      0|    }
  879|       |
  880|  44.5k|    if (!set_socket_nosigpipe(tcp_server->ns, sock)) {
  ------------------
  |  Branch (880:9): [True: 0, False: 44.5k]
  ------------------
  881|      0|        kill_sock(tcp_server->ns, sock);
  882|      0|        return -1;
  883|      0|    }
  884|       |
  885|  44.5k|    const uint16_t index = tcp_server->incoming_connection_queue_index % MAX_INCOMING_CONNECTIONS;
  ------------------
  |  |   16|  44.5k|#define MAX_INCOMING_CONNECTIONS 256
  ------------------
  886|       |
  887|  44.5k|    TCP_Secure_Connection *conn = &tcp_server->incoming_connection_queue[index];
  888|       |
  889|  44.5k|    if (conn->status != TCP_STATUS_NO_STATUS) {
  ------------------
  |  Branch (889:9): [True: 9.28k, False: 35.2k]
  ------------------
  890|  9.28k|        LOGGER_DEBUG(tcp_server->logger, "connection %d dropped before accepting", index);
  ------------------
  |  |   80|  9.28k|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  9.28k|    do {                                                                         \
  |  |  |  |   73|  9.28k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  18.5k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  9.28k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  891|  9.28k|        kill_tcp_secure_connection(conn);
  892|  9.28k|    }
  893|       |
  894|  44.5k|    conn->status = TCP_STATUS_CONNECTED;
  895|  44.5k|    conn->con.ns = tcp_server->ns;
  896|  44.5k|    conn->con.mem = tcp_server->mem;
  897|  44.5k|    conn->con.rng = tcp_server->rng;
  898|  44.5k|    conn->con.sock = sock;
  899|  44.5k|    conn->next_packet_length = 0;
  900|       |
  901|  44.5k|    ++tcp_server->incoming_connection_queue_index;
  902|  44.5k|    return index;
  903|  44.5k|}
TCP_server.c:kill_tcp_secure_connection:
  267|  9.43k|{
  268|  9.43k|    kill_sock(con->con.ns, con->con.sock);
  269|  9.43k|    wipe_secure_connection(con);
  270|  9.43k|}
TCP_server.c:do_tcp_incoming:
 1155|    174|{
 1156|  44.7k|    for (uint32_t i = 0; i < MAX_INCOMING_CONNECTIONS; ++i) {
  ------------------
  |  |   16|  44.7k|#define MAX_INCOMING_CONNECTIONS 256
  ------------------
  |  Branch (1156:26): [True: 44.5k, False: 174]
  ------------------
 1157|  44.5k|        do_incoming(tcp_server, i);
 1158|  44.5k|    }
 1159|    174|}
TCP_server.c:do_incoming:
 1054|  44.5k|{
 1055|  44.5k|    TCP_Secure_Connection *const conn = &tcp_server->incoming_connection_queue[i];
 1056|       |
 1057|  44.5k|    if (conn->status != TCP_STATUS_CONNECTED) {
  ------------------
  |  Branch (1057:9): [True: 0, False: 44.5k]
  ------------------
 1058|      0|        return -1;
 1059|      0|    }
 1060|       |
 1061|  44.5k|    LOGGER_TRACE(tcp_server->logger, "handling incoming TCP connection %d", i);
  ------------------
  |  |   79|  44.5k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  44.5k|    do {                                                                         \
  |  |  |  |   73|  44.5k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  89.0k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  44.5k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1062|       |
 1063|  44.5k|    const int ret = read_connection_handshake(tcp_server->logger, conn, tcp_server->secret_key);
 1064|       |
 1065|  44.5k|    if (ret == -1) {
  ------------------
  |  Branch (1065:9): [True: 0, False: 44.5k]
  ------------------
 1066|      0|        LOGGER_TRACE(tcp_server->logger, "incoming connection %d dropped due to failed handshake", i);
  ------------------
  |  |   79|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1067|      0|        kill_tcp_secure_connection(conn);
 1068|      0|        return -1;
 1069|      0|    }
 1070|       |
 1071|  44.5k|    if (ret != 1) {
  ------------------
  |  Branch (1071:9): [True: 44.1k, False: 443]
  ------------------
 1072|  44.1k|        return -1;
 1073|  44.1k|    }
 1074|       |
 1075|    443|    const int index_new = tcp_server->unconfirmed_connection_queue_index % MAX_INCOMING_CONNECTIONS;
  ------------------
  |  |   16|    443|#define MAX_INCOMING_CONNECTIONS 256
  ------------------
 1076|    443|    TCP_Secure_Connection *conn_old = conn;
 1077|    443|    TCP_Secure_Connection *conn_new = &tcp_server->unconfirmed_connection_queue[index_new];
 1078|       |
 1079|    443|    if (conn_new->status != TCP_STATUS_NO_STATUS) {
  ------------------
  |  Branch (1079:9): [True: 0, False: 443]
  ------------------
 1080|      0|        LOGGER_ERROR(tcp_server->logger, "incoming connection %d would overwrite existing", i);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1081|      0|        kill_tcp_secure_connection(conn_new);
 1082|      0|    }
 1083|       |
 1084|    443|    move_secure_connection(conn_new, conn_old);
 1085|    443|    ++tcp_server->unconfirmed_connection_queue_index;
 1086|       |
 1087|    443|    return index_new;
 1088|  44.5k|}
TCP_server.c:read_connection_handshake:
  371|  44.5k|{
  372|  44.5k|    uint8_t data[TCP_CLIENT_HANDSHAKE_SIZE];
  373|  44.5k|    const int len = read_tcp_packet(logger, con->con.mem, con->con.ns, con->con.sock, data, TCP_CLIENT_HANDSHAKE_SIZE, &con->con.ip_port);
  ------------------
  |  |   57|  44.5k|#define TCP_CLIENT_HANDSHAKE_SIZE (CRYPTO_PUBLIC_KEY_SIZE + TCP_SERVER_HANDSHAKE_SIZE)
  |  |  ------------------
  |  |  |  |   40|  44.5k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define TCP_CLIENT_HANDSHAKE_SIZE (CRYPTO_PUBLIC_KEY_SIZE + TCP_SERVER_HANDSHAKE_SIZE)
  |  |  ------------------
  |  |  |  |   56|  44.5k|#define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|  44.5k|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   55|  44.5k|#define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|  44.5k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|  44.5k|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|  44.5k|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  374|       |
  375|  44.5k|    if (len == -1) {
  ------------------
  |  Branch (375:9): [True: 44.1k, False: 443]
  ------------------
  376|  44.1k|        LOGGER_TRACE(logger, "connection handshake is not ready yet");
  ------------------
  |  |   79|  44.1k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  44.1k|    do {                                                                         \
  |  |  |  |   73|  44.1k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  88.2k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  44.1k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  377|  44.1k|        return 0;
  378|  44.1k|    }
  379|       |
  380|    443|    return handle_tcp_handshake(logger, con, data, len, self_secret_key);
  381|  44.5k|}
TCP_server.c:handle_tcp_handshake:
  307|    443|{
  308|    443|    if (length != TCP_CLIENT_HANDSHAKE_SIZE) {
  ------------------
  |  |   57|    443|#define TCP_CLIENT_HANDSHAKE_SIZE (CRYPTO_PUBLIC_KEY_SIZE + TCP_SERVER_HANDSHAKE_SIZE)
  |  |  ------------------
  |  |  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define TCP_CLIENT_HANDSHAKE_SIZE (CRYPTO_PUBLIC_KEY_SIZE + TCP_SERVER_HANDSHAKE_SIZE)
  |  |  ------------------
  |  |  |  |   56|    443|#define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   55|    443|#define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|    443|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (308:9): [True: 0, False: 443]
  ------------------
  309|      0|        LOGGER_ERROR(logger, "invalid handshake length: %d != %d", length, TCP_CLIENT_HANDSHAKE_SIZE);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  310|      0|        return -1;
  311|      0|    }
  312|       |
  313|    443|    if (con->status != TCP_STATUS_CONNECTED) {
  ------------------
  |  Branch (313:9): [True: 0, False: 443]
  ------------------
  314|      0|        LOGGER_ERROR(logger, "TCP connection %u not connected", (unsigned int)con->identifier);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  315|      0|        return -1;
  316|      0|    }
  317|       |
  318|    443|    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
  319|    443|    encrypt_precompute(data, self_secret_key, shared_key);
  320|    443|    uint8_t plain[TCP_HANDSHAKE_PLAIN_SIZE];
  321|    443|    int len = decrypt_data_symmetric(shared_key, data + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  322|    443|                                     data + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                   data + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  ------------------
                                                   data + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   55|    443|#define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  ------------------
                                                   data + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   61|    443|#define CRYPTO_MAC_SIZE                16
  ------------------
  323|       |
  324|    443|    if (len != TCP_HANDSHAKE_PLAIN_SIZE) {
  ------------------
  |  |   55|    443|#define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  ------------------
  |  Branch (324:9): [True: 0, False: 443]
  ------------------
  325|      0|        LOGGER_ERROR(logger, "invalid TCP handshake decrypted length: %d != %d", len, TCP_HANDSHAKE_PLAIN_SIZE);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  326|      0|        crypto_memzero(shared_key, sizeof(shared_key));
  327|      0|        return -1;
  328|      0|    }
  329|       |
  330|    443|    memcpy(con->public_key, data, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  331|    443|    uint8_t temp_secret_key[CRYPTO_SECRET_KEY_SIZE];
  332|    443|    uint8_t resp_plain[TCP_HANDSHAKE_PLAIN_SIZE];
  333|    443|    crypto_new_keypair(con->con.rng, resp_plain, temp_secret_key);
  334|    443|    random_nonce(con->con.rng, con->con.sent_nonce);
  335|    443|    memcpy(resp_plain + CRYPTO_PUBLIC_KEY_SIZE, con->con.sent_nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(resp_plain + CRYPTO_PUBLIC_KEY_SIZE, con->con.sent_nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  ------------------
  336|    443|    memcpy(con->recv_nonce, plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(con->recv_nonce, plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  ------------------
  337|       |
  338|    443|    uint8_t response[TCP_SERVER_HANDSHAKE_SIZE];
  339|    443|    random_nonce(con->con.rng, response);
  340|       |
  341|    443|    len = encrypt_data_symmetric(shared_key, response, resp_plain, TCP_HANDSHAKE_PLAIN_SIZE,
  ------------------
  |  |   55|    443|#define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  ------------------
  342|    443|                                 response + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  ------------------
  343|       |
  344|    443|    if (len != TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   55|    443|#define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  ------------------
  |  |  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  ------------------
                  if (len != TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   61|    443|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (344:9): [True: 0, False: 443]
  ------------------
  345|      0|        crypto_memzero(shared_key, sizeof(shared_key));
  346|      0|        return -1;
  347|      0|    }
  348|       |
  349|    443|    IP_Port ipp = {{{0}}};
  350|       |
  351|    443|    if (TCP_SERVER_HANDSHAKE_SIZE != net_send(con->con.ns, logger, con->con.sock, response, TCP_SERVER_HANDSHAKE_SIZE, &ipp)) {
  ------------------
  |  |   56|    443|#define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   55|    443|#define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|    443|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                  if (TCP_SERVER_HANDSHAKE_SIZE != net_send(con->con.ns, logger, con->con.sock, response, TCP_SERVER_HANDSHAKE_SIZE, &ipp)) {
  ------------------
  |  |   56|    443|#define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   55|    443|#define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    443|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|    443|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|    443|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  |  Branch (351:9): [True: 0, False: 443]
  ------------------
  352|      0|        crypto_memzero(shared_key, sizeof(shared_key));
  353|      0|        return -1;
  354|      0|    }
  355|       |
  356|    443|    encrypt_precompute(plain, temp_secret_key, con->con.shared_key);
  357|    443|    con->status = TCP_STATUS_UNCONFIRMED;
  358|       |
  359|    443|    crypto_memzero(shared_key, sizeof(shared_key));
  360|       |
  361|    443|    return 1;
  362|    443|}
TCP_server.c:move_secure_connection:
  149|    546|{
  150|    546|    *con_new = *con_old;
  151|    546|    crypto_memzero(con_old, sizeof(TCP_Secure_Connection));
  152|    546|}
TCP_server.c:do_tcp_unconfirmed:
 1163|    174|{
 1164|  44.7k|    for (uint32_t i = 0; i < MAX_INCOMING_CONNECTIONS; ++i) {
  ------------------
  |  |   16|  44.7k|#define MAX_INCOMING_CONNECTIONS 256
  ------------------
  |  Branch (1164:26): [True: 44.5k, False: 174]
  ------------------
 1165|  44.5k|        do_unconfirmed(tcp_server, mono_time, i);
 1166|  44.5k|    }
 1167|    174|}
TCP_server.c:do_unconfirmed:
 1092|  44.5k|{
 1093|  44.5k|    TCP_Secure_Connection *const conn = &tcp_server->unconfirmed_connection_queue[i];
 1094|       |
 1095|  44.5k|    if (conn->status != TCP_STATUS_UNCONFIRMED) {
  ------------------
  |  Branch (1095:9): [True: 44.0k, False: 518]
  ------------------
 1096|  44.0k|        return -1;
 1097|  44.0k|    }
 1098|       |
 1099|    518|    LOGGER_TRACE(tcp_server->logger, "handling unconfirmed TCP connection %d", i);
  ------------------
  |  |   79|    518|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    518|    do {                                                                         \
  |  |  |  |   73|    518|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  1.03k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|    518|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1100|       |
 1101|    518|    uint8_t packet[MAX_PACKET_SIZE];
 1102|    518|    const int len = read_packet_tcp_secure_connection(tcp_server->logger, conn->con.mem, conn->con.ns, conn->con.sock, &conn->next_packet_length, conn->con.shared_key, conn->recv_nonce, packet, sizeof(packet), &conn->con.ip_port);
 1103|       |
 1104|    518|    if (len == 0) {
  ------------------
  |  Branch (1104:9): [True: 271, False: 247]
  ------------------
 1105|    271|        return -1;
 1106|    271|    }
 1107|       |
 1108|    247|    if (len == -1) {
  ------------------
  |  Branch (1108:9): [True: 138, False: 109]
  ------------------
 1109|    138|        kill_tcp_secure_connection(conn);
 1110|    138|        return -1;
 1111|    138|    }
 1112|       |
 1113|    109|    return confirm_tcp_connection(tcp_server, mono_time, conn, packet, len);
 1114|    247|}
TCP_server.c:confirm_tcp_connection:
  843|    109|{
  844|    109|    const int index = add_accepted(tcp_server, mono_time, con);
  845|       |
  846|    109|    if (index == -1) {
  ------------------
  |  Branch (846:9): [True: 6, False: 103]
  ------------------
  847|      6|        LOGGER_DEBUG(tcp_server->logger, "dropping connection %u: not accepted", (unsigned int)con->identifier);
  ------------------
  |  |   80|      6|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      6|    do {                                                                         \
  |  |  |  |   73|      6|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     12|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      6|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  848|      6|        kill_tcp_secure_connection(con);
  849|      6|        return -1;
  850|      6|    }
  851|       |
  852|    103|    wipe_secure_connection(con);
  853|       |
  854|    103|    if (handle_tcp_packet(tcp_server, index, data, length) == -1) {
  ------------------
  |  Branch (854:9): [True: 59, False: 44]
  ------------------
  855|     59|        LOGGER_DEBUG(tcp_server->logger, "dropping connection %u: data packet (len=%d) not handled",
  ------------------
  |  |   80|     59|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     59|    do {                                                                         \
  |  |  |  |   73|     59|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    118|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|     59|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  856|     59|                     (unsigned int)con->identifier, length);
  857|     59|        kill_accepted(tcp_server, index);
  858|     59|        return -1;
  859|     59|    }
  860|       |
  861|     44|    return index;
  862|    103|}
TCP_server.c:add_accepted:
  191|    109|{
  192|    109|    int index = get_tcp_connection_index(tcp_server, con->public_key);
  193|       |
  194|    109|    if (index != -1) { /* If an old connection to the same public key exists, kill it. */
  ------------------
  |  Branch (194:9): [True: 1, False: 108]
  ------------------
  195|      1|        kill_accepted(tcp_server, index);
  196|      1|        index = -1;
  197|      1|    }
  198|       |
  199|    109|    if (tcp_server->size_accepted_connections == tcp_server->num_accepted_connections) {
  ------------------
  |  Branch (199:9): [True: 76, False: 33]
  ------------------
  200|     76|        if (alloc_new_connections(tcp_server, 4) == -1) {
  ------------------
  |  Branch (200:13): [True: 6, False: 70]
  ------------------
  201|      6|            return -1;
  202|      6|        }
  203|       |
  204|     70|        index = tcp_server->num_accepted_connections;
  205|     70|    } else {
  206|     43|        for (uint32_t i = tcp_server->size_accepted_connections; i != 0; --i) {
  ------------------
  |  Branch (206:66): [True: 43, False: 0]
  ------------------
  207|     43|            if (tcp_server->accepted_connection_array[i - 1].status == TCP_STATUS_NO_STATUS) {
  ------------------
  |  Branch (207:17): [True: 33, False: 10]
  ------------------
  208|     33|                index = i - 1;
  209|     33|                break;
  210|     33|            }
  211|     43|        }
  212|     33|    }
  213|       |
  214|    103|    if (index == -1) {
  ------------------
  |  Branch (214:9): [True: 0, False: 103]
  ------------------
  215|      0|        LOGGER_ERROR(tcp_server->logger, "FAIL index is -1");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  216|      0|        return -1;
  217|      0|    }
  218|       |
  219|    103|    if (!bs_list_add(&tcp_server->accepted_key_list, con->public_key, index)) {
  ------------------
  |  Branch (219:9): [True: 0, False: 103]
  ------------------
  220|      0|        return -1;
  221|      0|    }
  222|       |
  223|    103|    move_secure_connection(&tcp_server->accepted_connection_array[index], con);
  224|       |
  225|    103|    tcp_server->accepted_connection_array[index].status = TCP_STATUS_CONFIRMED;
  226|    103|    ++tcp_server->num_accepted_connections;
  227|    103|    tcp_server->accepted_connection_array[index].identifier = ++tcp_server->counter;
  228|    103|    tcp_server->accepted_connection_array[index].last_pinged = mono_time_get(mono_time);
  229|    103|    tcp_server->accepted_connection_array[index].ping_id = 0;
  230|       |
  231|    103|    return index;
  232|    103|}
TCP_server.c:get_tcp_connection_index:
  176|    114|{
  177|    114|    return bs_list_find(&tcp_server->accepted_key_list, public_key);
  178|    114|}
TCP_server.c:alloc_new_connections:
  114|     76|{
  115|     76|    const uint32_t new_size = tcp_server->size_accepted_connections + num;
  116|       |
  117|     76|    if (new_size < tcp_server->size_accepted_connections) {
  ------------------
  |  Branch (117:9): [True: 0, False: 76]
  ------------------
  118|      0|        return -1;
  119|      0|    }
  120|       |
  121|     76|    TCP_Secure_Connection *new_connections = (TCP_Secure_Connection *)mem_vrealloc(
  122|     76|                tcp_server->mem, tcp_server->accepted_connection_array,
  123|     76|                new_size, sizeof(TCP_Secure_Connection));
  124|       |
  125|     76|    if (new_connections == nullptr) {
  ------------------
  |  |   66|     76|#define nullptr NULL
  ------------------
  |  Branch (125:9): [True: 6, False: 70]
  ------------------
  126|      6|        return -1;
  127|      6|    }
  128|       |
  129|     70|    const uint32_t old_size = tcp_server->size_accepted_connections;
  130|     70|    const uint32_t size_new_entries = num * sizeof(TCP_Secure_Connection);
  131|     70|    memset(new_connections + old_size, 0, size_new_entries);
  132|       |
  133|     70|    tcp_server->accepted_connection_array = new_connections;
  134|     70|    tcp_server->size_accepted_connections = new_size;
  135|     70|    return 0;
  136|     76|}
TCP_server.c:handle_tcp_packet:
  665|    108|{
  666|    108|    if (length == 0) {
  ------------------
  |  Branch (666:9): [True: 0, False: 108]
  ------------------
  667|      0|        return -1;
  668|      0|    }
  669|       |
  670|    108|    TCP_Secure_Connection *const con = &tcp_server->accepted_connection_array[con_id];
  671|       |
  672|    108|    switch (data[0]) {
  673|      5|        case TCP_PACKET_ROUTING_REQUEST: {
  ------------------
  |  |   41|      5|#define TCP_PACKET_ROUTING_REQUEST  0
  ------------------
  |  Branch (673:9): [True: 5, False: 103]
  ------------------
  674|      5|            if (length != 1 + CRYPTO_PUBLIC_KEY_SIZE) {
  ------------------
  |  |   40|      5|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (674:17): [True: 5, False: 0]
  ------------------
  675|      5|                return -1;
  676|      5|            }
  677|       |
  678|      0|            LOGGER_TRACE(tcp_server->logger, "handling routing request for %d", con_id);
  ------------------
  |  |   79|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  679|      0|            return handle_tcp_routing_req(tcp_server, con_id, data + 1);
  680|      5|        }
  681|       |
  682|      1|        case TCP_PACKET_CONNECTION_NOTIFICATION: {
  ------------------
  |  |   43|      1|#define TCP_PACKET_CONNECTION_NOTIFICATION 2
  ------------------
  |  Branch (682:9): [True: 1, False: 107]
  ------------------
  683|      1|            if (length != 2) {
  ------------------
  |  Branch (683:17): [True: 1, False: 0]
  ------------------
  684|      1|                return -1;
  685|      1|            }
  686|       |
  687|      0|            LOGGER_TRACE(tcp_server->logger, "handling connection notification for %d", con_id);
  ------------------
  |  |   79|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  688|      0|            break;
  689|      1|        }
  690|       |
  691|      3|        case TCP_PACKET_DISCONNECT_NOTIFICATION: {
  ------------------
  |  |   44|      3|#define TCP_PACKET_DISCONNECT_NOTIFICATION 3
  ------------------
  |  Branch (691:9): [True: 3, False: 105]
  ------------------
  692|      3|            if (length != 2) {
  ------------------
  |  Branch (692:17): [True: 3, False: 0]
  ------------------
  693|      3|                return -1;
  694|      3|            }
  695|       |
  696|      0|            LOGGER_TRACE(tcp_server->logger, "handling disconnect notification for %d", con_id);
  ------------------
  |  |   79|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  697|      0|            return rm_connection_index(tcp_server, con, data[1] - NUM_RESERVED_PORTS);
  ------------------
  |  |   24|      0|#define NUM_RESERVED_PORTS 16
  ------------------
  698|      3|        }
  699|       |
  700|      1|        case TCP_PACKET_PING: {
  ------------------
  |  |   45|      1|#define TCP_PACKET_PING 4
  ------------------
  |  Branch (700:9): [True: 1, False: 107]
  ------------------
  701|      1|            if (length != 1 + sizeof(uint64_t)) {
  ------------------
  |  Branch (701:17): [True: 1, False: 0]
  ------------------
  702|      1|                return -1;
  703|      1|            }
  704|       |
  705|      0|            LOGGER_TRACE(tcp_server->logger, "handling ping for %d", con_id);
  ------------------
  |  |   79|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  706|       |
  707|      0|            uint8_t response[1 + sizeof(uint64_t)];
  708|      0|            response[0] = TCP_PACKET_PONG;
  ------------------
  |  |   46|      0|#define TCP_PACKET_PONG 5
  ------------------
  709|      0|            memcpy(response + 1, data + 1, sizeof(uint64_t));
  710|      0|            write_packet_tcp_secure_connection(tcp_server->logger, &con->con, response, sizeof(response), true);
  711|      0|            return 0;
  712|      1|        }
  713|       |
  714|      3|        case TCP_PACKET_PONG: {
  ------------------
  |  |   46|      3|#define TCP_PACKET_PONG 5
  ------------------
  |  Branch (714:9): [True: 3, False: 105]
  ------------------
  715|      3|            if (length != 1 + sizeof(uint64_t)) {
  ------------------
  |  Branch (715:17): [True: 3, False: 0]
  ------------------
  716|      3|                return -1;
  717|      3|            }
  718|       |
  719|      0|            LOGGER_TRACE(tcp_server->logger, "handling pong for %d", con_id);
  ------------------
  |  |   79|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  720|       |
  721|      0|            uint64_t ping_id;
  722|      0|            memcpy(&ping_id, data + 1, sizeof(uint64_t));
  723|       |
  724|      0|            if (ping_id != 0) {
  ------------------
  |  Branch (724:17): [True: 0, False: 0]
  ------------------
  725|      0|                if (ping_id == con->ping_id) {
  ------------------
  |  Branch (725:21): [True: 0, False: 0]
  ------------------
  726|      0|                    con->ping_id = 0;
  727|      0|                }
  728|       |
  729|      0|                return 0;
  730|      0|            }
  731|       |
  732|      0|            return -1;
  733|      0|        }
  734|       |
  735|      5|        case TCP_PACKET_OOB_SEND: {
  ------------------
  |  |   47|      5|#define TCP_PACKET_OOB_SEND 6
  ------------------
  |  Branch (735:9): [True: 5, False: 103]
  ------------------
  736|      5|            if (length <= 1 + CRYPTO_PUBLIC_KEY_SIZE) {
  ------------------
  |  |   40|      5|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (736:17): [True: 0, False: 5]
  ------------------
  737|      0|                return -1;
  738|      0|            }
  739|       |
  740|      5|            LOGGER_TRACE(tcp_server->logger, "handling oob send for %d", con_id);
  ------------------
  |  |   79|      5|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      5|    do {                                                                         \
  |  |  |  |   73|      5|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     10|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      5|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  741|       |
  742|      5|            return handle_tcp_oob_send(tcp_server, con_id, data + 1, data + 1 + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      5|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  743|      5|                                       length - (1 + CRYPTO_PUBLIC_KEY_SIZE));
  ------------------
  |  |   40|      5|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  744|      5|        }
  745|       |
  746|     40|        case TCP_PACKET_ONION_REQUEST: {
  ------------------
  |  |   49|     40|#define TCP_PACKET_ONION_REQUEST  8
  ------------------
  |  Branch (746:9): [True: 40, False: 68]
  ------------------
  747|     40|            LOGGER_TRACE(tcp_server->logger, "handling onion request for %d", con_id);
  ------------------
  |  |   79|     40|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     40|    do {                                                                         \
  |  |  |  |   73|     40|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     80|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|     40|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  748|       |
  749|     40|            if (tcp_server->onion != nullptr) {
  ------------------
  |  |   66|     40|#define nullptr NULL
  ------------------
  |  Branch (749:17): [True: 40, False: 0]
  ------------------
  750|     40|                if (length <= 1 + CRYPTO_NONCE_SIZE + ONION_SEND_BASE * 2) {
  ------------------
  |  |   66|     40|#define CRYPTO_NONCE_SIZE              24
  ------------------
                              if (length <= 1 + CRYPTO_NONCE_SIZE + ONION_SEND_BASE * 2) {
  ------------------
  |  |   43|     40|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   40|     40|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  228|     40|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  226|     40|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  225|     40|#define SIZE_IP6 16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  227|     40|#define SIZE_PORT 2
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     40|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  |  Branch (750:21): [True: 1, False: 39]
  ------------------
  751|      1|                    return -1;
  752|      1|                }
  753|       |
  754|     39|                IP_Port source = con_id_to_ip_port(con_id, con->identifier);
  755|     39|                onion_send_1(tcp_server->onion, data + 1 + CRYPTO_NONCE_SIZE, length - (1 + CRYPTO_NONCE_SIZE), &source,
  ------------------
  |  |   66|     39|#define CRYPTO_NONCE_SIZE              24
  ------------------
                              onion_send_1(tcp_server->onion, data + 1 + CRYPTO_NONCE_SIZE, length - (1 + CRYPTO_NONCE_SIZE), &source,
  ------------------
  |  |   66|     39|#define CRYPTO_NONCE_SIZE              24
  ------------------
  756|     39|                             data + 1);
  757|     39|            }
  758|       |
  759|     39|            return 0;
  760|     40|        }
  761|       |
  762|      1|        case TCP_PACKET_ONION_RESPONSE: {
  ------------------
  |  |   50|      1|#define TCP_PACKET_ONION_RESPONSE 9
  ------------------
  |  Branch (762:9): [True: 1, False: 107]
  ------------------
  763|      1|            LOGGER_TRACE(tcp_server->logger, "handling onion response for %d", con_id);
  ------------------
  |  |   79|      1|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      1|    do {                                                                         \
  |  |  |  |   73|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  764|      1|            return -1;
  765|     40|        }
  766|       |
  767|      3|        case TCP_PACKET_FORWARD_REQUEST: {
  ------------------
  |  |   51|      3|#define TCP_PACKET_FORWARD_REQUEST 10
  ------------------
  |  Branch (767:9): [True: 3, False: 105]
  ------------------
  768|      3|            if (tcp_server->forwarding == nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (768:17): [True: 0, False: 3]
  ------------------
  769|      0|                return -1;
  770|      0|            }
  771|       |
  772|      3|            const uint16_t sendback_data_len = 1 + sizeof(uint32_t) + sizeof(uint64_t);
  773|      3|            uint8_t sendback_data[1 + sizeof(uint32_t) + sizeof(uint64_t)];
  774|      3|            sendback_data[0] = SENDBACK_TCP;
  ------------------
  |  |   17|      3|#define SENDBACK_TCP 2
  ------------------
  775|      3|            net_pack_u32(sendback_data + 1, con_id);
  776|      3|            net_pack_u64(sendback_data + 1 + sizeof(uint32_t), con->identifier);
  777|       |
  778|      3|            IP_Port dest;
  779|      3|            const int ipport_length = unpack_ip_port(&dest, data + 1, length - 1, false);
  780|       |
  781|      3|            if (ipport_length == -1) {
  ------------------
  |  Branch (781:17): [True: 1, False: 2]
  ------------------
  782|      1|                return -1;
  783|      1|            }
  784|       |
  785|      2|            const uint8_t *const forward_data = data + (1 + ipport_length);
  786|      2|            const uint16_t forward_data_len = length - (1 + ipport_length);
  787|       |
  788|      2|            if (forward_data_len > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   20|      2|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   98|      2|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   19|      2|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (788:17): [True: 0, False: 2]
  ------------------
  789|      0|                return -1;
  790|      0|            }
  791|       |
  792|      2|            send_forwarding(tcp_server->forwarding, &dest, sendback_data, sendback_data_len, forward_data, forward_data_len);
  793|      2|            return 0;
  794|      2|        }
  795|       |
  796|      1|        case TCP_PACKET_FORWARDING: {
  ------------------
  |  |   52|      1|#define TCP_PACKET_FORWARDING 11
  ------------------
  |  Branch (796:9): [True: 1, False: 107]
  ------------------
  797|      1|            return -1;
  798|      2|        }
  799|       |
  800|     45|        default: {
  ------------------
  |  Branch (800:9): [True: 45, False: 63]
  ------------------
  801|     45|            if (data[0] < NUM_RESERVED_PORTS) {
  ------------------
  |  |   24|     45|#define NUM_RESERVED_PORTS 16
  ------------------
  |  Branch (801:17): [True: 27, False: 18]
  ------------------
  802|     27|                return -1;
  803|     27|            }
  804|       |
  805|     18|            const uint8_t c_id = data[0] - NUM_RESERVED_PORTS;
  ------------------
  |  |   24|     18|#define NUM_RESERVED_PORTS 16
  ------------------
  806|     18|            LOGGER_TRACE(tcp_server->logger, "handling packet id %d for %d", c_id, con_id);
  ------------------
  |  |   79|     18|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     18|    do {                                                                         \
  |  |  |  |   73|     18|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     36|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|     18|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  807|       |
  808|     18|            if (c_id >= NUM_CLIENT_CONNECTIONS) {
  ------------------
  |  |   25|     18|#define NUM_CLIENT_CONNECTIONS (256 - NUM_RESERVED_PORTS)
  |  |  ------------------
  |  |  |  |   24|     18|#define NUM_RESERVED_PORTS 16
  |  |  ------------------
  ------------------
  |  Branch (808:17): [True: 0, False: 18]
  ------------------
  809|      0|                return -1;
  810|      0|            }
  811|       |
  812|     18|            if (con->connections[c_id].status == 0) {
  ------------------
  |  Branch (812:17): [True: 18, False: 0]
  ------------------
  813|     18|                return -1;
  814|     18|            }
  815|       |
  816|      0|            if (con->connections[c_id].status != 2) {
  ------------------
  |  Branch (816:17): [True: 0, False: 0]
  ------------------
  817|      0|                return 0;
  818|      0|            }
  819|       |
  820|      0|            const uint32_t index = con->connections[c_id].index;
  821|      0|            const uint8_t other_c_id = con->connections[c_id].other_id + NUM_RESERVED_PORTS;
  ------------------
  |  |   24|      0|#define NUM_RESERVED_PORTS 16
  ------------------
  822|      0|            VLA(uint8_t, new_data, length);
  ------------------
  |  |   62|      0|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      0|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  823|      0|            memcpy(new_data, data, length);
  824|      0|            new_data[0] = other_c_id;
  825|      0|            const int ret = write_packet_tcp_secure_connection(tcp_server->logger,
  826|      0|                            &tcp_server->accepted_connection_array[index].con, new_data, length, false);
  827|       |
  828|      0|            if (ret == -1) {
  ------------------
  |  Branch (828:17): [True: 0, False: 0]
  ------------------
  829|      0|                return -1;
  830|      0|            }
  831|       |
  832|      0|            return 0;
  833|      0|        }
  834|    108|    }
  835|       |
  836|      0|    return 0;
  837|    108|}
TCP_server.c:rm_connection_index:
  541|  18.4k|{
  542|  18.4k|    if (con_number >= NUM_CLIENT_CONNECTIONS) {
  ------------------
  |  |   25|  18.4k|#define NUM_CLIENT_CONNECTIONS (256 - NUM_RESERVED_PORTS)
  |  |  ------------------
  |  |  |  |   24|  18.4k|#define NUM_RESERVED_PORTS 16
  |  |  ------------------
  ------------------
  |  Branch (542:9): [True: 0, False: 18.4k]
  ------------------
  543|      0|        return -1;
  544|      0|    }
  545|       |
  546|  18.4k|    if (con->connections[con_number].status != 0) {
  ------------------
  |  Branch (546:9): [True: 0, False: 18.4k]
  ------------------
  547|      0|        if (con->connections[con_number].status == 2) {
  ------------------
  |  Branch (547:13): [True: 0, False: 0]
  ------------------
  548|      0|            const uint32_t index = con->connections[con_number].index;
  549|      0|            const uint8_t other_id = con->connections[con_number].other_id;
  550|       |
  551|      0|            if (index >= tcp_server->size_accepted_connections) {
  ------------------
  |  Branch (551:17): [True: 0, False: 0]
  ------------------
  552|      0|                return -1;
  553|      0|            }
  554|       |
  555|      0|            tcp_server->accepted_connection_array[index].connections[other_id].other_id = 0;
  556|      0|            tcp_server->accepted_connection_array[index].connections[other_id].index = 0;
  557|      0|            tcp_server->accepted_connection_array[index].connections[other_id].status = 1;
  558|       |            // TODO(irungentoo): return values?
  559|      0|            send_disconnect_notification(tcp_server->logger, &tcp_server->accepted_connection_array[index], other_id);
  560|      0|        }
  561|       |
  562|      0|        con->connections[con_number].index = 0;
  563|      0|        con->connections[con_number].other_id = 0;
  564|      0|        con->connections[con_number].status = 0;
  565|      0|        return 0;
  566|      0|    }
  567|       |
  568|  18.4k|    return -1;
  569|  18.4k|}
TCP_server.c:handle_tcp_oob_send:
  514|      5|{
  515|      5|    if (length == 0 || length > TCP_MAX_OOB_DATA_LENGTH) {
  ------------------
  |  |   58|      5|#define TCP_MAX_OOB_DATA_LENGTH 1024
  ------------------
  |  Branch (515:9): [True: 0, False: 5]
  |  Branch (515:24): [True: 0, False: 5]
  ------------------
  516|      0|        return -1;
  517|      0|    }
  518|       |
  519|      5|    const TCP_Secure_Connection *con = &tcp_server->accepted_connection_array[con_id];
  520|       |
  521|      5|    const int other_index = get_tcp_connection_index(tcp_server, public_key);
  522|       |
  523|      5|    if (other_index != -1) {
  ------------------
  |  Branch (523:9): [True: 1, False: 4]
  ------------------
  524|      1|        VLA(uint8_t, resp_packet, 1 + CRYPTO_PUBLIC_KEY_SIZE + length);
  ------------------
  |  |   62|      1|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      1|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  525|      1|        resp_packet[0] = TCP_PACKET_OOB_RECV;
  ------------------
  |  |   48|      1|#define TCP_PACKET_OOB_RECV 7
  ------------------
  526|      1|        memcpy(resp_packet + 1, con->public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  527|      1|        memcpy(resp_packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, data, length);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  528|      1|        write_packet_tcp_secure_connection(tcp_server->logger, &tcp_server->accepted_connection_array[other_index].con,
  529|      1|                                           resp_packet, SIZEOF_VLA(resp_packet), false);
  ------------------
  |  |   29|      1|#define SIZEOF_VLA sizeof
  ------------------
  530|      1|    }
  531|       |
  532|      5|    return 0;
  533|      5|}
TCP_server.c:con_id_to_ip_port:
  576|     39|{
  577|     39|    IP_Port ip_port = {{{0}}};
  578|     39|    ip_port.ip.family = net_family_tcp_client();
  579|     39|    ip_port.ip.ip.v6.uint32[0] = con_id;
  580|     39|    ip_port.ip.ip.v6.uint64[1] = identifier;
  581|     39|    return ip_port;
  582|       |
  583|     39|}
TCP_server.c:kill_accepted:
  281|     77|{
  282|     77|    if ((uint32_t)index >= tcp_server->size_accepted_connections) {
  ------------------
  |  Branch (282:9): [True: 0, False: 77]
  ------------------
  283|      0|        return -1;
  284|      0|    }
  285|       |
  286|  18.5k|    for (uint32_t i = 0; i < NUM_CLIENT_CONNECTIONS; ++i) {
  ------------------
  |  |   25|  18.5k|#define NUM_CLIENT_CONNECTIONS (256 - NUM_RESERVED_PORTS)
  |  |  ------------------
  |  |  |  |   24|  18.5k|#define NUM_RESERVED_PORTS 16
  |  |  ------------------
  ------------------
  |  Branch (286:26): [True: 18.4k, False: 77]
  ------------------
  287|  18.4k|        rm_connection_index(tcp_server, &tcp_server->accepted_connection_array[index], i);
  288|  18.4k|    }
  289|       |
  290|     77|    const Socket sock = tcp_server->accepted_connection_array[index].con.sock;
  291|       |
  292|     77|    if (del_accepted(tcp_server, index) != 0) {
  ------------------
  |  Branch (292:9): [True: 0, False: 77]
  ------------------
  293|      0|        return -1;
  294|      0|    }
  295|       |
  296|     77|    kill_sock(tcp_server->ns, sock);
  297|     77|    return 0;
  298|     77|}
TCP_server.c:del_accepted:
  241|     77|{
  242|     77|    if ((uint32_t)index >= tcp_server->size_accepted_connections) {
  ------------------
  |  Branch (242:9): [True: 0, False: 77]
  ------------------
  243|      0|        return -1;
  244|      0|    }
  245|       |
  246|     77|    if (tcp_server->accepted_connection_array[index].status == TCP_STATUS_NO_STATUS) {
  ------------------
  |  Branch (246:9): [True: 0, False: 77]
  ------------------
  247|      0|        return -1;
  248|      0|    }
  249|       |
  250|     77|    if (!bs_list_remove(&tcp_server->accepted_key_list, tcp_server->accepted_connection_array[index].public_key, index)) {
  ------------------
  |  Branch (250:9): [True: 0, False: 77]
  ------------------
  251|      0|        return -1;
  252|      0|    }
  253|       |
  254|     77|    wipe_secure_connection(&tcp_server->accepted_connection_array[index]);
  255|     77|    --tcp_server->num_accepted_connections;
  256|       |
  257|     77|    if (tcp_server->num_accepted_connections == 0) {
  ------------------
  |  Branch (257:9): [True: 54, False: 23]
  ------------------
  258|     54|        free_accepted_connection_array(tcp_server);
  259|     54|    }
  260|       |
  261|     77|    return 0;
  262|     77|}
TCP_server.c:do_tcp_confirmed:
 1172|    174|{
 1173|       |#ifdef TCP_SERVER_USE_EPOLL
 1174|       |
 1175|       |    if (tcp_server->last_run_pinged == mono_time_get(mono_time)) {
 1176|       |        return;
 1177|       |    }
 1178|       |
 1179|       |    tcp_server->last_run_pinged = mono_time_get(mono_time);
 1180|       |#endif
 1181|       |
 1182|    286|    for (uint32_t i = 0; i < tcp_server->size_accepted_connections; ++i) {
  ------------------
  |  Branch (1182:26): [True: 112, False: 174]
  ------------------
 1183|    112|        TCP_Secure_Connection *conn = &tcp_server->accepted_connection_array[i];
 1184|       |
 1185|    112|        if (conn->status != TCP_STATUS_CONFIRMED) {
  ------------------
  |  Branch (1185:13): [True: 60, False: 52]
  ------------------
 1186|     60|            continue;
 1187|     60|        }
 1188|       |
 1189|     52|        if (mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_FREQUENCY)) {
  ------------------
  |  |   61|     52|#define TCP_PING_FREQUENCY 30
  ------------------
  |  Branch (1189:13): [True: 0, False: 52]
  ------------------
 1190|      0|            uint8_t ping[1 + sizeof(uint64_t)];
 1191|      0|            ping[0] = TCP_PACKET_PING;
  ------------------
  |  |   45|      0|#define TCP_PACKET_PING 4
  ------------------
 1192|      0|            uint64_t ping_id = random_u64(conn->con.rng);
 1193|       |
 1194|      0|            if (ping_id == 0) {
  ------------------
  |  Branch (1194:17): [True: 0, False: 0]
  ------------------
 1195|      0|                ++ping_id;
 1196|      0|            }
 1197|       |
 1198|      0|            memcpy(ping + 1, &ping_id, sizeof(uint64_t));
 1199|      0|            const int ret = write_packet_tcp_secure_connection(tcp_server->logger, &conn->con, ping, sizeof(ping), true);
 1200|       |
 1201|      0|            if (ret == 1) {
  ------------------
  |  Branch (1201:17): [True: 0, False: 0]
  ------------------
 1202|      0|                conn->last_pinged = mono_time_get(mono_time);
 1203|      0|                conn->ping_id = ping_id;
 1204|      0|            } else {
 1205|      0|                if (mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_FREQUENCY + TCP_PING_TIMEOUT)) {
  ------------------
  |  |   61|      0|#define TCP_PING_FREQUENCY 30
  ------------------
                              if (mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_FREQUENCY + TCP_PING_TIMEOUT)) {
  ------------------
  |  |   62|      0|#define TCP_PING_TIMEOUT 10
  ------------------
  |  Branch (1205:21): [True: 0, False: 0]
  ------------------
 1206|      0|                    kill_accepted(tcp_server, i);
 1207|      0|                    continue;
 1208|      0|                }
 1209|      0|            }
 1210|      0|        }
 1211|       |
 1212|     52|        if (conn->ping_id != 0 && mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_TIMEOUT)) {
  ------------------
  |  |   62|      0|#define TCP_PING_TIMEOUT 10
  ------------------
  |  Branch (1212:13): [True: 0, False: 52]
  |  Branch (1212:35): [True: 0, False: 0]
  ------------------
 1213|      0|            kill_accepted(tcp_server, i);
 1214|      0|            continue;
 1215|      0|        }
 1216|       |
 1217|     52|        send_pending_data(tcp_server->logger, &conn->con);
 1218|       |
 1219|     52|#ifndef TCP_SERVER_USE_EPOLL
 1220|       |
 1221|     52|        do_confirmed_recv(tcp_server, i);
 1222|       |
 1223|     52|#endif
 1224|     52|    }
 1225|    174|}
TCP_server.c:do_confirmed_recv:
 1145|     52|{
 1146|     54|    while (tcp_process_secure_packet(tcp_server, i)) {
  ------------------
  |  Branch (1146:12): [True: 2, False: 52]
  ------------------
 1147|       |        // Keep reading until an error occurs or there is no more data to read.
 1148|      2|        continue;
 1149|      2|    }
 1150|     52|}
TCP_server.c:tcp_process_secure_packet:
 1118|     54|{
 1119|     54|    TCP_Secure_Connection *const conn = &tcp_server->accepted_connection_array[i];
 1120|       |
 1121|     54|    uint8_t packet[MAX_PACKET_SIZE];
 1122|     54|    const int len = read_packet_tcp_secure_connection(tcp_server->logger, conn->con.mem, conn->con.ns, conn->con.sock, &conn->next_packet_length, conn->con.shared_key, conn->recv_nonce, packet, sizeof(packet), &conn->con.ip_port);
 1123|     54|    LOGGER_TRACE(tcp_server->logger, "processing packet for %d: %d", i, len);
  ------------------
  |  |   79|     54|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     54|    do {                                                                         \
  |  |  |  |   73|     54|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    108|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|     54|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1124|       |
 1125|     54|    if (len == 0) {
  ------------------
  |  Branch (1125:9): [True: 35, False: 19]
  ------------------
 1126|     35|        return false;
 1127|     35|    }
 1128|       |
 1129|     19|    if (len == -1) {
  ------------------
  |  Branch (1129:9): [True: 14, False: 5]
  ------------------
 1130|     14|        kill_accepted(tcp_server, i);
 1131|     14|        return false;
 1132|     14|    }
 1133|       |
 1134|      5|    if (handle_tcp_packet(tcp_server, i, packet, len) == -1) {
  ------------------
  |  Branch (1134:9): [True: 3, False: 2]
  ------------------
 1135|      3|        LOGGER_TRACE(tcp_server->logger, "dropping connection %d: data packet (len=%d) not handled", i, len);
  ------------------
  |  |   79|      3|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      3|    do {                                                                         \
  |  |  |  |   73|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1136|      3|        kill_accepted(tcp_server, i);
 1137|      3|        return false;
 1138|      3|    }
 1139|       |
 1140|      2|    return true;
 1141|      5|}
TCP_server.c:wipe_secure_connection:
  140|  84.1k|{
  141|  84.1k|    if (con->status != 0) {
  ------------------
  |  Branch (141:9): [True: 44.5k, False: 39.5k]
  ------------------
  142|  44.5k|        wipe_priority_list(con->con.mem, con->con.priority_queue_start);
  143|  44.5k|        crypto_memzero(con, sizeof(TCP_Secure_Connection));
  144|  44.5k|    }
  145|  84.1k|}
TCP_server.c:free_accepted_connection_array:
  156|    199|{
  157|    199|    if (tcp_server->accepted_connection_array == nullptr) {
  ------------------
  |  |   66|    199|#define nullptr NULL
  ------------------
  |  Branch (157:9): [True: 129, False: 70]
  ------------------
  158|    129|        return;
  159|    129|    }
  160|       |
  161|    350|    for (uint32_t i = 0; i < tcp_server->size_accepted_connections; ++i) {
  ------------------
  |  Branch (161:26): [True: 280, False: 70]
  ------------------
  162|    280|        wipe_secure_connection(&tcp_server->accepted_connection_array[i]);
  163|    280|    }
  164|       |
  165|     70|    mem_delete(tcp_server->mem, tcp_server->accepted_connection_array);
  166|     70|    tcp_server->accepted_connection_array = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  167|     70|    tcp_server->size_accepted_connections = 0;
  168|     70|}

announce_response_of_request_type:
   26|      8|{
   27|      8|    switch (request_type) {
   28|      6|        case NET_PACKET_DATA_SEARCH_REQUEST:
  ------------------
  |  Branch (28:9): [True: 6, False: 2]
  ------------------
   29|      6|            return NET_PACKET_DATA_SEARCH_RESPONSE;
   30|       |
   31|      0|        case NET_PACKET_DATA_RETRIEVE_REQUEST:
  ------------------
  |  Branch (31:9): [True: 0, False: 8]
  ------------------
   32|      0|            return NET_PACKET_DATA_RETRIEVE_RESPONSE;
   33|       |
   34|      2|        case NET_PACKET_STORE_ANNOUNCE_REQUEST:
  ------------------
  |  Branch (34:9): [True: 2, False: 6]
  ------------------
   35|      2|            return NET_PACKET_STORE_ANNOUNCE_RESPONSE;
   36|       |
   37|      0|        default: {
  ------------------
  |  Branch (37:9): [True: 0, False: 8]
  ------------------
   38|      0|            assert(false);
   39|      0|            return NET_PACKET_MAX;
   40|      0|        }
   41|      8|    }
   42|      8|}
announce_get_bucketnum:
  105|     16|{
  106|     16|    const uint16_t index = bit_by_bit_cmp(base, pk);
  107|       |
  108|     16|    return truncate_pk_at_index(base, index + 1, ANNOUNCE_BUCKET_PREFIX_LENGTH) ^
  ------------------
  |  |   65|     16|#define ANNOUNCE_BUCKET_PREFIX_LENGTH 5
  ------------------
  109|     16|           truncate_pk_at_index(pk, index + 1, ANNOUNCE_BUCKET_PREFIX_LENGTH);
  ------------------
  |  |   65|     16|#define ANNOUNCE_BUCKET_PREFIX_LENGTH 5
  ------------------
  110|     16|}
announce_store_data:
  221|      3|{
  222|      3|    if (length > MAX_ANNOUNCEMENT_SIZE) {
  ------------------
  |  |   10|      3|#define MAX_ANNOUNCEMENT_SIZE 512
  ------------------
  |  Branch (222:9): [True: 1, False: 2]
  ------------------
  223|      1|        return false;
  224|      1|    }
  225|       |
  226|      2|    Announce_Entry *entry = find_entry_slot(announce, data_public_key);
  227|       |
  228|      2|    if (entry == nullptr) {
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
  |  Branch (228:9): [True: 0, False: 2]
  ------------------
  229|      0|        return false;
  230|      0|    }
  231|       |
  232|      2|    if (length > 0) {
  ------------------
  |  Branch (232:9): [True: 1, False: 1]
  ------------------
  233|      1|        assert(data != nullptr);
  234|       |
  235|      1|        if (entry->data != nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (235:13): [True: 0, False: 1]
  ------------------
  236|      0|            free(entry->data);
  237|      0|        }
  238|       |
  239|      1|        entry->data = (uint8_t *)malloc(length);
  240|       |
  241|      1|        if (entry->data == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (241:13): [True: 0, False: 1]
  ------------------
  242|      0|            return false;
  243|      0|        }
  244|       |
  245|      1|        memcpy(entry->data, data, length);
  246|      1|    }
  247|       |
  248|      2|    entry->length = length;
  249|      2|    memcpy(entry->data_public_key, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      2|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  250|      2|    entry->store_until = mono_time_get(announce->mono_time) + timeout;
  251|       |
  252|      2|    return true;
  253|      2|}
new_announcements:
  642|    946|{
  643|    946|    if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   66|  1.89k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   66|  1.89k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (643:9): [True: 0, False: 946]
  |  Branch (643:27): [True: 0, False: 946]
  |  Branch (643:51): [True: 0, False: 946]
  ------------------
  644|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  645|      0|    }
  646|       |
  647|    946|    Announcements *announce = (Announcements *)calloc(1, sizeof(Announcements));
  648|       |
  649|    946|    if (announce == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (649:9): [True: 0, False: 946]
  ------------------
  650|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  651|      0|    }
  652|       |
  653|    946|    announce->log = log;
  654|    946|    announce->mem = mem;
  655|    946|    announce->rng = rng;
  656|    946|    announce->forwarding = forwarding;
  657|    946|    announce->mono_time = mono_time;
  658|    946|    announce->dht = forwarding_get_dht(forwarding);
  659|    946|    announce->net = dht_get_net(announce->dht);
  660|    946|    announce->public_key = dht_get_self_public_key(announce->dht);
  661|    946|    announce->secret_key = dht_get_self_secret_key(announce->dht);
  662|    946|    new_hmac_key(announce->rng, announce->hmac_key);
  663|    946|    announce->shared_keys = shared_key_cache_new(mono_time, mem, announce->secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   23|    946|#define KEYS_TIMEOUT 600
  ------------------
                  announce->shared_keys = shared_key_cache_new(mono_time, mem, announce->secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   22|    946|#define MAX_KEYS_PER_SLOT 4
  ------------------
  664|    946|    if (announce->shared_keys == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (664:9): [True: 5, False: 941]
  ------------------
  665|      5|        free(announce);
  666|      5|        return nullptr;
  ------------------
  |  |   66|      5|#define nullptr NULL
  ------------------
  667|      5|    }
  668|       |
  669|    941|    announce->start_time = mono_time_get(announce->mono_time);
  670|       |
  671|    941|    set_callback_forwarded_request(forwarding, forwarded_request_callback, announce);
  672|       |
  673|    941|    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, handle_dht_announce_request, announce);
  674|    941|    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, handle_dht_announce_request, announce);
  675|    941|    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, handle_dht_announce_request, announce);
  676|       |
  677|    941|    return announce;
  678|    946|}
kill_announcements:
  681|    946|{
  682|    946|    if (announce == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (682:9): [True: 5, False: 941]
  ------------------
  683|      5|        return;
  684|      5|    }
  685|       |
  686|    941|    set_callback_forwarded_request(announce->forwarding, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
                  set_callback_forwarded_request(announce->forwarding, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
  687|       |
  688|    941|    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
  689|    941|    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
  690|    941|    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
  691|       |
  692|    941|    crypto_memzero(announce->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  136|    941|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  693|    941|    shared_key_cache_free(announce->shared_keys);
  694|       |
  695|   241k|    for (uint32_t i = 0; i < ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   66|   241k|#define ANNOUNCE_BUCKETS 32 // ANNOUNCE_BUCKETS = 2 ** ANNOUNCE_BUCKET_PREFIX_LENGTH
  ------------------
                  for (uint32_t i = 0; i < ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   64|   241k|#define ANNOUNCE_BUCKET_SIZE 8
  ------------------
  |  Branch (695:26): [True: 240k, False: 941]
  ------------------
  696|   240k|        if (announce->entries[i].data != nullptr) {
  ------------------
  |  |   66|   240k|#define nullptr NULL
  ------------------
  |  Branch (696:13): [True: 1, False: 240k]
  ------------------
  697|      1|            free(announce->entries[i].data);
  698|      1|        }
  699|   240k|    }
  700|       |
  701|    941|    free(announce);
  702|    941|}
announce.c:truncate_pk_at_index:
   96|     32|{
   97|     32|    assert(bits < 8);
   98|      0|    const uint8_t i = index / 8;
   99|     32|    const uint8_t j = index % 8;
  100|     32|    return ((uint8_t)((i < CRYPTO_PUBLIC_KEY_SIZE ? pk[i] : 0) << j) >> (8 - bits)) |
  ------------------
  |  |   40|     32|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (100:24): [True: 32, False: 0]
  ------------------
  101|     32|           ((i + 1 < CRYPTO_PUBLIC_KEY_SIZE ? pk[i + 1] : 0) >> (16 - bits - j));
  ------------------
  |  |   40|     32|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (101:14): [True: 32, False: 0]
  ------------------
  102|     32|}
announce.c:get_stored_const:
  144|      6|{
  145|      6|    const Announce_Entry *const bucket = bucket_of_key_const(announce, data_public_key);
  146|       |
  147|     38|    for (uint32_t i = 0; i < ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   64|     38|#define ANNOUNCE_BUCKET_SIZE 8
  ------------------
  |  Branch (147:26): [True: 34, False: 4]
  ------------------
  148|     34|        if (pk_equal(bucket[i].data_public_key, data_public_key)) {
  ------------------
  |  Branch (148:13): [True: 2, False: 32]
  ------------------
  149|      2|            if (entry_is_empty(announce, &bucket[i])) {
  ------------------
  |  Branch (149:17): [True: 2, False: 0]
  ------------------
  150|      2|                break;
  151|      2|            }
  152|       |
  153|      0|            return &bucket[i];
  154|      2|        }
  155|     34|    }
  156|       |
  157|      6|    return nullptr;
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  158|      6|}
announce.c:bucket_of_key_const:
  138|      6|{
  139|      6|    return &announce->entries[announce_get_bucketnum(announce->public_key, pk) * ANNOUNCE_BUCKET_SIZE];
  ------------------
  |  |   64|      6|#define ANNOUNCE_BUCKET_SIZE 8
  ------------------
  140|      6|}
announce.c:entry_is_empty:
   83|     51|{
   84|     51|    return mono_time_get(announce->mono_time) >= entry->store_until;
   85|     51|}
announce.c:find_entry_slot:
  185|      8|{
  186|      8|    Announce_Entry *const bucket = bucket_of_key(announce, data_public_key);
  187|       |
  188|      8|    Announce_Entry *slot = nullptr;
  ------------------
  |  |   66|      8|#define nullptr NULL
  ------------------
  189|      8|    uint16_t min_index = bit_by_bit_cmp(announce->public_key, data_public_key);
  190|       |
  191|     56|    for (uint32_t i = 0; i < ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   64|     56|#define ANNOUNCE_BUCKET_SIZE 8
  ------------------
  |  Branch (191:26): [True: 50, False: 6]
  ------------------
  192|     50|        if (pk_equal(bucket[i].data_public_key, data_public_key)) {
  ------------------
  |  Branch (192:13): [True: 2, False: 48]
  ------------------
  193|      2|            return &bucket[i];
  194|      2|        }
  195|       |
  196|     48|        if (entry_is_empty(announce, &bucket[i])) {
  ------------------
  |  Branch (196:13): [True: 48, False: 0]
  ------------------
  197|     48|            slot = &bucket[i];
  198|     48|            min_index = 0;
  199|     48|            continue;
  200|     48|        }
  201|       |
  202|      0|        const uint16_t index = bit_by_bit_cmp(announce->public_key, bucket[i].data_public_key);
  203|       |
  204|      0|        if (index < min_index) {
  ------------------
  |  Branch (204:13): [True: 0, False: 0]
  ------------------
  205|      0|            slot = &bucket[i];
  206|      0|            min_index = index;
  207|      0|        }
  208|      0|    }
  209|       |
  210|      6|    return slot;
  211|      8|}
announce.c:bucket_of_key:
  114|     10|{
  115|     10|    return &announce->entries[announce_get_bucketnum(announce->public_key, pk) * ANNOUNCE_BUCKET_SIZE];
  ------------------
  |  |   64|     10|#define ANNOUNCE_BUCKET_SIZE 8
  ------------------
  116|     10|}
announce.c:forwarded_request_callback:
  605|      7|{
  606|      7|    Announcements *announce = (Announcements *) object;
  607|       |
  608|      7|    uint8_t reply[MAX_FORWARD_DATA_SIZE];
  609|       |
  610|      7|    const int len = create_reply(announce, forwarder,
  611|      7|                                 sendback, sendback_length,
  612|      7|                                 data, length, reply, sizeof(reply));
  613|       |
  614|      7|    if (len == -1) {
  ------------------
  |  Branch (614:9): [True: 7, False: 0]
  ------------------
  615|      7|        return;
  616|      7|    }
  617|       |
  618|      0|    forward_reply(announce->net, forwarder, sendback, sendback_length, reply, len);
  619|      0|}
announce.c:create_reply:
  553|     89|{
  554|     89|    const int plain_len = (int)length - (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   40|     89|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  const int plain_len = (int)length - (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   66|     89|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  const int plain_len = (int)length - (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   61|     89|#define CRYPTO_MAC_SIZE                16
  ------------------
  555|       |
  556|     89|    if (plain_len < (int)sizeof(uint64_t)) {
  ------------------
  |  Branch (556:9): [True: 14, False: 75]
  ------------------
  557|     14|        return -1;
  558|     14|    }
  559|       |
  560|     75|    VLA(uint8_t, plain, plain_len);
  ------------------
  |  |   62|     75|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     75|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  561|     75|    const uint8_t *shared_key = dht_get_shared_key_recv(announce->dht, data + 1);
  562|       |
  563|     75|    if (decrypt_data_symmetric(shared_key,
  ------------------
  |  Branch (563:9): [True: 0, False: 75]
  ------------------
  564|     75|                               data + 1 + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|     75|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  565|     75|                               data + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   40|     75|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                             data + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|     75|#define CRYPTO_NONCE_SIZE              24
  ------------------
  566|     75|                               plain_len + CRYPTO_MAC_SIZE,
  ------------------
  |  |   61|     75|#define CRYPTO_MAC_SIZE                16
  ------------------
  567|     75|                               plain) != plain_len) {
  568|      0|        return -1;
  569|      0|    }
  570|       |
  571|     75|    const int plain_reply_max_len = (int)reply_max_length -
  572|     75|                                    (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   40|     75|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                  (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   66|     75|#define CRYPTO_NONCE_SIZE              24
  ------------------
                                                  (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   61|     75|#define CRYPTO_MAC_SIZE                16
  ------------------
  573|       |
  574|     75|    if (plain_reply_max_len < sizeof(uint64_t)) {
  ------------------
  |  Branch (574:9): [True: 0, False: 75]
  ------------------
  575|      0|        return -1;
  576|      0|    }
  577|       |
  578|     75|    VLA(uint8_t, plain_reply, plain_reply_max_len);
  ------------------
  |  |   62|     75|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     75|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  579|       |
  580|     75|    const int plain_reply_noping_len = create_reply_plain(announce,
  581|     75|                                       data + 1, source, data[0],
  582|     75|                                       sendback, sendback_length,
  583|     75|                                       plain, plain_len - sizeof(uint64_t),
  584|     75|                                       plain_reply, plain_reply_max_len - sizeof(uint64_t));
  585|       |
  586|     75|    if (plain_reply_noping_len == -1) {
  ------------------
  |  Branch (586:9): [True: 67, False: 8]
  ------------------
  587|     67|        return -1;
  588|     67|    }
  589|       |
  590|      8|    memcpy(plain_reply + plain_reply_noping_len,
  591|      8|           plain + (plain_len - sizeof(uint64_t)), sizeof(uint64_t));
  592|       |
  593|      8|    const uint16_t plain_reply_len = plain_reply_noping_len + sizeof(uint64_t);
  594|       |
  595|      8|    const uint8_t response_type = announce_response_of_request_type(data[0]);
  596|       |
  597|      8|    return dht_create_packet(announce->mem, announce->rng, announce->public_key, shared_key,
  598|      8|                             response_type, plain_reply, plain_reply_len, reply, reply_max_length);
  599|     75|}
announce.c:create_reply_plain:
  515|     75|{
  516|     75|    if (length < CRYPTO_PUBLIC_KEY_SIZE) {
  ------------------
  |  |   40|     75|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (516:9): [True: 10, False: 65]
  ------------------
  517|     10|        return -1;
  518|     10|    }
  519|       |
  520|     65|    const uint8_t *const data_public_key = data;
  521|       |
  522|     65|    uint8_t to_auth[DATA_SEARCH_TO_AUTH_MAX_SIZE];
  523|     65|    const int to_auth_length = create_data_search_to_auth(announce->log, data_public_key, requester_key, source,
  524|     65|                               sendback, sendback_length, to_auth, DATA_SEARCH_TO_AUTH_MAX_SIZE);
  ------------------
  |  |  268|     65|#define DATA_SEARCH_TO_AUTH_MAX_SIZE (CRYPTO_PUBLIC_KEY_SIZE * 2 + MAX_PACKED_IPPORT_SIZE + MAX_SENDBACK_SIZE)
  |  |  ------------------
  |  |  |  |   40|     65|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define DATA_SEARCH_TO_AUTH_MAX_SIZE (CRYPTO_PUBLIC_KEY_SIZE * 2 + MAX_PACKED_IPPORT_SIZE + MAX_SENDBACK_SIZE)
  |  |  ------------------
  |  |  |  |   24|     65|#define MAX_PACKED_IPPORT_SIZE (1 + SIZE_IP6 + sizeof(uint16_t))
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|     65|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define DATA_SEARCH_TO_AUTH_MAX_SIZE (CRYPTO_PUBLIC_KEY_SIZE * 2 + MAX_PACKED_IPPORT_SIZE + MAX_SENDBACK_SIZE)
  |  |  ------------------
  |  |  |  |   19|     65|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  525|       |
  526|     65|    if (to_auth_length == -1) {
  ------------------
  |  Branch (526:9): [True: 1, False: 64]
  ------------------
  527|      1|        return -1;
  528|      1|    }
  529|       |
  530|     64|    switch (type) {
  531|     16|        case NET_PACKET_DATA_SEARCH_REQUEST:
  ------------------
  |  Branch (531:9): [True: 16, False: 48]
  ------------------
  532|     16|            return create_reply_plain_data_search_request(announce, source, data, length, reply, reply_max_length, to_auth,
  533|     16|                    (uint16_t)to_auth_length);
  534|       |
  535|     12|        case NET_PACKET_DATA_RETRIEVE_REQUEST:
  ------------------
  |  Branch (535:9): [True: 12, False: 52]
  ------------------
  536|     12|            return create_reply_plain_data_retrieve_request(announce, source, data, length, reply, reply_max_length, to_auth,
  537|     12|                    (uint16_t)to_auth_length);
  538|       |
  539|     33|        case NET_PACKET_STORE_ANNOUNCE_REQUEST:
  ------------------
  |  Branch (539:9): [True: 33, False: 31]
  ------------------
  540|     33|            return create_reply_plain_store_announce_request(announce, source, data, length, reply, reply_max_length, to_auth,
  541|     33|                    (uint16_t)to_auth_length);
  542|       |
  543|      3|        default:
  ------------------
  |  Branch (543:9): [True: 3, False: 61]
  ------------------
  544|      3|            return -1;
  545|     64|    }
  546|     64|}
announce.c:create_data_search_to_auth:
  275|     65|{
  276|     65|    if (max_length < DATA_SEARCH_TO_AUTH_MAX_SIZE
  ------------------
  |  |  268|    130|#define DATA_SEARCH_TO_AUTH_MAX_SIZE (CRYPTO_PUBLIC_KEY_SIZE * 2 + MAX_PACKED_IPPORT_SIZE + MAX_SENDBACK_SIZE)
  |  |  ------------------
  |  |  |  |   40|     65|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define DATA_SEARCH_TO_AUTH_MAX_SIZE (CRYPTO_PUBLIC_KEY_SIZE * 2 + MAX_PACKED_IPPORT_SIZE + MAX_SENDBACK_SIZE)
  |  |  ------------------
  |  |  |  |   24|     65|#define MAX_PACKED_IPPORT_SIZE (1 + SIZE_IP6 + sizeof(uint16_t))
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|     65|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define DATA_SEARCH_TO_AUTH_MAX_SIZE (CRYPTO_PUBLIC_KEY_SIZE * 2 + MAX_PACKED_IPPORT_SIZE + MAX_SENDBACK_SIZE)
  |  |  ------------------
  |  |  |  |   19|     65|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (276:9): [True: 0, False: 65]
  ------------------
  277|     65|            || sendback_length > MAX_SENDBACK_SIZE) {
  ------------------
  |  |   19|     65|#define MAX_SENDBACK_SIZE (0xff - 1)
  ------------------
  |  Branch (277:16): [True: 1, False: 64]
  ------------------
  278|      1|        return -1;
  279|      1|    }
  280|       |
  281|     64|    memcpy(dest, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|     64|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  282|     64|    memcpy(dest + CRYPTO_PUBLIC_KEY_SIZE, requester_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|     64|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(dest + CRYPTO_PUBLIC_KEY_SIZE, requester_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|     64|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  283|       |
  284|     64|    const int ipport_length = pack_ip_port(logger, dest + CRYPTO_PUBLIC_KEY_SIZE * 2, MAX_PACKED_IPPORT_SIZE, source);
  ------------------
  |  |   40|     64|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  const int ipport_length = pack_ip_port(logger, dest + CRYPTO_PUBLIC_KEY_SIZE * 2, MAX_PACKED_IPPORT_SIZE, source);
  ------------------
  |  |   24|     64|#define MAX_PACKED_IPPORT_SIZE (1 + SIZE_IP6 + sizeof(uint16_t))
  |  |  ------------------
  |  |  |  |  225|     64|#define SIZE_IP6 16
  |  |  ------------------
  ------------------
  285|       |
  286|     64|    if (ipport_length == -1) {
  ------------------
  |  Branch (286:9): [True: 0, False: 64]
  ------------------
  287|      0|        return -1;
  288|      0|    }
  289|       |
  290|     64|    if (sendback_length > 0) {
  ------------------
  |  Branch (290:9): [True: 3, False: 61]
  ------------------
  291|      3|        assert(sendback != nullptr);
  292|      3|        memcpy(dest + CRYPTO_PUBLIC_KEY_SIZE * 2 + ipport_length, sendback, sendback_length);
  ------------------
  |  |   40|      3|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  293|      3|    }
  294|       |
  295|     64|    return CRYPTO_PUBLIC_KEY_SIZE * 2 + ipport_length + sendback_length;
  ------------------
  |  |   40|     64|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  296|     64|}
announce.c:create_reply_plain_data_search_request:
  306|     16|{
  307|     16|    if (length != CRYPTO_PUBLIC_KEY_SIZE &&
  ------------------
  |  |   40|     32|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (307:9): [True: 13, False: 3]
  ------------------
  308|     16|            length != CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA256_SIZE) {
  ------------------
  |  |   40|     13|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                          length != CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA256_SIZE) {
  ------------------
  |  |   71|     13|#define CRYPTO_SHA256_SIZE             32
  ------------------
  |  Branch (308:13): [True: 10, False: 3]
  ------------------
  309|     10|        return -1;
  310|     10|    }
  311|       |
  312|      6|    const uint8_t *const data_public_key = data;
  313|       |
  314|      6|    const uint8_t *previous_hash = nullptr;
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  315|       |
  316|      6|    if (length == CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA256_SIZE) {
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  if (length == CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA256_SIZE) {
  ------------------
  |  |   71|      6|#define CRYPTO_SHA256_SIZE             32
  ------------------
  |  Branch (316:9): [True: 3, False: 3]
  ------------------
  317|      3|        previous_hash = data + CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|      3|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  318|      3|    }
  319|       |
  320|      6|    const int nodes_max_length = (int)reply_max_length -
  321|      6|                                 (CRYPTO_PUBLIC_KEY_SIZE + 1 + CRYPTO_SHA256_SIZE + TIMED_AUTH_SIZE + 1 + 1);
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                               (CRYPTO_PUBLIC_KEY_SIZE + 1 + CRYPTO_SHA256_SIZE + TIMED_AUTH_SIZE + 1 + 1);
  ------------------
  |  |   71|      6|#define CRYPTO_SHA256_SIZE             32
  ------------------
                                               (CRYPTO_PUBLIC_KEY_SIZE + 1 + CRYPTO_SHA256_SIZE + TIMED_AUTH_SIZE + 1 + 1);
  ------------------
  |  |   10|      6|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|      6|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  322|       |
  323|      6|    if (nodes_max_length < 0) {
  ------------------
  |  Branch (323:9): [True: 0, False: 6]
  ------------------
  324|      0|        return -1;
  325|      0|    }
  326|       |
  327|      6|    uint8_t *p = reply;
  328|       |
  329|      6|    memcpy(p, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  330|      6|    p += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  331|       |
  332|      6|    const Announce_Entry *const stored = get_stored_const(announce, data_public_key);
  333|       |
  334|      6|    if (stored == nullptr) {
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  |  Branch (334:9): [True: 6, False: 0]
  ------------------
  335|      6|        *p = 0;
  336|      6|        ++p;
  337|      6|    } else {
  338|      0|        *p = 1;
  339|      0|        ++p;
  340|      0|        crypto_sha256(p, stored->data, stored->length);
  341|      0|        p += CRYPTO_SHA256_SIZE;
  ------------------
  |  |   71|      0|#define CRYPTO_SHA256_SIZE             32
  ------------------
  342|      0|    }
  343|       |
  344|      6|    generate_timed_auth(announce->mono_time, DATA_SEARCH_TIMEOUT, announce->hmac_key,
  ------------------
  |  |  298|      6|#define DATA_SEARCH_TIMEOUT 60
  ------------------
  345|      6|                        to_auth, to_auth_length, p);
  346|      6|    p += TIMED_AUTH_SIZE;
  ------------------
  |  |   10|      6|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|      6|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  347|       |
  348|      6|    *p = would_accept_store_request(announce, data_public_key);
  349|      6|    ++p;
  350|       |
  351|      6|    Node_format nodes_list[MAX_SENT_NODES];
  352|      6|    const int num_nodes = get_close_nodes(announce->dht, data_public_key, nodes_list,
  353|      6|                                          net_family_unspec(), ip_is_lan(&source->ip), true);
  354|       |
  355|      6|    if (num_nodes < 0 || num_nodes > MAX_SENT_NODES) {
  ------------------
  |  |   54|      6|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (355:9): [True: 0, False: 6]
  |  Branch (355:26): [True: 0, False: 6]
  ------------------
  356|      0|        return -1;
  357|      0|    }
  358|       |
  359|      6|    *p = num_nodes;
  360|      6|    ++p;
  361|       |
  362|      6|    p += pack_nodes(announce->log, p, nodes_max_length, nodes_list, num_nodes);
  363|       |
  364|      6|    const uint32_t reply_len = p - reply;
  365|       |
  366|      6|    if (previous_hash != nullptr) {
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  |  Branch (366:9): [True: 3, False: 3]
  ------------------
  367|      3|        uint8_t hash[CRYPTO_SHA256_SIZE];
  368|       |
  369|      3|        crypto_sha256(hash, reply, reply_len);
  370|       |
  371|      3|        if (crypto_sha256_eq(hash, previous_hash)) {
  ------------------
  |  Branch (371:13): [True: 1, False: 2]
  ------------------
  372|      1|            return CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  373|      1|        }
  374|      3|    }
  375|       |
  376|      5|    return reply_len;
  377|      6|}
announce.c:would_accept_store_request:
  215|      6|{
  216|      6|    return find_entry_slot(announce, data_public_key) != nullptr;
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  217|      6|}
announce.c:create_reply_plain_data_retrieve_request:
  385|     12|{
  386|     12|    if (length != CRYPTO_PUBLIC_KEY_SIZE + 1 + TIMED_AUTH_SIZE) {
  ------------------
  |  |   40|     12|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  if (length != CRYPTO_PUBLIC_KEY_SIZE + 1 + TIMED_AUTH_SIZE) {
  ------------------
  |  |   10|     12|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     12|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  |  Branch (386:9): [True: 10, False: 2]
  ------------------
  387|     10|        return -1;
  388|     10|    }
  389|       |
  390|      2|    if (data[CRYPTO_PUBLIC_KEY_SIZE] != 0) {
  ------------------
  |  |   40|      2|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (390:9): [True: 1, False: 1]
  ------------------
  391|      1|        return -1;
  392|      1|    }
  393|       |
  394|      1|    const uint8_t *const data_public_key = data;
  395|      1|    const uint8_t *const auth = data + CRYPTO_PUBLIC_KEY_SIZE + 1;
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  396|       |
  397|      1|    if (!check_timed_auth(announce->mono_time, DATA_SEARCH_TIMEOUT, announce->hmac_key,
  ------------------
  |  |  298|      1|#define DATA_SEARCH_TIMEOUT 60
  ------------------
  |  Branch (397:9): [True: 1, False: 0]
  ------------------
  398|      1|                          to_auth, to_auth_length, auth)) {
  399|      1|        return -1;
  400|      1|    }
  401|       |
  402|      0|    const Announce_Entry *const entry = get_stored_const(announce, data_public_key);
  403|       |
  404|      0|    if (entry == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (404:9): [True: 0, False: 0]
  ------------------
  405|      0|        return -1;
  406|      0|    }
  407|       |
  408|      0|    const uint16_t reply_len = CRYPTO_PUBLIC_KEY_SIZE + 1 + entry->length;
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  409|       |
  410|      0|    if (reply_max_length < reply_len) {
  ------------------
  |  Branch (410:9): [True: 0, False: 0]
  ------------------
  411|      0|        return -1;
  412|      0|    }
  413|       |
  414|      0|    memcpy(reply, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  415|      0|    reply[CRYPTO_PUBLIC_KEY_SIZE] = 1;
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  416|      0|    memcpy(reply + CRYPTO_PUBLIC_KEY_SIZE + 1, entry->data, entry->length);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  417|       |
  418|      0|    return reply_len;
  419|      0|}
announce.c:create_reply_plain_store_announce_request:
  427|     33|{
  428|     33|    const int plain_len = (int)length - (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   40|     33|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  const int plain_len = (int)length - (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   66|     33|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  const int plain_len = (int)length - (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
  ------------------
  |  |   61|     33|#define CRYPTO_MAC_SIZE                16
  ------------------
  429|     33|    const int announcement_len = (int)plain_len - (TIMED_AUTH_SIZE + sizeof(uint32_t) + 1);
  ------------------
  |  |   10|     33|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     33|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  430|       |
  431|     33|    const uint8_t *const data_public_key = data;
  432|       |
  433|     33|    if (announcement_len < 0) {
  ------------------
  |  Branch (433:9): [True: 11, False: 22]
  ------------------
  434|     11|        return -1;
  435|     11|    }
  436|       |
  437|     22|    VLA(uint8_t, plain, plain_len);
  ------------------
  |  |   62|     22|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     22|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  438|       |
  439|     22|    const uint8_t* shared_key = shared_key_cache_lookup(announce->shared_keys, data_public_key);
  440|       |
  441|     22|    if (shared_key == nullptr) {
  ------------------
  |  |   66|     22|#define nullptr NULL
  ------------------
  |  Branch (441:9): [True: 0, False: 22]
  ------------------
  442|       |        /* Error looking up/deriving the shared key */
  443|      0|        return -1;
  444|      0|    }
  445|       |
  446|     22|    if (decrypt_data_symmetric(shared_key,
  ------------------
  |  Branch (446:9): [True: 0, False: 22]
  ------------------
  447|     22|                               data + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|     22|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  448|     22|                               data + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   40|     22|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                             data + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|     22|#define CRYPTO_NONCE_SIZE              24
  ------------------
  449|     22|                               plain_len + CRYPTO_MAC_SIZE,
  ------------------
  |  |   61|     22|#define CRYPTO_MAC_SIZE                16
  ------------------
  450|     22|                               plain) != plain_len) {
  451|      0|        return -1;
  452|      0|    }
  453|       |
  454|     22|    const uint8_t *const auth = plain;
  455|     22|    uint32_t requested_timeout;
  456|     22|    net_unpack_u32(plain + TIMED_AUTH_SIZE, &requested_timeout);
  ------------------
  |  |   10|     22|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     22|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  457|     22|    const uint32_t timeout = calculate_timeout(announce, requested_timeout);
  458|     22|    const uint8_t announcement_type = plain[TIMED_AUTH_SIZE + sizeof(uint32_t)];
  ------------------
  |  |   10|     22|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     22|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  459|     22|    const uint8_t *announcement = plain + TIMED_AUTH_SIZE + sizeof(uint32_t) + 1;
  ------------------
  |  |   10|     22|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     22|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  460|       |
  461|     22|    if (!check_timed_auth(announce->mono_time, DATA_SEARCH_TIMEOUT, announce->hmac_key,
  ------------------
  |  |  298|     22|#define DATA_SEARCH_TIMEOUT 60
  ------------------
  |  Branch (461:9): [True: 15, False: 7]
  ------------------
  462|     22|                          to_auth, to_auth_length, auth)) {
  463|     15|        return -1;
  464|     15|    }
  465|       |
  466|      7|    if (announcement_type > 1) {
  ------------------
  |  Branch (466:9): [True: 1, False: 6]
  ------------------
  467|      1|        return -1;
  468|      1|    }
  469|       |
  470|      6|    if (announcement_type == 1) {
  ------------------
  |  Branch (470:9): [True: 3, False: 3]
  ------------------
  471|      3|        if (announcement_len != CRYPTO_SHA256_SIZE) {
  ------------------
  |  |   71|      3|#define CRYPTO_SHA256_SIZE             32
  ------------------
  |  Branch (471:13): [True: 1, False: 2]
  ------------------
  472|      1|            return -1;
  473|      1|        }
  474|       |
  475|      2|        Announce_Entry *stored = get_stored(announce, data_public_key);
  476|       |
  477|      2|        if (stored == nullptr) {
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
  |  Branch (477:13): [True: 2, False: 0]
  ------------------
  478|      2|            return -1;
  479|      2|        }
  480|       |
  481|      0|        uint8_t stored_hash[CRYPTO_SHA256_SIZE];
  482|      0|        crypto_sha256(stored_hash, stored->data, stored->length);
  483|       |
  484|      0|        if (!crypto_sha256_eq(announcement, stored_hash)) {
  ------------------
  |  Branch (484:13): [True: 0, False: 0]
  ------------------
  485|      0|            delete_entry(stored);
  486|      0|            return -1;
  487|      0|        } else {
  488|      0|            stored->store_until = mono_time_get(announce->mono_time) + timeout;
  489|      0|        }
  490|      3|    } else {
  491|      3|        if (!announce_store_data(announce, data_public_key, announcement, announcement_len, timeout)) {
  ------------------
  |  Branch (491:13): [True: 1, False: 2]
  ------------------
  492|      1|            return -1;
  493|      1|        }
  494|      3|    }
  495|       |
  496|      2|    const uint16_t reply_len = CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t) + sizeof(uint64_t);
  ------------------
  |  |   40|      2|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  497|       |
  498|      2|    if (reply_max_length < reply_len) {
  ------------------
  |  Branch (498:9): [True: 0, False: 2]
  ------------------
  499|      0|        return -1;
  500|      0|    }
  501|       |
  502|      2|    memcpy(reply, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      2|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  503|      2|    net_pack_u32(reply + CRYPTO_PUBLIC_KEY_SIZE, timeout);
  ------------------
  |  |   40|      2|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  504|      2|    net_pack_u64(reply + CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t),
  ------------------
  |  |   40|      2|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  505|      2|                 mono_time_get(announce->mono_time) + announce->synch_offset);
  506|      2|    return reply_len;
  507|      2|}
announce.c:calculate_timeout:
  257|     22|{
  258|     22|    const uint64_t uptime = mono_time_get(announce->mono_time) - announce->start_time;
  259|     22|    const uint32_t max_announcement_timeout = max_u32(
  260|     22|                (uint32_t)min_u64(
  261|     22|                    MAX_MAX_ANNOUNCEMENT_TIMEOUT,
  ------------------
  |  |   53|     22|#define MAX_MAX_ANNOUNCEMENT_TIMEOUT 900
  ------------------
  262|     22|                    uptime / MAX_ANNOUNCEMENT_TIMEOUT_UPTIME_RATIO),
  ------------------
  |  |   55|     22|#define MAX_ANNOUNCEMENT_TIMEOUT_UPTIME_RATIO 4
  ------------------
  263|     22|                MIN_MAX_ANNOUNCEMENT_TIMEOUT);
  ------------------
  |  |   54|     22|#define MIN_MAX_ANNOUNCEMENT_TIMEOUT 10
  ------------------
  264|       |
  265|     22|    return min_u32(max_announcement_timeout, requested_timeout);
  266|     22|}
announce.c:get_stored:
  120|      2|{
  121|      2|    Announce_Entry *const bucket = bucket_of_key(announce, data_public_key);
  122|       |
  123|     10|    for (uint32_t i = 0; i < ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   64|     10|#define ANNOUNCE_BUCKET_SIZE 8
  ------------------
  |  Branch (123:26): [True: 9, False: 1]
  ------------------
  124|      9|        if (pk_equal(bucket[i].data_public_key, data_public_key)) {
  ------------------
  |  Branch (124:13): [True: 1, False: 8]
  ------------------
  125|      1|            if (entry_is_empty(announce, &bucket[i])) {
  ------------------
  |  Branch (125:17): [True: 1, False: 0]
  ------------------
  126|      1|                break;
  127|      1|            }
  128|       |
  129|      0|            return &bucket[i];
  130|      1|        }
  131|      9|    }
  132|       |
  133|      2|    return nullptr;
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
  134|      2|}
announce.c:handle_dht_announce_request:
  624|     82|{
  625|     82|    Announcements *announce = (Announcements *) object;
  626|       |
  627|     82|    uint8_t reply[MAX_FORWARD_DATA_SIZE];
  628|       |
  629|     82|    const int len = create_reply(announce, source,
  630|     82|                                 nullptr, 0,
  ------------------
  |  |   66|     82|#define nullptr NULL
  ------------------
  631|     82|                                 data, length, reply, sizeof(reply));
  632|       |
  633|     82|    if (len == -1) {
  ------------------
  |  Branch (633:9): [True: 74, False: 8]
  ------------------
  634|     74|        return -1;
  635|     74|    }
  636|       |
  637|      8|    return sendpacket(announce->net, source, reply, len) == len ? 0 : -1;
  ------------------
  |  Branch (637:12): [True: 8, False: 0]
  ------------------
  638|     82|}

bin_pack_obj:
   66|   145k|{
   67|   145k|    Bin_Pack bp;
   68|   145k|    bin_pack_init(&bp, buf, buf_size);
   69|   145k|    return callback(&bp, obj);
   70|   145k|}
bin_pack_obj_size:
   73|   145k|{
   74|   145k|    Bin_Pack bp;
   75|   145k|    bin_pack_init(&bp, nullptr, 0);
  ------------------
  |  |   66|   145k|#define nullptr NULL
  ------------------
   76|   145k|    callback(&bp, obj);
   77|   145k|    return bp.bytes_pos;
   78|   145k|}
bin_pack_array:
   96|   291k|{
   97|   291k|    return cmp_write_array(&bp->ctx, size);
   98|   291k|}
bin_pack_u32:
  116|    512|{
  117|    512|    return cmp_write_uinteger(&bp->ctx, val);
  118|    512|}
bin_pack_bin:
  126|  1.02k|{
  127|  1.02k|    return cmp_write_bin(&bp->ctx, data, length);
  128|  1.02k|}
bin_pack.c:bin_pack_init:
   58|   290k|{
   59|   290k|    bp->bytes = buf;
   60|   290k|    bp->bytes_size = buf_size;
   61|   290k|    bp->bytes_pos = 0;
   62|   290k|    cmp_init(&bp->ctx, bp, null_reader, null_skipper, buf_writer);
   63|   290k|}
bin_pack.c:buf_writer:
   37|   295k|{
   38|   295k|    Bin_Pack *bp = (Bin_Pack *)ctx->buf;
   39|   295k|    assert(bp != nullptr);
   40|      0|    const uint32_t new_pos = bp->bytes_pos + count;
   41|   295k|    if (new_pos < bp->bytes_pos) {
  ------------------
  |  Branch (41:9): [True: 0, False: 295k]
  ------------------
   42|       |        // 32 bit overflow.
   43|      0|        return 0;
   44|      0|    }
   45|   295k|    if (bp->bytes != nullptr) {
  ------------------
  |  |   66|   295k|#define nullptr NULL
  ------------------
  |  Branch (45:9): [True: 147k, False: 147k]
  ------------------
   46|   147k|        if (new_pos > bp->bytes_size) {
  ------------------
  |  Branch (46:13): [True: 0, False: 147k]
  ------------------
   47|       |            // Buffer too small.
   48|      0|            return 0;
   49|      0|        }
   50|   147k|        memcpy(bp->bytes + bp->bytes_pos, data, count);
   51|   147k|    }
   52|   295k|    bp->bytes_pos += count;
   53|   295k|    return count;
   54|   295k|}

crypto_memzero:
  143|  61.3k|{
  144|  61.3k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) || defined(VANILLA_NACL)
  145|  61.3k|    memset(data, 0, length);
  146|       |#else
  147|       |    sodium_memzero(data, length);
  148|       |#endif
  149|  61.3k|}
crypto_memlock:
  152|  6.60k|{
  153|  6.60k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) || defined(VANILLA_NACL)
  154|  6.60k|    return false;
  155|       |#else
  156|       |
  157|       |    if (sodium_mlock(data, length) != 0) {
  158|       |        return false;
  159|       |    }
  160|       |
  161|       |    return true;
  162|       |#endif
  163|  6.60k|}
crypto_memunlock:
  166|  6.60k|{
  167|  6.60k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) || defined(VANILLA_NACL)
  168|  6.60k|    return false;
  169|       |#else
  170|       |
  171|       |    if (sodium_munlock(data, length) != 0) {
  172|       |        return false;
  173|       |    }
  174|       |
  175|       |    return true;
  176|       |#endif
  177|  6.60k|}
pk_equal:
  180|  2.41M|{
  181|  2.41M|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  182|       |    // Hope that this is better for the fuzzer
  183|  2.41M|    return memcmp(pk1, pk2, CRYPTO_PUBLIC_KEY_SIZE) == 0;
  ------------------
  |  |   40|  2.41M|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  184|       |#else
  185|       |    return crypto_verify_32(pk1, pk2) == 0;
  186|       |#endif
  187|  2.41M|}
pk_copy:
  190|  24.0k|{
  191|  24.0k|    memcpy(dest, src, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|  24.0k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  192|  24.0k|}
crypto_sha256_eq:
  209|      3|{
  210|      3|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  211|       |    // Hope that this is better for the fuzzer
  212|      3|    return memcmp(cksum1, cksum2, CRYPTO_SHA256_SIZE) == 0;
  ------------------
  |  |   71|      3|#define CRYPTO_SHA256_SIZE             32
  ------------------
  213|       |#else
  214|       |    return crypto_verify_32(cksum1, cksum2) == 0;
  215|       |#endif
  216|      3|}
random_u16:
  226|  50.4k|{
  227|  50.4k|    uint16_t randnum;
  228|  50.4k|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  229|  50.4k|    return randnum;
  230|  50.4k|}
random_u32:
  233|  15.6k|{
  234|  15.6k|    uint32_t randnum;
  235|  15.6k|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  236|  15.6k|    return randnum;
  237|  15.6k|}
random_u64:
  240|  2.87k|{
  241|  2.87k|    uint64_t randnum;
  242|  2.87k|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  243|  2.87k|    return randnum;
  244|  2.87k|}
public_key_valid:
  272|    128|{
  273|       |    /* Last bit of key is always zero. */
  274|    128|    return public_key[31] < 128;
  275|    128|}
encrypt_precompute:
  279|  3.18k|{
  280|  3.18k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  281|  3.18k|    memcpy(shared_key, public_key, CRYPTO_SHARED_KEY_SIZE);
  ------------------
  |  |   50|  3.18k|#define CRYPTO_SHARED_KEY_SIZE         32
  ------------------
  282|  3.18k|    return 0;
  283|       |#else
  284|       |    return crypto_box_beforenm(shared_key, public_key, secret_key);
  285|       |#endif
  286|  3.18k|}
encrypt_data_symmetric:
  290|  1.90k|{
  291|  1.90k|    if (length == 0 || shared_key == nullptr || nonce == nullptr || plain == nullptr || encrypted == nullptr) {
  ------------------
  |  |   66|  3.81k|#define nullptr NULL
  ------------------
                  if (length == 0 || shared_key == nullptr || nonce == nullptr || plain == nullptr || encrypted == nullptr) {
  ------------------
  |  |   66|  3.81k|#define nullptr NULL
  ------------------
                  if (length == 0 || shared_key == nullptr || nonce == nullptr || plain == nullptr || encrypted == nullptr) {
  ------------------
  |  |   66|  3.81k|#define nullptr NULL
  ------------------
                  if (length == 0 || shared_key == nullptr || nonce == nullptr || plain == nullptr || encrypted == nullptr) {
  ------------------
  |  |   66|  1.90k|#define nullptr NULL
  ------------------
  |  Branch (291:9): [True: 0, False: 1.90k]
  |  Branch (291:24): [True: 0, False: 1.90k]
  |  Branch (291:49): [True: 0, False: 1.90k]
  |  Branch (291:69): [True: 0, False: 1.90k]
  |  Branch (291:89): [True: 0, False: 1.90k]
  ------------------
  292|      0|        return -1;
  293|      0|    }
  294|       |
  295|  1.90k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  296|       |    // Don't encrypt anything.
  297|  1.90k|    memcpy(encrypted, plain, length);
  298|       |    // Zero MAC to avoid uninitialized memory reads.
  299|  1.90k|    memset(encrypted + length, 0, crypto_box_MACBYTES);
  300|       |#else
  301|       |
  302|       |    const size_t size_temp_plain = length + crypto_box_ZEROBYTES;
  303|       |    const size_t size_temp_encrypted = length + crypto_box_MACBYTES + crypto_box_BOXZEROBYTES;
  304|       |
  305|       |    uint8_t *temp_plain = crypto_malloc(size_temp_plain);
  306|       |    uint8_t *temp_encrypted = crypto_malloc(size_temp_encrypted);
  307|       |
  308|       |    if (temp_plain == nullptr || temp_encrypted == nullptr) {
  309|       |        crypto_free(temp_plain, size_temp_plain);
  310|       |        crypto_free(temp_encrypted, size_temp_encrypted);
  311|       |        return -1;
  312|       |    }
  313|       |
  314|       |    // crypto_box_afternm requires the entire range of the output array be
  315|       |    // initialised with something. It doesn't matter what it's initialised with,
  316|       |    // so we'll pick 0x00.
  317|       |    memset(temp_encrypted, 0, size_temp_encrypted);
  318|       |
  319|       |    memset(temp_plain, 0, crypto_box_ZEROBYTES);
  320|       |    // Pad the message with 32 0 bytes.
  321|       |    memcpy(temp_plain + crypto_box_ZEROBYTES, plain, length);
  322|       |
  323|       |    if (crypto_box_afternm(temp_encrypted, temp_plain, length + crypto_box_ZEROBYTES, nonce,
  324|       |                           shared_key) != 0) {
  325|       |        crypto_free(temp_plain, size_temp_plain);
  326|       |        crypto_free(temp_encrypted, size_temp_encrypted);
  327|       |        return -1;
  328|       |    }
  329|       |
  330|       |    // Unpad the encrypted message.
  331|       |    memcpy(encrypted, temp_encrypted + crypto_box_BOXZEROBYTES, length + crypto_box_MACBYTES);
  332|       |
  333|       |    crypto_free(temp_plain, size_temp_plain);
  334|       |    crypto_free(temp_encrypted, size_temp_encrypted);
  335|       |#endif
  336|  1.90k|    assert(length < INT32_MAX - crypto_box_MACBYTES);
  337|      0|    return (int32_t)(length + crypto_box_MACBYTES);
  338|  1.90k|}
decrypt_data_symmetric:
  342|  1.95k|{
  343|  1.95k|    if (length <= crypto_box_BOXZEROBYTES || shared_key == nullptr || nonce == nullptr || encrypted == nullptr
  ------------------
  |  |   66|  3.91k|#define nullptr NULL
  ------------------
                  if (length <= crypto_box_BOXZEROBYTES || shared_key == nullptr || nonce == nullptr || encrypted == nullptr
  ------------------
  |  |   66|  3.91k|#define nullptr NULL
  ------------------
                  if (length <= crypto_box_BOXZEROBYTES || shared_key == nullptr || nonce == nullptr || encrypted == nullptr
  ------------------
  |  |   66|  3.91k|#define nullptr NULL
  ------------------
  |  Branch (343:9): [True: 4, False: 1.95k]
  |  Branch (343:46): [True: 0, False: 1.95k]
  |  Branch (343:71): [True: 0, False: 1.95k]
  |  Branch (343:91): [True: 0, False: 1.95k]
  ------------------
  344|  1.95k|            || plain == nullptr) {
  ------------------
  |  |   66|  1.95k|#define nullptr NULL
  ------------------
  |  Branch (344:16): [True: 0, False: 1.95k]
  ------------------
  345|      4|        return -1;
  346|      4|    }
  347|       |
  348|  1.95k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  349|  1.95k|    assert(length >= crypto_box_MACBYTES);
  350|      0|    memcpy(plain, encrypted, length - crypto_box_MACBYTES);  // Don't encrypt anything
  351|       |#else
  352|       |
  353|       |    const size_t size_temp_plain = length + crypto_box_ZEROBYTES;
  354|       |    const size_t size_temp_encrypted = length + crypto_box_BOXZEROBYTES;
  355|       |
  356|       |    uint8_t *temp_plain = crypto_malloc(size_temp_plain);
  357|       |    uint8_t *temp_encrypted = crypto_malloc(size_temp_encrypted);
  358|       |
  359|       |    if (temp_plain == nullptr || temp_encrypted == nullptr) {
  360|       |        crypto_free(temp_plain, size_temp_plain);
  361|       |        crypto_free(temp_encrypted, size_temp_encrypted);
  362|       |        return -1;
  363|       |    }
  364|       |
  365|       |    // crypto_box_open_afternm requires the entire range of the output array be
  366|       |    // initialised with something. It doesn't matter what it's initialised with,
  367|       |    // so we'll pick 0x00.
  368|       |    memset(temp_plain, 0, size_temp_plain);
  369|       |
  370|       |    memset(temp_encrypted, 0, crypto_box_BOXZEROBYTES);
  371|       |    // Pad the message with 16 0 bytes.
  372|       |    memcpy(temp_encrypted + crypto_box_BOXZEROBYTES, encrypted, length);
  373|       |
  374|       |    if (crypto_box_open_afternm(temp_plain, temp_encrypted, length + crypto_box_BOXZEROBYTES, nonce,
  375|       |                                shared_key) != 0) {
  376|       |        crypto_free(temp_plain, size_temp_plain);
  377|       |        crypto_free(temp_encrypted, size_temp_encrypted);
  378|       |        return -1;
  379|       |    }
  380|       |
  381|       |    memcpy(plain, temp_plain + crypto_box_ZEROBYTES, length - crypto_box_MACBYTES);
  382|       |
  383|       |    crypto_free(temp_plain, size_temp_plain);
  384|       |    crypto_free(temp_encrypted, size_temp_encrypted);
  385|       |#endif
  386|  1.95k|    assert(length > crypto_box_MACBYTES);
  387|      0|    assert(length < INT32_MAX);
  388|      0|    return (int32_t)(length - crypto_box_MACBYTES);
  389|  1.95k|}
decrypt_data:
  407|    493|{
  408|    493|    if (public_key == nullptr || secret_key == nullptr) {
  ------------------
  |  |   66|    986|#define nullptr NULL
  ------------------
                  if (public_key == nullptr || secret_key == nullptr) {
  ------------------
  |  |   66|    493|#define nullptr NULL
  ------------------
  |  Branch (408:9): [True: 0, False: 493]
  |  Branch (408:34): [True: 0, False: 493]
  ------------------
  409|      0|        return -1;
  410|      0|    }
  411|       |
  412|    493|    uint8_t k[crypto_box_BEFORENMBYTES];
  413|    493|    encrypt_precompute(public_key, secret_key, k);
  414|    493|    const int ret = decrypt_data_symmetric(k, nonce, encrypted, length, plain);
  415|    493|    crypto_memzero(k, sizeof(k));
  416|    493|    return ret;
  417|    493|}
increment_nonce:
  420|    413|{
  421|       |    /* TODO(irungentoo): use `increment_nonce_number(nonce, 1)` or
  422|       |     * sodium_increment (change to little endian).
  423|       |     *
  424|       |     * NOTE don't use breaks inside this loop.
  425|       |     * In particular, make sure, as far as possible,
  426|       |     * that loop bounds and their potential underflow or overflow
  427|       |     * are independent of user-controlled input (you may have heard of the Heartbleed bug).
  428|       |     */
  429|    413|    uint_fast16_t carry = 1U;
  430|       |
  431|  10.3k|    for (uint32_t i = crypto_box_NONCEBYTES; i != 0; --i) {
  ------------------
  |  Branch (431:46): [True: 9.91k, False: 413]
  ------------------
  432|  9.91k|        carry += (uint_fast16_t)nonce[i - 1];
  433|  9.91k|        nonce[i - 1] = (uint8_t)carry;
  434|  9.91k|        carry >>= 8;
  435|  9.91k|    }
  436|    413|}
random_nonce:
  461|  2.51k|{
  462|  2.51k|    random_bytes(rng, nonce, crypto_box_NONCEBYTES);
  463|  2.51k|}
new_symmetric_key:
  466|  2.83k|{
  467|  2.83k|    random_bytes(rng, key, CRYPTO_SYMMETRIC_KEY_SIZE);
  ------------------
  |  |   55|  2.83k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  ------------------
  |  |  |  |   50|  2.83k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  ------------------
  ------------------
  468|  2.83k|}
crypto_new_keypair:
  471|  5.67k|{
  472|  5.67k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  473|  5.67k|    random_bytes(rng, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   45|  5.67k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
  474|  5.67k|    memset(public_key, 0, CRYPTO_PUBLIC_KEY_SIZE);  // Make MSAN happy
  ------------------
  |  |   40|  5.67k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  475|  5.67k|    crypto_derive_public_key(public_key, secret_key);
  476|  5.67k|    return 0;
  477|       |#else
  478|       |    return crypto_box_keypair(public_key, secret_key);
  479|       |#endif
  480|  5.67k|}
crypto_derive_public_key:
  483|  6.76k|{
  484|  6.76k|    crypto_scalarmult_curve25519_base(public_key, secret_key);
  485|  6.76k|}
new_hmac_key:
  488|  2.83k|{
  489|  2.83k|    random_bytes(rng, key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  136|  2.83k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  490|  2.83k|}
crypto_hmac:
  494|     57|{
  495|     57|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  496|     57|    memcpy(auth, key, 16);
  497|     57|    memcpy(auth + 16, data, length < 16 ? length : 16);
  ------------------
  |  Branch (497:29): [True: 0, False: 57]
  ------------------
  498|       |#else
  499|       |    crypto_auth(auth, data, length, key);
  500|       |#endif
  501|     57|}
crypto_hmac_verify:
  505|     91|{
  506|     91|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  507|     91|    return memcmp(auth, key, 16) == 0 && memcmp(auth + 16, data, length < 16 ? length : 16) == 0;
  ------------------
  |  Branch (507:12): [True: 23, False: 68]
  |  Branch (507:42): [True: 8, False: 15]
  |  Branch (507:66): [True: 0, False: 23]
  ------------------
  508|       |#else
  509|       |    return crypto_auth_verify(auth, data, length, key) == 0;
  510|       |#endif
  511|     91|}
crypto_sha256:
  514|      3|{
  515|      3|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  516|      3|    memset(hash, 0, CRYPTO_SHA256_SIZE);
  ------------------
  |  |   71|      3|#define CRYPTO_SHA256_SIZE             32
  ------------------
  517|      3|    memcpy(hash, data, length < CRYPTO_SHA256_SIZE ? length : CRYPTO_SHA256_SIZE);
  ------------------
  |  |   71|      3|#define CRYPTO_SHA256_SIZE             32
  ------------------
                  memcpy(hash, data, length < CRYPTO_SHA256_SIZE ? length : CRYPTO_SHA256_SIZE);
  ------------------
  |  |   71|      3|#define CRYPTO_SHA256_SIZE             32
  ------------------
  |  Branch (517:24): [True: 0, False: 3]
  ------------------
  518|       |#else
  519|       |    crypto_hash_sha256(hash, data, length);
  520|       |#endif
  521|      3|}
system_random:
  563|    968|{
  564|    968|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  565|    968|    if ((true)) {
  ------------------
  |  Branch (565:9): [Folded - Ignored]
  ------------------
  566|    968|        return nullptr;
  ------------------
  |  |   66|    968|#define nullptr NULL
  ------------------
  567|    968|    }
  568|      0|#endif
  569|      0|#ifndef VANILLA_NACL
  570|       |    // It is safe to call this function more than once and from different
  571|       |    // threads -- subsequent calls won't have any effects.
  572|      0|    if (sodium_init() == -1) {
  ------------------
  |  Branch (572:9): [True: 0, False: 0]
  ------------------
  573|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  574|      0|    }
  575|      0|#endif
  576|      0|    return &system_random_obj;
  577|      0|}
random_bytes:
  580|  82.8k|{
  581|  82.8k|    rng->funcs->random_bytes(rng->obj, bytes, length);
  582|  82.8k|}

tox_events_clear_conference_connected:
  110|     70|{
  111|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (111:9): [True: 0, False: 70]
  ------------------
  112|      0|        return;
  113|      0|    }
  114|       |
  115|     70|    for (uint32_t i = 0; i < events->conference_connected_size; ++i) {
  ------------------
  |  Branch (115:26): [True: 0, False: 70]
  ------------------
  116|      0|        tox_event_conference_connected_destruct(&events->conference_connected[i]);
  117|      0|    }
  118|       |
  119|     70|    free(events->conference_connected);
  120|     70|    events->conference_connected = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  121|     70|    events->conference_connected_size = 0;
  122|     70|    events->conference_connected_capacity = 0;
  123|     70|}
tox_events_get_conference_connected_size:
  126|   654k|{
  127|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (127:9): [True: 653k, False: 630]
  ------------------
  128|   653k|        return 0;
  129|   653k|    }
  130|       |
  131|    630|    return events->conference_connected_size;
  132|   654k|}
tox_events_pack_conference_connected:
  142|   290k|{
  143|   290k|    const uint32_t size = tox_events_get_conference_connected_size(events);
  144|       |
  145|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (145:26): [True: 0, False: 290k]
  ------------------
  146|      0|        if (!tox_event_conference_connected_pack(tox_events_get_conference_connected(events, i), bp)) {
  ------------------
  |  Branch (146:13): [True: 0, False: 0]
  ------------------
  147|      0|            return false;
  148|      0|        }
  149|      0|    }
  150|   290k|    return true;
  151|   290k|}

tox_events_clear_conference_invite:
  167|     70|{
  168|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (168:9): [True: 0, False: 70]
  ------------------
  169|      0|        return;
  170|      0|    }
  171|       |
  172|     70|    for (uint32_t i = 0; i < events->conference_invite_size; ++i) {
  ------------------
  |  Branch (172:26): [True: 0, False: 70]
  ------------------
  173|      0|        tox_event_conference_invite_destruct(&events->conference_invite[i]);
  174|      0|    }
  175|       |
  176|     70|    free(events->conference_invite);
  177|     70|    events->conference_invite = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  178|     70|    events->conference_invite_size = 0;
  179|     70|    events->conference_invite_capacity = 0;
  180|     70|}
tox_events_get_conference_invite_size:
  183|   654k|{
  184|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (184:9): [True: 653k, False: 630]
  ------------------
  185|   653k|        return 0;
  186|   653k|    }
  187|       |
  188|    630|    return events->conference_invite_size;
  189|   654k|}
tox_events_pack_conference_invite:
  199|   290k|{
  200|   290k|    const uint32_t size = tox_events_get_conference_invite_size(events);
  201|       |
  202|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (202:26): [True: 0, False: 290k]
  ------------------
  203|      0|        if (!tox_event_conference_invite_pack(tox_events_get_conference_invite(events, i), bp)) {
  ------------------
  |  Branch (203:13): [True: 0, False: 0]
  ------------------
  204|      0|            return false;
  205|      0|        }
  206|      0|    }
  207|   290k|    return true;
  208|   290k|}

tox_events_clear_conference_message:
  183|     70|{
  184|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (184:9): [True: 0, False: 70]
  ------------------
  185|      0|        return;
  186|      0|    }
  187|       |
  188|     70|    for (uint32_t i = 0; i < events->conference_message_size; ++i) {
  ------------------
  |  Branch (188:26): [True: 0, False: 70]
  ------------------
  189|      0|        tox_event_conference_message_destruct(&events->conference_message[i]);
  190|      0|    }
  191|       |
  192|     70|    free(events->conference_message);
  193|     70|    events->conference_message = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  194|     70|    events->conference_message_size = 0;
  195|     70|    events->conference_message_capacity = 0;
  196|     70|}
tox_events_get_conference_message_size:
  199|   654k|{
  200|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (200:9): [True: 653k, False: 630]
  ------------------
  201|   653k|        return 0;
  202|   653k|    }
  203|       |
  204|    630|    return events->conference_message_size;
  205|   654k|}
tox_events_pack_conference_message:
  215|   290k|{
  216|   290k|    const uint32_t size = tox_events_get_conference_message_size(events);
  217|       |
  218|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (218:26): [True: 0, False: 290k]
  ------------------
  219|      0|        if (!tox_event_conference_message_pack(tox_events_get_conference_message(events, i), bp)) {
  ------------------
  |  Branch (219:13): [True: 0, False: 0]
  ------------------
  220|      0|            return false;
  221|      0|        }
  222|      0|    }
  223|   290k|    return true;
  224|   290k|}

tox_events_clear_conference_peer_list_changed:
  114|     70|{
  115|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (115:9): [True: 0, False: 70]
  ------------------
  116|      0|        return;
  117|      0|    }
  118|       |
  119|     70|    for (uint32_t i = 0; i < events->conference_peer_list_changed_size; ++i) {
  ------------------
  |  Branch (119:26): [True: 0, False: 70]
  ------------------
  120|      0|        tox_event_conference_peer_list_changed_destruct(&events->conference_peer_list_changed[i]);
  121|      0|    }
  122|       |
  123|     70|    free(events->conference_peer_list_changed);
  124|     70|    events->conference_peer_list_changed = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  125|     70|    events->conference_peer_list_changed_size = 0;
  126|     70|    events->conference_peer_list_changed_capacity = 0;
  127|     70|}
tox_events_get_conference_peer_list_changed_size:
  130|   654k|{
  131|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (131:9): [True: 653k, False: 630]
  ------------------
  132|   653k|        return 0;
  133|   653k|    }
  134|       |
  135|    630|    return events->conference_peer_list_changed_size;
  136|   654k|}
tox_events_pack_conference_peer_list_changed:
  147|   290k|{
  148|   290k|    const uint32_t size = tox_events_get_conference_peer_list_changed_size(events);
  149|       |
  150|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (150:26): [True: 0, False: 290k]
  ------------------
  151|      0|        if (!tox_event_conference_peer_list_changed_pack(tox_events_get_conference_peer_list_changed(events, i), bp)) {
  ------------------
  |  Branch (151:13): [True: 0, False: 0]
  ------------------
  152|      0|            return false;
  153|      0|        }
  154|      0|    }
  155|   290k|    return true;
  156|   290k|}

tox_events_clear_conference_peer_name:
  168|     70|{
  169|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (169:9): [True: 0, False: 70]
  ------------------
  170|      0|        return;
  171|      0|    }
  172|       |
  173|     70|    for (uint32_t i = 0; i < events->conference_peer_name_size; ++i) {
  ------------------
  |  Branch (173:26): [True: 0, False: 70]
  ------------------
  174|      0|        tox_event_conference_peer_name_destruct(&events->conference_peer_name[i]);
  175|      0|    }
  176|       |
  177|     70|    free(events->conference_peer_name);
  178|     70|    events->conference_peer_name = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  179|     70|    events->conference_peer_name_size = 0;
  180|     70|    events->conference_peer_name_capacity = 0;
  181|     70|}
tox_events_get_conference_peer_name_size:
  184|   654k|{
  185|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (185:9): [True: 653k, False: 630]
  ------------------
  186|   653k|        return 0;
  187|   653k|    }
  188|       |
  189|    630|    return events->conference_peer_name_size;
  190|   654k|}
tox_events_pack_conference_peer_name:
  200|   290k|{
  201|   290k|    const uint32_t size = tox_events_get_conference_peer_name_size(events);
  202|       |
  203|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (203:26): [True: 0, False: 290k]
  ------------------
  204|      0|        if (!tox_event_conference_peer_name_pack(tox_events_get_conference_peer_name(events, i), bp)) {
  ------------------
  |  Branch (204:13): [True: 0, False: 0]
  ------------------
  205|      0|            return false;
  206|      0|        }
  207|      0|    }
  208|   290k|    return true;
  209|   290k|}

tox_events_clear_conference_title:
  166|     70|{
  167|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (167:9): [True: 0, False: 70]
  ------------------
  168|      0|        return;
  169|      0|    }
  170|       |
  171|     70|    for (uint32_t i = 0; i < events->conference_title_size; ++i) {
  ------------------
  |  Branch (171:26): [True: 0, False: 70]
  ------------------
  172|      0|        tox_event_conference_title_destruct(&events->conference_title[i]);
  173|      0|    }
  174|       |
  175|     70|    free(events->conference_title);
  176|     70|    events->conference_title = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  177|     70|    events->conference_title_size = 0;
  178|     70|    events->conference_title_capacity = 0;
  179|     70|}
tox_events_get_conference_title_size:
  182|   654k|{
  183|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (183:9): [True: 653k, False: 630]
  ------------------
  184|   653k|        return 0;
  185|   653k|    }
  186|       |
  187|    630|    return events->conference_title_size;
  188|   654k|}
tox_events_pack_conference_title:
  198|   290k|{
  199|   290k|    const uint32_t size = tox_events_get_conference_title_size(events);
  200|       |
  201|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (201:26): [True: 0, False: 290k]
  ------------------
  202|      0|        if (!tox_event_conference_title_pack(tox_events_get_conference_title(events, i), bp)) {
  ------------------
  |  Branch (202:13): [True: 0, False: 0]
  ------------------
  203|      0|            return false;
  204|      0|        }
  205|      0|    }
  206|   290k|    return true;
  207|   290k|}

tox_events_alloc:
   13|    128|{
   14|    128|    Tox_Events_State *state = (Tox_Events_State *)user_data;
   15|    128|    assert(state != nullptr);
   16|       |
   17|    128|    if (state->events != nullptr) {
  ------------------
  |  |   66|    128|#define nullptr NULL
  ------------------
  |  Branch (17:9): [True: 58, False: 70]
  ------------------
   18|       |        // Already allocated.
   19|     58|        return state;
   20|     58|    }
   21|       |
   22|     70|    state->events = (Tox_Events *)calloc(1, sizeof(Tox_Events));
   23|       |
   24|     70|    if (state->events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (24:9): [True: 0, False: 70]
  ------------------
   25|       |        // It's still null => allocation failed.
   26|      0|        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
   27|     70|    } else {
   28|     70|        *state->events = (Tox_Events) {
   29|     70|            nullptr
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
   30|     70|        };
   31|     70|    }
   32|       |
   33|     70|    return state;
   34|    128|}
tox_events_free:
   37|  72.6k|{
   38|  72.6k|    if (events == nullptr) {
  ------------------
  |  |   66|  72.6k|#define nullptr NULL
  ------------------
  |  Branch (38:9): [True: 72.6k, False: 70]
  ------------------
   39|  72.6k|        return;
   40|  72.6k|    }
   41|       |
   42|     70|    tox_events_clear_conference_connected(events);
   43|     70|    tox_events_clear_conference_invite(events);
   44|     70|    tox_events_clear_conference_message(events);
   45|     70|    tox_events_clear_conference_peer_list_changed(events);
   46|     70|    tox_events_clear_conference_peer_name(events);
   47|     70|    tox_events_clear_conference_title(events);
   48|     70|    tox_events_clear_file_chunk_request(events);
   49|     70|    tox_events_clear_file_recv_chunk(events);
   50|     70|    tox_events_clear_file_recv_control(events);
   51|     70|    tox_events_clear_file_recv(events);
   52|     70|    tox_events_clear_friend_connection_status(events);
   53|     70|    tox_events_clear_friend_lossless_packet(events);
   54|     70|    tox_events_clear_friend_lossy_packet(events);
   55|     70|    tox_events_clear_friend_message(events);
   56|     70|    tox_events_clear_friend_name(events);
   57|     70|    tox_events_clear_friend_read_receipt(events);
   58|     70|    tox_events_clear_friend_request(events);
   59|     70|    tox_events_clear_friend_status(events);
   60|     70|    tox_events_clear_friend_status_message(events);
   61|     70|    tox_events_clear_friend_typing(events);
   62|     70|    tox_events_clear_self_connection_status(events);
   63|     70|    free(events);
   64|     70|}

tox_events_clear_file_chunk_request:
  160|     70|{
  161|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (161:9): [True: 0, False: 70]
  ------------------
  162|      0|        return;
  163|      0|    }
  164|       |
  165|     70|    for (uint32_t i = 0; i < events->file_chunk_request_size; ++i) {
  ------------------
  |  Branch (165:26): [True: 0, False: 70]
  ------------------
  166|      0|        tox_event_file_chunk_request_destruct(&events->file_chunk_request[i]);
  167|      0|    }
  168|       |
  169|     70|    free(events->file_chunk_request);
  170|     70|    events->file_chunk_request = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  171|     70|    events->file_chunk_request_size = 0;
  172|     70|    events->file_chunk_request_capacity = 0;
  173|     70|}
tox_events_get_file_chunk_request_size:
  176|   654k|{
  177|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (177:9): [True: 653k, False: 630]
  ------------------
  178|   653k|        return 0;
  179|   653k|    }
  180|       |
  181|    630|    return events->file_chunk_request_size;
  182|   654k|}
tox_events_pack_file_chunk_request:
  192|   290k|{
  193|   290k|    const uint32_t size = tox_events_get_file_chunk_request_size(events);
  194|       |
  195|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (195:26): [True: 0, False: 290k]
  ------------------
  196|      0|        if (!tox_event_file_chunk_request_pack(tox_events_get_file_chunk_request(events, i), bp)) {
  ------------------
  |  Branch (196:13): [True: 0, False: 0]
  ------------------
  197|      0|            return false;
  198|      0|        }
  199|      0|    }
  200|   290k|    return true;
  201|   290k|}

tox_events_clear_file_recv:
  198|     70|{
  199|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (199:9): [True: 0, False: 70]
  ------------------
  200|      0|        return;
  201|      0|    }
  202|       |
  203|     70|    for (uint32_t i = 0; i < events->file_recv_size; ++i) {
  ------------------
  |  Branch (203:26): [True: 0, False: 70]
  ------------------
  204|      0|        tox_event_file_recv_destruct(&events->file_recv[i]);
  205|      0|    }
  206|       |
  207|     70|    free(events->file_recv);
  208|     70|    events->file_recv = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  209|     70|    events->file_recv_size = 0;
  210|     70|    events->file_recv_capacity = 0;
  211|     70|}
tox_events_get_file_recv_size:
  214|   654k|{
  215|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (215:9): [True: 653k, False: 630]
  ------------------
  216|   653k|        return 0;
  217|   653k|    }
  218|       |
  219|    630|    return events->file_recv_size;
  220|   654k|}
tox_events_pack_file_recv:
  230|   290k|{
  231|   290k|    const uint32_t size = tox_events_get_file_recv_size(events);
  232|       |
  233|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (233:26): [True: 0, False: 290k]
  ------------------
  234|      0|        if (!tox_event_file_recv_pack(tox_events_get_file_recv(events, i), bp)) {
  ------------------
  |  Branch (234:13): [True: 0, False: 0]
  ------------------
  235|      0|            return false;
  236|      0|        }
  237|      0|    }
  238|   290k|    return true;
  239|   290k|}

tox_events_clear_file_recv_chunk:
  182|     70|{
  183|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (183:9): [True: 0, False: 70]
  ------------------
  184|      0|        return;
  185|      0|    }
  186|       |
  187|     70|    for (uint32_t i = 0; i < events->file_recv_chunk_size; ++i) {
  ------------------
  |  Branch (187:26): [True: 0, False: 70]
  ------------------
  188|      0|        tox_event_file_recv_chunk_destruct(&events->file_recv_chunk[i]);
  189|      0|    }
  190|       |
  191|     70|    free(events->file_recv_chunk);
  192|     70|    events->file_recv_chunk = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  193|     70|    events->file_recv_chunk_size = 0;
  194|     70|    events->file_recv_chunk_capacity = 0;
  195|     70|}
tox_events_get_file_recv_chunk_size:
  198|   654k|{
  199|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (199:9): [True: 653k, False: 630]
  ------------------
  200|   653k|        return 0;
  201|   653k|    }
  202|       |
  203|    630|    return events->file_recv_chunk_size;
  204|   654k|}
tox_events_pack_file_recv_chunk:
  214|   290k|{
  215|   290k|    const uint32_t size = tox_events_get_file_recv_chunk_size(events);
  216|       |
  217|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (217:26): [True: 0, False: 290k]
  ------------------
  218|      0|        if (!tox_event_file_recv_chunk_pack(tox_events_get_file_recv_chunk(events, i), bp)) {
  ------------------
  |  Branch (218:13): [True: 0, False: 0]
  ------------------
  219|      0|            return false;
  220|      0|        }
  221|      0|    }
  222|   290k|    return true;
  223|   290k|}

tox_events_clear_file_recv_control:
  146|     70|{
  147|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (147:9): [True: 0, False: 70]
  ------------------
  148|      0|        return;
  149|      0|    }
  150|       |
  151|     70|    for (uint32_t i = 0; i < events->file_recv_control_size; ++i) {
  ------------------
  |  Branch (151:26): [True: 0, False: 70]
  ------------------
  152|      0|        tox_event_file_recv_control_destruct(&events->file_recv_control[i]);
  153|      0|    }
  154|       |
  155|     70|    free(events->file_recv_control);
  156|     70|    events->file_recv_control = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  157|     70|    events->file_recv_control_size = 0;
  158|     70|    events->file_recv_control_capacity = 0;
  159|     70|}
tox_events_get_file_recv_control_size:
  162|   654k|{
  163|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (163:9): [True: 653k, False: 630]
  ------------------
  164|   653k|        return 0;
  165|   653k|    }
  166|       |
  167|    630|    return events->file_recv_control_size;
  168|   654k|}
tox_events_pack_file_recv_control:
  178|   290k|{
  179|   290k|    const uint32_t size = tox_events_get_file_recv_control_size(events);
  180|       |
  181|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (181:26): [True: 0, False: 290k]
  ------------------
  182|      0|        if (!tox_event_file_recv_control_pack(tox_events_get_file_recv_control(events, i), bp)) {
  ------------------
  |  Branch (182:13): [True: 0, False: 0]
  ------------------
  183|      0|            return false;
  184|      0|        }
  185|      0|    }
  186|   290k|    return true;
  187|   290k|}

tox_events_clear_friend_connection_status:
  133|     70|{
  134|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (134:9): [True: 0, False: 70]
  ------------------
  135|      0|        return;
  136|      0|    }
  137|       |
  138|     70|    for (uint32_t i = 0; i < events->friend_connection_status_size; ++i) {
  ------------------
  |  Branch (138:26): [True: 0, False: 70]
  ------------------
  139|      0|        tox_event_friend_connection_status_destruct(&events->friend_connection_status[i]);
  140|      0|    }
  141|       |
  142|     70|    free(events->friend_connection_status);
  143|     70|    events->friend_connection_status = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  144|     70|    events->friend_connection_status_size = 0;
  145|     70|    events->friend_connection_status_capacity = 0;
  146|     70|}
tox_events_get_friend_connection_status_size:
  149|   654k|{
  150|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (150:9): [True: 653k, False: 630]
  ------------------
  151|   653k|        return 0;
  152|   653k|    }
  153|       |
  154|    630|    return events->friend_connection_status_size;
  155|   654k|}
tox_events_pack_friend_connection_status:
  166|   290k|{
  167|   290k|    const uint32_t size = tox_events_get_friend_connection_status_size(events);
  168|       |
  169|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (169:26): [True: 0, False: 290k]
  ------------------
  170|      0|        if (!tox_event_friend_connection_status_pack(tox_events_get_friend_connection_status(events, i), bp)) {
  ------------------
  |  Branch (170:13): [True: 0, False: 0]
  ------------------
  171|      0|            return false;
  172|      0|        }
  173|      0|    }
  174|   290k|    return true;
  175|   290k|}

tox_events_clear_friend_lossless_packet:
  152|     70|{
  153|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (153:9): [True: 0, False: 70]
  ------------------
  154|      0|        return;
  155|      0|    }
  156|       |
  157|     70|    for (uint32_t i = 0; i < events->friend_lossless_packet_size; ++i) {
  ------------------
  |  Branch (157:26): [True: 0, False: 70]
  ------------------
  158|      0|        tox_event_friend_lossless_packet_destruct(&events->friend_lossless_packet[i]);
  159|      0|    }
  160|       |
  161|     70|    free(events->friend_lossless_packet);
  162|     70|    events->friend_lossless_packet = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  163|     70|    events->friend_lossless_packet_size = 0;
  164|     70|    events->friend_lossless_packet_capacity = 0;
  165|     70|}
tox_events_get_friend_lossless_packet_size:
  168|   654k|{
  169|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (169:9): [True: 653k, False: 630]
  ------------------
  170|   653k|        return 0;
  171|   653k|    }
  172|       |
  173|    630|    return events->friend_lossless_packet_size;
  174|   654k|}
tox_events_pack_friend_lossless_packet:
  184|   290k|{
  185|   290k|    const uint32_t size = tox_events_get_friend_lossless_packet_size(events);
  186|       |
  187|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (187:26): [True: 0, False: 290k]
  ------------------
  188|      0|        if (!tox_event_friend_lossless_packet_pack(tox_events_get_friend_lossless_packet(events, i), bp)) {
  ------------------
  |  Branch (188:13): [True: 0, False: 0]
  ------------------
  189|      0|            return false;
  190|      0|        }
  191|      0|    }
  192|   290k|    return true;
  193|   290k|}

tox_events_clear_friend_lossy_packet:
  151|     70|{
  152|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (152:9): [True: 0, False: 70]
  ------------------
  153|      0|        return;
  154|      0|    }
  155|       |
  156|     70|    for (uint32_t i = 0; i < events->friend_lossy_packet_size; ++i) {
  ------------------
  |  Branch (156:26): [True: 0, False: 70]
  ------------------
  157|      0|        tox_event_friend_lossy_packet_destruct(&events->friend_lossy_packet[i]);
  158|      0|    }
  159|       |
  160|     70|    free(events->friend_lossy_packet);
  161|     70|    events->friend_lossy_packet = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  162|     70|    events->friend_lossy_packet_size = 0;
  163|     70|    events->friend_lossy_packet_capacity = 0;
  164|     70|}
tox_events_get_friend_lossy_packet_size:
  167|   654k|{
  168|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (168:9): [True: 653k, False: 630]
  ------------------
  169|   653k|        return 0;
  170|   653k|    }
  171|       |
  172|    630|    return events->friend_lossy_packet_size;
  173|   654k|}
tox_events_pack_friend_lossy_packet:
  183|   290k|{
  184|   290k|    const uint32_t size = tox_events_get_friend_lossy_packet_size(events);
  185|       |
  186|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (186:26): [True: 0, False: 290k]
  ------------------
  187|      0|        if (!tox_event_friend_lossy_packet_pack(tox_events_get_friend_lossy_packet(events, i), bp)) {
  ------------------
  |  Branch (187:13): [True: 0, False: 0]
  ------------------
  188|      0|            return false;
  189|      0|        }
  190|      0|    }
  191|   290k|    return true;
  192|   290k|}

tox_events_clear_friend_message:
  166|     70|{
  167|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (167:9): [True: 0, False: 70]
  ------------------
  168|      0|        return;
  169|      0|    }
  170|       |
  171|     70|    for (uint32_t i = 0; i < events->friend_message_size; ++i) {
  ------------------
  |  Branch (171:26): [True: 0, False: 70]
  ------------------
  172|      0|        tox_event_friend_message_destruct(&events->friend_message[i]);
  173|      0|    }
  174|       |
  175|     70|    free(events->friend_message);
  176|     70|    events->friend_message = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  177|     70|    events->friend_message_size = 0;
  178|     70|    events->friend_message_capacity = 0;
  179|     70|}
tox_events_get_friend_message_size:
  182|   654k|{
  183|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (183:9): [True: 653k, False: 630]
  ------------------
  184|   653k|        return 0;
  185|   653k|    }
  186|       |
  187|    630|    return events->friend_message_size;
  188|   654k|}
tox_events_pack_friend_message:
  198|   290k|{
  199|   290k|    const uint32_t size = tox_events_get_friend_message_size(events);
  200|       |
  201|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (201:26): [True: 0, False: 290k]
  ------------------
  202|      0|        if (!tox_event_friend_message_pack(tox_events_get_friend_message(events, i), bp)) {
  ------------------
  |  Branch (202:13): [True: 0, False: 0]
  ------------------
  203|      0|            return false;
  204|      0|        }
  205|      0|    }
  206|   290k|    return true;
  207|   290k|}

tox_events_clear_friend_name:
  150|     70|{
  151|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (151:9): [True: 0, False: 70]
  ------------------
  152|      0|        return;
  153|      0|    }
  154|       |
  155|     70|    for (uint32_t i = 0; i < events->friend_name_size; ++i) {
  ------------------
  |  Branch (155:26): [True: 0, False: 70]
  ------------------
  156|      0|        tox_event_friend_name_destruct(&events->friend_name[i]);
  157|      0|    }
  158|       |
  159|     70|    free(events->friend_name);
  160|     70|    events->friend_name = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  161|     70|    events->friend_name_size = 0;
  162|     70|    events->friend_name_capacity = 0;
  163|     70|}
tox_events_get_friend_name_size:
  166|   654k|{
  167|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (167:9): [True: 653k, False: 630]
  ------------------
  168|   653k|        return 0;
  169|   653k|    }
  170|       |
  171|    630|    return events->friend_name_size;
  172|   654k|}
tox_events_pack_friend_name:
  182|   290k|{
  183|   290k|    const uint32_t size = tox_events_get_friend_name_size(events);
  184|       |
  185|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (185:26): [True: 0, False: 290k]
  ------------------
  186|      0|        if (!tox_event_friend_name_pack(tox_events_get_friend_name(events, i), bp)) {
  ------------------
  |  Branch (186:13): [True: 0, False: 0]
  ------------------
  187|      0|            return false;
  188|      0|        }
  189|      0|    }
  190|   290k|    return true;
  191|   290k|}

tox_events_clear_friend_read_receipt:
  130|     70|{
  131|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (131:9): [True: 0, False: 70]
  ------------------
  132|      0|        return;
  133|      0|    }
  134|       |
  135|     70|    for (uint32_t i = 0; i < events->friend_read_receipt_size; ++i) {
  ------------------
  |  Branch (135:26): [True: 0, False: 70]
  ------------------
  136|      0|        tox_event_friend_read_receipt_destruct(&events->friend_read_receipt[i]);
  137|      0|    }
  138|       |
  139|     70|    free(events->friend_read_receipt);
  140|     70|    events->friend_read_receipt = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  141|     70|    events->friend_read_receipt_size = 0;
  142|     70|    events->friend_read_receipt_capacity = 0;
  143|     70|}
tox_events_get_friend_read_receipt_size:
  146|   654k|{
  147|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (147:9): [True: 653k, False: 630]
  ------------------
  148|   653k|        return 0;
  149|   653k|    }
  150|       |
  151|    630|    return events->friend_read_receipt_size;
  152|   654k|}
tox_events_pack_friend_read_receipt:
  162|   290k|{
  163|   290k|    const uint32_t size = tox_events_get_friend_read_receipt_size(events);
  164|       |
  165|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (165:26): [True: 0, False: 290k]
  ------------------
  166|      0|        if (!tox_event_friend_read_receipt_pack(tox_events_get_friend_read_receipt(events, i), bp)) {
  ------------------
  |  Branch (166:13): [True: 0, False: 0]
  ------------------
  167|      0|            return false;
  168|      0|        }
  169|      0|    }
  170|   290k|    return true;
  171|   290k|}

tox_event_friend_request_get_public_key:
   53|    128|{
   54|    128|    assert(friend_request != nullptr);
   55|      0|    return friend_request->public_key;
   56|    128|}
tox_events_clear_friend_request:
  151|     70|{
  152|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (152:9): [True: 0, False: 70]
  ------------------
  153|      0|        return;
  154|      0|    }
  155|       |
  156|    198|    for (uint32_t i = 0; i < events->friend_request_size; ++i) {
  ------------------
  |  Branch (156:26): [True: 128, False: 70]
  ------------------
  157|    128|        tox_event_friend_request_destruct(&events->friend_request[i]);
  158|    128|    }
  159|       |
  160|     70|    free(events->friend_request);
  161|     70|    events->friend_request = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  162|     70|    events->friend_request_size = 0;
  163|     70|    events->friend_request_capacity = 0;
  164|     70|}
tox_events_get_friend_request_size:
  167|   654k|{
  168|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (168:9): [True: 653k, False: 630]
  ------------------
  169|   653k|        return 0;
  170|   653k|    }
  171|       |
  172|    630|    return events->friend_request_size;
  173|   654k|}
tox_events_get_friend_request:
  176|    640|{
  177|    640|    assert(index < events->friend_request_size);
  178|      0|    assert(events->friend_request != nullptr);
  179|      0|    return &events->friend_request[index];
  180|    640|}
tox_events_pack_friend_request:
  183|   290k|{
  184|   290k|    const uint32_t size = tox_events_get_friend_request_size(events);
  185|       |
  186|   291k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (186:26): [True: 512, False: 290k]
  ------------------
  187|    512|        if (!tox_event_friend_request_pack(tox_events_get_friend_request(events, i), bp)) {
  ------------------
  |  Branch (187:13): [True: 0, False: 512]
  ------------------
  188|      0|            return false;
  189|      0|        }
  190|    512|    }
  191|   290k|    return true;
  192|   290k|}
tox_events_handle_friend_request:
  215|    128|{
  216|    128|    Tox_Events_State *state = tox_events_alloc(user_data);
  217|    128|    assert(state != nullptr);
  218|       |
  219|    128|    if (state->events == nullptr) {
  ------------------
  |  |   66|    128|#define nullptr NULL
  ------------------
  |  Branch (219:9): [True: 0, False: 128]
  ------------------
  220|      0|        return;
  221|      0|    }
  222|       |
  223|    128|    Tox_Event_Friend_Request *friend_request = tox_events_add_friend_request(state->events);
  224|       |
  225|    128|    if (friend_request == nullptr) {
  ------------------
  |  |   66|    128|#define nullptr NULL
  ------------------
  |  Branch (225:9): [True: 0, False: 128]
  ------------------
  226|      0|        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
  227|      0|        return;
  228|      0|    }
  229|       |
  230|    128|    tox_event_friend_request_set_public_key(friend_request, public_key);
  231|    128|    tox_event_friend_request_set_message(friend_request, message, length);
  232|    128|}
friend_request.c:tox_event_friend_request_destruct:
   40|    128|{
   41|    128|    free(friend_request->message);
   42|    128|}
friend_request.c:tox_event_friend_request_pack:
   94|    512|{
   95|    512|    assert(event != nullptr);
   96|    512|    return bin_pack_array(bp, 2)
  ------------------
  |  Branch (96:12): [True: 512, False: 0]
  ------------------
   97|    512|           && bin_pack_u32(bp, TOX_EVENT_FRIEND_REQUEST)
  ------------------
  |  Branch (97:15): [True: 512, False: 0]
  ------------------
   98|    512|           && bin_pack_array(bp, 2)
  ------------------
  |  Branch (98:15): [True: 512, False: 0]
  ------------------
   99|    512|           && bin_pack_bin(bp, event->public_key, TOX_PUBLIC_KEY_SIZE)
  ------------------
  |  |  217|    512|#define TOX_PUBLIC_KEY_SIZE            32
  ------------------
  |  Branch (99:15): [True: 512, False: 0]
  ------------------
  100|    512|           && bin_pack_bin(bp, event->message, event->message_length);
  ------------------
  |  Branch (100:15): [True: 512, False: 0]
  ------------------
  101|    512|}
friend_request.c:tox_events_add_friend_request:
  126|    128|{
  127|    128|    if (events->friend_request_size == UINT32_MAX) {
  ------------------
  |  Branch (127:9): [True: 0, False: 128]
  ------------------
  128|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  129|      0|    }
  130|       |
  131|    128|    if (events->friend_request_size == events->friend_request_capacity) {
  ------------------
  |  Branch (131:9): [True: 120, False: 8]
  ------------------
  132|    120|        const uint32_t new_friend_request_capacity = events->friend_request_capacity * 2 + 1;
  133|    120|        Tox_Event_Friend_Request *new_friend_request = (Tox_Event_Friend_Request *)realloc(
  134|    120|                    events->friend_request, new_friend_request_capacity * sizeof(Tox_Event_Friend_Request));
  135|       |
  136|    120|        if (new_friend_request == nullptr) {
  ------------------
  |  |   66|    120|#define nullptr NULL
  ------------------
  |  Branch (136:13): [True: 0, False: 120]
  ------------------
  137|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  138|      0|        }
  139|       |
  140|    120|        events->friend_request = new_friend_request;
  141|    120|        events->friend_request_capacity = new_friend_request_capacity;
  142|    120|    }
  143|       |
  144|    128|    Tox_Event_Friend_Request *const friend_request = &events->friend_request[events->friend_request_size];
  145|    128|    tox_event_friend_request_construct(friend_request);
  146|    128|    ++events->friend_request_size;
  147|    128|    return friend_request;
  148|    128|}
friend_request.c:tox_event_friend_request_construct:
   33|    128|{
   34|    128|    *friend_request = (Tox_Event_Friend_Request) {
   35|    128|        0
   36|    128|    };
   37|    128|}
friend_request.c:tox_event_friend_request_set_public_key:
   46|    128|{
   47|    128|    assert(friend_request != nullptr);
   48|       |
   49|    128|    memcpy(friend_request->public_key, public_key, TOX_PUBLIC_KEY_SIZE);
  ------------------
  |  |  217|    128|#define TOX_PUBLIC_KEY_SIZE            32
  ------------------
   50|    128|    return true;
   51|    128|}
friend_request.c:tox_event_friend_request_set_message:
   61|    128|{
   62|    128|    assert(friend_request != nullptr);
   63|       |
   64|    128|    if (friend_request->message != nullptr) {
  ------------------
  |  |   66|    128|#define nullptr NULL
  ------------------
  |  Branch (64:9): [True: 0, False: 128]
  ------------------
   65|      0|        free(friend_request->message);
   66|      0|        friend_request->message = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   67|      0|        friend_request->message_length = 0;
   68|      0|    }
   69|       |
   70|    128|    friend_request->message = (uint8_t *)malloc(message_length);
   71|       |
   72|    128|    if (friend_request->message == nullptr) {
  ------------------
  |  |   66|    128|#define nullptr NULL
  ------------------
  |  Branch (72:9): [True: 0, False: 128]
  ------------------
   73|      0|        return false;
   74|      0|    }
   75|       |
   76|    128|    memcpy(friend_request->message, message, message_length);
   77|    128|    friend_request->message_length = message_length;
   78|    128|    return true;
   79|    128|}

tox_events_clear_friend_status:
  130|     70|{
  131|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (131:9): [True: 0, False: 70]
  ------------------
  132|      0|        return;
  133|      0|    }
  134|       |
  135|     70|    for (uint32_t i = 0; i < events->friend_status_size; ++i) {
  ------------------
  |  Branch (135:26): [True: 0, False: 70]
  ------------------
  136|      0|        tox_event_friend_status_destruct(&events->friend_status[i]);
  137|      0|    }
  138|       |
  139|     70|    free(events->friend_status);
  140|     70|    events->friend_status = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  141|     70|    events->friend_status_size = 0;
  142|     70|    events->friend_status_capacity = 0;
  143|     70|}
tox_events_get_friend_status_size:
  146|   654k|{
  147|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (147:9): [True: 653k, False: 630]
  ------------------
  148|   653k|        return 0;
  149|   653k|    }
  150|       |
  151|    630|    return events->friend_status_size;
  152|   654k|}
tox_events_pack_friend_status:
  162|   290k|{
  163|   290k|    const uint32_t size = tox_events_get_friend_status_size(events);
  164|       |
  165|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (165:26): [True: 0, False: 290k]
  ------------------
  166|      0|        if (!tox_event_friend_status_pack(tox_events_get_friend_status(events, i), bp)) {
  ------------------
  |  Branch (166:13): [True: 0, False: 0]
  ------------------
  167|      0|            return false;
  168|      0|        }
  169|      0|    }
  170|   290k|    return true;
  171|   290k|}

tox_events_clear_friend_status_message:
  153|     70|{
  154|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (154:9): [True: 0, False: 70]
  ------------------
  155|      0|        return;
  156|      0|    }
  157|       |
  158|     70|    for (uint32_t i = 0; i < events->friend_status_message_size; ++i) {
  ------------------
  |  Branch (158:26): [True: 0, False: 70]
  ------------------
  159|      0|        tox_event_friend_status_message_destruct(&events->friend_status_message[i]);
  160|      0|    }
  161|       |
  162|     70|    free(events->friend_status_message);
  163|     70|    events->friend_status_message = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  164|     70|    events->friend_status_message_size = 0;
  165|     70|    events->friend_status_message_capacity = 0;
  166|     70|}
tox_events_get_friend_status_message_size:
  169|   654k|{
  170|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (170:9): [True: 653k, False: 630]
  ------------------
  171|   653k|        return 0;
  172|   653k|    }
  173|       |
  174|    630|    return events->friend_status_message_size;
  175|   654k|}
tox_events_pack_friend_status_message:
  185|   290k|{
  186|   290k|    const uint32_t size = tox_events_get_friend_status_message_size(events);
  187|       |
  188|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (188:26): [True: 0, False: 290k]
  ------------------
  189|      0|        if (!tox_event_friend_status_message_pack(tox_events_get_friend_status_message(events, i), bp)) {
  ------------------
  |  Branch (189:13): [True: 0, False: 0]
  ------------------
  190|      0|            return false;
  191|      0|        }
  192|      0|    }
  193|   290k|    return true;
  194|   290k|}

tox_events_clear_friend_typing:
  128|     70|{
  129|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (129:9): [True: 0, False: 70]
  ------------------
  130|      0|        return;
  131|      0|    }
  132|       |
  133|     70|    for (uint32_t i = 0; i < events->friend_typing_size; ++i) {
  ------------------
  |  Branch (133:26): [True: 0, False: 70]
  ------------------
  134|      0|        tox_event_friend_typing_destruct(&events->friend_typing[i]);
  135|      0|    }
  136|       |
  137|     70|    free(events->friend_typing);
  138|     70|    events->friend_typing = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  139|     70|    events->friend_typing_size = 0;
  140|     70|    events->friend_typing_capacity = 0;
  141|     70|}
tox_events_get_friend_typing_size:
  144|   654k|{
  145|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (145:9): [True: 653k, False: 630]
  ------------------
  146|   653k|        return 0;
  147|   653k|    }
  148|       |
  149|    630|    return events->friend_typing_size;
  150|   654k|}
tox_events_pack_friend_typing:
  160|   290k|{
  161|   290k|    const uint32_t size = tox_events_get_friend_typing_size(events);
  162|       |
  163|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (163:26): [True: 0, False: 290k]
  ------------------
  164|      0|        if (!tox_event_friend_typing_pack(tox_events_get_friend_typing(events, i), bp)) {
  ------------------
  |  Branch (164:13): [True: 0, False: 0]
  ------------------
  165|      0|            return false;
  166|      0|        }
  167|      0|    }
  168|   290k|    return true;
  169|   290k|}

tox_events_clear_self_connection_status:
  111|     70|{
  112|     70|    if (events == nullptr) {
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  |  Branch (112:9): [True: 0, False: 70]
  ------------------
  113|      0|        return;
  114|      0|    }
  115|       |
  116|     70|    for (uint32_t i = 0; i < events->self_connection_status_size; ++i) {
  ------------------
  |  Branch (116:26): [True: 0, False: 70]
  ------------------
  117|      0|        tox_event_self_connection_status_destruct(&events->self_connection_status[i]);
  118|      0|    }
  119|       |
  120|     70|    free(events->self_connection_status);
  121|     70|    events->self_connection_status = nullptr;
  ------------------
  |  |   66|     70|#define nullptr NULL
  ------------------
  122|     70|    events->self_connection_status_size = 0;
  123|     70|    events->self_connection_status_capacity = 0;
  124|     70|}
tox_events_get_self_connection_status_size:
  127|   654k|{
  128|   654k|    if (events == nullptr) {
  ------------------
  |  |   66|   654k|#define nullptr NULL
  ------------------
  |  Branch (128:9): [True: 653k, False: 630]
  ------------------
  129|   653k|        return 0;
  130|   653k|    }
  131|       |
  132|    630|    return events->self_connection_status_size;
  133|   654k|}
tox_events_pack_self_connection_status:
  143|   290k|{
  144|   290k|    const uint32_t size = tox_events_get_self_connection_status_size(events);
  145|       |
  146|   290k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (146:26): [True: 0, False: 290k]
  ------------------
  147|      0|        if (!tox_event_self_connection_status_pack(tox_events_get_self_connection_status(events, i), bp)) {
  ------------------
  |  Branch (147:13): [True: 0, False: 0]
  ------------------
  148|      0|            return false;
  149|      0|        }
  150|      0|    }
  151|   290k|    return true;
  152|   290k|}

forwarding_get_dht:
   35|    946|{
   36|    946|    return forwarding->dht;
   37|    946|}
send_forwarding:
  127|      2|{
  128|      2|    if (length > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   20|      2|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   98|      2|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   19|      2|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (128:9): [True: 0, False: 2]
  ------------------
  129|      0|        return false;
  130|      0|    }
  131|       |
  132|      2|    const uint16_t len = forwarding_packet_length(sendback_data_len, length);
  133|      2|    VLA(uint8_t, packet, len);
  ------------------
  |  |   62|      2|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      2|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  134|      2|    create_forwarding_packet(forwarding, sendback_data, sendback_data_len, data, length, packet);
  135|      2|    return sendpacket(forwarding->net, dest, packet, len) == len;
  136|      2|}
set_callback_forwarded_request:
  338|  1.88k|{
  339|  1.88k|    forwarding->forwarded_request_callback = function;
  340|  1.88k|    forwarding->forwarded_request_callback_object = object;
  341|  1.88k|}
set_callback_forward_reply:
  350|    290|{
  351|    290|    forwarding->forward_reply_callback = function;
  352|    290|    forwarding->forward_reply_callback_object = object;
  353|    290|}
new_forwarding:
  356|    946|{
  357|    946|    if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   66|  1.89k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   66|  1.89k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (357:9): [True: 0, False: 946]
  |  Branch (357:27): [True: 0, False: 946]
  |  Branch (357:51): [True: 0, False: 946]
  ------------------
  358|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  359|      0|    }
  360|       |
  361|    946|    Forwarding *forwarding = (Forwarding *)calloc(1, sizeof(Forwarding));
  362|       |
  363|    946|    if (forwarding == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (363:9): [True: 0, False: 946]
  ------------------
  364|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  365|      0|    }
  366|       |
  367|    946|    forwarding->log = log;
  368|    946|    forwarding->rng = rng;
  369|    946|    forwarding->mono_time = mono_time;
  370|    946|    forwarding->dht = dht;
  371|    946|    forwarding->net = dht_get_net(dht);
  372|       |
  373|    946|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, &handle_forward_request, forwarding);
  374|    946|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, &handle_forward_reply, forwarding);
  375|    946|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, &handle_forwarding, forwarding);
  376|       |
  377|    946|    new_hmac_key(forwarding->rng, forwarding->hmac_key);
  378|       |
  379|    946|    return forwarding;
  380|    946|}
kill_forwarding:
  383|    946|{
  384|    946|    if (forwarding == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (384:9): [True: 0, False: 946]
  ------------------
  385|      0|        return;
  386|      0|    }
  387|       |
  388|    946|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  389|    946|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  390|    946|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  391|       |
  392|    946|    crypto_memzero(forwarding->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  136|    946|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  393|       |
  394|    946|    free(forwarding);
  395|    946|}
forwarding.c:forwarding_packet_length:
   86|     31|{
   87|     31|    const uint16_t sendback_len = sendback_data_len == 0 ? 0 : TIMED_AUTH_SIZE + sendback_data_len;
  ------------------
  |  |   10|     31|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     31|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  |  Branch (87:35): [True: 0, False: 31]
  ------------------
   88|     31|    return 1 + 1 + sendback_len + data_length;
   89|     31|}
forwarding.c:create_forwarding_packet:
   96|     31|{
   97|     31|    packet[0] = NET_PACKET_FORWARDING;
   98|       |
   99|     31|    if (sendback_data_len == 0) {
  ------------------
  |  Branch (99:9): [True: 0, False: 31]
  ------------------
  100|      0|        packet[1] = 0;
  101|      0|        memcpy(packet + 1 + 1, data, length);
  102|     31|    } else {
  103|     31|        const uint16_t sendback_len = TIMED_AUTH_SIZE + sendback_data_len;
  ------------------
  |  |   10|     31|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     31|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  104|       |
  105|     31|        if (sendback_len > MAX_SENDBACK_SIZE) {
  ------------------
  |  |   19|     31|#define MAX_SENDBACK_SIZE (0xff - 1)
  ------------------
  |  Branch (105:13): [True: 0, False: 31]
  ------------------
  106|      0|            return false;
  107|      0|        }
  108|       |
  109|     31|        packet[1] = sendback_len;
  110|     31|        generate_timed_auth(forwarding->mono_time, SENDBACK_TIMEOUT, forwarding->hmac_key, sendback_data,
  ------------------
  |  |   39|     31|#define SENDBACK_TIMEOUT 3600
  ------------------
  111|     31|                            sendback_data_len, packet + 1 + 1);
  112|       |
  113|     31|        if (sendback_data_len != 0) {
  ------------------
  |  Branch (113:13): [True: 31, False: 0]
  ------------------
  114|     31|            assert(sendback_data != nullptr);
  115|     31|            memcpy(packet + 1 + 1 + TIMED_AUTH_SIZE, sendback_data, sendback_data_len);
  ------------------
  |  |   10|     31|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     31|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  116|     31|        }
  117|       |
  118|      0|        memcpy(packet + 1 + 1 + sendback_len, data, length);
  119|     31|    }
  120|       |
  121|     31|    return true;
  122|     31|}
forwarding.c:handle_forward_request:
  170|     42|{
  171|     42|    const Forwarding *forwarding = (const Forwarding *)object;
  172|       |
  173|     42|    uint8_t sendback_data[1 + MAX_PACKED_IPPORT_SIZE];
  174|     42|    sendback_data[0] = SENDBACK_IPPORT;
  ------------------
  |  |   15|     42|#define SENDBACK_IPPORT 0
  ------------------
  175|       |
  176|     42|    const int ipport_length = pack_ip_port(forwarding->log, sendback_data + 1, MAX_PACKED_IPPORT_SIZE, source);
  ------------------
  |  |   24|     42|#define MAX_PACKED_IPPORT_SIZE (1 + SIZE_IP6 + sizeof(uint16_t))
  |  |  ------------------
  |  |  |  |  225|     42|#define SIZE_IP6 16
  |  |  ------------------
  ------------------
  177|       |
  178|     42|    if (ipport_length == -1) {
  ------------------
  |  Branch (178:9): [True: 0, False: 42]
  ------------------
  179|      0|        return 1;
  180|      0|    }
  181|       |
  182|     42|    return handle_forward_request_dht(forwarding, sendback_data, 1 + ipport_length, packet, length) ? 0 : 1;
  ------------------
  |  Branch (182:12): [True: 0, False: 42]
  ------------------
  183|     42|}
forwarding.c:handle_forward_request_dht:
  144|     44|{
  145|     44|    if (length < FORWARD_REQUEST_MIN_PACKET_SIZE) {
  ------------------
  |  |  138|     44|#define FORWARD_REQUEST_MIN_PACKET_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   40|     44|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (145:9): [True: 13, False: 31]
  ------------------
  146|     13|        return false;
  147|     13|    }
  148|       |
  149|     31|    const uint8_t *const public_key = packet + 1;
  150|     31|    const uint8_t *const forward_data = packet + (1 + CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|     31|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  151|     31|    const uint16_t forward_data_len = length - (1 + CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|     31|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  152|       |
  153|     31|    if (TIMED_AUTH_SIZE + sendback_data_len > MAX_SENDBACK_SIZE ||
  ------------------
  |  |   10|     31|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     31|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
                  if (TIMED_AUTH_SIZE + sendback_data_len > MAX_SENDBACK_SIZE ||
  ------------------
  |  |   19|     62|#define MAX_SENDBACK_SIZE (0xff - 1)
  ------------------
  |  Branch (153:9): [True: 1, False: 30]
  ------------------
  154|     31|            forward_data_len > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   20|     30|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   98|     30|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   19|     30|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (154:13): [True: 1, False: 29]
  ------------------
  155|      2|        return false;
  156|      2|    }
  157|       |
  158|     29|    const uint16_t len = forwarding_packet_length(sendback_data_len, forward_data_len);
  159|     29|    VLA(uint8_t, forwarding_packet, len);
  ------------------
  |  |   62|     29|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     29|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  160|       |
  161|     29|    create_forwarding_packet(forwarding, sendback_data, sendback_data_len, forward_data, forward_data_len,
  162|     29|                             forwarding_packet);
  163|       |
  164|     29|    return route_packet(forwarding->dht, public_key, forwarding_packet, len) == len;
  165|     31|}
forwarding.c:handle_forward_reply:
  191|     32|{
  192|     32|    const Forwarding *forwarding = (const Forwarding *)object;
  193|       |
  194|     32|    if (length < FORWARD_REPLY_MIN_PACKET_SIZE) {
  ------------------
  |  |  186|     32|#define FORWARD_REPLY_MIN_PACKET_SIZE (1 + 1 + MIN_NONEMPTY_SENDBACK_SIZE)
  |  |  ------------------
  |  |  |  |  185|     32|#define MIN_NONEMPTY_SENDBACK_SIZE TIMED_AUTH_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   10|     32|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  131|     32|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (194:9): [True: 6, False: 26]
  ------------------
  195|      6|        return 1;
  196|      6|    }
  197|       |
  198|     26|    const uint8_t sendback_len = packet[1];
  199|     26|    const uint8_t *const sendback_auth = packet + 1 + 1;
  200|     26|    const uint8_t *const sendback_data = sendback_auth + TIMED_AUTH_SIZE;
  ------------------
  |  |   10|     26|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     26|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  201|       |
  202|     26|    if (sendback_len > MAX_SENDBACK_SIZE) {
  ------------------
  |  |   19|     26|#define MAX_SENDBACK_SIZE (0xff - 1)
  ------------------
  |  Branch (202:9): [True: 3, False: 23]
  ------------------
  203|       |        /* value 0xff is reserved for possible future expansion */
  204|      3|        return 1;
  205|      3|    }
  206|       |
  207|     23|    if (sendback_len < TIMED_AUTH_SIZE + 1) {
  ------------------
  |  |   10|     23|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     23|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  |  Branch (207:9): [True: 10, False: 13]
  ------------------
  208|     10|        return 1;
  209|     10|    }
  210|       |
  211|     13|    const uint16_t sendback_data_len = sendback_len - TIMED_AUTH_SIZE;
  ------------------
  |  |   10|     13|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  ------------------
  |  |  |  |  131|     13|#define CRYPTO_HMAC_SIZE               32
  |  |  ------------------
  ------------------
  212|       |
  213|     13|    if (length < 1 + 1 + sendback_len) {
  ------------------
  |  Branch (213:9): [True: 10, False: 3]
  ------------------
  214|     10|        return 1;
  215|     10|    }
  216|       |
  217|      3|    const uint8_t *const to_forward = packet + (1 + 1 + sendback_len);
  218|      3|    const uint16_t to_forward_len = length - (1 + 1 + sendback_len);
  219|       |
  220|      3|    if (!check_timed_auth(forwarding->mono_time, SENDBACK_TIMEOUT, forwarding->hmac_key, sendback_data, sendback_data_len,
  ------------------
  |  |   39|      3|#define SENDBACK_TIMEOUT 3600
  ------------------
  |  Branch (220:9): [True: 3, False: 0]
  ------------------
  221|      3|                          sendback_auth)) {
  222|      3|        return 1;
  223|      3|    }
  224|       |
  225|      0|    if (sendback_data[0] == SENDBACK_IPPORT) {
  ------------------
  |  |   15|      0|#define SENDBACK_IPPORT 0
  ------------------
  |  Branch (225:9): [True: 0, False: 0]
  ------------------
  226|      0|        IP_Port dest;
  227|       |
  228|      0|        if (unpack_ip_port(&dest, sendback_data + 1, sendback_data_len - 1, false)
  ------------------
  |  Branch (228:13): [True: 0, False: 0]
  ------------------
  229|      0|                != sendback_data_len - 1) {
  230|      0|            return 1;
  231|      0|        }
  232|       |
  233|      0|        return send_forwarding(forwarding, &dest, nullptr, 0, to_forward, to_forward_len) ? 0 : 1;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (233:16): [True: 0, False: 0]
  ------------------
  234|      0|    }
  235|       |
  236|      0|    if (sendback_data[0] == SENDBACK_FORWARD) {
  ------------------
  |  |   16|      0|#define SENDBACK_FORWARD 1
  ------------------
  |  Branch (236:9): [True: 0, False: 0]
  ------------------
  237|      0|        IP_Port forwarder;
  238|      0|        const int ipport_length = unpack_ip_port(&forwarder, sendback_data + 1, sendback_data_len - 1, false);
  239|       |
  240|      0|        if (ipport_length == -1) {
  ------------------
  |  Branch (240:13): [True: 0, False: 0]
  ------------------
  241|      0|            return 1;
  242|      0|        }
  243|       |
  244|      0|        const uint8_t *const forward_sendback = sendback_data + (1 + ipport_length);
  245|      0|        const uint16_t forward_sendback_len = sendback_data_len - (1 + ipport_length);
  246|       |
  247|      0|        return forward_reply(forwarding->net, &forwarder, forward_sendback, forward_sendback_len, to_forward,
  ------------------
  |  Branch (247:16): [True: 0, False: 0]
  ------------------
  248|      0|                             to_forward_len) ? 0 : 1;
  249|      0|    }
  250|       |
  251|      0|    if (forwarding->forward_reply_callback == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (251:9): [True: 0, False: 0]
  ------------------
  252|      0|        return 1;
  253|      0|    }
  254|       |
  255|      0|    return forwarding->forward_reply_callback(forwarding->forward_reply_callback_object,
  ------------------
  |  Branch (255:12): [True: 0, False: 0]
  ------------------
  256|      0|            sendback_data, sendback_data_len,
  257|      0|            to_forward, to_forward_len) ? 0 : 1;
  258|      0|}
forwarding.c:handle_forwarding:
  265|    241|{
  266|    241|    const Forwarding *forwarding = (const Forwarding *)object;
  267|       |
  268|    241|    if (length < FORWARDING_MIN_PACKET_SIZE) {
  ------------------
  |  |  260|    241|#define FORWARDING_MIN_PACKET_SIZE (1 + 1)
  ------------------
  |  Branch (268:9): [True: 10, False: 231]
  ------------------
  269|     10|        return 1;
  270|     10|    }
  271|       |
  272|    231|    const uint8_t sendback_len = packet[1];
  273|       |
  274|    231|    if (length < 1 + 1 + sendback_len) {
  ------------------
  |  Branch (274:9): [True: 68, False: 163]
  ------------------
  275|     68|        return 1;
  276|     68|    }
  277|       |
  278|    163|    const uint8_t *const sendback = packet + 1 + 1;
  279|       |
  280|    163|    const uint8_t *const forwarded = sendback + sendback_len;
  281|    163|    const uint16_t forwarded_len = length - (1 + 1 + sendback_len);
  282|       |
  283|    163|    if (forwarded_len >= 1 && forwarded[0] == NET_PACKET_FORWARD_REQUEST) {
  ------------------
  |  Branch (283:9): [True: 45, False: 118]
  |  Branch (283:31): [True: 2, False: 43]
  ------------------
  284|      2|        VLA(uint8_t, sendback_data, 1 + MAX_PACKED_IPPORT_SIZE + sendback_len);
  ------------------
  |  |   62|      2|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      2|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  285|      2|        sendback_data[0] = SENDBACK_FORWARD;
  ------------------
  |  |   16|      2|#define SENDBACK_FORWARD 1
  ------------------
  286|       |
  287|      2|        const int ipport_length = pack_ip_port(forwarding->log, sendback_data + 1, MAX_PACKED_IPPORT_SIZE, source);
  ------------------
  |  |   24|      2|#define MAX_PACKED_IPPORT_SIZE (1 + SIZE_IP6 + sizeof(uint16_t))
  |  |  ------------------
  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  ------------------
  ------------------
  288|       |
  289|      2|        if (ipport_length == -1) {
  ------------------
  |  Branch (289:13): [True: 0, False: 2]
  ------------------
  290|      0|            return 1;
  291|      0|        }
  292|       |
  293|      2|        memcpy(sendback_data + 1 + ipport_length, sendback, sendback_len);
  294|       |
  295|      2|        return handle_forward_request_dht(forwarding, sendback_data, 1 + ipport_length + sendback_len, forwarded,
  ------------------
  |  Branch (295:16): [True: 0, False: 2]
  ------------------
  296|      2|                                          forwarded_len) ? 0 : 1;
  297|      2|    }
  298|       |
  299|    161|    if (sendback_len > 0) {
  ------------------
  |  Branch (299:9): [True: 7, False: 154]
  ------------------
  300|      7|        if (forwarding->forwarded_request_callback == nullptr) {
  ------------------
  |  |   66|      7|#define nullptr NULL
  ------------------
  |  Branch (300:13): [True: 0, False: 7]
  ------------------
  301|      0|            return 1;
  302|      0|        }
  303|       |
  304|      7|        forwarding->forwarded_request_callback(forwarding->forwarded_request_callback_object,
  305|      7|                                               source, sendback, sendback_len,
  306|      7|                                               forwarded, forwarded_len, userdata);
  307|      7|        return 0;
  308|    154|    } else {
  309|    154|        if (forwarding->forwarded_response_callback == nullptr) {
  ------------------
  |  |   66|    154|#define nullptr NULL
  ------------------
  |  Branch (309:13): [True: 154, False: 0]
  ------------------
  310|    154|            return 1;
  311|    154|        }
  312|       |
  313|      0|        forwarding->forwarded_response_callback(forwarding->forwarded_response_callback_object,
  314|      0|                                                forwarded, forwarded_len, userdata);
  315|      0|        return 0;
  316|    154|    }
  317|    161|}

get_conn:
  192|  2.80k|{
  193|  2.80k|    if (!friendconn_id_valid(fr_c, friendcon_id)) {
  ------------------
  |  Branch (193:9): [True: 0, False: 2.80k]
  ------------------
  194|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  195|      0|    }
  196|       |
  197|  2.80k|    return &fr_c->conns[friendcon_id];
  198|  2.80k|}
getfriend_conn_id_pk:
  205|    121|{
  206|    289|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (206:26): [True: 168, False: 121]
  ------------------
  207|    168|        const Friend_Conn *friend_con = get_conn(fr_c, i);
  208|       |
  209|    168|        if (friend_con != nullptr) {
  ------------------
  |  |   66|    168|#define nullptr NULL
  ------------------
  |  Branch (209:13): [True: 168, False: 0]
  ------------------
  210|    168|            if (pk_equal(friend_con->real_public_key, real_pk)) {
  ------------------
  |  Branch (210:17): [True: 0, False: 168]
  ------------------
  211|      0|                return i;
  212|      0|            }
  213|    168|        }
  214|    168|    }
  215|       |
  216|    121|    return -1;
  217|    121|}
friend_con_connected:
  673|    121|{
  674|    121|    const Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  675|       |
  676|    121|    if (friend_con == nullptr) {
  ------------------
  |  |   66|    121|#define nullptr NULL
  ------------------
  |  Branch (676:9): [True: 0, False: 121]
  ------------------
  677|      0|        return 0;
  678|      0|    }
  679|       |
  680|    121|    return friend_con->status;
  681|    121|}
friend_connection_callbacks:
  725|    121|{
  726|    121|    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  727|       |
  728|    121|    if (friend_con == nullptr) {
  ------------------
  |  |   66|    121|#define nullptr NULL
  ------------------
  |  Branch (728:9): [True: 0, False: 121]
  ------------------
  729|      0|        return -1;
  730|      0|    }
  731|       |
  732|    121|    if (index >= MAX_FRIEND_CONNECTION_CALLBACKS) {
  ------------------
  |  |   17|    121|#define MAX_FRIEND_CONNECTION_CALLBACKS 2
  ------------------
  |  Branch (732:9): [True: 0, False: 121]
  ------------------
  733|      0|        return -1;
  734|      0|    }
  735|       |
  736|    121|    if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   66|    242|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   66|    242|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   66|    242|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   66|    121|#define nullptr NULL
  ------------------
  |  Branch (736:9): [True: 121, False: 0]
  |  Branch (736:31): [True: 0, False: 121]
  |  Branch (736:61): [True: 0, False: 121]
  |  Branch (736:89): [True: 0, False: 121]
  ------------------
  737|      0|        LOGGER_ERROR(fr_c->logger, "non-null user data object but null callbacks");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  738|      0|        return -1;
  739|      0|    }
  740|       |
  741|    121|    friend_con->callbacks[index].status_callback = status_callback;
  742|    121|    friend_con->callbacks[index].data_callback = data_callback;
  743|    121|    friend_con->callbacks[index].lossy_data_callback = lossy_data_callback;
  744|       |
  745|    121|    friend_con->callbacks[index].callback_object = object;
  746|    121|    friend_con->callbacks[index].callback_id = number;
  747|       |
  748|    121|    return 0;
  749|    121|}
set_global_status_callback:
  753|  1.86k|{
  754|  1.86k|    if (object != nullptr && global_status_callback == nullptr) {
  ------------------
  |  |   66|  3.73k|#define nullptr NULL
  ------------------
                  if (object != nullptr && global_status_callback == nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (754:9): [True: 933, False: 933]
  |  Branch (754:30): [True: 0, False: 933]
  ------------------
  755|      0|        LOGGER_ERROR(fr_c->logger, "non-null user data object but null callback");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  756|      0|        object = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  757|      0|    }
  758|       |
  759|  1.86k|    fr_c->global_status_callback = global_status_callback;
  760|  1.86k|    fr_c->global_status_callback_object = object;
  761|  1.86k|}
new_friend_connection:
  786|    121|{
  787|    121|    int friendcon_id = getfriend_conn_id_pk(fr_c, real_public_key);
  788|       |
  789|    121|    if (friendcon_id != -1) {
  ------------------
  |  Branch (789:9): [True: 0, False: 121]
  ------------------
  790|      0|        ++fr_c->conns[friendcon_id].lock_count;
  791|      0|        return friendcon_id;
  792|      0|    }
  793|       |
  794|    121|    friendcon_id = create_friend_conn(fr_c);
  795|       |
  796|    121|    if (friendcon_id == -1) {
  ------------------
  |  Branch (796:9): [True: 0, False: 121]
  ------------------
  797|      0|        return -1;
  798|      0|    }
  799|       |
  800|    121|    const int32_t onion_friendnum = onion_addfriend(fr_c->onion_c, real_public_key);
  801|       |
  802|    121|    if (onion_friendnum == -1) {
  ------------------
  |  Branch (802:9): [True: 0, False: 121]
  ------------------
  803|      0|        return -1;
  804|      0|    }
  805|       |
  806|    121|    Friend_Conn *const friend_con = &fr_c->conns[friendcon_id];
  807|       |
  808|    121|    friend_con->crypt_connection_id = -1;
  809|    121|    friend_con->status = FRIENDCONN_STATUS_CONNECTING;
  810|    121|    memcpy(friend_con->real_public_key, real_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    121|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  811|    121|    friend_con->onion_friendnum = onion_friendnum;
  812|       |
  813|    121|    recv_tcp_relay_handler(fr_c->onion_c, onion_friendnum, &tcp_relay_node_callback, fr_c, friendcon_id);
  814|    121|    onion_dht_pk_callback(fr_c->onion_c, onion_friendnum, &dht_pk_callback, fr_c, friendcon_id);
  815|       |
  816|    121|    return friendcon_id;
  817|    121|}
kill_friend_connection:
  825|    121|{
  826|    121|    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  827|       |
  828|    121|    if (friend_con == nullptr) {
  ------------------
  |  |   66|    121|#define nullptr NULL
  ------------------
  |  Branch (828:9): [True: 0, False: 121]
  ------------------
  829|      0|        return -1;
  830|      0|    }
  831|       |
  832|    121|    if (friend_con->lock_count > 0) {
  ------------------
  |  Branch (832:9): [True: 0, False: 121]
  ------------------
  833|      0|        --friend_con->lock_count;
  834|      0|        return 0;
  835|      0|    }
  836|       |
  837|    121|    onion_delfriend(fr_c->onion_c, friend_con->onion_friendnum);
  838|    121|    crypto_kill(fr_c->net_crypto, friend_con->crypt_connection_id);
  839|       |
  840|    121|    if (friend_con->dht_lock_token > 0) {
  ------------------
  |  Branch (840:9): [True: 1, False: 120]
  ------------------
  841|      1|        dht_delfriend(fr_c->dht, friend_con->dht_temp_pk, friend_con->dht_lock_token);
  842|      1|        friend_con->dht_lock_token = 0;
  843|      1|    }
  844|       |
  845|    121|    return wipe_friend_conn(fr_c, friendcon_id);
  846|    121|}
set_friend_request_callback:
  854|    933|{
  855|    933|    fr_c->fr_request_callback = fr_request_callback;
  856|    933|    fr_c->fr_request_object = object;
  857|    933|    oniondata_registerhandler(fr_c->onion_c, CRYPTO_PACKET_FRIEND_REQ, fr_request_callback, object);
  ------------------
  |  |   80|    933|#define CRYPTO_PACKET_FRIEND_REQ    32  // Friend request crypto packet ID.
  ------------------
  858|    933|}
new_friend_connections:
  903|    946|{
  904|    946|    if (onion_c == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (904:9): [True: 3, False: 943]
  ------------------
  905|      3|        return nullptr;
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  906|      3|    }
  907|       |
  908|    943|    Friend_Connections *const temp = (Friend_Connections *)calloc(1, sizeof(Friend_Connections));
  909|       |
  910|    943|    if (temp == nullptr) {
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
  |  Branch (910:9): [True: 0, False: 943]
  ------------------
  911|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  912|      0|    }
  913|       |
  914|    943|    temp->mono_time = mono_time;
  915|    943|    temp->logger = logger;
  916|    943|    temp->dht = onion_get_dht(onion_c);
  917|    943|    temp->net_crypto = onion_get_net_crypto(onion_c);
  918|    943|    temp->onion_c = onion_c;
  919|    943|    temp->local_discovery_enabled = local_discovery_enabled;
  920|       |    // Don't include default port in port range
  921|    943|    temp->next_lan_port = TOX_PORTRANGE_FROM + 1;
  ------------------
  |  |  201|    943|#define TOX_PORTRANGE_FROM 33445
  ------------------
  922|       |
  923|    943|    new_connection_handler(temp->net_crypto, &handle_new_connections, temp);
  924|       |
  925|    943|    if (temp->local_discovery_enabled) {
  ------------------
  |  Branch (925:9): [True: 943, False: 0]
  ------------------
  926|    943|        temp->broadcast = lan_discovery_init(ns);
  927|       |
  928|    943|        if (temp->broadcast == nullptr) {
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
  |  Branch (928:13): [True: 0, False: 943]
  ------------------
  929|      0|            LOGGER_ERROR(logger, "could not initialise LAN discovery");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  930|      0|        }
  931|    943|    }
  932|       |
  933|    943|    return temp;
  934|    943|}
do_friend_connections:
  962|  72.6k|{
  963|  72.6k|    const uint64_t temp_time = mono_time_get(fr_c->mono_time);
  964|       |
  965|  74.9k|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (965:26): [True: 2.26k, False: 72.6k]
  ------------------
  966|  2.26k|        Friend_Conn *const friend_con = get_conn(fr_c, i);
  967|       |
  968|  2.26k|        if (friend_con != nullptr) {
  ------------------
  |  |   66|  2.26k|#define nullptr NULL
  ------------------
  |  Branch (968:13): [True: 2.26k, False: 0]
  ------------------
  969|  2.26k|            if (friend_con->status == FRIENDCONN_STATUS_CONNECTING) {
  ------------------
  |  Branch (969:17): [True: 2.26k, False: 0]
  ------------------
  970|  2.26k|                if (friend_con->dht_pk_lastrecv + FRIEND_DHT_TIMEOUT < temp_time) {
  ------------------
  |  |   32|  2.26k|#define FRIEND_DHT_TIMEOUT BAD_NODE_TIMEOUT
  |  |  ------------------
  |  |  |  |   68|  2.26k|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  2.26k|#define PING_INTERVAL 60
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|  2.26k|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  2.26k|#define PING_INTERVAL 60
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   67|  2.26k|#define PING_ROUNDTRIP 2
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (970:21): [True: 2.26k, False: 1]
  ------------------
  971|  2.26k|                    if (friend_con->dht_lock_token > 0) {
  ------------------
  |  Branch (971:25): [True: 0, False: 2.26k]
  ------------------
  972|      0|                        dht_delfriend(fr_c->dht, friend_con->dht_temp_pk, friend_con->dht_lock_token);
  973|      0|                        friend_con->dht_lock_token = 0;
  974|      0|                        memset(friend_con->dht_temp_pk, 0, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  975|      0|                    }
  976|  2.26k|                }
  977|       |
  978|  2.26k|                if (friend_con->dht_ip_port_lastrecv + FRIEND_DHT_TIMEOUT < temp_time) {
  ------------------
  |  |   32|  2.26k|#define FRIEND_DHT_TIMEOUT BAD_NODE_TIMEOUT
  |  |  ------------------
  |  |  |  |   68|  2.26k|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  2.26k|#define PING_INTERVAL 60
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|  2.26k|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  2.26k|#define PING_INTERVAL 60
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   67|  2.26k|#define PING_ROUNDTRIP 2
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (978:21): [True: 2.26k, False: 0]
  ------------------
  979|  2.26k|                    friend_con->dht_ip_port.ip.family = net_family_unspec();
  980|  2.26k|                }
  981|       |
  982|  2.26k|                if (friend_con->dht_lock_token > 0) {
  ------------------
  |  Branch (982:21): [True: 1, False: 2.26k]
  ------------------
  983|      1|                    if (friend_new_connection(fr_c, i) == 0) {
  ------------------
  |  Branch (983:25): [True: 0, False: 1]
  ------------------
  984|      0|                        set_direct_ip_port(fr_c->net_crypto, friend_con->crypt_connection_id, &friend_con->dht_ip_port, false);
  985|      0|                        connect_to_saved_tcp_relays(fr_c, i, MAX_FRIEND_TCP_CONNECTIONS / 2); /* Only fill it half up. */
  ------------------
  |  |   31|      0|#define MAX_FRIEND_TCP_CONNECTIONS 6
  ------------------
  986|      0|                    }
  987|      1|                }
  988|  2.26k|            } else if (friend_con->status == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (988:24): [True: 0, False: 0]
  ------------------
  989|      0|                if (friend_con->ping_lastsent + FRIEND_PING_INTERVAL < temp_time) {
  ------------------
  |  |   26|      0|#define FRIEND_PING_INTERVAL 8
  ------------------
  |  Branch (989:21): [True: 0, False: 0]
  ------------------
  990|      0|                    send_ping(fr_c, i);
  991|      0|                }
  992|       |
  993|      0|                if (friend_con->share_relays_lastsent + SHARE_RELAYS_INTERVAL < temp_time) {
  ------------------
  |  |   40|      0|#define SHARE_RELAYS_INTERVAL (60 * 2)
  ------------------
  |  Branch (993:21): [True: 0, False: 0]
  ------------------
  994|      0|                    send_relays(fr_c, i);
  995|      0|                }
  996|       |
  997|      0|                if (friend_con->ping_lastrecv + FRIEND_CONNECTION_TIMEOUT < temp_time) {
  ------------------
  |  |   29|      0|#define FRIEND_CONNECTION_TIMEOUT (FRIEND_PING_INTERVAL * 4)
  |  |  ------------------
  |  |  |  |   26|      0|#define FRIEND_PING_INTERVAL 8
  |  |  ------------------
  ------------------
  |  Branch (997:21): [True: 0, False: 0]
  ------------------
  998|       |                    /* If we stopped receiving ping packets, kill it. */
  999|      0|                    crypto_kill(fr_c->net_crypto, friend_con->crypt_connection_id);
 1000|      0|                    friend_con->crypt_connection_id = -1;
 1001|      0|                    handle_status(fr_c, i, false, userdata); /* Going offline. */
 1002|      0|                }
 1003|      0|            }
 1004|  2.26k|        }
 1005|  2.26k|    }
 1006|       |
 1007|  72.6k|    if (fr_c->local_discovery_enabled) {
  ------------------
  |  Branch (1007:9): [True: 72.6k, False: 0]
  ------------------
 1008|  72.6k|        lan_discovery(fr_c);
 1009|  72.6k|    }
 1010|  72.6k|}
kill_friend_connections:
 1014|    946|{
 1015|    946|    if (fr_c == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (1015:9): [True: 3, False: 943]
  ------------------
 1016|      3|        return;
 1017|      3|    }
 1018|       |
 1019|  1.06k|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (1019:26): [True: 121, False: 943]
  ------------------
 1020|    121|        kill_friend_connection(fr_c, i);
 1021|    121|    }
 1022|       |
 1023|    943|    lan_discovery_kill(fr_c->broadcast);
 1024|    943|    free(fr_c);
 1025|    943|}
friend_connection.c:friendconn_id_valid:
  105|  2.92k|{
  106|  2.92k|    return (unsigned int)friendcon_id < fr_c->num_cons &&
  ------------------
  |  Branch (106:12): [True: 2.92k, False: 0]
  ------------------
  107|  2.92k|           fr_c->conns != nullptr &&
  ------------------
  |  |   66|  5.84k|#define nullptr NULL
  ------------------
  |  Branch (107:12): [True: 2.92k, False: 0]
  ------------------
  108|  2.92k|           fr_c->conns[friendcon_id].status != FRIENDCONN_STATUS_NONE;
  ------------------
  |  Branch (108:12): [True: 2.92k, False: 0]
  ------------------
  109|  2.92k|}
friend_connection.c:dht_pk_callback:
  442|      1|{
  443|      1|    Friend_Connections *const fr_c = (Friend_Connections *)object;
  444|      1|    Friend_Conn *const friend_con = get_conn(fr_c, number);
  445|       |
  446|      1|    if (friend_con == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (446:9): [True: 0, False: 1]
  ------------------
  447|      0|        return;
  448|      0|    }
  449|       |
  450|      1|    if (pk_equal(friend_con->dht_temp_pk, dht_public_key)) {
  ------------------
  |  Branch (450:9): [True: 0, False: 1]
  ------------------
  451|      0|        return;
  452|      0|    }
  453|       |
  454|      1|    change_dht_pk(fr_c, number, dht_public_key);
  455|       |
  456|       |    /* if pk changed, create a new connection.*/
  457|      1|    if (friend_con->crypt_connection_id != -1) {
  ------------------
  |  Branch (457:9): [True: 0, False: 1]
  ------------------
  458|      0|        crypto_kill(fr_c->net_crypto, friend_con->crypt_connection_id);
  459|      0|        friend_con->crypt_connection_id = -1;
  460|      0|        handle_status(object, number, false, userdata); /* Going offline. */
  461|      0|    }
  462|       |
  463|      1|    friend_new_connection(fr_c, number);
  464|      1|    onion_set_friend_dht_pubkey(fr_c->onion_c, friend_con->onion_friendnum, dht_public_key);
  465|      1|}
friend_connection.c:change_dht_pk:
  371|      1|{
  372|      1|    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  373|       |
  374|      1|    if (friend_con == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (374:9): [True: 0, False: 1]
  ------------------
  375|      0|        return;
  376|      0|    }
  377|       |
  378|      1|    friend_con->dht_pk_lastrecv = mono_time_get(fr_c->mono_time);
  379|       |
  380|      1|    if (friend_con->dht_lock_token > 0) {
  ------------------
  |  Branch (380:9): [True: 0, False: 1]
  ------------------
  381|      0|        if (dht_delfriend(fr_c->dht, friend_con->dht_temp_pk, friend_con->dht_lock_token) != 0) {
  ------------------
  |  Branch (381:13): [True: 0, False: 0]
  ------------------
  382|      0|            LOGGER_ERROR(fr_c->logger, "a. Could not delete dht peer. Please report this.");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  383|      0|            return;
  384|      0|        }
  385|      0|        friend_con->dht_lock_token = 0;
  386|      0|    }
  387|       |
  388|      1|    dht_addfriend(fr_c->dht, dht_public_key, dht_ip_callback, fr_c, friendcon_id, &friend_con->dht_lock_token);
  389|      1|    memcpy(friend_con->dht_temp_pk, dht_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  390|      1|}
friend_connection.c:create_friend_conn:
  143|    121|{
  144|    289|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (144:26): [True: 168, False: 121]
  ------------------
  145|    168|        if (fr_c->conns[i].status == FRIENDCONN_STATUS_NONE) {
  ------------------
  |  Branch (145:13): [True: 0, False: 168]
  ------------------
  146|      0|            return i;
  147|      0|        }
  148|    168|    }
  149|       |
  150|    121|    if (!realloc_friendconns(fr_c, fr_c->num_cons + 1)) {
  ------------------
  |  Branch (150:9): [True: 0, False: 121]
  ------------------
  151|      0|        return -1;
  152|      0|    }
  153|       |
  154|    121|    const int id = fr_c->num_cons;
  155|    121|    ++fr_c->num_cons;
  156|    121|    fr_c->conns[id] = empty_friend_conn;
  157|       |
  158|    121|    return id;
  159|    121|}
friend_connection.c:realloc_friendconns:
  119|    164|{
  120|    164|    if (num == 0) {
  ------------------
  |  Branch (120:9): [True: 43, False: 121]
  ------------------
  121|     43|        free(fr_c->conns);
  122|     43|        fr_c->conns = nullptr;
  ------------------
  |  |   66|     43|#define nullptr NULL
  ------------------
  123|     43|        return true;
  124|     43|    }
  125|       |
  126|    121|    Friend_Conn *newgroup_cons = (Friend_Conn *)realloc(fr_c->conns, num * sizeof(Friend_Conn));
  127|       |
  128|    121|    if (newgroup_cons == nullptr) {
  ------------------
  |  |   66|    121|#define nullptr NULL
  ------------------
  |  Branch (128:9): [True: 0, False: 121]
  ------------------
  129|      0|        return false;
  130|      0|    }
  131|       |
  132|    121|    fr_c->conns = newgroup_cons;
  133|    121|    return true;
  134|    121|}
friend_connection.c:wipe_friend_conn:
  168|    121|{
  169|    121|    if (!friendconn_id_valid(fr_c, friendcon_id)) {
  ------------------
  |  Branch (169:9): [True: 0, False: 121]
  ------------------
  170|      0|        return -1;
  171|      0|    }
  172|       |
  173|    121|    fr_c->conns[friendcon_id] = empty_friend_conn;
  174|       |
  175|    121|    uint32_t i;
  176|       |
  177|    242|    for (i = fr_c->num_cons; i != 0; --i) {
  ------------------
  |  Branch (177:30): [True: 199, False: 43]
  ------------------
  178|    199|        if (fr_c->conns[i - 1].status != FRIENDCONN_STATUS_NONE) {
  ------------------
  |  Branch (178:13): [True: 78, False: 121]
  ------------------
  179|     78|            break;
  180|     78|        }
  181|    199|    }
  182|       |
  183|    121|    if (fr_c->num_cons != i) {
  ------------------
  |  Branch (183:9): [True: 43, False: 78]
  ------------------
  184|     43|        fr_c->num_cons = i;
  185|     43|        realloc_friendconns(fr_c, fr_c->num_cons);
  186|     43|    }
  187|       |
  188|    121|    return 0;
  189|    121|}
friend_connection.c:friend_new_connection:
  599|      2|{
  600|      2|    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  601|       |
  602|      2|    if (friend_con == nullptr) {
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
  |  Branch (602:9): [True: 0, False: 2]
  ------------------
  603|      0|        return -1;
  604|      0|    }
  605|       |
  606|      2|    if (friend_con->crypt_connection_id != -1) {
  ------------------
  |  Branch (606:9): [True: 1, False: 1]
  ------------------
  607|      1|        return -1;
  608|      1|    }
  609|       |
  610|       |    /* If dht_temp_pk does not contains a pk. */
  611|      1|    if (friend_con->dht_lock_token == 0) {
  ------------------
  |  Branch (611:9): [True: 0, False: 1]
  ------------------
  612|      0|        return -1;
  613|      0|    }
  614|       |
  615|      1|    const int id = new_crypto_connection(fr_c->net_crypto, friend_con->real_public_key, friend_con->dht_temp_pk);
  616|       |
  617|      1|    if (id == -1) {
  ------------------
  |  Branch (617:9): [True: 0, False: 1]
  ------------------
  618|      0|        return -1;
  619|      0|    }
  620|       |
  621|      1|    friend_con->crypt_connection_id = id;
  622|      1|    connection_status_handler(fr_c->net_crypto, id, &handle_status, fr_c, friendcon_id);
  623|      1|    connection_data_handler(fr_c->net_crypto, id, &handle_packet, fr_c, friendcon_id);
  624|      1|    connection_lossy_data_handler(fr_c->net_crypto, id, &handle_lossy_packet, fr_c, friendcon_id);
  625|      1|    nc_dht_pk_callback(fr_c->net_crypto, id, &dht_pk_callback, fr_c, friendcon_id);
  626|       |
  627|      1|    return 0;
  628|      1|}
friend_connection.c:lan_discovery:
  939|  72.6k|{
  940|  72.6k|    if (fr_c->last_lan_discovery + LAN_DISCOVERY_INTERVAL < mono_time_get(fr_c->mono_time)) {
  ------------------
  |  |   17|  72.6k|#define LAN_DISCOVERY_INTERVAL         10
  ------------------
  |  Branch (940:9): [True: 2.12k, False: 70.5k]
  ------------------
  941|  2.12k|        const uint16_t first = fr_c->next_lan_port;
  942|  2.12k|        uint16_t last = first + PORTS_PER_DISCOVERY;
  ------------------
  |  |   18|  2.12k|#define PORTS_PER_DISCOVERY 10
  ------------------
  943|  2.12k|        last = last > TOX_PORTRANGE_TO ? TOX_PORTRANGE_TO : last;
  ------------------
  |  |  202|  2.12k|#define TOX_PORTRANGE_TO   33545
  ------------------
                      last = last > TOX_PORTRANGE_TO ? TOX_PORTRANGE_TO : last;
  ------------------
  |  |  202|     95|#define TOX_PORTRANGE_TO   33545
  ------------------
  |  Branch (943:16): [True: 95, False: 2.03k]
  ------------------
  944|       |
  945|       |        // Always send to default port
  946|  2.12k|        lan_discovery_send(dht_get_net(fr_c->dht), fr_c->broadcast, dht_get_self_public_key(fr_c->dht),
  947|  2.12k|                           net_htons(TOX_PORT_DEFAULT));
  ------------------
  |  |  203|  2.12k|#define TOX_PORT_DEFAULT   TOX_PORTRANGE_FROM
  |  |  ------------------
  |  |  |  |  201|  2.12k|#define TOX_PORTRANGE_FROM 33445
  |  |  ------------------
  ------------------
  948|       |
  949|       |        // And check some extra ports
  950|  23.3k|        for (uint16_t port = first; port < last; ++port) {
  ------------------
  |  Branch (950:37): [True: 21.1k, False: 2.12k]
  ------------------
  951|  21.1k|            lan_discovery_send(dht_get_net(fr_c->dht), fr_c->broadcast, dht_get_self_public_key(fr_c->dht), net_htons(port));
  952|  21.1k|        }
  953|       |
  954|       |        // Don't include default port in port range
  955|  2.12k|        fr_c->next_lan_port = last != TOX_PORTRANGE_TO ? last : TOX_PORTRANGE_FROM + 1;
  ------------------
  |  |  202|  2.12k|#define TOX_PORTRANGE_TO   33545
  ------------------
                      fr_c->next_lan_port = last != TOX_PORTRANGE_TO ? last : TOX_PORTRANGE_FROM + 1;
  ------------------
  |  |  201|     95|#define TOX_PORTRANGE_FROM 33445
  ------------------
  |  Branch (955:31): [True: 2.03k, False: 95]
  ------------------
  956|  2.12k|        fr_c->last_lan_discovery = mono_time_get(fr_c->mono_time);
  957|  2.12k|    }
  958|  72.6k|}

set_nospam:
   42|    933|{
   43|    933|    fr->nospam = num;
   44|    933|}
callback_friendrequest:
   54|    933|{
   55|    933|    fr->handle_friendrequest = function;
   56|    933|    fr->handle_friendrequest_isset = 1;
   57|    933|    fr->handle_friendrequest_object = object;
   58|    933|}
set_filter_function:
   64|    933|{
   65|    933|    fr->filter_function = function;
   66|    933|    fr->filter_function_userdata = userdata;
   67|    933|}
friendreq_init:
  159|    933|{
  160|    933|    set_friend_request_callback(fr_c, &friendreq_handlepacket, fr);
  161|    933|}
friendreq_new:
  164|    964|{
  165|    964|    return (Friend_Requests *)calloc(1, sizeof(Friend_Requests));
  166|    964|}
friendreq_kill:
  169|    964|{
  170|    964|    free(fr);
  171|    964|}
friend_requests.c:friendreq_handlepacket:
  119|    197|{
  120|    197|    Friend_Requests *const fr = (Friend_Requests *)object;
  121|       |
  122|    197|    if (length <= 1 + sizeof(fr->nospam) || length > ONION_CLIENT_MAX_DATA_SIZE) {
  ------------------
  |  |  179|    196|#define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  ------------------
  |  |  |  |   36|    196|#define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   48|    196|#define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   37|    196|#define ONION_MAX_PACKET_SIZE 1400
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   46|    196|#define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|    196|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   43|    196|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   40|    196|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  228|    196|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  226|    196|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|    196|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  227|    196|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   61|    196|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   35|    196|#define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|    196|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|    196|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|    196|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|    196|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  ------------------
  |  |  |  |  178|    196|#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    196|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|    196|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (122:9): [True: 1, False: 196]
  |  Branch (122:45): [True: 0, False: 196]
  ------------------
  123|      1|        return 1;
  124|      1|    }
  125|       |
  126|    196|    ++packet;
  127|    196|    --length;
  128|       |
  129|    196|    if (fr->handle_friendrequest_isset == 0) {
  ------------------
  |  Branch (129:9): [True: 0, False: 196]
  ------------------
  130|      0|        return 1;
  131|      0|    }
  132|       |
  133|    196|    if (request_received(fr, source_pubkey)) {
  ------------------
  |  Branch (133:9): [True: 44, False: 152]
  ------------------
  134|     44|        return 1;
  135|     44|    }
  136|       |
  137|    152|    if (memcmp(packet, &fr->nospam, sizeof(fr->nospam)) != 0) {
  ------------------
  |  Branch (137:9): [True: 24, False: 128]
  ------------------
  138|     24|        return 1;
  139|     24|    }
  140|       |
  141|    128|    if (fr->filter_function != nullptr) {
  ------------------
  |  |   66|    128|#define nullptr NULL
  ------------------
  |  Branch (141:9): [True: 128, False: 0]
  ------------------
  142|    128|        if (fr->filter_function(source_pubkey, fr->filter_function_userdata) != 0) {
  ------------------
  |  Branch (142:13): [True: 0, False: 128]
  ------------------
  143|      0|            return 1;
  144|      0|        }
  145|    128|    }
  146|       |
  147|    128|    addto_receivedlist(fr, source_pubkey);
  148|       |
  149|    128|    const uint32_t message_len = length - sizeof(fr->nospam);
  150|    128|    VLA(uint8_t, message, message_len + 1);
  ------------------
  |  |   62|    128|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|    128|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  151|    128|    memcpy(message, packet + sizeof(fr->nospam), message_len);
  152|    128|    message[SIZEOF_VLA(message) - 1] = 0; /* Be sure the message is null terminated. */
  ------------------
  |  |   29|    128|#define SIZEOF_VLA sizeof
  ------------------
  153|       |
  154|    128|    fr->handle_friendrequest(fr->handle_friendrequest_object, source_pubkey, message, message_len, userdata);
  155|    128|    return 0;
  156|    128|}
friend_requests.c:request_received:
   88|    196|{
   89|  5.10k|    for (uint32_t i = 0; i < MAX_RECEIVED_STORED; ++i) {
  ------------------
  |  |   21|  5.10k|#define MAX_RECEIVED_STORED 32
  ------------------
  |  Branch (89:26): [True: 4.95k, False: 152]
  ------------------
   90|  4.95k|        if (pk_equal(fr->received.requests[i], real_pk)) {
  ------------------
  |  Branch (90:13): [True: 44, False: 4.90k]
  ------------------
   91|     44|            return true;
   92|     44|        }
   93|  4.95k|    }
   94|       |
   95|    152|    return false;
   96|    196|}
friend_requests.c:addto_receivedlist:
   72|    128|{
   73|    128|    if (fr->received.requests_index >= MAX_RECEIVED_STORED) {
  ------------------
  |  |   21|    128|#define MAX_RECEIVED_STORED 32
  ------------------
  |  Branch (73:9): [True: 0, False: 128]
  ------------------
   74|      0|        fr->received.requests_index = 0;
   75|      0|    }
   76|       |
   77|    128|    pk_copy(fr->received.requests[fr->received.requests_index], real_pk);
   78|    128|    ++fr->received.requests_index;
   79|    128|}

g_callback_group_invite:
 1828|    933|{
 1829|    933|    g_c->invite_callback = function;
 1830|    933|}
g_callback_group_connected:
 1834|    933|{
 1835|    933|    g_c->connected_callback = function;
 1836|    933|}
g_callback_group_message:
 1840|    933|{
 1841|    933|    g_c->message_callback = function;
 1842|    933|}
g_callback_peer_name:
 1849|    933|{
 1850|    933|    g_c->peer_name_callback = function;
 1851|    933|}
g_callback_peer_list_changed:
 1858|    933|{
 1859|    933|    g_c->peer_list_changed_callback = function;
 1860|    933|}
g_callback_group_title:
 1864|    933|{
 1865|    933|    g_c->title_callback = function;
 1866|    933|}
new_groupchats:
 3756|    933|{
 3757|    933|    if (m == nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (3757:9): [True: 0, False: 933]
  ------------------
 3758|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3759|      0|    }
 3760|       |
 3761|    933|    Group_Chats *temp = (Group_Chats *)calloc(1, sizeof(Group_Chats));
 3762|       |
 3763|    933|    if (temp == nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (3763:9): [True: 0, False: 933]
  ------------------
 3764|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3765|      0|    }
 3766|       |
 3767|    933|    temp->mono_time = mono_time;
 3768|    933|    temp->m = m;
 3769|    933|    temp->fr_c = m->fr_c;
 3770|    933|    m->conferences_object = temp;
 3771|    933|    m_callback_conference_invite(m, &handle_friend_invite_packet);
 3772|       |
 3773|    933|    set_global_status_callback(m->fr_c, &g_handle_any_status, temp);
 3774|       |
 3775|    933|    return temp;
 3776|    933|}
do_groupchats:
 3780|  72.6k|{
 3781|  72.6k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3781:26): [True: 0, False: 72.6k]
  ------------------
 3782|      0|        Group_c *g = get_group_c(g_c, i);
 3783|       |
 3784|      0|        if (g == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (3784:13): [True: 0, False: 0]
  ------------------
 3785|      0|            continue;
 3786|      0|        }
 3787|       |
 3788|      0|        if (g->status == GROUPCHAT_STATUS_CONNECTED) {
  ------------------
  |  Branch (3788:13): [True: 0, False: 0]
  ------------------
 3789|      0|            connect_to_closest(g_c, i, userdata);
 3790|      0|            ping_groupchat(g_c, i);
 3791|      0|            groupchat_freeze_timedout(g_c, i, userdata);
 3792|      0|            clean_connections(g_c, g);
 3793|       |
 3794|      0|            if (g->need_send_name) {
  ------------------
  |  Branch (3794:17): [True: 0, False: 0]
  ------------------
 3795|      0|                group_name_send(g_c, i, g_c->m->name, g_c->m->name_length);
 3796|      0|                g->need_send_name = false;
 3797|      0|            }
 3798|      0|        }
 3799|      0|    }
 3800|       |
 3801|       |    // TODO(irungentoo):
 3802|  72.6k|}
kill_groupchats:
 3806|    933|{
 3807|    933|    if (g_c == nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (3807:9): [True: 0, False: 933]
  ------------------
 3808|      0|        return;
 3809|      0|    }
 3810|       |
 3811|    933|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3811:26): [True: 0, False: 933]
  ------------------
 3812|      0|        del_groupchat(g_c, i, false);
 3813|      0|    }
 3814|       |
 3815|    933|    m_callback_conference_invite(g_c->m, nullptr);
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
 3816|    933|    set_global_status_callback(g_c->m->fr_c, nullptr, nullptr);
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
                  set_global_status_callback(g_c->m->fr_c, nullptr, nullptr);
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
 3817|    933|    g_c->m->conferences_object = nullptr;
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
 3818|    933|    free(g_c);
 3819|    933|}

gca_get_announces:
   61|      3|{
   62|      3|    if (gc_announces == nullptr || gc_announces_list == nullptr || chat_id == nullptr || max_nodes == 0
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
                  if (gc_announces == nullptr || gc_announces_list == nullptr || chat_id == nullptr || max_nodes == 0
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
                  if (gc_announces == nullptr || gc_announces_list == nullptr || chat_id == nullptr || max_nodes == 0
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  |  Branch (62:9): [True: 0, False: 3]
  |  Branch (62:36): [True: 0, False: 3]
  |  Branch (62:68): [True: 0, False: 3]
  |  Branch (62:90): [True: 0, False: 3]
  ------------------
   63|      3|            || except_public_key == nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (63:16): [True: 0, False: 3]
  ------------------
   64|      0|        return -1;
   65|      0|    }
   66|       |
   67|      3|    const GC_Announces *announces = get_announces_by_chat_id(gc_announces_list, chat_id);
   68|       |
   69|      3|    if (announces == nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (69:9): [True: 0, False: 3]
  ------------------
   70|      0|        return 0;
   71|      0|    }
   72|       |
   73|      3|    uint16_t added_count = 0;
   74|       |
   75|      6|    for (size_t i = 0; i < announces->index && i < GCA_MAX_SAVED_ANNOUNCES_PER_GC && added_count < max_nodes; ++i) {
  ------------------
  |  |   21|      9|#define GCA_MAX_SAVED_ANNOUNCES_PER_GC 16
  ------------------
  |  Branch (75:24): [True: 3, False: 3]
  |  Branch (75:48): [True: 3, False: 0]
  |  Branch (75:86): [True: 3, False: 0]
  ------------------
   76|      3|        const size_t index = i % GCA_MAX_SAVED_ANNOUNCES_PER_GC;
  ------------------
  |  |   21|      3|#define GCA_MAX_SAVED_ANNOUNCES_PER_GC 16
  ------------------
   77|       |
   78|      3|        if (memcmp(except_public_key, &announces->peer_announces[index].base_announce.peer_public_key,
  ------------------
  |  Branch (78:13): [True: 3, False: 0]
  ------------------
   79|      3|                   ENC_PUBLIC_KEY_SIZE) == 0) {
  ------------------
  |  |   27|      3|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|      3|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
   80|      3|            continue;
   81|      3|        }
   82|       |
   83|      0|        bool already_added = false;
   84|       |
   85|      0|        for (size_t j = 0; j < added_count; ++j) {
  ------------------
  |  Branch (85:28): [True: 0, False: 0]
  ------------------
   86|      0|            if (memcmp(&gc_announces[j].peer_public_key, &announces->peer_announces[index].base_announce.peer_public_key,
  ------------------
  |  Branch (86:17): [True: 0, False: 0]
  ------------------
   87|      0|                       ENC_PUBLIC_KEY_SIZE) == 0) {
  ------------------
  |  |   27|      0|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
   88|      0|                already_added = true;
   89|      0|                break;
   90|      0|            }
   91|      0|        }
   92|       |
   93|      0|        if (!already_added) {
  ------------------
  |  Branch (93:13): [True: 0, False: 0]
  ------------------
   94|      0|            gc_announces[added_count] = announces->peer_announces[index].base_announce;
   95|      0|            ++added_count;
   96|      0|        }
   97|      0|    }
   98|       |
   99|      3|    return added_count;
  100|      3|}
gca_unpack_public_announce:
  248|     17|{
  249|     17|    if (length < CHAT_ID_SIZE) {
  ------------------
  |  |   33|     17|#define CHAT_ID_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|     17|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|     17|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (249:9): [True: 1, False: 16]
  ------------------
  250|      1|        LOGGER_ERROR(log, "invalid public announce length: %u", length);
  ------------------
  |  |   83|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      1|    do {                                                                         \
  |  |  |  |   73|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      1|        }                                                                        \
  |  |  |  |   76|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  251|      1|        return -1;
  252|      1|    }
  253|       |
  254|     16|    if (data == nullptr) {
  ------------------
  |  |   66|     16|#define nullptr NULL
  ------------------
  |  Branch (254:9): [True: 0, False: 16]
  ------------------
  255|      0|        LOGGER_ERROR(log, "data is null");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  256|      0|        return -1;
  257|      0|    }
  258|       |
  259|     16|    if (public_announce == nullptr) {
  ------------------
  |  |   66|     16|#define nullptr NULL
  ------------------
  |  Branch (259:9): [True: 0, False: 16]
  ------------------
  260|      0|        LOGGER_ERROR(log, "public_announce is null");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  261|      0|        return -1;
  262|      0|    }
  263|       |
  264|     16|    memcpy(public_announce->chat_public_key, data, CHAT_ID_SIZE);
  ------------------
  |  |   33|     16|#define CHAT_ID_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|     16|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|     16|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  265|       |
  266|     16|    const int base_announce_size = gca_unpack_announce(log, data + ENC_PUBLIC_KEY_SIZE, length - ENC_PUBLIC_KEY_SIZE,
  ------------------
  |  |   27|     16|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|     16|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
                  const int base_announce_size = gca_unpack_announce(log, data + ENC_PUBLIC_KEY_SIZE, length - ENC_PUBLIC_KEY_SIZE,
  ------------------
  |  |   27|     16|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|     16|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  267|     16|                                   &public_announce->base_announce);
  268|       |
  269|     16|    if (base_announce_size == -1) {
  ------------------
  |  Branch (269:9): [True: 13, False: 3]
  ------------------
  270|     13|        LOGGER_ERROR(log, "Failed to unpack group announce");
  ------------------
  |  |   83|     13|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     13|    do {                                                                         \
  |  |  |  |   73|     13|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     26|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     13|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     13|        }                                                                        \
  |  |  |  |   76|     13|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  271|     13|        return -1;
  272|     13|    }
  273|       |
  274|      3|    return base_announce_size + CHAT_ID_SIZE;
  ------------------
  |  |   33|      3|#define CHAT_ID_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|      3|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|      3|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  275|     16|}
gca_pack_announces_list:
  279|      3|{
  280|      3|    if (data == nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (280:9): [True: 0, False: 3]
  ------------------
  281|      0|        LOGGER_ERROR(log, "data is null");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  282|      0|        return -1;
  283|      0|    }
  284|       |
  285|      3|    if (announces == nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (285:9): [True: 0, False: 3]
  ------------------
  286|      0|        LOGGER_ERROR(log, "announces is null");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  287|      0|        return -1;
  288|      0|    }
  289|       |
  290|      3|    uint16_t offset = 0;
  291|       |
  292|      3|    for (size_t i = 0; i < announces_count; ++i) {
  ------------------
  |  Branch (292:24): [True: 0, False: 3]
  ------------------
  293|      0|        const int packed_length = gca_pack_announce(log, data + offset, length - offset, &announces[i]);
  294|       |
  295|      0|        if (packed_length < 0) {
  ------------------
  |  Branch (295:13): [True: 0, False: 0]
  ------------------
  296|      0|            LOGGER_ERROR(log, "Failed to pack group announce");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  297|      0|            return -1;
  298|      0|        }
  299|       |
  300|      0|        offset += packed_length;
  301|      0|    }
  302|       |
  303|      3|    if (processed != nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (303:9): [True: 3, False: 0]
  ------------------
  304|      3|        *processed = offset;
  305|      3|    }
  306|       |
  307|      3|    return announces_count;
  308|      3|}
gca_add_announce:
  343|      3|{
  344|      3|    if (gc_announces_list == nullptr || public_announce == nullptr) {
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
                  if (gc_announces_list == nullptr || public_announce == nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (344:9): [True: 0, False: 3]
  |  Branch (344:41): [True: 0, False: 3]
  ------------------
  345|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  346|      0|    }
  347|       |
  348|      3|    GC_Announces *announces = get_announces_by_chat_id(gc_announces_list, public_announce->chat_public_key);
  349|       |
  350|       |    // No entry for this chat_id exists so we create one
  351|      3|    if (announces == nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (351:9): [True: 3, False: 0]
  ------------------
  352|      3|        announces = (GC_Announces *)calloc(1, sizeof(GC_Announces));
  353|       |
  354|      3|        if (announces == nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (354:13): [True: 0, False: 3]
  ------------------
  355|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  356|      0|        }
  357|       |
  358|      3|        announces->index = 0;
  359|      3|        announces->prev_announce = nullptr;
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  360|       |
  361|      3|        if (gc_announces_list->root_announces != nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (361:13): [True: 0, False: 3]
  ------------------
  362|      0|            gc_announces_list->root_announces->prev_announce = announces;
  363|      0|        }
  364|       |
  365|      3|        announces->next_announce = gc_announces_list->root_announces;
  366|      3|        gc_announces_list->root_announces = announces;
  367|      3|        memcpy(announces->chat_id, public_announce->chat_public_key, CHAT_ID_SIZE);
  ------------------
  |  |   33|      3|#define CHAT_ID_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|      3|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|      3|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  368|      3|    }
  369|       |
  370|      3|    const uint64_t cur_time = mono_time_get(mono_time);
  371|       |
  372|      3|    announces->last_announce_received_timestamp = cur_time;
  373|       |
  374|      3|    const uint64_t index = announces->index % GCA_MAX_SAVED_ANNOUNCES_PER_GC;
  ------------------
  |  |   21|      3|#define GCA_MAX_SAVED_ANNOUNCES_PER_GC 16
  ------------------
  375|       |
  376|      3|    GC_Peer_Announce *gc_peer_announce = &announces->peer_announces[index];
  377|       |
  378|      3|    gc_peer_announce->base_announce = public_announce->base_announce;
  379|       |
  380|      3|    gc_peer_announce->timestamp = cur_time;
  381|       |
  382|      3|    ++announces->index;
  383|       |
  384|      3|    return gc_peer_announce;
  385|      3|}
new_gca_list:
  397|    946|{
  398|    946|    GC_Announces_List *announces_list = (GC_Announces_List *)calloc(1, sizeof(GC_Announces_List));
  399|    946|    return announces_list;
  400|    946|}
kill_gca:
  403|    946|{
  404|    946|    if (announces_list == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (404:9): [True: 0, False: 946]
  ------------------
  405|      0|        return;
  406|      0|    }
  407|       |
  408|    946|    GC_Announces *root = announces_list->root_announces;
  409|       |
  410|    949|    while (root != nullptr) {
  ------------------
  |  |   66|    949|#define nullptr NULL
  ------------------
  |  Branch (410:12): [True: 3, False: 946]
  ------------------
  411|      3|        GC_Announces *next = root->next_announce;
  412|      3|        free(root);
  413|      3|        root = next;
  414|      3|    }
  415|       |
  416|    946|    free(announces_list);
  417|    946|}
do_gca:
  426|  72.6k|{
  427|  72.6k|    if (gc_announces_list == nullptr) {
  ------------------
  |  |   66|  72.6k|#define nullptr NULL
  ------------------
  |  Branch (427:9): [True: 0, False: 72.6k]
  ------------------
  428|      0|        return;
  429|      0|    }
  430|       |
  431|  72.6k|    if (!mono_time_is_timeout(mono_time, gc_announces_list->last_timeout_check, GCA_DO_GCA_TIMEOUT)) {
  ------------------
  |  |  423|  72.6k|#define GCA_DO_GCA_TIMEOUT 1
  ------------------
  |  Branch (431:9): [True: 57.4k, False: 15.2k]
  ------------------
  432|  57.4k|        return;
  433|  57.4k|    }
  434|       |
  435|  15.2k|    gc_announces_list->last_timeout_check = mono_time_get(mono_time);
  436|       |
  437|  15.2k|    GC_Announces *announces = gc_announces_list->root_announces;
  438|       |
  439|  15.2k|    while (announces != nullptr) {
  ------------------
  |  |   66|  15.2k|#define nullptr NULL
  ------------------
  |  Branch (439:12): [True: 3, False: 15.2k]
  ------------------
  440|      3|        if (mono_time_is_timeout(mono_time, announces->last_announce_received_timestamp, GCA_ANNOUNCE_SAVE_TIMEOUT)) {
  ------------------
  |  |  420|      3|#define GCA_ANNOUNCE_SAVE_TIMEOUT 30
  ------------------
  |  Branch (440:13): [True: 0, False: 3]
  ------------------
  441|      0|            GC_Announces *to_delete = announces;
  442|      0|            announces = announces->next_announce;
  443|      0|            remove_announces(gc_announces_list, to_delete);
  444|      0|            continue;
  445|      0|        }
  446|       |
  447|      3|        announces = announces->next_announce;
  448|      3|    }
  449|  15.2k|}
group_announce.c:get_announces_by_chat_id:
   45|      6|{
   46|      6|    GC_Announces *announces = gc_announces_list->root_announces;
   47|       |
   48|      6|    while (announces != nullptr) {
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  |  Branch (48:12): [True: 3, False: 3]
  ------------------
   49|      3|        if (memcmp(announces->chat_id, chat_id, CHAT_ID_SIZE) == 0) {
  ------------------
  |  |   33|      3|#define CHAT_ID_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|      3|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|      3|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (49:13): [True: 3, False: 0]
  ------------------
   50|      3|            return announces;
   51|      3|        }
   52|       |
   53|      0|        announces = announces->next_announce;
   54|      0|    }
   55|       |
   56|      3|    return nullptr;
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
   57|      6|}
group_announce.c:gca_unpack_announce:
  169|     16|{
  170|     16|    if (length < ENC_PUBLIC_KEY_SIZE + 2) {
  ------------------
  |  |   27|     16|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|     16|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (170:9): [True: 1, False: 15]
  ------------------
  171|      1|        LOGGER_ERROR(log, "Invalid announce length: %u", length);
  ------------------
  |  |   83|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      1|    do {                                                                         \
  |  |  |  |   73|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      1|        }                                                                        \
  |  |  |  |   76|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  172|      1|        return -1;
  173|      1|    }
  174|       |
  175|     15|    if (data == nullptr) {
  ------------------
  |  |   66|     15|#define nullptr NULL
  ------------------
  |  Branch (175:9): [True: 0, False: 15]
  ------------------
  176|      0|        LOGGER_ERROR(log, "data is null");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  177|      0|        return -1;
  178|      0|    }
  179|       |
  180|     15|    if (announce == nullptr) {
  ------------------
  |  |   66|     15|#define nullptr NULL
  ------------------
  |  Branch (180:9): [True: 0, False: 15]
  ------------------
  181|      0|        LOGGER_ERROR(log, "announce is null");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  182|      0|        return -1;
  183|      0|    }
  184|       |
  185|     15|    uint16_t offset = 0;
  186|     15|    memcpy(announce->peer_public_key, data + offset, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |   27|     15|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  187|     15|    offset += ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |   27|     15|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  188|       |
  189|     15|    net_unpack_bool(&data[offset], &announce->ip_port_is_set);
  190|     15|    ++offset;
  191|       |
  192|     15|    announce->tcp_relays_count = data[offset];
  193|     15|    ++offset;
  194|       |
  195|     15|    if (announce->tcp_relays_count > GCA_MAX_ANNOUNCED_TCP_RELAYS) {
  ------------------
  |  |   24|     15|#define GCA_MAX_ANNOUNCED_TCP_RELAYS 1
  ------------------
  |  Branch (195:9): [True: 1, False: 14]
  ------------------
  196|      1|        return -1;
  197|      1|    }
  198|       |
  199|     14|    if (announce->ip_port_is_set) {
  ------------------
  |  Branch (199:9): [True: 12, False: 2]
  ------------------
  200|     12|        if (length - offset == 0) {
  ------------------
  |  Branch (200:13): [True: 1, False: 11]
  ------------------
  201|      1|            return -1;
  202|      1|        }
  203|       |
  204|     11|        const int ip_port_length = unpack_ip_port(&announce->ip_port, data + offset, length - offset, false);
  205|       |
  206|     11|        if (ip_port_length == -1) {
  ------------------
  |  Branch (206:13): [True: 5, False: 6]
  ------------------
  207|      5|            LOGGER_ERROR(log, "Failed to unpack ip_port");
  ------------------
  |  |   83|      5|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      5|    do {                                                                         \
  |  |  |  |   73|      5|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     10|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      5|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      5|        }                                                                        \
  |  |  |  |   76|      5|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  208|      5|            return -1;
  209|      5|        }
  210|       |
  211|      6|        offset += ip_port_length;
  212|      6|    }
  213|       |
  214|      8|    uint16_t nodes_length;
  215|      8|    const int nodes_count = unpack_nodes(announce->tcp_relays, announce->tcp_relays_count, &nodes_length,
  216|      8|                                         data + offset, length - offset, true);
  217|       |
  218|      8|    if (nodes_count != announce->tcp_relays_count) {
  ------------------
  |  Branch (218:9): [True: 5, False: 3]
  ------------------
  219|      5|        LOGGER_ERROR(log, "Failed to unpack TCP nodes");
  ------------------
  |  |   83|      5|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      5|    do {                                                                         \
  |  |  |  |   73|      5|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     10|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      5|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      5|        }                                                                        \
  |  |  |  |   76|      5|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  220|      5|        return -1;
  221|      5|    }
  222|       |
  223|      3|    return offset + nodes_length;
  224|      8|}

gc_callback_message:
 6474|    933|{
 6475|    933|    GC_Session *c = m->group_handler;
 6476|    933|    c->message = function;
 6477|    933|}
gc_callback_private_message:
 6480|    933|{
 6481|    933|    GC_Session *c = m->group_handler;
 6482|    933|    c->private_message = function;
 6483|    933|}
gc_callback_custom_packet:
 6486|    933|{
 6487|    933|    GC_Session *c = m->group_handler;
 6488|    933|    c->custom_packet = function;
 6489|    933|}
gc_callback_custom_private_packet:
 6492|    933|{
 6493|    933|    GC_Session *c = m->group_handler;
 6494|    933|    c->custom_private_packet = function;
 6495|    933|}
gc_callback_moderation:
 6498|    933|{
 6499|    933|    GC_Session *c = m->group_handler;
 6500|    933|    c->moderation = function;
 6501|    933|}
gc_callback_nick_change:
 6504|    933|{
 6505|    933|    GC_Session *c = m->group_handler;
 6506|    933|    c->nick_change = function;
 6507|    933|}
gc_callback_status_change:
 6510|    933|{
 6511|    933|    GC_Session *c = m->group_handler;
 6512|    933|    c->status_change = function;
 6513|    933|}
gc_callback_topic_change:
 6516|    933|{
 6517|    933|    GC_Session *c = m->group_handler;
 6518|    933|    c->topic_change = function;
 6519|    933|}
gc_callback_topic_lock:
 6522|    933|{
 6523|    933|    GC_Session *c = m->group_handler;
 6524|    933|    c->topic_lock = function;
 6525|    933|}
gc_callback_voice_state:
 6528|    933|{
 6529|    933|    GC_Session *c = m->group_handler;
 6530|    933|    c->voice_state = function;
 6531|    933|}
gc_callback_peer_limit:
 6534|    933|{
 6535|    933|    GC_Session *c = m->group_handler;
 6536|    933|    c->peer_limit = function;
 6537|    933|}
gc_callback_privacy_state:
 6540|    933|{
 6541|    933|    GC_Session *c = m->group_handler;
 6542|    933|    c->privacy_state = function;
 6543|    933|}
gc_callback_password:
 6546|    933|{
 6547|    933|    GC_Session *c = m->group_handler;
 6548|    933|    c->password = function;
 6549|    933|}
gc_callback_peer_join:
 6552|    933|{
 6553|    933|    GC_Session *c = m->group_handler;
 6554|    933|    c->peer_join = function;
 6555|    933|}
gc_callback_peer_exit:
 6558|    933|{
 6559|    933|    GC_Session *c = m->group_handler;
 6560|    933|    c->peer_exit = function;
 6561|    933|}
gc_callback_self_join:
 6564|    933|{
 6565|    933|    GC_Session *c = m->group_handler;
 6566|    933|    c->self_join = function;
 6567|    933|}
gc_callback_rejected:
 6570|    933|{
 6571|    933|    GC_Session *c = m->group_handler;
 6572|    933|    c->rejected = function;
 6573|    933|}
do_gc:
 7152|  72.6k|{
 7153|  72.6k|    if (c == nullptr) {
  ------------------
  |  |   66|  72.6k|#define nullptr NULL
  ------------------
  |  Branch (7153:9): [True: 0, False: 72.6k]
  ------------------
 7154|      0|        return;
 7155|      0|    }
 7156|       |
 7157|  72.6k|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (7157:26): [True: 0, False: 72.6k]
  ------------------
 7158|      0|        GC_Chat *chat = &c->chats[i];
 7159|       |
 7160|      0|        const GC_Conn_State state = chat->connection_state;
 7161|       |
 7162|      0|        if (state == CS_NONE) {
  ------------------
  |  Branch (7162:13): [True: 0, False: 0]
  ------------------
 7163|      0|            continue;
 7164|      0|        }
 7165|       |
 7166|      0|        if (state != CS_DISCONNECTED) {
  ------------------
  |  Branch (7166:13): [True: 0, False: 0]
  ------------------
 7167|      0|            do_peer_connections(c, chat, userdata);
 7168|      0|            do_gc_tcp(c, chat, userdata);
 7169|      0|            do_handshakes(chat);
 7170|      0|            do_self_connection(c, chat);
 7171|      0|        }
 7172|       |
 7173|      0|        if (chat->connection_state == CS_CONNECTED) {
  ------------------
  |  Branch (7173:13): [True: 0, False: 0]
  ------------------
 7174|      0|            do_gc_ping_and_key_rotation(chat);
 7175|      0|            do_timed_out_reconn(chat);
 7176|      0|        }
 7177|       |
 7178|      0|        do_new_connection_cooldown(chat);
 7179|      0|        do_peer_delete(c, chat, userdata);
 7180|      0|    }
 7181|  72.6k|}
new_dht_groupchats:
 8093|    935|{
 8094|    935|    if (m == nullptr) {
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
  |  Branch (8094:9): [True: 0, False: 935]
  ------------------
 8095|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 8096|      0|    }
 8097|       |
 8098|    935|    GC_Session *c = (GC_Session *)calloc(1, sizeof(GC_Session));
 8099|       |
 8100|    935|    if (c == nullptr) {
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
  |  Branch (8100:9): [True: 0, False: 935]
  ------------------
 8101|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 8102|      0|    }
 8103|       |
 8104|    935|    c->messenger = m;
 8105|    935|    c->announces_list = m->group_announce;
 8106|       |
 8107|    935|    networking_registerhandler(m->net, NET_PACKET_GC_LOSSLESS, &handle_gc_udp_packet, m);
 8108|    935|    networking_registerhandler(m->net, NET_PACKET_GC_LOSSY, &handle_gc_udp_packet, m);
 8109|    935|    networking_registerhandler(m->net, NET_PACKET_GC_HANDSHAKE, &handle_gc_udp_packet, m);
 8110|    935|    onion_group_announce_register(m->onion_c, gc_handle_announce_response_callback, c);
 8111|       |
 8112|    935|    return c;
 8113|    935|}
kill_dht_groupchats:
 8178|    935|{
 8179|    935|    if (c == nullptr) {
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
  |  Branch (8179:9): [True: 0, False: 935]
  ------------------
 8180|      0|        return;
 8181|      0|    }
 8182|       |
 8183|    935|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (8183:26): [True: 0, False: 935]
  ------------------
 8184|      0|        GC_Chat *chat = &c->chats[i];
 8185|       |
 8186|      0|        if (chat->connection_state == CS_NONE) {
  ------------------
  |  Branch (8186:13): [True: 0, False: 0]
  ------------------
 8187|      0|            continue;
 8188|      0|        }
 8189|       |
 8190|      0|        if (group_can_handle_packets(chat)) {
  ------------------
  |  Branch (8190:13): [True: 0, False: 0]
  ------------------
 8191|      0|            send_gc_self_exit(chat, nullptr, 0);
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 8192|      0|        }
 8193|       |
 8194|      0|        group_cleanup(c, chat);
 8195|      0|    }
 8196|       |
 8197|    935|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSY, nullptr, nullptr);
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSY, nullptr, nullptr);
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
 8198|    935|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSLESS, nullptr, nullptr);
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSLESS, nullptr, nullptr);
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
 8199|    935|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_HANDSHAKE, nullptr, nullptr);
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_HANDSHAKE, nullptr, nullptr);
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
 8200|    935|    onion_group_announce_register(c->messenger->onion_c, nullptr, nullptr);
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
                  onion_group_announce_register(c->messenger->onion_c, nullptr, nullptr);
  ------------------
  |  |   66|    935|#define nullptr NULL
  ------------------
 8201|       |
 8202|    935|    free(c->chats);
 8203|    935|    free(c);
 8204|    935|}
group_chats.c:get_chat_by_id:
  526|     20|{
  527|     20|    if (c == nullptr) {
  ------------------
  |  |   66|     20|#define nullptr NULL
  ------------------
  |  Branch (527:9): [True: 0, False: 20]
  ------------------
  528|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  529|      0|    }
  530|       |
  531|     20|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (531:26): [True: 0, False: 20]
  ------------------
  532|      0|        GC_Chat *chat = &c->chats[i];
  533|       |
  534|      0|        if (chat->connection_state == CS_NONE) {
  ------------------
  |  Branch (534:13): [True: 0, False: 0]
  ------------------
  535|      0|            continue;
  536|      0|        }
  537|       |
  538|      0|        if (memcmp(id, chat->self_public_key, ENC_PUBLIC_KEY_SIZE) == 0) {
  ------------------
  |  |   27|      0|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (538:13): [True: 0, False: 0]
  ------------------
  539|      0|            return chat;
  540|      0|        }
  541|       |
  542|      0|        if (get_peer_number_of_enc_pk(chat, id, false) != -1) {
  ------------------
  |  Branch (542:13): [True: 0, False: 0]
  ------------------
  543|      0|            return chat;
  544|      0|        }
  545|      0|    }
  546|       |
  547|     20|    return nullptr;
  ------------------
  |  |   66|     20|#define nullptr NULL
  ------------------
  548|     20|}
group_chats.c:handle_gc_udp_packet:
 6398|     32|{
 6399|     32|    const Messenger *m = (Messenger *)object;
 6400|       |
 6401|     32|    if (m == nullptr) {
  ------------------
  |  |   66|     32|#define nullptr NULL
  ------------------
  |  Branch (6401:9): [True: 0, False: 32]
  ------------------
 6402|      0|        return -1;
 6403|      0|    }
 6404|       |
 6405|     32|    if (length <= MIN_UDP_PACKET_SIZE) {
  ------------------
  |  | 6394|     32|#define MIN_UDP_PACKET_SIZE (1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   27|     32|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     32|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define MIN_UDP_PACKET_SIZE (1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     32|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define MIN_UDP_PACKET_SIZE (1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     32|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  |  Branch (6405:9): [True: 10, False: 22]
  ------------------
 6406|     10|        LOGGER_WARNING(m->log, "Got UDP packet with invalid length: %u (expected %u to %u)", length,
  ------------------
  |  |   82|     10|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     10|    do {                                                                         \
  |  |  |  |   73|     10|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     20|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     10|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     10|        }                                                                        \
  |  |  |  |   76|     10|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6407|     10|                       MIN_UDP_PACKET_SIZE, MAX_GC_PACKET_INCOMING_CHUNK_SIZE + MIN_UDP_PACKET_SIZE + ENC_PUBLIC_KEY_SIZE);
 6408|     10|        return -1;
 6409|     10|    }
 6410|       |
 6411|     22|    if (length > MAX_GC_PACKET_INCOMING_CHUNK_SIZE + MIN_UDP_PACKET_SIZE + ENC_PUBLIC_KEY_SIZE) {
  ------------------
  |  |   32|     22|#define MAX_GC_PACKET_INCOMING_CHUNK_SIZE 1372
  ------------------
                  if (length > MAX_GC_PACKET_INCOMING_CHUNK_SIZE + MIN_UDP_PACKET_SIZE + ENC_PUBLIC_KEY_SIZE) {
  ------------------
  |  | 6394|     22|#define MIN_UDP_PACKET_SIZE (1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   27|     22|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     22|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define MIN_UDP_PACKET_SIZE (1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     22|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define MIN_UDP_PACKET_SIZE (1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     22|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                  if (length > MAX_GC_PACKET_INCOMING_CHUNK_SIZE + MIN_UDP_PACKET_SIZE + ENC_PUBLIC_KEY_SIZE) {
  ------------------
  |  |   27|     22|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|     22|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (6411:9): [True: 2, False: 20]
  ------------------
 6412|      2|        LOGGER_WARNING(m->log, "Got UDP packet with invalid length: %u (expected %u to %u)", length,
  ------------------
  |  |   82|      2|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      2|    do {                                                                         \
  |  |  |  |   73|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      2|        }                                                                        \
  |  |  |  |   76|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6413|      2|                       MIN_UDP_PACKET_SIZE, MAX_GC_PACKET_INCOMING_CHUNK_SIZE + MIN_UDP_PACKET_SIZE + ENC_PUBLIC_KEY_SIZE);
 6414|      2|        return -1;
 6415|      2|    }
 6416|       |
 6417|     20|    const uint8_t packet_type = packet[0];
 6418|     20|    const uint8_t *sender_pk = packet + 1;
 6419|       |
 6420|     20|    const GC_Session *c = m->group_handler;
 6421|     20|    GC_Chat *chat = nullptr;
  ------------------
  |  |   66|     20|#define nullptr NULL
  ------------------
 6422|       |
 6423|     20|    if (packet_type == NET_PACKET_GC_HANDSHAKE) {
  ------------------
  |  Branch (6423:9): [True: 10, False: 10]
  ------------------
 6424|     10|        chat = get_chat_by_id(c, packet + 1 + ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |   27|     10|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|     10|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 6425|     10|    } else {
 6426|     10|        chat = get_chat_by_id(c, sender_pk);
 6427|     10|    }
 6428|       |
 6429|     20|    if (chat == nullptr) {
  ------------------
  |  |   66|     20|#define nullptr NULL
  ------------------
  |  Branch (6429:9): [True: 20, False: 0]
  ------------------
 6430|     20|        return -1;
 6431|     20|    }
 6432|       |
 6433|      0|    if (!group_can_handle_packets(chat)) {
  ------------------
  |  Branch (6433:9): [True: 0, False: 0]
  ------------------
 6434|      0|        return -1;
 6435|      0|    }
 6436|       |
 6437|      0|    const uint8_t *payload = packet + 1 + ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |   27|      0|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 6438|      0|    uint16_t payload_len = length - 1 - ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |   27|      0|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 6439|      0|    bool ret = false;
 6440|       |
 6441|      0|    switch (packet_type) {
 6442|      0|        case NET_PACKET_GC_LOSSLESS: {
  ------------------
  |  Branch (6442:9): [True: 0, False: 0]
  ------------------
 6443|      0|            ret = handle_gc_lossless_packet(c, chat, sender_pk, payload, payload_len, true, userdata);
 6444|      0|            break;
 6445|      0|        }
 6446|       |
 6447|      0|        case NET_PACKET_GC_LOSSY: {
  ------------------
  |  Branch (6447:9): [True: 0, False: 0]
  ------------------
 6448|      0|            ret = handle_gc_lossy_packet(c, chat, sender_pk, payload, payload_len, true, userdata);
 6449|      0|            break;
 6450|      0|        }
 6451|       |
 6452|      0|        case NET_PACKET_GC_HANDSHAKE: {
  ------------------
  |  Branch (6452:9): [True: 0, False: 0]
  ------------------
 6453|       |            // handshake packets have an extra public key in plaintext header
 6454|      0|            if (length <= 1 + ENC_PUBLIC_KEY_SIZE + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   27|      0|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
                          if (length <= 1 + ENC_PUBLIC_KEY_SIZE + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   27|      0|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
                          if (length <= 1 + ENC_PUBLIC_KEY_SIZE + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
                          if (length <= 1 + ENC_PUBLIC_KEY_SIZE + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (6454:17): [True: 0, False: 0]
  ------------------
 6455|      0|                return -1;
 6456|      0|            }
 6457|       |
 6458|      0|            payload_len = payload_len - ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |   27|      0|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 6459|      0|            payload = payload + ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |   27|      0|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 6460|       |
 6461|      0|            ret = handle_gc_handshake_packet(chat, sender_pk, ipp, payload, payload_len, true, userdata) != -1;
 6462|      0|            break;
 6463|      0|        }
 6464|       |
 6465|      0|        default: {
  ------------------
  |  Branch (6465:9): [True: 0, False: 0]
  ------------------
 6466|      0|            return -1;
 6467|      0|        }
 6468|      0|    }
 6469|       |
 6470|      0|    return ret ? 0 : -1;
  ------------------
  |  Branch (6470:12): [True: 0, False: 0]
  ------------------
 6471|      0|}

gca_onion_init:
   64|    935|{
   65|    935|    onion_announce_extra_data_callback(onion_a, GCA_MAX_SENT_ANNOUNCES * sizeof(GC_Announce), pack_group_announces,
  ------------------
  |  |   27|    935|#define GCA_MAX_SENT_ANNOUNCES 4
  ------------------
   66|    935|                                       group_announce);
   67|    935|}
group_onion_announce.c:pack_group_announces:
   21|     17|{
   22|     17|    GC_Announces_List *gc_announces_list = (GC_Announces_List *)object;
   23|     17|    GC_Public_Announce public_announce;
   24|       |
   25|     17|    if (gca_unpack_public_announce(logger, plain, plain_size,
  ------------------
  |  Branch (25:9): [True: 14, False: 3]
  ------------------
   26|     17|                                   &public_announce) == -1) {
   27|     14|        LOGGER_WARNING(logger, "Failed to unpack public group announce");
  ------------------
  |  |   82|     14|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     14|    do {                                                                         \
  |  |  |  |   73|     14|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     28|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     14|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     14|        }                                                                        \
  |  |  |  |   76|     14|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   28|     14|        return -1;
   29|     14|    }
   30|       |
   31|      3|    const GC_Peer_Announce *new_announce = gca_add_announce(mono_time, gc_announces_list, &public_announce);
   32|       |
   33|      3|    if (new_announce == nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (33:9): [True: 0, False: 3]
  ------------------
   34|      0|        LOGGER_ERROR(logger, "Failed to add group announce");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   35|      0|        return -1;
   36|      0|    }
   37|       |
   38|      3|    GC_Announce gc_announces[GCA_MAX_SENT_ANNOUNCES];
   39|      3|    const int num_ann = gca_get_announces(gc_announces_list,
   40|      3|                                          gc_announces,
   41|      3|                                          GCA_MAX_SENT_ANNOUNCES,
  ------------------
  |  |   27|      3|#define GCA_MAX_SENT_ANNOUNCES 4
  ------------------
   42|      3|                                          public_announce.chat_public_key,
   43|      3|                                          new_announce->base_announce.peer_public_key);
   44|       |
   45|      3|    if (num_ann < 0) {
  ------------------
  |  Branch (45:9): [True: 0, False: 3]
  ------------------
   46|      0|        LOGGER_ERROR(logger, "failed to get group announce");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   47|      0|        return -1;
   48|      0|    }
   49|       |
   50|      3|    assert(num_ann <= UINT8_MAX);
   51|       |
   52|      0|    size_t announces_length = 0;
   53|       |
   54|      3|    if (gca_pack_announces_list(logger, response + offset, response_size - offset, gc_announces, (uint8_t)num_ann,
  ------------------
  |  Branch (54:9): [True: 0, False: 3]
  ------------------
   55|      3|                                &announces_length) != num_ann) {
   56|      0|        LOGGER_WARNING(logger, "Failed to pack group announces list");
  ------------------
  |  |   82|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   57|      0|        return -1;
   58|      0|    }
   59|       |
   60|      3|    return announces_length;
   61|      3|}

bs_list_init:
  138|  1.09k|{
  139|       |    // set initial values
  140|  1.09k|    list->n = 0;
  141|  1.09k|    list->element_size = element_size;
  142|  1.09k|    list->capacity = 0;
  143|  1.09k|    list->data = nullptr;
  ------------------
  |  |   66|  1.09k|#define nullptr NULL
  ------------------
  144|  1.09k|    list->ids = nullptr;
  ------------------
  |  |   66|  1.09k|#define nullptr NULL
  ------------------
  145|       |
  146|  1.09k|    if (initial_capacity != 0) {
  ------------------
  |  Branch (146:9): [True: 1.09k, False: 0]
  ------------------
  147|  1.09k|        if (!resize(list, initial_capacity)) {
  ------------------
  |  Branch (147:13): [True: 0, False: 1.09k]
  ------------------
  148|      0|            return 0;
  149|      0|        }
  150|  1.09k|    }
  151|       |
  152|  1.09k|    list->capacity = initial_capacity;
  153|       |
  154|  1.09k|    return 1;
  155|  1.09k|}
bs_list_free:
  158|  1.09k|{
  159|  1.09k|    if (list == nullptr) {
  ------------------
  |  |   66|  1.09k|#define nullptr NULL
  ------------------
  |  Branch (159:9): [True: 0, False: 1.09k]
  ------------------
  160|      0|        return;
  161|      0|    }
  162|       |
  163|       |    // free both arrays
  164|  1.09k|    free(list->data);
  165|  1.09k|    list->data = nullptr;
  ------------------
  |  |   66|  1.09k|#define nullptr NULL
  ------------------
  166|       |
  167|  1.09k|    free(list->ids);
  168|  1.09k|    list->ids = nullptr;
  ------------------
  |  |   66|  1.09k|#define nullptr NULL
  ------------------
  169|  1.09k|}
bs_list_find:
  172|    168|{
  173|    168|    const int r = find(list, data);
  174|       |
  175|       |    // return only -1 and positive values
  176|    168|    if (r < 0) {
  ------------------
  |  Branch (176:9): [True: 166, False: 2]
  ------------------
  177|    166|        return -1;
  178|    166|    }
  179|       |
  180|      2|    return list->ids[r];
  181|    168|}
bs_list_add:
  184|    103|{
  185|       |    // find where the new element should be inserted
  186|       |    // see: return value of find()
  187|    103|    int i = find(list, data);
  188|       |
  189|    103|    if (i >= 0) {
  ------------------
  |  Branch (189:9): [True: 0, False: 103]
  ------------------
  190|       |        // already in list
  191|      0|        return false;
  192|      0|    }
  193|       |
  194|    103|    i = ~i;
  195|       |
  196|       |    // increase the size of the arrays if needed
  197|    103|    if (list->n == list->capacity) {
  ------------------
  |  Branch (197:9): [True: 0, False: 103]
  ------------------
  198|       |        // 1.5 * n + 1
  199|      0|        const uint32_t new_capacity = list->n + list->n / 2 + 1;
  200|       |
  201|      0|        if (!resize(list, new_capacity)) {
  ------------------
  |  Branch (201:13): [True: 0, False: 0]
  ------------------
  202|      0|            return false;
  203|      0|        }
  204|       |
  205|      0|        list->capacity = new_capacity;
  206|      0|    }
  207|       |
  208|       |    // insert data to element array
  209|    103|    memmove(list->data + (i + 1) * list->element_size, list->data + i * list->element_size,
  210|    103|            (list->n - i) * list->element_size);
  211|    103|    memcpy(list->data + i * list->element_size, data, list->element_size);
  212|       |
  213|       |    // insert id to id array
  214|    103|    memmove(&list->ids[i + 1], &list->ids[i], (list->n - i) * sizeof(int));
  215|    103|    list->ids[i] = id;
  216|       |
  217|       |    // increase n
  218|    103|    ++list->n;
  219|       |
  220|    103|    return true;
  221|    103|}
bs_list_remove:
  224|     79|{
  225|     79|    const int i = find(list, data);
  226|       |
  227|     79|    if (i < 0) {
  ------------------
  |  Branch (227:9): [True: 2, False: 77]
  ------------------
  228|      2|        return false;
  229|      2|    }
  230|       |
  231|     77|    if (list->ids[i] != id) {
  ------------------
  |  Branch (231:9): [True: 0, False: 77]
  ------------------
  232|       |        // this should never happen
  233|      0|        return false;
  234|      0|    }
  235|       |
  236|       |    // decrease the size of the arrays if needed
  237|     77|    if (list->n < list->capacity / 2) {
  ------------------
  |  Branch (237:9): [True: 58, False: 19]
  ------------------
  238|     58|        const uint32_t new_capacity = list->capacity / 2;
  239|       |
  240|     58|        if (resize(list, new_capacity)) {
  ------------------
  |  Branch (240:13): [True: 58, False: 0]
  ------------------
  241|     58|            list->capacity = new_capacity;
  242|     58|        }
  243|     58|    }
  244|       |
  245|     77|    --list->n;
  246|       |
  247|     77|    memmove(list->data + i * list->element_size, list->data + (i + 1) * list->element_size,
  248|     77|            (list->n - i) * list->element_size);
  249|     77|    memmove(&list->ids[i], &list->ids[i + 1], (list->n - i) * sizeof(int));
  250|       |
  251|     77|    return true;
  252|     77|}
list.c:resize:
  111|  1.14k|{
  112|  1.14k|    if (new_size == 0) {
  ------------------
  |  Branch (112:9): [True: 0, False: 1.14k]
  ------------------
  113|      0|        bs_list_free(list);
  114|      0|        return true;
  115|      0|    }
  116|       |
  117|  1.14k|    uint8_t *data = (uint8_t *)realloc(list->data, list->element_size * new_size);
  118|       |
  119|  1.14k|    if (data == nullptr) {
  ------------------
  |  |   66|  1.14k|#define nullptr NULL
  ------------------
  |  Branch (119:9): [True: 0, False: 1.14k]
  ------------------
  120|      0|        return false;
  121|      0|    }
  122|       |
  123|  1.14k|    list->data = data;
  124|       |
  125|  1.14k|    int *ids = (int *)realloc(list->ids, sizeof(int) * new_size);
  126|       |
  127|  1.14k|    if (ids == nullptr) {
  ------------------
  |  |   66|  1.14k|#define nullptr NULL
  ------------------
  |  Branch (127:9): [True: 0, False: 1.14k]
  ------------------
  128|      0|        return false;
  129|      0|    }
  130|       |
  131|  1.14k|    list->ids = ids;
  132|       |
  133|  1.14k|    return true;
  134|  1.14k|}
list.c:find:
   45|    350|{
   46|       |    // should work well, but could be improved
   47|    350|    if (list->n == 0) {
  ------------------
  |  Branch (47:9): [True: 201, False: 149]
  ------------------
   48|    201|        return list_index(0);
   49|    201|    }
   50|       |
   51|    149|    uint32_t i = list->n / 2; // current position in the array
   52|    149|    uint32_t delta = i / 2;   // how much we move in the array
   53|       |
   54|    149|    if (delta == 0) {
  ------------------
  |  Branch (54:9): [True: 149, False: 0]
  ------------------
   55|    149|        delta = 1;
   56|    149|    }
   57|       |
   58|    149|    int d = -1; // used to determine if closest match is found
   59|       |    // closest match is found if we move back to where we have already been
   60|       |
   61|    179|    while (true) {
   62|    179|        const int r = memcmp(data, list->data + list->element_size * i, list->element_size);
   63|       |
   64|    179|        if (r == 0) {
  ------------------
  |  Branch (64:13): [True: 79, False: 100]
  ------------------
   65|     79|            return i;
   66|     79|        }
   67|       |
   68|    100|        if (r > 0) {
  ------------------
  |  Branch (68:13): [True: 45, False: 55]
  ------------------
   69|       |            // data is greater
   70|       |            // move down
   71|     45|            i += delta;
   72|       |
   73|     45|            if (d == 0 || i == list->n) {
  ------------------
  |  Branch (73:17): [True: 13, False: 32]
  |  Branch (73:27): [True: 27, False: 5]
  ------------------
   74|       |                // reached bottom of list, or closest match
   75|     40|                return list_index(i);
   76|     40|            }
   77|       |
   78|      5|            delta = delta / 2;
   79|       |
   80|      5|            if (delta == 0) {
  ------------------
  |  Branch (80:17): [True: 5, False: 0]
  ------------------
   81|      5|                delta = 1;
   82|      5|                d = 1;
   83|      5|            }
   84|     55|        } else {
   85|       |            // data is smaller
   86|     55|            if (d == 1 || i == 0) {
  ------------------
  |  Branch (86:17): [True: 0, False: 55]
  |  Branch (86:27): [True: 30, False: 25]
  ------------------
   87|       |                // reached top or list or closest match
   88|     30|                return list_index(i);
   89|     30|            }
   90|       |
   91|       |            // move up
   92|     25|            i -= delta;
   93|       |
   94|     25|            delta = delta / 2;
   95|       |
   96|     25|            if (delta == 0) {
  ------------------
  |  Branch (96:17): [True: 25, False: 0]
  ------------------
   97|     25|                delta = 1;
   98|     25|                d = 0;
   99|     25|            }
  100|     25|        }
  101|    100|    }
  102|    149|}
list.c:list_index:
   33|    271|{
   34|    271|    return ~i;
   35|    271|}

logger_new:
   72|    964|{
   73|    964|    return (Logger *)calloc(1, sizeof(Logger));
   74|    964|}
logger_kill:
   77|    964|{
   78|    964|    free(log);
   79|    964|}
logger_callback_log:
   82|    964|{
   83|    964|    log->callback = function;
   84|    964|    log->context  = context;
   85|    964|    log->userdata = userdata;
   86|    964|}
logger_write:
   90|  16.9k|{
   91|  16.9k|    if (log == nullptr) {
  ------------------
  |  |   66|  16.9k|#define nullptr NULL
  ------------------
  |  Branch (91:9): [True: 0, False: 16.9k]
  ------------------
   92|      0|        log = &logger_stderr;
   93|      0|    }
   94|       |
   95|  16.9k|    if (log->callback == nullptr) {
  ------------------
  |  |   66|  16.9k|#define nullptr NULL
  ------------------
  |  Branch (95:9): [True: 0, False: 16.9k]
  ------------------
   96|      0|        return;
   97|      0|    }
   98|       |
   99|       |    // Only pass the file name, not the entire file path, for privacy reasons.
  100|       |    // The full path may contain PII of the person compiling toxcore (their
  101|       |    // username and directory layout).
  102|  16.9k|    const char *filename = strrchr(file, '/');
  103|  16.9k|    file = filename != nullptr ? filename + 1 : file;
  ------------------
  |  |   66|  16.9k|#define nullptr NULL
  ------------------
  |  Branch (103:12): [True: 16.9k, False: 0]
  ------------------
  104|       |#if defined(_WIN32) || defined(__CYGWIN__)
  105|       |    // On Windows, the path separator *may* be a backslash, so we look for that
  106|       |    // one too.
  107|       |    const char *windows_filename = strrchr(file, '\\');
  108|       |    file = windows_filename != nullptr ? windows_filename + 1 : file;
  109|       |#endif
  110|       |
  111|       |    // Format message
  112|  16.9k|    char msg[1024];
  113|  16.9k|    va_list args;
  114|  16.9k|    va_start(args, format);
  115|  16.9k|    vsnprintf(msg, sizeof(msg), format, args);
  116|  16.9k|    va_end(args);
  117|       |
  118|  16.9k|    log->callback(log->context, level, file, line, func, msg, log->userdata);
  119|  16.9k|}

system_memory:
   45|    968|{
   46|    968|    return &system_memory_obj;
   47|    968|}
mem_balloc:
   50|   147k|{
   51|   147k|    void *const ptr = mem->funcs->malloc(mem->obj, size);
   52|   147k|    return ptr;
   53|   147k|}
mem_alloc:
   56|  23.5k|{
   57|  23.5k|    void *const ptr = mem->funcs->calloc(mem->obj, 1, size);
   58|  23.5k|    return ptr;
   59|  23.5k|}
mem_valloc:
   62|  27.6k|{
   63|  27.6k|    const uint32_t bytes = nmemb * size;
   64|       |
   65|  27.6k|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (65:9): [True: 27.6k, False: 0]
  |  Branch (65:22): [True: 0, False: 27.6k]
  ------------------
   66|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   67|      0|    }
   68|       |
   69|  27.6k|    void *const ptr = mem->funcs->calloc(mem->obj, nmemb, size);
   70|  27.6k|    return ptr;
   71|  27.6k|}
mem_vrealloc:
   74|  11.1k|{
   75|  11.1k|    const uint32_t bytes = nmemb * size;
   76|       |
   77|  11.1k|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (77:9): [True: 11.1k, False: 0]
  |  Branch (77:22): [True: 0, False: 11.1k]
  ------------------
   78|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   79|      0|    }
   80|       |
   81|  11.1k|    void *const new_ptr = mem->funcs->realloc(mem->obj, ptr, bytes);
   82|  11.1k|    return new_ptr;
   83|  11.1k|}
mem_delete:
   86|   204k|{
   87|   204k|    mem->funcs->free(mem->obj, ptr);
   88|   204k|}

mono_time_new:
  126|    967|{
  127|    967|    Mono_Time *mono_time = (Mono_Time *)mem_alloc(mem, sizeof(Mono_Time));
  128|       |
  129|    967|    if (mono_time == nullptr) {
  ------------------
  |  |   66|    967|#define nullptr NULL
  ------------------
  |  Branch (129:9): [True: 1, False: 966]
  ------------------
  130|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  131|      1|    }
  132|       |
  133|    966|#ifndef ESP_PLATFORM
  134|    966|    mono_time->time_update_lock = (pthread_rwlock_t *)mem_alloc(mem, sizeof(pthread_rwlock_t));
  135|       |
  136|    966|    if (mono_time->time_update_lock == nullptr) {
  ------------------
  |  |   66|    966|#define nullptr NULL
  ------------------
  |  Branch (136:9): [True: 1, False: 965]
  ------------------
  137|      1|        mem_delete(mem, mono_time);
  138|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  139|      1|    }
  140|       |
  141|    965|    if (pthread_rwlock_init(mono_time->time_update_lock, nullptr) != 0) {
  ------------------
  |  |   66|    965|#define nullptr NULL
  ------------------
  |  Branch (141:9): [True: 0, False: 965]
  ------------------
  142|      0|        mem_delete(mem, mono_time->time_update_lock);
  143|      0|        mem_delete(mem, mono_time);
  144|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  145|      0|    }
  146|    965|#endif
  147|       |
  148|    965|    mono_time_set_current_time_callback(mono_time, current_time_callback, user_data);
  149|       |
  150|       |#ifdef OS_WIN32
  151|       |
  152|       |    mono_time->last_clock_mono = 0;
  153|       |    mono_time->last_clock_update = false;
  154|       |
  155|       |    if (pthread_mutex_init(&mono_time->last_clock_lock, nullptr) < 0) {
  156|       |        mem_delete(mem, mono_time->time_update_lock);
  157|       |        mem_delete(mem, mono_time);
  158|       |        return nullptr;
  159|       |    }
  160|       |
  161|       |#endif
  162|       |
  163|    965|    mono_time->cur_time = 0;
  164|    965|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  165|       |    // Maximum reproducibility. Never return time = 0.
  166|    965|    mono_time->base_time = 1;
  167|       |#else
  168|       |    mono_time->base_time = (uint64_t)time(nullptr) * 1000ULL - current_time_monotonic(mono_time);
  169|       |#endif
  170|       |
  171|    965|    mono_time_update(mono_time);
  172|       |
  173|    965|    return mono_time;
  174|    965|}
mono_time_free:
  177|    965|{
  178|    965|    if (mono_time == nullptr) {
  ------------------
  |  |   66|    965|#define nullptr NULL
  ------------------
  |  Branch (178:9): [True: 0, False: 965]
  ------------------
  179|      0|        return;
  180|      0|    }
  181|       |#ifdef OS_WIN32
  182|       |    pthread_mutex_destroy(&mono_time->last_clock_lock);
  183|       |#endif
  184|    965|#ifndef ESP_PLATFORM
  185|    965|    pthread_rwlock_destroy(mono_time->time_update_lock);
  186|    965|    mem_delete(mem, mono_time->time_update_lock);
  187|    965|#endif
  188|    965|    mem_delete(mem, mono_time);
  189|    965|}
mono_time_update:
  192|  73.6k|{
  193|       |#ifdef OS_WIN32
  194|       |    /* we actually want to update the overflow state of mono_time here */
  195|       |    pthread_mutex_lock(&mono_time->last_clock_lock);
  196|       |    mono_time->last_clock_update = true;
  197|       |#endif
  198|  73.6k|    const uint64_t cur_time =
  199|  73.6k|        mono_time->base_time + mono_time->current_time_callback(mono_time->user_data);
  200|       |#ifdef OS_WIN32
  201|       |    pthread_mutex_unlock(&mono_time->last_clock_lock);
  202|       |#endif
  203|       |
  204|  73.6k|#ifndef ESP_PLATFORM
  205|  73.6k|    pthread_rwlock_wrlock(mono_time->time_update_lock);
  206|  73.6k|#endif
  207|  73.6k|    mono_time->cur_time = cur_time;
  208|  73.6k|#ifndef ESP_PLATFORM
  209|  73.6k|    pthread_rwlock_unlock(mono_time->time_update_lock);
  210|  73.6k|#endif
  211|  73.6k|}
mono_time_get_ms:
  214|  5.22M|{
  215|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  216|       |    // Fuzzing is only single thread for now, no locking needed */
  217|       |    pthread_rwlock_rdlock(mono_time->time_update_lock);
  218|       |#endif
  219|  5.22M|    const uint64_t cur_time = mono_time->cur_time;
  220|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  221|       |    pthread_rwlock_unlock(mono_time->time_update_lock);
  222|       |#endif
  223|  5.22M|    return cur_time;
  224|  5.22M|}
mono_time_get:
  227|  5.22M|{
  228|  5.22M|    return mono_time_get_ms(mono_time) / 1000ULL;
  229|  5.22M|}
mono_time_is_timeout:
  232|  4.78M|{
  233|  4.78M|    return timestamp + timeout <= mono_time_get(mono_time);
  234|  4.78M|}
mono_time_set_current_time_callback:
  238|    965|{
  239|    965|    if (current_time_callback == nullptr) {
  ------------------
  |  |   66|    965|#define nullptr NULL
  ------------------
  |  Branch (239:9): [True: 0, False: 965]
  ------------------
  240|      0|        mono_time->current_time_callback = current_time_monotonic_default;
  241|      0|        mono_time->user_data = mono_time;
  242|    965|    } else {
  243|    965|        mono_time->current_time_callback = current_time_callback;
  244|    965|        mono_time->user_data = user_data;
  245|    965|    }
  246|    965|}
current_time_monotonic:
  254|  72.6k|{
  255|       |    /* For WIN32 we don't want to change overflow state of mono_time here */
  256|       |#ifdef OS_WIN32
  257|       |    /* We don't want to update the overflow state of mono_time here,
  258|       |     * but must protect against other threads */
  259|       |    pthread_mutex_lock(&mono_time->last_clock_lock);
  260|       |#endif
  261|  72.6k|    const uint64_t cur_time = mono_time->current_time_callback(mono_time->user_data);
  262|       |#ifdef OS_WIN32
  263|       |    pthread_mutex_unlock(&mono_time->last_clock_lock);
  264|       |#endif
  265|  72.6k|    return cur_time;
  266|  72.6k|}

nc_get_self_public_key:
  163|    244|{
  164|    244|    return c->self_public_key;
  165|    244|}
nc_get_self_secret_key:
  168|    241|{
  169|    241|    return c->self_secret_key;
  170|    241|}
nc_get_tcp_c:
  173|  16.1k|{
  174|  16.1k|    return c->tcp_c;
  175|  16.1k|}
nc_get_dht:
  178|    943|{
  179|    943|    return c->dht;
  180|    943|}
new_connection_handler:
 2005|    943|{
 2006|    943|    c->new_connection_callback = new_connection_callback;
 2007|    943|    c->new_connection_callback_object = object;
 2008|    943|}
new_crypto_connection:
 2142|      1|{
 2143|      1|    int crypt_connection_id = getcryptconnection_id(c, real_public_key);
 2144|       |
 2145|      1|    if (crypt_connection_id != -1) {
  ------------------
  |  Branch (2145:9): [True: 0, False: 1]
  ------------------
 2146|      0|        return crypt_connection_id;
 2147|      0|    }
 2148|       |
 2149|      1|    crypt_connection_id = create_crypto_connection(c);
 2150|       |
 2151|      1|    if (crypt_connection_id == -1) {
  ------------------
  |  Branch (2151:9): [True: 0, False: 1]
  ------------------
 2152|      0|        return -1;
 2153|      0|    }
 2154|       |
 2155|      1|    Crypto_Connection *conn = &c->crypto_connections[crypt_connection_id];
 2156|       |
 2157|      1|    pthread_mutex_lock(&c->tcp_mutex);
 2158|      1|    const int connection_number_tcp = new_tcp_connection_to(c->tcp_c, dht_public_key, crypt_connection_id);
 2159|      1|    pthread_mutex_unlock(&c->tcp_mutex);
 2160|       |
 2161|      1|    if (connection_number_tcp == -1) {
  ------------------
  |  Branch (2161:9): [True: 0, False: 1]
  ------------------
 2162|      0|        wipe_crypto_connection(c, crypt_connection_id);
 2163|      0|        return -1;
 2164|      0|    }
 2165|       |
 2166|      1|    conn->connection_number_tcp = connection_number_tcp;
 2167|      1|    memcpy(conn->public_key, real_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2168|      1|    random_nonce(c->rng, conn->sent_nonce);
 2169|      1|    crypto_new_keypair(c->rng, conn->sessionpublic_key, conn->sessionsecret_key);
 2170|      1|    conn->status = CRYPTO_CONN_COOKIE_REQUESTING;
 2171|      1|    conn->packet_send_rate = CRYPTO_PACKET_MIN_RATE;
  ------------------
  |  |   74|      1|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
 2172|      1|    conn->packet_send_rate_requested = CRYPTO_PACKET_MIN_RATE;
  ------------------
  |  |   74|      1|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
 2173|      1|    conn->packets_left = CRYPTO_MIN_QUEUE_LENGTH;
  ------------------
  |  |   77|      1|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
 2174|      1|    conn->rtt_time = DEFAULT_PING_CONNECTION;
  ------------------
  |  |  113|      1|#define DEFAULT_PING_CONNECTION 1000
  ------------------
 2175|      1|    memcpy(conn->dht_public_key, dht_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2176|       |
 2177|      1|    conn->cookie_request_number = random_u64(c->rng);
 2178|      1|    uint8_t cookie_request[COOKIE_REQUEST_LENGTH];
 2179|       |
 2180|      1|    if (create_cookie_request(c, cookie_request, conn->dht_public_key, conn->cookie_request_number,
  ------------------
  |  Branch (2180:9): [True: 0, False: 1]
  ------------------
 2181|      1|                              conn->shared_key) != sizeof(cookie_request)
 2182|      1|            || new_temp_packet(c, crypt_connection_id, cookie_request, sizeof(cookie_request)) != 0) {
  ------------------
  |  Branch (2182:16): [True: 0, False: 1]
  ------------------
 2183|      0|        pthread_mutex_lock(&c->tcp_mutex);
 2184|      0|        kill_tcp_connection_to(c->tcp_c, conn->connection_number_tcp);
 2185|      0|        pthread_mutex_unlock(&c->tcp_mutex);
 2186|      0|        wipe_crypto_connection(c, crypt_connection_id);
 2187|      0|        return -1;
 2188|      0|    }
 2189|       |
 2190|      1|    return crypt_connection_id;
 2191|      1|}
add_tcp_relay:
 2310|    545|{
 2311|    545|    pthread_mutex_lock(&c->tcp_mutex);
 2312|    545|    const int ret = add_tcp_relay_global(c->tcp_c, ip_port, public_key);
 2313|    545|    pthread_mutex_unlock(&c->tcp_mutex);
 2314|    545|    return ret;
 2315|    545|}
connection_status_handler:
 2457|      1|{
 2458|      1|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 2459|       |
 2460|      1|    if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (2460:9): [True: 0, False: 1]
  ------------------
 2461|      0|        return -1;
 2462|      0|    }
 2463|       |
 2464|      1|    conn->connection_status_callback = connection_status_callback;
 2465|      1|    conn->connection_status_callback_object = object;
 2466|      1|    conn->connection_status_callback_id = id;
 2467|      1|    return 0;
 2468|      1|}
connection_data_handler:
 2480|      1|{
 2481|      1|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 2482|       |
 2483|      1|    if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (2483:9): [True: 0, False: 1]
  ------------------
 2484|      0|        return -1;
 2485|      0|    }
 2486|       |
 2487|      1|    conn->connection_data_callback = connection_data_callback;
 2488|      1|    conn->connection_data_callback_object = object;
 2489|      1|    conn->connection_data_callback_id = id;
 2490|      1|    return 0;
 2491|      1|}
connection_lossy_data_handler:
 2504|      1|{
 2505|      1|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 2506|       |
 2507|      1|    if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (2507:9): [True: 0, False: 1]
  ------------------
 2508|      0|        return -1;
 2509|      0|    }
 2510|       |
 2511|      1|    conn->connection_lossy_data_callback = connection_lossy_data_callback;
 2512|      1|    conn->connection_lossy_data_callback_object = object;
 2513|      1|    conn->connection_lossy_data_callback_id = id;
 2514|      1|    return 0;
 2515|      1|}
nc_dht_pk_callback:
 2529|      1|{
 2530|      1|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 2531|       |
 2532|      1|    if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (2532:9): [True: 0, False: 1]
  ------------------
 2533|      0|        return -1;
 2534|      0|    }
 2535|       |
 2536|      1|    conn->dht_pk_callback = function;
 2537|      1|    conn->dht_pk_callback_object = object;
 2538|      1|    conn->dht_pk_callback_number = number;
 2539|      1|    return 0;
 2540|      1|}
crypto_kill:
 3030|    121|{
 3031|    121|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 3032|       |
 3033|    121|    int ret = -1;
 3034|       |
 3035|    121|    if (conn != nullptr) {
  ------------------
  |  |   66|    121|#define nullptr NULL
  ------------------
  |  Branch (3035:9): [True: 1, False: 120]
  ------------------
 3036|      1|        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
  ------------------
  |  Branch (3036:13): [True: 0, False: 1]
  ------------------
 3037|      0|            send_kill_packet(c, crypt_connection_id);
 3038|      0|        }
 3039|       |
 3040|      1|        pthread_mutex_lock(&c->tcp_mutex);
 3041|      1|        kill_tcp_connection_to(c->tcp_c, conn->connection_number_tcp);
 3042|      1|        pthread_mutex_unlock(&c->tcp_mutex);
 3043|       |
 3044|      1|        bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv4, crypt_connection_id);
 3045|      1|        bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv6, crypt_connection_id);
 3046|      1|        clear_temp_packet(c, crypt_connection_id);
 3047|      1|        clear_buffer(c->mem, &conn->send_array);
 3048|      1|        clear_buffer(c->mem, &conn->recv_array);
 3049|      1|        ret = wipe_crypto_connection(c, crypt_connection_id);
 3050|      1|    }
 3051|       |
 3052|    121|    return ret;
 3053|    121|}
new_keys:
 3083|    946|{
 3084|    946|    crypto_new_keypair(c->rng, c->self_public_key, c->self_secret_key);
 3085|    946|}
new_net_crypto:
 3112|    948|{
 3113|    948|    if (dht == nullptr) {
  ------------------
  |  |   66|    948|#define nullptr NULL
  ------------------
  |  Branch (3113:9): [True: 0, False: 948]
  ------------------
 3114|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3115|      0|    }
 3116|       |
 3117|    948|    Net_Crypto *temp = (Net_Crypto *)mem_alloc(mem, sizeof(Net_Crypto));
 3118|       |
 3119|    948|    if (temp == nullptr) {
  ------------------
  |  |   66|    948|#define nullptr NULL
  ------------------
  |  Branch (3119:9): [True: 1, False: 947]
  ------------------
 3120|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 3121|      1|    }
 3122|       |
 3123|    947|    temp->log = log;
 3124|    947|    temp->mem = mem;
 3125|    947|    temp->rng = rng;
 3126|    947|    temp->mono_time = mono_time;
 3127|    947|    temp->ns = ns;
 3128|       |
 3129|    947|    temp->tcp_c = new_tcp_connections(log, mem, rng, ns, mono_time, dht_get_self_secret_key(dht), proxy_info);
 3130|       |
 3131|    947|    if (temp->tcp_c == nullptr) {
  ------------------
  |  |   66|    947|#define nullptr NULL
  ------------------
  |  Branch (3131:9): [True: 1, False: 946]
  ------------------
 3132|      1|        mem_delete(mem, temp);
 3133|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 3134|      1|    }
 3135|       |
 3136|    946|    set_packet_tcp_connection_callback(temp->tcp_c, &tcp_data_callback, temp);
 3137|    946|    set_oob_packet_tcp_connection_callback(temp->tcp_c, &tcp_oob_callback, temp);
 3138|       |
 3139|    946|    if (create_recursive_mutex(&temp->tcp_mutex) != 0 ||
  ------------------
  |  Branch (3139:9): [True: 0, False: 946]
  ------------------
 3140|    946|            pthread_mutex_init(&temp->connections_mutex, nullptr) != 0) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (3140:13): [True: 0, False: 946]
  ------------------
 3141|      0|        kill_tcp_connections(temp->tcp_c);
 3142|      0|        mem_delete(mem, temp);
 3143|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3144|      0|    }
 3145|       |
 3146|    946|    temp->dht = dht;
 3147|       |
 3148|    946|    new_keys(temp);
 3149|    946|    new_symmetric_key(rng, temp->secret_symmetric_key);
 3150|       |
 3151|    946|    temp->current_sleep_time = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |   88|    946|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 3152|       |
 3153|    946|    networking_registerhandler(dht_get_net(dht), NET_PACKET_COOKIE_REQUEST, &udp_handle_cookie_request, temp);
 3154|    946|    networking_registerhandler(dht_get_net(dht), NET_PACKET_COOKIE_RESPONSE, &udp_handle_packet, temp);
 3155|    946|    networking_registerhandler(dht_get_net(dht), NET_PACKET_CRYPTO_HS, &udp_handle_packet, temp);
 3156|    946|    networking_registerhandler(dht_get_net(dht), NET_PACKET_CRYPTO_DATA, &udp_handle_packet, temp);
 3157|       |
 3158|    946|    bs_list_init(&temp->ip_port_list, sizeof(IP_Port), 8);
 3159|       |
 3160|    946|    return temp;
 3161|    946|}
do_net_crypto:
 3201|  72.6k|{
 3202|  72.6k|    kill_timedout(c, userdata);
 3203|  72.6k|    do_tcp(c, userdata);
 3204|  72.6k|    send_crypto_packets(c);
 3205|  72.6k|}
kill_net_crypto:
 3208|    946|{
 3209|    946|    if (c == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (3209:9): [True: 0, False: 946]
  ------------------
 3210|      0|        return;
 3211|      0|    }
 3212|       |
 3213|    946|    const Memory *mem = c->mem;
 3214|       |
 3215|    946|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (3215:26): [True: 0, False: 946]
  ------------------
 3216|      0|        crypto_kill(c, i);
 3217|      0|    }
 3218|       |
 3219|    946|    pthread_mutex_destroy(&c->tcp_mutex);
 3220|    946|    pthread_mutex_destroy(&c->connections_mutex);
 3221|       |
 3222|    946|    kill_tcp_connections(c->tcp_c);
 3223|    946|    bs_list_free(&c->ip_port_list);
 3224|    946|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
 3225|    946|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
 3226|    946|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
 3227|    946|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
 3228|    946|    crypto_memzero(c, sizeof(Net_Crypto));
 3229|    946|    mem_delete(mem, c);
 3230|    946|}
net_crypto.c:getcryptconnection_id:
 1942|      1|{
 1943|      1|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (1943:26): [True: 0, False: 1]
  ------------------
 1944|      0|        if (!crypt_connection_id_is_valid(c, i)) {
  ------------------
  |  Branch (1944:13): [True: 0, False: 0]
  ------------------
 1945|      0|            continue;
 1946|      0|        }
 1947|       |
 1948|      0|        if (pk_equal(public_key, c->crypto_connections[i].public_key)) {
  ------------------
  |  Branch (1948:13): [True: 0, False: 0]
  ------------------
 1949|      0|            return i;
 1950|      0|        }
 1951|      0|    }
 1952|       |
 1953|      1|    return -1;
 1954|      1|}
net_crypto.c:crypt_connection_id_is_valid:
  184|    133|{
  185|    133|    if ((uint32_t)crypt_connection_id >= c->crypto_connections_length) {
  ------------------
  |  Branch (185:9): [True: 120, False: 13]
  ------------------
  186|    120|        return false;
  187|    120|    }
  188|       |
  189|     13|    if (c->crypto_connections == nullptr) {
  ------------------
  |  |   66|     13|#define nullptr NULL
  ------------------
  |  Branch (189:9): [True: 0, False: 13]
  ------------------
  190|      0|        return false;
  191|      0|    }
  192|       |
  193|     13|    const Crypto_Conn_State status = c->crypto_connections[crypt_connection_id].status;
  194|       |
  195|     13|    return status != CRYPTO_CONN_NO_CONNECTION && status != CRYPTO_CONN_FREE;
  ------------------
  |  Branch (195:12): [True: 13, False: 0]
  |  Branch (195:51): [True: 13, False: 0]
  ------------------
  196|     13|}
net_crypto.c:create_crypto_connection:
 1837|      1|{
 1838|      1|    while (true) { /* TODO(irungentoo): is this really the best way to do this? */
 1839|      1|        pthread_mutex_lock(&c->connections_mutex);
 1840|       |
 1841|      1|        if (c->connection_use_counter == 0) {
  ------------------
  |  Branch (1841:13): [True: 1, False: 0]
  ------------------
 1842|      1|            break;
 1843|      1|        }
 1844|       |
 1845|      0|        pthread_mutex_unlock(&c->connections_mutex);
 1846|      0|    }
 1847|       |
 1848|      1|    int id = -1;
 1849|       |
 1850|      1|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (1850:26): [True: 0, False: 1]
  ------------------
 1851|      0|        if (c->crypto_connections[i].status == CRYPTO_CONN_FREE) {
  ------------------
  |  Branch (1851:13): [True: 0, False: 0]
  ------------------
 1852|      0|            id = i;
 1853|      0|            break;
 1854|      0|        }
 1855|      0|    }
 1856|       |
 1857|      1|    if (id == -1) {
  ------------------
  |  Branch (1857:9): [True: 1, False: 0]
  ------------------
 1858|      1|        if (realloc_cryptoconnection(c, c->crypto_connections_length + 1) == 0) {
  ------------------
  |  Branch (1858:13): [True: 1, False: 0]
  ------------------
 1859|      1|            id = c->crypto_connections_length;
 1860|      1|            ++c->crypto_connections_length;
 1861|      1|            c->crypto_connections[id] = empty_crypto_connection;
 1862|      1|        }
 1863|      1|    }
 1864|       |
 1865|      1|    if (id != -1) {
  ------------------
  |  Branch (1865:9): [True: 1, False: 0]
  ------------------
 1866|       |        // Memsetting float/double to 0 is non-portable, so we explicitly set them to 0
 1867|      1|        c->crypto_connections[id].packet_recv_rate = 0;
 1868|      1|        c->crypto_connections[id].packet_send_rate = 0;
 1869|      1|        c->crypto_connections[id].last_packets_left_rem = 0;
 1870|      1|        c->crypto_connections[id].packet_send_rate_requested = 0;
 1871|      1|        c->crypto_connections[id].last_packets_left_requested_rem = 0;
 1872|      1|        c->crypto_connections[id].mutex = (pthread_mutex_t *)mem_alloc(c->mem, sizeof(pthread_mutex_t));
 1873|       |
 1874|      1|        if (c->crypto_connections[id].mutex == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1874:13): [True: 0, False: 1]
  ------------------
 1875|      0|            pthread_mutex_unlock(&c->connections_mutex);
 1876|      0|            return -1;
 1877|      0|        }
 1878|       |
 1879|      1|        if (pthread_mutex_init(c->crypto_connections[id].mutex, nullptr) != 0) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1879:13): [True: 0, False: 1]
  ------------------
 1880|      0|            mem_delete(c->mem, c->crypto_connections[id].mutex);
 1881|      0|            pthread_mutex_unlock(&c->connections_mutex);
 1882|      0|            return -1;
 1883|      0|        }
 1884|       |
 1885|      1|        c->crypto_connections[id].status = CRYPTO_CONN_NO_CONNECTION;
 1886|      1|    }
 1887|       |
 1888|      1|    pthread_mutex_unlock(&c->connections_mutex);
 1889|      1|    return id;
 1890|      1|}
net_crypto.c:realloc_cryptoconnection:
 1811|      2|{
 1812|      2|    if (num == 0) {
  ------------------
  |  Branch (1812:9): [True: 1, False: 1]
  ------------------
 1813|      1|        mem_delete(c->mem, c->crypto_connections);
 1814|      1|        c->crypto_connections = nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 1815|      1|        return 0;
 1816|      1|    }
 1817|       |
 1818|      1|    Crypto_Connection *newcrypto_connections = (Crypto_Connection *)mem_vrealloc(
 1819|      1|            c->mem, c->crypto_connections, num, sizeof(Crypto_Connection));
 1820|       |
 1821|      1|    if (newcrypto_connections == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1821:9): [True: 0, False: 1]
  ------------------
 1822|      0|        return -1;
 1823|      0|    }
 1824|       |
 1825|      1|    c->crypto_connections = newcrypto_connections;
 1826|      1|    return 0;
 1827|      1|}
net_crypto.c:wipe_crypto_connection:
 1899|      1|{
 1900|      1|    if ((uint32_t)crypt_connection_id >= c->crypto_connections_length) {
  ------------------
  |  Branch (1900:9): [True: 0, False: 1]
  ------------------
 1901|      0|        return -1;
 1902|      0|    }
 1903|       |
 1904|      1|    if (c->crypto_connections == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1904:9): [True: 0, False: 1]
  ------------------
 1905|      0|        return -1;
 1906|      0|    }
 1907|       |
 1908|      1|    const Crypto_Conn_State status = c->crypto_connections[crypt_connection_id].status;
 1909|       |
 1910|      1|    if (status == CRYPTO_CONN_FREE) {
  ------------------
  |  Branch (1910:9): [True: 0, False: 1]
  ------------------
 1911|      0|        return -1;
 1912|      0|    }
 1913|       |
 1914|      1|    uint32_t i;
 1915|       |
 1916|      1|    pthread_mutex_destroy(c->crypto_connections[crypt_connection_id].mutex);
 1917|      1|    mem_delete(c->mem, c->crypto_connections[crypt_connection_id].mutex);
 1918|      1|    crypto_memzero(&c->crypto_connections[crypt_connection_id], sizeof(Crypto_Connection));
 1919|       |
 1920|       |    /* check if we can resize the connections array */
 1921|      2|    for (i = c->crypto_connections_length; i != 0; --i) {
  ------------------
  |  Branch (1921:44): [True: 1, False: 1]
  ------------------
 1922|      1|        if (c->crypto_connections[i - 1].status != CRYPTO_CONN_FREE) {
  ------------------
  |  Branch (1922:13): [True: 0, False: 1]
  ------------------
 1923|      0|            break;
 1924|      0|        }
 1925|      1|    }
 1926|       |
 1927|      1|    if (c->crypto_connections_length != i) {
  ------------------
  |  Branch (1927:9): [True: 1, False: 0]
  ------------------
 1928|      1|        c->crypto_connections_length = i;
 1929|      1|        realloc_cryptoconnection(c, c->crypto_connections_length);
 1930|      1|    }
 1931|       |
 1932|      1|    return 0;
 1933|      1|}
net_crypto.c:create_cookie:
  252|      1|{
  253|      1|    uint8_t contents[COOKIE_CONTENTS_LENGTH];
  254|      1|    const uint64_t temp_time = mono_time_get(mono_time);
  255|      1|    memcpy(contents, &temp_time, sizeof(temp_time));
  256|      1|    memcpy(contents + sizeof(temp_time), bytes, COOKIE_DATA_LENGTH);
  ------------------
  |  |  200|      1|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  ------------------
  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  257|      1|    random_nonce(rng, cookie);
  258|      1|    const int len = encrypt_data_symmetric(encryption_key, cookie, contents, sizeof(contents), cookie + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  259|       |
  260|      1|    if (len != COOKIE_LENGTH - CRYPTO_NONCE_SIZE) {
  ------------------
  |  |  202|      1|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  201|      1|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  ------------------
  |  |  |  |  |  |  200|      1|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                  if (len != COOKIE_LENGTH - CRYPTO_NONCE_SIZE) {
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  |  Branch (260:9): [True: 0, False: 1]
  ------------------
  261|      0|        return -1;
  262|      0|    }
  263|       |
  264|      1|    return 0;
  265|      1|}
net_crypto.c:send_temp_packet:
 1439|      1|{
 1440|      1|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 1441|       |
 1442|      1|    if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1442:9): [True: 0, False: 1]
  ------------------
 1443|      0|        return -1;
 1444|      0|    }
 1445|       |
 1446|      1|    if (conn->temp_packet == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1446:9): [True: 0, False: 1]
  ------------------
 1447|      0|        return -1;
 1448|      0|    }
 1449|       |
 1450|      1|    if (send_packet_to(c, crypt_connection_id, conn->temp_packet, conn->temp_packet_length) != 0) {
  ------------------
  |  Branch (1450:9): [True: 1, False: 0]
  ------------------
 1451|      1|        return -1;
 1452|      1|    }
 1453|       |
 1454|      0|    conn->temp_packet_sent_time = current_time_monotonic(c->mono_time);
 1455|      0|    ++conn->temp_packet_num_sent;
 1456|      0|    return 0;
 1457|      1|}
net_crypto.c:send_packet_to:
  681|      1|{
  682|       |// TODO(irungentoo): TCP, etc...
  683|      1|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
  684|       |
  685|      1|    if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (685:9): [True: 0, False: 1]
  ------------------
  686|      0|        return -1;
  687|      0|    }
  688|       |
  689|      1|    bool direct_send_attempt = false;
  690|       |
  691|      1|    pthread_mutex_lock(conn->mutex);
  692|      1|    IP_Port ip_port = return_ip_port_connection(c, crypt_connection_id);
  693|       |
  694|       |    // TODO(irungentoo): on bad networks, direct connections might not last indefinitely.
  695|      1|    if (!net_family_is_unspec(ip_port.ip.family)) {
  ------------------
  |  Branch (695:9): [True: 0, False: 1]
  ------------------
  696|      0|        bool direct_connected = false;
  697|       |
  698|       |        // FIXME(sudden6): handle return value
  699|      0|        crypto_connection_status(c, crypt_connection_id, &direct_connected, nullptr);
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  700|       |
  701|      0|        if (direct_connected) {
  ------------------
  |  Branch (701:13): [True: 0, False: 0]
  ------------------
  702|      0|            if ((uint32_t)sendpacket(dht_get_net(c->dht), &ip_port, data, length) == length) {
  ------------------
  |  Branch (702:17): [True: 0, False: 0]
  ------------------
  703|      0|                pthread_mutex_unlock(conn->mutex);
  704|      0|                return 0;
  705|      0|            }
  706|       |
  707|      0|            pthread_mutex_unlock(conn->mutex);
  708|      0|            LOGGER_WARNING(c->log, "sending packet of length %d failed", length);
  ------------------
  |  |   82|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  709|      0|            return -1;
  710|      0|        }
  711|       |
  712|       |        // TODO(irungentoo): a better way of sending packets directly to confirm the others ip.
  713|      0|        const uint64_t current_time = mono_time_get(c->mono_time);
  714|       |
  715|      0|        if ((((UDP_DIRECT_TIMEOUT / 2) + conn->direct_send_attempt_time) < current_time && length < 96)
  ------------------
  |  |   97|      0|#define UDP_DIRECT_TIMEOUT 8
  ------------------
  |  Branch (715:14): [True: 0, False: 0]
  |  Branch (715:92): [True: 0, False: 0]
  ------------------
  716|      0|                || data[0] == NET_PACKET_COOKIE_REQUEST || data[0] == NET_PACKET_CRYPTO_HS) {
  ------------------
  |  Branch (716:20): [True: 0, False: 0]
  |  Branch (716:60): [True: 0, False: 0]
  ------------------
  717|      0|            if ((uint32_t)sendpacket(dht_get_net(c->dht), &ip_port, data, length) == length) {
  ------------------
  |  Branch (717:17): [True: 0, False: 0]
  ------------------
  718|      0|                direct_send_attempt = true;
  719|      0|                conn->direct_send_attempt_time = mono_time_get(c->mono_time);
  720|      0|            }
  721|      0|        }
  722|      0|    }
  723|       |
  724|      1|    pthread_mutex_unlock(conn->mutex);
  725|      1|    pthread_mutex_lock(&c->tcp_mutex);
  726|      1|    const int ret = send_packet_tcp_connection(c->tcp_c, conn->connection_number_tcp, data, length);
  727|      1|    pthread_mutex_unlock(&c->tcp_mutex);
  728|       |
  729|      1|    pthread_mutex_lock(conn->mutex);
  730|       |
  731|      1|    if (ret == 0) {
  ------------------
  |  Branch (731:9): [True: 0, False: 1]
  ------------------
  732|      0|        conn->last_tcp_sent = current_time_monotonic(c->mono_time);
  733|      0|    }
  734|       |
  735|      1|    pthread_mutex_unlock(conn->mutex);
  736|       |
  737|      1|    if (direct_send_attempt) {
  ------------------
  |  Branch (737:9): [True: 0, False: 1]
  ------------------
  738|      0|        return 0;
  739|      0|    }
  740|       |
  741|      1|    return ret;
  742|      1|}
net_crypto.c:return_ip_port_connection:
  623|      1|{
  624|      1|    const IP_Port empty = {{{0}}};
  625|       |
  626|      1|    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
  627|       |
  628|      1|    if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (628:9): [True: 0, False: 1]
  ------------------
  629|      0|        return empty;
  630|      0|    }
  631|       |
  632|      1|    const uint64_t current_time = mono_time_get(c->mono_time);
  633|      1|    bool v6 = false;
  634|      1|    bool v4 = false;
  635|       |
  636|      1|    if ((UDP_DIRECT_TIMEOUT + conn->direct_lastrecv_timev4) > current_time) {
  ------------------
  |  |   97|      1|#define UDP_DIRECT_TIMEOUT 8
  ------------------
  |  Branch (636:9): [True: 0, False: 1]
  ------------------
  637|      0|        v4 = true;
  638|      0|    }
  639|       |
  640|      1|    if ((UDP_DIRECT_TIMEOUT + conn->direct_lastrecv_timev6) > current_time) {
  ------------------
  |  |   97|      1|#define UDP_DIRECT_TIMEOUT 8
  ------------------
  |  Branch (640:9): [True: 0, False: 1]
  ------------------
  641|      0|        v6 = true;
  642|      0|    }
  643|       |
  644|       |    /* Prefer IP_Ports which haven't timed out to those which have.
  645|       |     * To break ties, prefer ipv4 lan, then ipv6, then non-lan ipv4.
  646|       |     */
  647|      1|    if (v4 && ip_is_lan(&conn->ip_portv4.ip)) {
  ------------------
  |  Branch (647:9): [True: 0, False: 1]
  |  Branch (647:15): [True: 0, False: 0]
  ------------------
  648|      0|        return conn->ip_portv4;
  649|      0|    }
  650|       |
  651|      1|    if (v6 && net_family_is_ipv6(conn->ip_portv6.ip.family)) {
  ------------------
  |  Branch (651:9): [True: 0, False: 1]
  |  Branch (651:15): [True: 0, False: 0]
  ------------------
  652|      0|        return conn->ip_portv6;
  653|      0|    }
  654|       |
  655|      1|    if (v4 && net_family_is_ipv4(conn->ip_portv4.ip.family)) {
  ------------------
  |  Branch (655:9): [True: 0, False: 1]
  |  Branch (655:15): [True: 0, False: 0]
  ------------------
  656|      0|        return conn->ip_portv4;
  657|      0|    }
  658|       |
  659|      1|    if (ip_is_lan(&conn->ip_portv4.ip)) {
  ------------------
  |  Branch (659:9): [True: 0, False: 1]
  ------------------
  660|      0|        return conn->ip_portv4;
  661|      0|    }
  662|       |
  663|      1|    if (net_family_is_ipv6(conn->ip_portv6.ip.family)) {
  ------------------
  |  Branch (663:9): [True: 0, False: 1]
  ------------------
  664|      0|        return conn->ip_portv6;
  665|      0|    }
  666|       |
  667|      1|    if (net_family_is_ipv4(conn->ip_portv4.ip.family)) {
  ------------------
  |  Branch (667:9): [True: 0, False: 1]
  ------------------
  668|      0|        return conn->ip_portv4;
  669|      0|    }
  670|       |
  671|      1|    return empty;
  672|      1|}
net_crypto.c:create_cookie_request:
  220|      1|{
  221|      1|    uint8_t plain[COOKIE_REQUEST_PLAIN_LENGTH];
  222|      1|    uint8_t padding[CRYPTO_PUBLIC_KEY_SIZE] = {0};
  223|       |
  224|      1|    memcpy(plain, c->self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  225|      1|    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, padding, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, padding, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  226|      1|    memcpy(plain + (CRYPTO_PUBLIC_KEY_SIZE * 2), &number, sizeof(uint64_t));
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  227|      1|    const uint8_t *tmp_shared_key = dht_get_shared_key_sent(c->dht, dht_public_key);
  228|      1|    memcpy(shared_key, tmp_shared_key, CRYPTO_SHARED_KEY_SIZE);
  ------------------
  |  |   50|      1|#define CRYPTO_SHARED_KEY_SIZE         32
  ------------------
  229|      1|    uint8_t nonce[CRYPTO_NONCE_SIZE];
  230|      1|    random_nonce(c->rng, nonce);
  231|      1|    packet[0] = NET_PACKET_COOKIE_REQUEST;
  232|      1|    memcpy(packet + 1, dht_get_self_public_key(c->dht), CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  233|      1|    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  234|      1|    const int len = encrypt_data_symmetric(shared_key, nonce, plain, sizeof(plain),
  235|      1|                                           packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                         packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  236|       |
  237|      1|    if (len != COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE) {
  ------------------
  |  |  204|      1|#define COOKIE_REQUEST_PLAIN_LENGTH (uint16_t)(COOKIE_DATA_LENGTH + sizeof(uint64_t))
  |  |  ------------------
  |  |  |  |  200|      1|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (len != COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (237:9): [True: 0, False: 1]
  ------------------
  238|      0|        return -1;
  239|      0|    }
  240|       |
  241|      1|    return 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + len;
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  return 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + len;
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  242|      1|}
net_crypto.c:new_temp_packet:
 1377|      1|{
 1378|      1|    if (length == 0 || length > MAX_CRYPTO_PACKET_SIZE) {
  ------------------
  |  |   80|      1|#define MAX_CRYPTO_PACKET_SIZE (uint16_t)1400
  ------------------
  |  Branch (1378:9): [True: 0, False: 1]
  |  Branch (1378:24): [True: 0, False: 1]
  ------------------
 1379|      0|        return -1;
 1380|      0|    }
 1381|       |
 1382|      1|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 1383|       |
 1384|      1|    if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1384:9): [True: 0, False: 1]
  ------------------
 1385|      0|        return -1;
 1386|      0|    }
 1387|       |
 1388|      1|    uint8_t *temp_packet = (uint8_t *)mem_balloc(c->mem, length);
 1389|       |
 1390|      1|    if (temp_packet == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1390:9): [True: 0, False: 1]
  ------------------
 1391|      0|        return -1;
 1392|      0|    }
 1393|       |
 1394|      1|    if (conn->temp_packet != nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1394:9): [True: 0, False: 1]
  ------------------
 1395|      0|        mem_delete(c->mem, conn->temp_packet);
 1396|      0|    }
 1397|       |
 1398|      1|    memcpy(temp_packet, packet, length);
 1399|      1|    conn->temp_packet = temp_packet;
 1400|      1|    conn->temp_packet_length = length;
 1401|      1|    conn->temp_packet_sent_time = 0;
 1402|      1|    conn->temp_packet_num_sent = 0;
 1403|      1|    return 0;
 1404|      1|}
net_crypto.c:get_crypto_connection:
  568|    133|{
  569|    133|    if (!crypt_connection_id_is_valid(c, crypt_connection_id)) {
  ------------------
  |  Branch (569:9): [True: 120, False: 13]
  ------------------
  570|    120|        return nullptr;
  ------------------
  |  |   66|    120|#define nullptr NULL
  ------------------
  571|    120|    }
  572|       |
  573|     13|    return &c->crypto_connections[crypt_connection_id];
  574|    133|}
net_crypto.c:clear_temp_packet:
 1413|      1|{
 1414|      1|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 1415|       |
 1416|      1|    if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1416:9): [True: 0, False: 1]
  ------------------
 1417|      0|        return -1;
 1418|      0|    }
 1419|       |
 1420|      1|    if (conn->temp_packet != nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1420:9): [True: 1, False: 0]
  ------------------
 1421|      1|        mem_delete(c->mem, conn->temp_packet);
 1422|      1|    }
 1423|       |
 1424|      1|    conn->temp_packet = nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 1425|      1|    conn->temp_packet_length = 0;
 1426|      1|    conn->temp_packet_sent_time = 0;
 1427|      1|    conn->temp_packet_num_sent = 0;
 1428|      1|    return 0;
 1429|      1|}
net_crypto.c:clear_buffer:
  901|      2|{
  902|      2|    uint32_t i;
  903|       |
  904|      2|    for (i = array->buffer_start; i != array->buffer_end; ++i) {
  ------------------
  |  Branch (904:35): [True: 0, False: 2]
  ------------------
  905|      0|        const uint32_t num = i % CRYPTO_PACKET_BUFFER_SIZE;
  ------------------
  |  |   71|      0|#define CRYPTO_PACKET_BUFFER_SIZE 32768 // Must be a power of 2
  ------------------
  906|       |
  907|      0|        if (array->buffer[num] != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (907:13): [True: 0, False: 0]
  ------------------
  908|      0|            mem_delete(mem, array->buffer[num]);
  909|      0|            array->buffer[num] = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  910|      0|        }
  911|      0|    }
  912|       |
  913|      2|    array->buffer_start = i;
  914|      2|    return 0;
  915|      2|}
net_crypto.c:handle_cookie_request:
  339|     12|{
  340|     12|    if (length != COOKIE_REQUEST_LENGTH) {
  ------------------
  |  |  205|     12|#define COOKIE_REQUEST_LENGTH (uint16_t)(1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   40|     12|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define COOKIE_REQUEST_LENGTH (uint16_t)(1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     12|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_REQUEST_LENGTH (uint16_t)(1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  204|     12|#define COOKIE_REQUEST_PLAIN_LENGTH (uint16_t)(COOKIE_DATA_LENGTH + sizeof(uint64_t))
  |  |  |  |  ------------------
  |  |  |  |  |  |  200|     12|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     12|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_REQUEST_LENGTH (uint16_t)(1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     12|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  |  Branch (340:9): [True: 11, False: 1]
  ------------------
  341|     11|        return -1;
  342|     11|    }
  343|       |
  344|      1|    memcpy(dht_public_key, packet + 1, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  345|      1|    const uint8_t *tmp_shared_key = dht_get_shared_key_sent(c->dht, dht_public_key);
  346|      1|    memcpy(shared_key, tmp_shared_key, CRYPTO_SHARED_KEY_SIZE);
  ------------------
  |  |   50|      1|#define CRYPTO_SHARED_KEY_SIZE         32
  ------------------
  347|      1|    const int len = decrypt_data_symmetric(shared_key, packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  348|      1|                                           packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE,
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                         packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE,
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
                                                         packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE,
  ------------------
  |  |  204|      1|#define COOKIE_REQUEST_PLAIN_LENGTH (uint16_t)(COOKIE_DATA_LENGTH + sizeof(uint64_t))
  |  |  ------------------
  |  |  |  |  200|      1|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                                                         packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE,
  ------------------
  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  ------------------
  349|      1|                                           request_plain);
  350|       |
  351|      1|    if (len != COOKIE_REQUEST_PLAIN_LENGTH) {
  ------------------
  |  |  204|      1|#define COOKIE_REQUEST_PLAIN_LENGTH (uint16_t)(COOKIE_DATA_LENGTH + sizeof(uint64_t))
  |  |  ------------------
  |  |  |  |  200|      1|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (351:9): [True: 0, False: 1]
  ------------------
  352|      0|        return -1;
  353|      0|    }
  354|       |
  355|      1|    return 0;
  356|      1|}
net_crypto.c:create_cookie_response:
  307|      1|{
  308|      1|    uint8_t cookie_plain[COOKIE_DATA_LENGTH];
  309|      1|    memcpy(cookie_plain, request_plain, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  310|      1|    memcpy(cookie_plain + CRYPTO_PUBLIC_KEY_SIZE, dht_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(cookie_plain + CRYPTO_PUBLIC_KEY_SIZE, dht_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  311|      1|    uint8_t plain[COOKIE_LENGTH + sizeof(uint64_t)];
  312|       |
  313|      1|    if (create_cookie(c->rng, c->mono_time, plain, cookie_plain, c->secret_symmetric_key) != 0) {
  ------------------
  |  Branch (313:9): [True: 0, False: 1]
  ------------------
  314|      0|        return -1;
  315|      0|    }
  316|       |
  317|      1|    memcpy(plain + COOKIE_LENGTH, request_plain + COOKIE_DATA_LENGTH, sizeof(uint64_t));
  ------------------
  |  |  202|      1|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  201|      1|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  ------------------
  |  |  |  |  |  |  200|      1|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                  memcpy(plain + COOKIE_LENGTH, request_plain + COOKIE_DATA_LENGTH, sizeof(uint64_t));
  ------------------
  |  |  200|      1|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  ------------------
  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  318|      1|    packet[0] = NET_PACKET_COOKIE_RESPONSE;
  319|      1|    random_nonce(c->rng, packet + 1);
  320|      1|    const int len = encrypt_data_symmetric(shared_key, packet + 1, plain, sizeof(plain), packet + 1 + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  321|       |
  322|      1|    if (len != COOKIE_RESPONSE_LENGTH - (1 + CRYPTO_NONCE_SIZE)) {
  ------------------
  |  |  206|      1|#define COOKIE_RESPONSE_LENGTH (uint16_t)(1 + CRYPTO_NONCE_SIZE + COOKIE_LENGTH + sizeof(uint64_t) + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_RESPONSE_LENGTH (uint16_t)(1 + CRYPTO_NONCE_SIZE + COOKIE_LENGTH + sizeof(uint64_t) + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  202|      1|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  201|      1|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  200|      1|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_RESPONSE_LENGTH (uint16_t)(1 + CRYPTO_NONCE_SIZE + COOKIE_LENGTH + sizeof(uint64_t) + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                  if (len != COOKIE_RESPONSE_LENGTH - (1 + CRYPTO_NONCE_SIZE)) {
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  |  Branch (322:9): [True: 0, False: 1]
  ------------------
  323|      0|        return -1;
  324|      0|    }
  325|       |
  326|      1|    return COOKIE_RESPONSE_LENGTH;
  ------------------
  |  |  206|      1|#define COOKIE_RESPONSE_LENGTH (uint16_t)(1 + CRYPTO_NONCE_SIZE + COOKIE_LENGTH + sizeof(uint64_t) + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_RESPONSE_LENGTH (uint16_t)(1 + CRYPTO_NONCE_SIZE + COOKIE_LENGTH + sizeof(uint64_t) + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  202|      1|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  201|      1|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  200|      1|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_RESPONSE_LENGTH (uint16_t)(1 + CRYPTO_NONCE_SIZE + COOKIE_LENGTH + sizeof(uint64_t) + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  327|      1|}
net_crypto.c:handle_crypto_handshake:
  526|     16|{
  527|     16|    if (length != HANDSHAKE_PACKET_LENGTH) {
  ------------------
  |  |  465|     16|#define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  202|     16|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     16|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  201|     16|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  200|     16|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   40|     16|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     16|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     16|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     16|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   40|     16|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   76|     16|#define CRYPTO_SHA512_SIZE             64
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  202|     16|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     16|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  201|     16|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  200|     16|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   40|     16|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     16|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     16|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  |  Branch (527:9): [True: 14, False: 2]
  ------------------
  528|     14|        return false;
  529|     14|    }
  530|       |
  531|      2|    uint8_t cookie_plain[COOKIE_DATA_LENGTH];
  532|       |
  533|      2|    if (open_cookie(c->mono_time, cookie_plain, packet + 1, c->secret_symmetric_key) != 0) {
  ------------------
  |  Branch (533:9): [True: 2, False: 0]
  ------------------
  534|      2|        return false;
  535|      2|    }
  536|       |
  537|      0|    if (expected_real_pk != nullptr && !pk_equal(cookie_plain, expected_real_pk)) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (537:9): [True: 0, False: 0]
  |  Branch (537:40): [True: 0, False: 0]
  ------------------
  538|      0|        return false;
  539|      0|    }
  540|       |
  541|      0|    uint8_t cookie_hash[CRYPTO_SHA512_SIZE];
  542|      0|    crypto_sha512(cookie_hash, packet + 1, COOKIE_LENGTH);
  ------------------
  |  |  202|      0|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  201|      0|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  ------------------
  |  |  |  |  |  |  200|      0|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  543|       |
  544|      0|    uint8_t plain[CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH];
  545|      0|    const int len = decrypt_data(cookie_plain, c->self_secret_key, packet + 1 + COOKIE_LENGTH,
  ------------------
  |  |  202|      0|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  201|      0|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  ------------------
  |  |  |  |  |  |  200|      0|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  546|      0|                                 packet + 1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE,
  ------------------
  |  |  202|      0|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  201|      0|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  ------------------
  |  |  |  |  |  |  200|      0|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                                               packet + 1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
  547|      0|                                 HANDSHAKE_PACKET_LENGTH - (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |  465|      0|#define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  202|      0|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  201|      0|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  200|      0|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   76|      0|#define CRYPTO_SHA512_SIZE             64
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  202|      0|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  201|      0|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  200|      0|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                                               HANDSHAKE_PACKET_LENGTH - (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |  202|      0|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  201|      0|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  ------------------
  |  |  |  |  |  |  200|      0|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                                               HANDSHAKE_PACKET_LENGTH - (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
  548|       |
  549|      0|    if (len != sizeof(plain)) {
  ------------------
  |  Branch (549:9): [True: 0, False: 0]
  ------------------
  550|      0|        return false;
  551|      0|    }
  552|       |
  553|      0|    if (!crypto_sha512_eq(cookie_hash, plain + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE)) {
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  if (!crypto_sha512_eq(cookie_hash, plain + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE)) {
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (553:9): [True: 0, False: 0]
  ------------------
  554|      0|        return false;
  555|      0|    }
  556|       |
  557|      0|    memcpy(nonce, plain, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
  558|      0|    memcpy(session_pk, plain + CRYPTO_NONCE_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  memcpy(session_pk, plain + CRYPTO_NONCE_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  559|      0|    memcpy(cookie, plain + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE, COOKIE_LENGTH);
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  memcpy(cookie, plain + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE, COOKIE_LENGTH);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(cookie, plain + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE, COOKIE_LENGTH);
  ------------------
  |  |   76|      0|#define CRYPTO_SHA512_SIZE             64
  ------------------
                  memcpy(cookie, plain + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE, COOKIE_LENGTH);
  ------------------
  |  |  202|      0|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  201|      0|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  ------------------
  |  |  |  |  |  |  200|      0|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  560|      0|    memcpy(peer_real_pk, cookie_plain, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  561|      0|    memcpy(dht_public_key, cookie_plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(dht_public_key, cookie_plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  562|      0|    return true;
  563|      0|}
net_crypto.c:open_cookie:
  275|      2|{
  276|      2|    uint8_t contents[COOKIE_CONTENTS_LENGTH];
  277|      2|    const int len = decrypt_data_symmetric(encryption_key, cookie, cookie + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  ------------------
  278|      2|                                           COOKIE_LENGTH - CRYPTO_NONCE_SIZE, contents);
  ------------------
  |  |  202|      2|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  201|      2|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  ------------------
  |  |  |  |  |  |  200|      2|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|      2|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                                                         COOKIE_LENGTH - CRYPTO_NONCE_SIZE, contents);
  ------------------
  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  ------------------
  279|       |
  280|      2|    if (len != sizeof(contents)) {
  ------------------
  |  Branch (280:9): [True: 0, False: 2]
  ------------------
  281|      0|        return -1;
  282|      0|    }
  283|       |
  284|      2|    uint64_t cookie_time;
  285|      2|    memcpy(&cookie_time, contents, sizeof(cookie_time));
  286|      2|    const uint64_t temp_time = mono_time_get(mono_time);
  287|       |
  288|      2|    if (cookie_time + COOKIE_TIMEOUT < temp_time || temp_time < cookie_time) {
  ------------------
  |  |  199|      2|#define COOKIE_TIMEOUT 15
  ------------------
  |  Branch (288:9): [True: 1, False: 1]
  |  Branch (288:53): [True: 1, False: 0]
  ------------------
  289|      2|        return -1;
  290|      2|    }
  291|       |
  292|      0|    memcpy(bytes, contents + sizeof(cookie_time), COOKIE_DATA_LENGTH);
  ------------------
  |  |  200|      0|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  293|      0|    return 0;
  294|      2|}
net_crypto.c:tcp_oob_callback:
 2261|      6|{
 2262|      6|    Net_Crypto *c = (Net_Crypto *)object;
 2263|       |
 2264|      6|    if (length == 0 || length > MAX_CRYPTO_PACKET_SIZE) {
  ------------------
  |  |   80|      6|#define MAX_CRYPTO_PACKET_SIZE (uint16_t)1400
  ------------------
  |  Branch (2264:9): [True: 0, False: 6]
  |  Branch (2264:24): [True: 2, False: 4]
  ------------------
 2265|      2|        return -1;
 2266|      2|    }
 2267|       |
 2268|      4|    if (data[0] == NET_PACKET_COOKIE_REQUEST) {
  ------------------
  |  Branch (2268:9): [True: 1, False: 3]
  ------------------
 2269|      1|        return tcp_oob_handle_cookie_request(c, tcp_connections_number, public_key, data, length);
 2270|      1|    }
 2271|       |
 2272|      3|    if (data[0] == NET_PACKET_CRYPTO_HS) {
  ------------------
  |  Branch (2272:9): [True: 1, False: 2]
  ------------------
 2273|      1|        IP_Port source = tcp_connections_number_to_ip_port(tcp_connections_number);
 2274|       |
 2275|      1|        if (handle_new_connection_handshake(c, &source, data, length, userdata) != 0) {
  ------------------
  |  Branch (2275:13): [True: 1, False: 0]
  ------------------
 2276|      1|            return -1;
 2277|      1|        }
 2278|       |
 2279|      0|        return 0;
 2280|      1|    }
 2281|       |
 2282|      2|    return -1;
 2283|      3|}
net_crypto.c:tcp_oob_handle_cookie_request:
  412|      1|{
  413|      1|    uint8_t request_plain[COOKIE_REQUEST_PLAIN_LENGTH];
  414|      1|    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
  415|      1|    uint8_t dht_public_key_temp[CRYPTO_PUBLIC_KEY_SIZE];
  416|       |
  417|      1|    if (handle_cookie_request(c, request_plain, shared_key, dht_public_key_temp, packet, length) != 0) {
  ------------------
  |  Branch (417:9): [True: 1, False: 0]
  ------------------
  418|      1|        return -1;
  419|      1|    }
  420|       |
  421|      0|    if (!pk_equal(dht_public_key, dht_public_key_temp)) {
  ------------------
  |  Branch (421:9): [True: 0, False: 0]
  ------------------
  422|      0|        return -1;
  423|      0|    }
  424|       |
  425|      0|    uint8_t data[COOKIE_RESPONSE_LENGTH];
  426|       |
  427|      0|    if (create_cookie_response(c, data, request_plain, shared_key, dht_public_key) != sizeof(data)) {
  ------------------
  |  Branch (427:9): [True: 0, False: 0]
  ------------------
  428|      0|        return -1;
  429|      0|    }
  430|       |
  431|      0|    const int ret = tcp_send_oob_packet(c->tcp_c, tcp_connections_number, dht_public_key, data, sizeof(data));
  432|      0|    return ret;
  433|      0|}
net_crypto.c:handle_new_connection_handshake:
 2019|     45|{
 2020|     45|    New_Connection n_c;
 2021|     45|    n_c.cookie = (uint8_t *)mem_balloc(c->mem, COOKIE_LENGTH);
  ------------------
  |  |  202|     45|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     45|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  201|     45|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  ------------------
  |  |  |  |  |  |  200|     45|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     45|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     45|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
 2022|       |
 2023|     45|    if (n_c.cookie == nullptr) {
  ------------------
  |  |   66|     45|#define nullptr NULL
  ------------------
  |  Branch (2023:9): [True: 29, False: 16]
  ------------------
 2024|     29|        return -1;
 2025|     29|    }
 2026|       |
 2027|     16|    n_c.source = *source;
 2028|     16|    n_c.cookie_length = COOKIE_LENGTH;
  ------------------
  |  |  202|     16|#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     16|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  201|     16|#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
  |  |  |  |  ------------------
  |  |  |  |  |  |  200|     16|#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     16|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     16|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
 2029|       |
 2030|     16|    if (!handle_crypto_handshake(c, n_c.recv_nonce, n_c.peersessionpublic_key, n_c.public_key, n_c.dht_public_key,
  ------------------
  |  Branch (2030:9): [True: 16, False: 0]
  ------------------
 2031|     16|                                 n_c.cookie, data, length, nullptr)) {
  ------------------
  |  |   66|     16|#define nullptr NULL
  ------------------
 2032|     16|        mem_delete(c->mem, n_c.cookie);
 2033|     16|        return -1;
 2034|     16|    }
 2035|       |
 2036|      0|    const int crypt_connection_id = getcryptconnection_id(c, n_c.public_key);
 2037|       |
 2038|      0|    if (crypt_connection_id != -1) {
  ------------------
  |  Branch (2038:9): [True: 0, False: 0]
  ------------------
 2039|      0|        Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 2040|       |
 2041|      0|        if (conn == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (2041:13): [True: 0, False: 0]
  ------------------
 2042|      0|            return -1;
 2043|      0|        }
 2044|       |
 2045|      0|        if (!pk_equal(n_c.dht_public_key, conn->dht_public_key)) {
  ------------------
  |  Branch (2045:13): [True: 0, False: 0]
  ------------------
 2046|      0|            connection_kill(c, crypt_connection_id, userdata);
 2047|      0|        } else {
 2048|      0|            if (conn->status != CRYPTO_CONN_COOKIE_REQUESTING && conn->status != CRYPTO_CONN_HANDSHAKE_SENT) {
  ------------------
  |  Branch (2048:17): [True: 0, False: 0]
  |  Branch (2048:66): [True: 0, False: 0]
  ------------------
 2049|      0|                mem_delete(c->mem, n_c.cookie);
 2050|      0|                return -1;
 2051|      0|            }
 2052|       |
 2053|      0|            memcpy(conn->recv_nonce, n_c.recv_nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
 2054|      0|            memcpy(conn->peersessionpublic_key, n_c.peersessionpublic_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2055|      0|            encrypt_precompute(conn->peersessionpublic_key, conn->sessionsecret_key, conn->shared_key);
 2056|       |
 2057|      0|            crypto_connection_add_source(c, crypt_connection_id, source);
 2058|       |
 2059|      0|            if (create_send_handshake(c, crypt_connection_id, n_c.cookie, n_c.dht_public_key) != 0) {
  ------------------
  |  Branch (2059:17): [True: 0, False: 0]
  ------------------
 2060|      0|                mem_delete(c->mem, n_c.cookie);
 2061|      0|                return -1;
 2062|      0|            }
 2063|       |
 2064|      0|            conn->status = CRYPTO_CONN_NOT_CONFIRMED;
 2065|      0|            mem_delete(c->mem, n_c.cookie);
 2066|      0|            return 0;
 2067|      0|        }
 2068|      0|    }
 2069|       |
 2070|      0|    const int ret = c->new_connection_callback(c->new_connection_callback_object, &n_c);
 2071|      0|    mem_delete(c->mem, n_c.cookie);
 2072|      0|    return ret;
 2073|      0|}
net_crypto.c:udp_handle_cookie_request:
  362|     11|{
  363|     11|    const Net_Crypto *c = (const Net_Crypto *)object;
  364|     11|    uint8_t request_plain[COOKIE_REQUEST_PLAIN_LENGTH];
  365|     11|    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
  366|     11|    uint8_t dht_public_key[CRYPTO_PUBLIC_KEY_SIZE];
  367|       |
  368|     11|    if (handle_cookie_request(c, request_plain, shared_key, dht_public_key, packet, length) != 0) {
  ------------------
  |  Branch (368:9): [True: 10, False: 1]
  ------------------
  369|     10|        return 1;
  370|     10|    }
  371|       |
  372|      1|    uint8_t data[COOKIE_RESPONSE_LENGTH];
  373|       |
  374|      1|    if (create_cookie_response(c, data, request_plain, shared_key, dht_public_key) != sizeof(data)) {
  ------------------
  |  Branch (374:9): [True: 0, False: 1]
  ------------------
  375|      0|        return 1;
  376|      0|    }
  377|       |
  378|      1|    if ((uint32_t)sendpacket(dht_get_net(c->dht), source, data, sizeof(data)) != sizeof(data)) {
  ------------------
  |  Branch (378:9): [True: 0, False: 1]
  ------------------
  379|      0|        return 1;
  380|      0|    }
  381|       |
  382|      1|    return 0;
  383|      1|}
net_crypto.c:udp_handle_packet:
 2566|     64|{
 2567|     64|    Net_Crypto *c = (Net_Crypto *)object;
 2568|       |
 2569|     64|    if (length <= CRYPTO_MIN_PACKET_SIZE || length > MAX_CRYPTO_PACKET_SIZE) {
  ------------------
  |  | 2553|    128|#define CRYPTO_MIN_PACKET_SIZE (1 + sizeof(uint16_t) + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     64|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                  if (length <= CRYPTO_MIN_PACKET_SIZE || length > MAX_CRYPTO_PACKET_SIZE) {
  ------------------
  |  |   80|     57|#define MAX_CRYPTO_PACKET_SIZE (uint16_t)1400
  ------------------
  |  Branch (2569:9): [True: 7, False: 57]
  |  Branch (2569:45): [True: 3, False: 54]
  ------------------
 2570|     10|        return 1;
 2571|     10|    }
 2572|       |
 2573|     54|    const int crypt_connection_id = crypto_id_ip_port(c, source);
 2574|       |
 2575|     54|    if (crypt_connection_id == -1) {
  ------------------
  |  Branch (2575:9): [True: 54, False: 0]
  ------------------
 2576|     54|        if (packet[0] != NET_PACKET_CRYPTO_HS) {
  ------------------
  |  Branch (2576:13): [True: 10, False: 44]
  ------------------
 2577|     10|            return 1;
 2578|     10|        }
 2579|       |
 2580|     44|        if (handle_new_connection_handshake(c, source, packet, length, userdata) != 0) {
  ------------------
  |  Branch (2580:13): [True: 44, False: 0]
  ------------------
 2581|     44|            return 1;
 2582|     44|        }
 2583|       |
 2584|      0|        return 0;
 2585|     44|    }
 2586|       |
 2587|      0|    if (handle_packet_connection(c, crypt_connection_id, packet, length, true, userdata) != 0) {
  ------------------
  |  Branch (2587:9): [True: 0, False: 0]
  ------------------
 2588|      0|        return 1;
 2589|      0|    }
 2590|       |
 2591|      0|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 2592|       |
 2593|      0|    if (conn == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (2593:9): [True: 0, False: 0]
  ------------------
 2594|      0|        return -1;
 2595|      0|    }
 2596|       |
 2597|      0|    pthread_mutex_lock(conn->mutex);
 2598|       |
 2599|      0|    if (net_family_is_ipv4(source->ip.family)) {
  ------------------
  |  Branch (2599:9): [True: 0, False: 0]
  ------------------
 2600|      0|        conn->direct_lastrecv_timev4 = mono_time_get(c->mono_time);
 2601|      0|    } else {
 2602|      0|        conn->direct_lastrecv_timev6 = mono_time_get(c->mono_time);
 2603|      0|    }
 2604|       |
 2605|      0|    pthread_mutex_unlock(conn->mutex);
 2606|      0|    return 0;
 2607|      0|}
net_crypto.c:crypto_id_ip_port:
 2549|     54|{
 2550|     54|    return bs_list_find(&c->ip_port_list, (const uint8_t *)ip_port);
 2551|     54|}
net_crypto.c:kill_timedout:
 3165|  72.6k|{
 3166|  72.6k|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (3166:26): [True: 1, False: 72.6k]
  ------------------
 3167|      1|        const Crypto_Connection *conn = get_crypto_connection(c, i);
 3168|       |
 3169|      1|        if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (3169:13): [True: 0, False: 1]
  ------------------
 3170|      0|            continue;
 3171|      0|        }
 3172|       |
 3173|      1|        if (conn->status == CRYPTO_CONN_COOKIE_REQUESTING || conn->status == CRYPTO_CONN_HANDSHAKE_SENT
  ------------------
  |  Branch (3173:13): [True: 1, False: 0]
  |  Branch (3173:62): [True: 0, False: 0]
  ------------------
 3174|      1|                || conn->status == CRYPTO_CONN_NOT_CONFIRMED) {
  ------------------
  |  Branch (3174:20): [True: 0, False: 0]
  ------------------
 3175|      1|            if (conn->temp_packet_num_sent < MAX_NUM_SENDPACKET_TRIES) {
  ------------------
  |  |   94|      1|#define MAX_NUM_SENDPACKET_TRIES 8
  ------------------
  |  Branch (3175:17): [True: 1, False: 0]
  ------------------
 3176|      1|                continue;
 3177|      1|            }
 3178|       |
 3179|      0|            connection_kill(c, i, userdata);
 3180|      0|        }
 3181|       |
 3182|       |#if 0
 3183|       |
 3184|       |        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
 3185|       |            // TODO(irungentoo): add a timeout here?
 3186|       |            /* do_timeout_here(); */
 3187|       |        }
 3188|       |
 3189|       |#endif
 3190|      1|    }
 3191|  72.6k|}
net_crypto.c:do_tcp:
 2417|  72.6k|{
 2418|  72.6k|    pthread_mutex_lock(&c->tcp_mutex);
 2419|  72.6k|    do_tcp_connections(c->log, c->tcp_c, userdata);
 2420|  72.6k|    pthread_mutex_unlock(&c->tcp_mutex);
 2421|       |
 2422|  72.6k|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (2422:26): [True: 1, False: 72.6k]
  ------------------
 2423|      1|        const Crypto_Connection *conn = get_crypto_connection(c, i);
 2424|       |
 2425|      1|        if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (2425:13): [True: 0, False: 1]
  ------------------
 2426|      0|            continue;
 2427|      0|        }
 2428|       |
 2429|      1|        if (conn->status != CRYPTO_CONN_ESTABLISHED) {
  ------------------
  |  Branch (2429:13): [True: 1, False: 0]
  ------------------
 2430|      1|            continue;
 2431|      1|        }
 2432|       |
 2433|      0|        bool direct_connected = false;
 2434|       |
 2435|      0|        if (!crypto_connection_status(c, i, &direct_connected, nullptr)) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (2435:13): [True: 0, False: 0]
  ------------------
 2436|      0|            continue;
 2437|      0|        }
 2438|       |
 2439|      0|        pthread_mutex_lock(&c->tcp_mutex);
 2440|      0|        set_tcp_connection_to_status(c->tcp_c, conn->connection_number_tcp, !direct_connected);
 2441|      0|        pthread_mutex_unlock(&c->tcp_mutex);
 2442|      0|    }
 2443|  72.6k|}
net_crypto.c:send_crypto_packets:
 2631|  72.6k|{
 2632|  72.6k|    const uint64_t temp_time = current_time_monotonic(c->mono_time);
 2633|  72.6k|    double total_send_rate = 0;
 2634|  72.6k|    uint32_t peak_request_packet_interval = -1;
 2635|       |
 2636|  72.6k|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (2636:26): [True: 1, False: 72.6k]
  ------------------
 2637|      1|        Crypto_Connection *conn = get_crypto_connection(c, i);
 2638|       |
 2639|      1|        if (conn == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (2639:13): [True: 0, False: 1]
  ------------------
 2640|      0|            continue;
 2641|      0|        }
 2642|       |
 2643|      1|        if ((CRYPTO_SEND_PACKET_INTERVAL + conn->temp_packet_sent_time) < temp_time) {
  ------------------
  |  |   88|      1|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
  |  Branch (2643:13): [True: 1, False: 0]
  ------------------
 2644|      1|            send_temp_packet(c, i);
 2645|      1|        }
 2646|       |
 2647|      1|        if ((conn->status == CRYPTO_CONN_NOT_CONFIRMED || conn->status == CRYPTO_CONN_ESTABLISHED)
  ------------------
  |  Branch (2647:14): [True: 0, False: 1]
  |  Branch (2647:59): [True: 0, False: 1]
  ------------------
 2648|      1|                && (CRYPTO_SEND_PACKET_INTERVAL + conn->last_request_packet_sent) < temp_time) {
  ------------------
  |  |   88|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
  |  Branch (2648:20): [True: 0, False: 0]
  ------------------
 2649|      0|            if (send_request_packet(c, i) == 0) {
  ------------------
  |  Branch (2649:17): [True: 0, False: 0]
  ------------------
 2650|      0|                conn->last_request_packet_sent = temp_time;
 2651|      0|            }
 2652|      0|        }
 2653|       |
 2654|      1|        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
  ------------------
  |  Branch (2654:13): [True: 0, False: 1]
  ------------------
 2655|      0|            if (conn->packet_recv_rate > CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   74|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2655:17): [True: 0, False: 0]
  ------------------
 2656|      0|                double request_packet_interval = REQUEST_PACKETS_COMPARE_CONSTANT / ((num_packets_array(
  ------------------
  |  | 2617|      0|#define REQUEST_PACKETS_COMPARE_CONSTANT (0.125 * 100.0)
  ------------------
 2657|      0|                                                     &conn->recv_array) + 1.0) / (conn->packet_recv_rate + 1.0));
 2658|       |
 2659|      0|                const double request_packet_interval2 = ((CRYPTO_PACKET_MIN_RATE / conn->packet_recv_rate) *
  ------------------
  |  |   74|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
 2660|      0|                                                        (double)CRYPTO_SEND_PACKET_INTERVAL) + (double)PACKET_COUNTER_AVERAGE_INTERVAL;
  ------------------
  |  |   88|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
                                                                      (double)CRYPTO_SEND_PACKET_INTERVAL) + (double)PACKET_COUNTER_AVERAGE_INTERVAL;
  ------------------
  |  | 2612|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2661|       |
 2662|      0|                if (request_packet_interval2 < request_packet_interval) {
  ------------------
  |  Branch (2662:21): [True: 0, False: 0]
  ------------------
 2663|      0|                    request_packet_interval = request_packet_interval2;
 2664|      0|                }
 2665|       |
 2666|      0|                if (request_packet_interval < PACKET_COUNTER_AVERAGE_INTERVAL) {
  ------------------
  |  | 2612|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
  |  Branch (2666:21): [True: 0, False: 0]
  ------------------
 2667|      0|                    request_packet_interval = PACKET_COUNTER_AVERAGE_INTERVAL;
  ------------------
  |  | 2612|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2668|      0|                }
 2669|       |
 2670|      0|                if (request_packet_interval > CRYPTO_SEND_PACKET_INTERVAL) {
  ------------------
  |  |   88|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
  |  Branch (2670:21): [True: 0, False: 0]
  ------------------
 2671|      0|                    request_packet_interval = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |   88|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 2672|      0|                }
 2673|       |
 2674|      0|                if (temp_time - conn->last_request_packet_sent > (uint64_t)request_packet_interval) {
  ------------------
  |  Branch (2674:21): [True: 0, False: 0]
  ------------------
 2675|      0|                    if (send_request_packet(c, i) == 0) {
  ------------------
  |  Branch (2675:25): [True: 0, False: 0]
  ------------------
 2676|      0|                        conn->last_request_packet_sent = temp_time;
 2677|      0|                    }
 2678|      0|                }
 2679|       |
 2680|      0|                if (request_packet_interval < peak_request_packet_interval) {
  ------------------
  |  Branch (2680:21): [True: 0, False: 0]
  ------------------
 2681|      0|                    peak_request_packet_interval = request_packet_interval;
 2682|      0|                }
 2683|      0|            }
 2684|       |
 2685|      0|            if ((PACKET_COUNTER_AVERAGE_INTERVAL + conn->packet_counter_set) < temp_time) {
  ------------------
  |  | 2612|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
  |  Branch (2685:17): [True: 0, False: 0]
  ------------------
 2686|      0|                const double dt = (double)(temp_time - conn->packet_counter_set);
 2687|       |
 2688|      0|                conn->packet_recv_rate = (double)conn->packet_counter / (dt / 1000.0);
 2689|      0|                conn->packet_counter = 0;
 2690|      0|                conn->packet_counter_set = temp_time;
 2691|       |
 2692|      0|                const uint32_t packets_sent = conn->packets_sent;
 2693|      0|                conn->packets_sent = 0;
 2694|       |
 2695|      0|                const uint32_t packets_resent = conn->packets_resent;
 2696|      0|                conn->packets_resent = 0;
 2697|       |
 2698|       |                /* conjestion control
 2699|       |                 *  calculate a new value of conn->packet_send_rate based on some data
 2700|       |                 */
 2701|       |
 2702|      0|                const unsigned int pos = conn->last_sendqueue_counter % CONGESTION_QUEUE_ARRAY_SIZE;
  ------------------
  |  |  109|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2703|      0|                conn->last_sendqueue_size[pos] = num_packets_array(&conn->send_array);
 2704|       |
 2705|      0|                long signed int sum = 0;
 2706|      0|                sum = (long signed int)conn->last_sendqueue_size[pos] -
 2707|      0|                      (long signed int)conn->last_sendqueue_size[(pos + 1) % CONGESTION_QUEUE_ARRAY_SIZE];
  ------------------
  |  |  109|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2708|       |
 2709|      0|                const unsigned int n_p_pos = conn->last_sendqueue_counter % CONGESTION_LAST_SENT_ARRAY_SIZE;
  ------------------
  |  |  110|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  109|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
 2710|      0|                conn->last_num_packets_sent[n_p_pos] = packets_sent;
 2711|      0|                conn->last_num_packets_resent[n_p_pos] = packets_resent;
 2712|       |
 2713|      0|                conn->last_sendqueue_counter = (conn->last_sendqueue_counter + 1) %
 2714|      0|                                               (CONGESTION_QUEUE_ARRAY_SIZE * CONGESTION_LAST_SENT_ARRAY_SIZE);
  ------------------
  |  |  109|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
                                                             (CONGESTION_QUEUE_ARRAY_SIZE * CONGESTION_LAST_SENT_ARRAY_SIZE);
  ------------------
  |  |  110|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  109|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
 2715|       |
 2716|      0|                bool direct_connected = false;
 2717|       |                /* return value can be ignored since the `if` above ensures the connection is established */
 2718|      0|                crypto_connection_status(c, i, &direct_connected, nullptr);
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2719|       |
 2720|       |                /* When switching from TCP to UDP, don't change the packet send rate for CONGESTION_EVENT_TIMEOUT ms. */
 2721|      0|                if (!(direct_connected && conn->last_tcp_sent + CONGESTION_EVENT_TIMEOUT > temp_time)) {
  ------------------
  |  | 2620|      0|#define CONGESTION_EVENT_TIMEOUT 1000
  ------------------
  |  Branch (2721:23): [True: 0, False: 0]
  |  Branch (2721:43): [True: 0, False: 0]
  ------------------
 2722|      0|                    long signed int total_sent = 0;
 2723|      0|                    long signed int total_resent = 0;
 2724|       |
 2725|       |                    // TODO(irungentoo): use real delay
 2726|      0|                    unsigned int delay = (unsigned int)(((double)conn->rtt_time / PACKET_COUNTER_AVERAGE_INTERVAL) + 0.5);
  ------------------
  |  | 2612|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2727|      0|                    const unsigned int packets_set_rem_array = CONGESTION_LAST_SENT_ARRAY_SIZE - CONGESTION_QUEUE_ARRAY_SIZE;
  ------------------
  |  |  110|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  109|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
                                  const unsigned int packets_set_rem_array = CONGESTION_LAST_SENT_ARRAY_SIZE - CONGESTION_QUEUE_ARRAY_SIZE;
  ------------------
  |  |  109|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2728|       |
 2729|      0|                    if (delay > packets_set_rem_array) {
  ------------------
  |  Branch (2729:25): [True: 0, False: 0]
  ------------------
 2730|      0|                        delay = packets_set_rem_array;
 2731|      0|                    }
 2732|       |
 2733|      0|                    for (unsigned j = 0; j < CONGESTION_QUEUE_ARRAY_SIZE; ++j) {
  ------------------
  |  |  109|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
  |  Branch (2733:42): [True: 0, False: 0]
  ------------------
 2734|      0|                        const unsigned int ind = (j + (packets_set_rem_array  - delay) + n_p_pos) % CONGESTION_LAST_SENT_ARRAY_SIZE;
  ------------------
  |  |  110|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  109|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
 2735|      0|                        total_sent += conn->last_num_packets_sent[ind];
 2736|      0|                        total_resent += conn->last_num_packets_resent[ind];
 2737|      0|                    }
 2738|       |
 2739|      0|                    if (sum > 0) {
  ------------------
  |  Branch (2739:25): [True: 0, False: 0]
  ------------------
 2740|      0|                        total_sent -= sum;
 2741|      0|                    } else {
 2742|      0|                        if (total_resent > -sum) {
  ------------------
  |  Branch (2742:29): [True: 0, False: 0]
  ------------------
 2743|      0|                            total_resent = -sum;
 2744|      0|                        }
 2745|      0|                    }
 2746|       |
 2747|       |                    /* if queue is too big only allow resending packets. */
 2748|      0|                    const uint32_t npackets = num_packets_array(&conn->send_array);
 2749|      0|                    double min_speed = 1000.0 * (((double)total_sent) / ((double)CONGESTION_QUEUE_ARRAY_SIZE *
  ------------------
  |  |  109|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2750|      0|                                                 PACKET_COUNTER_AVERAGE_INTERVAL));
  ------------------
  |  | 2612|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2751|       |
 2752|      0|                    const double min_speed_request = 1000.0 * (((double)(total_sent + total_resent)) / (
 2753|      0|                                                         (double)CONGESTION_QUEUE_ARRAY_SIZE * PACKET_COUNTER_AVERAGE_INTERVAL));
  ------------------
  |  |  109|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
                                                                       (double)CONGESTION_QUEUE_ARRAY_SIZE * PACKET_COUNTER_AVERAGE_INTERVAL));
  ------------------
  |  | 2612|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2754|       |
 2755|      0|                    if (min_speed < CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   74|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2755:25): [True: 0, False: 0]
  ------------------
 2756|      0|                        min_speed = CRYPTO_PACKET_MIN_RATE;
  ------------------
  |  |   74|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
 2757|      0|                    }
 2758|       |
 2759|      0|                    const double send_array_ratio = (double)npackets / min_speed;
 2760|       |
 2761|       |                    // TODO(irungentoo): Improve formula?
 2762|      0|                    if (send_array_ratio > SEND_QUEUE_RATIO && CRYPTO_MIN_QUEUE_LENGTH < npackets) {
  ------------------
  |  | 2627|      0|#define SEND_QUEUE_RATIO 2.0
  ------------------
                                  if (send_array_ratio > SEND_QUEUE_RATIO && CRYPTO_MIN_QUEUE_LENGTH < npackets) {
  ------------------
  |  |   77|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
  |  Branch (2762:25): [True: 0, False: 0]
  |  Branch (2762:64): [True: 0, False: 0]
  ------------------
 2763|      0|                        conn->packet_send_rate = min_speed * (1.0 / (send_array_ratio / SEND_QUEUE_RATIO));
  ------------------
  |  | 2627|      0|#define SEND_QUEUE_RATIO 2.0
  ------------------
 2764|      0|                    } else if (conn->last_congestion_event + CONGESTION_EVENT_TIMEOUT < temp_time) {
  ------------------
  |  | 2620|      0|#define CONGESTION_EVENT_TIMEOUT 1000
  ------------------
  |  Branch (2764:32): [True: 0, False: 0]
  ------------------
 2765|      0|                        conn->packet_send_rate = min_speed * 1.2;
 2766|      0|                    } else {
 2767|      0|                        conn->packet_send_rate = min_speed * 0.9;
 2768|      0|                    }
 2769|       |
 2770|      0|                    conn->packet_send_rate_requested = min_speed_request * 1.2;
 2771|       |
 2772|      0|                    if (conn->packet_send_rate < CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   74|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2772:25): [True: 0, False: 0]
  ------------------
 2773|      0|                        conn->packet_send_rate = CRYPTO_PACKET_MIN_RATE;
  ------------------
  |  |   74|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
 2774|      0|                    }
 2775|       |
 2776|      0|                    if (conn->packet_send_rate_requested < conn->packet_send_rate) {
  ------------------
  |  Branch (2776:25): [True: 0, False: 0]
  ------------------
 2777|      0|                        conn->packet_send_rate_requested = conn->packet_send_rate;
 2778|      0|                    }
 2779|      0|                }
 2780|      0|            }
 2781|       |
 2782|      0|            if (conn->last_packets_left_set == 0 || conn->last_packets_left_requested_set == 0) {
  ------------------
  |  Branch (2782:17): [True: 0, False: 0]
  |  Branch (2782:53): [True: 0, False: 0]
  ------------------
 2783|      0|                conn->last_packets_left_requested_set = temp_time;
 2784|      0|                conn->last_packets_left_set = temp_time;
 2785|      0|                conn->packets_left_requested = CRYPTO_MIN_QUEUE_LENGTH;
  ------------------
  |  |   77|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
 2786|      0|                conn->packets_left = CRYPTO_MIN_QUEUE_LENGTH;
  ------------------
  |  |   77|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
 2787|      0|            } else {
 2788|      0|                if (((uint64_t)((1000.0 / conn->packet_send_rate) + 0.5) + conn->last_packets_left_set) <= temp_time) {
  ------------------
  |  Branch (2788:21): [True: 0, False: 0]
  ------------------
 2789|      0|                    double n_packets = conn->packet_send_rate * (((double)(temp_time - conn->last_packets_left_set)) / 1000.0);
 2790|      0|                    n_packets += conn->last_packets_left_rem;
 2791|       |
 2792|      0|                    const uint32_t num_packets = n_packets;
 2793|      0|                    const double rem = n_packets - (double)num_packets;
 2794|       |
 2795|      0|                    if (conn->packets_left > num_packets * 4 + CRYPTO_MIN_QUEUE_LENGTH) {
  ------------------
  |  |   77|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
  |  Branch (2795:25): [True: 0, False: 0]
  ------------------
 2796|      0|                        conn->packets_left = num_packets * 4 + CRYPTO_MIN_QUEUE_LENGTH;
  ------------------
  |  |   77|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
 2797|      0|                    } else {
 2798|      0|                        conn->packets_left += num_packets;
 2799|      0|                    }
 2800|       |
 2801|      0|                    conn->last_packets_left_set = temp_time;
 2802|      0|                    conn->last_packets_left_rem = rem;
 2803|      0|                }
 2804|       |
 2805|      0|                if (((uint64_t)((1000.0 / conn->packet_send_rate_requested) + 0.5) + conn->last_packets_left_requested_set) <=
  ------------------
  |  Branch (2805:21): [True: 0, False: 0]
  ------------------
 2806|      0|                        temp_time) {
 2807|      0|                    double n_packets = conn->packet_send_rate_requested * (((double)(temp_time - conn->last_packets_left_requested_set)) /
 2808|      0|                                       1000.0);
 2809|      0|                    n_packets += conn->last_packets_left_requested_rem;
 2810|       |
 2811|      0|                    uint32_t num_packets = n_packets;
 2812|      0|                    double rem = n_packets - (double)num_packets;
 2813|      0|                    conn->packets_left_requested = num_packets;
 2814|       |
 2815|      0|                    conn->last_packets_left_requested_set = temp_time;
 2816|      0|                    conn->last_packets_left_requested_rem = rem;
 2817|      0|                }
 2818|       |
 2819|      0|                if (conn->packets_left > conn->packets_left_requested) {
  ------------------
  |  Branch (2819:21): [True: 0, False: 0]
  ------------------
 2820|      0|                    conn->packets_left_requested = conn->packets_left;
 2821|      0|                }
 2822|      0|            }
 2823|       |
 2824|      0|            const int ret = send_requested_packets(c, i, conn->packets_left_requested);
 2825|       |
 2826|      0|            if (ret != -1) {
  ------------------
  |  Branch (2826:17): [True: 0, False: 0]
  ------------------
 2827|      0|                conn->packets_left_requested -= ret;
 2828|      0|                conn->packets_resent += ret;
 2829|       |
 2830|      0|                if ((unsigned int)ret < conn->packets_left) {
  ------------------
  |  Branch (2830:21): [True: 0, False: 0]
  ------------------
 2831|      0|                    conn->packets_left -= ret;
 2832|      0|                } else {
 2833|      0|                    conn->last_congestion_event = temp_time;
 2834|      0|                    conn->packets_left = 0;
 2835|      0|                }
 2836|      0|            }
 2837|       |
 2838|      0|            if (conn->packet_send_rate > CRYPTO_PACKET_MIN_RATE * 1.5) {
  ------------------
  |  |   74|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2838:17): [True: 0, False: 0]
  ------------------
 2839|      0|                total_send_rate += conn->packet_send_rate;
 2840|      0|            }
 2841|      0|        }
 2842|      1|    }
 2843|       |
 2844|  72.6k|    c->current_sleep_time = -1;
 2845|  72.6k|    uint32_t sleep_time = peak_request_packet_interval;
 2846|       |
 2847|  72.6k|    if (c->current_sleep_time > sleep_time) {
  ------------------
  |  Branch (2847:9): [True: 0, False: 72.6k]
  ------------------
 2848|      0|        c->current_sleep_time = sleep_time;
 2849|      0|    }
 2850|       |
 2851|  72.6k|    if (total_send_rate > CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   74|  72.6k|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2851:9): [True: 0, False: 72.6k]
  ------------------
 2852|      0|        sleep_time = 1000.0 / total_send_rate;
 2853|       |
 2854|      0|        if (c->current_sleep_time > sleep_time) {
  ------------------
  |  Branch (2854:13): [True: 0, False: 0]
  ------------------
 2855|      0|            c->current_sleep_time = sleep_time + 1;
 2856|      0|        }
 2857|      0|    }
 2858|       |
 2859|  72.6k|    sleep_time = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |   88|  72.6k|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 2860|       |
 2861|  72.6k|    if (c->current_sleep_time > sleep_time) {
  ------------------
  |  Branch (2861:9): [True: 72.6k, False: 0]
  ------------------
 2862|  72.6k|        c->current_sleep_time = sleep_time;
 2863|  72.6k|    }
 2864|  72.6k|}

get_ip4_loopback:
  356|    137|{
  357|    137|    IP4 loopback;
  358|    137|    loopback.uint32 = htonl(INADDR_LOOPBACK);
  359|    137|    return loopback;
  360|    137|}
net_family_unspec:
  381|  4.47k|{
  382|  4.47k|    return family_unspec;
  383|  4.47k|}
net_family_ipv4:
  386|  25.6k|{
  387|  25.6k|    return family_ipv4;
  388|  25.6k|}
net_family_ipv6:
  391|  37.9k|{
  392|  37.9k|    return family_ipv6;
  393|  37.9k|}
net_family_tcp_server:
  396|      2|{
  397|      2|    return family_tcp_server;
  398|      2|}
net_family_tcp_client:
  401|     39|{
  402|     39|    return family_tcp_client;
  403|     39|}
net_family_tcp_ipv4:
  406|      2|{
  407|      2|    return family_tcp_ipv4;
  408|      2|}
net_family_tcp_ipv6:
  411|      1|{
  412|      1|    return family_tcp_ipv6;
  413|      1|}
net_family_is_unspec:
  426|  2.44M|{
  427|  2.44M|    return family.value == family_unspec.value;
  428|  2.44M|}
net_family_is_ipv4:
  431|  92.6k|{
  432|  92.6k|    return family.value == family_ipv4.value;
  433|  92.6k|}
net_family_is_ipv6:
  436|   100k|{
  437|   100k|    return family.value == family_ipv6.value;
  438|   100k|}
net_family_is_tcp_client:
  446|     13|{
  447|     13|    return family.value == family_tcp_client.value;
  448|     13|}
net_family_is_tcp_ipv4:
  451|    545|{
  452|    545|    return family.value == family_tcp_ipv4.value;
  453|    545|}
net_family_is_tcp_ipv6:
  456|    545|{
  457|    545|    return family.value == family_tcp_ipv6.value;
  458|    545|}
net_family_is_tox_tcp_ipv4:
  461|     98|{
  462|     98|    return family.value == family_tox_tcp_ipv4.value;
  463|     98|}
sock_valid:
  471|  46.0k|{
  472|  46.0k|    return sock.sock != net_invalid_socket.sock;
  473|  46.0k|}
system_network:
  597|    968|{
  598|    968|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  599|    968|    if ((true)) {
  ------------------
  |  Branch (599:9): [Folded - Ignored]
  ------------------
  600|    968|        return nullptr;
  ------------------
  |  |   66|    968|#define nullptr NULL
  ------------------
  601|    968|    }
  602|      0|#endif
  603|       |#ifdef OS_WIN32
  604|       |    WSADATA wsaData;
  605|       |
  606|       |    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != NO_ERROR) {
  607|       |        return nullptr;
  608|       |    }
  609|       |#endif
  610|      0|    return &system_network_obj;
  611|    968|}
net_send:
  806|  1.26k|{
  807|  1.26k|    const int res = ns->funcs->send(ns->obj, sock.sock, buf, len);
  808|  1.26k|    loglogdata(log, "T=>", buf, len, ip_port, res);
  809|  1.26k|    return res;
  810|  1.26k|}
net_recv:
  822|  16.9k|{
  823|  16.9k|    const int res = ns->funcs->recv(ns->obj, sock.sock, buf, len);
  824|  16.9k|    loglogdata(log, "=>T", buf, len, ip_port, res);
  825|  16.9k|    return res;
  826|  16.9k|}
net_listen:
  836|    145|{
  837|    145|    return ns->funcs->listen(ns->obj, sock.sock, backlog);
  838|    145|}
net_accept:
  847|  44.5k|{
  848|  44.5k|    const Socket newsock = {ns->funcs->accept(ns->obj, sock.sock)};
  849|  44.5k|    return newsock;
  850|  44.5k|}
kill_sock:
  854|  10.8k|{
  855|  10.8k|    ns->funcs->close(ns->obj, sock.sock);
  856|  10.8k|}
set_socket_nonblock:
  859|  45.9k|{
  860|  45.9k|    return ns->funcs->socket_nonblock(ns->obj, sock.sock, true) == 0;
  861|  45.9k|}
set_socket_nosigpipe:
  864|  45.7k|{
  865|       |#if defined(__APPLE__)
  866|       |    int set = 1;
  867|       |    return net_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
  868|       |#else
  869|  45.7k|    return true;
  870|  45.7k|#endif
  871|  45.7k|}
set_socket_reuseaddr:
  874|    145|{
  875|    145|    int set = 1;
  876|    145|    return net_setsockopt(ns, sock, SOL_SOCKET, SO_REUSEADDR, &set, sizeof(set)) == 0;
  877|    145|}
set_socket_dualstack:
  880|    831|{
  881|    831|    int ipv6only = 0;
  882|    831|    size_t optsize = sizeof(ipv6only);
  883|    831|    const int res = net_getsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, &optsize);
  884|       |
  885|    831|    if ((res == 0) && (ipv6only == 0)) {
  ------------------
  |  Branch (885:9): [True: 831, False: 0]
  |  Branch (885:23): [True: 831, False: 0]
  ------------------
  886|    831|        return true;
  887|    831|    }
  888|       |
  889|      0|    ipv6only = 0;
  890|      0|    return net_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only)) == 0;
  891|    831|}
net_family:
  912|  46.6k|{
  913|  46.6k|    return net->family;
  914|  46.6k|}
send_packet:
  925|  18.9k|{
  926|  18.9k|    IP_Port ipp_copy = *ip_port;
  927|       |
  928|  18.9k|    if (net_family_is_unspec(ip_port->ip.family)) {
  ------------------
  |  Branch (928:9): [True: 16, False: 18.8k]
  ------------------
  929|       |        // TODO(iphydf): Make this an error. Currently this fails sometimes when
  930|       |        // called from DHT.c:do_ping_and_sendnode_requests.
  931|     16|        return -1;
  932|     16|    }
  933|       |
  934|  18.8k|    if (net_family_is_unspec(net->family)) { /* Socket not initialized */
  ------------------
  |  Branch (934:9): [True: 3, False: 18.8k]
  ------------------
  935|       |        // TODO(iphydf): Make this an error. Currently, the onion client calls
  936|       |        // this via DHT getnodes.
  937|      3|        LOGGER_WARNING(net->log, "attempted to send message of length %u on uninitialised socket", packet.length);
  ------------------
  |  |   82|      3|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      3|    do {                                                                         \
  |  |  |  |   73|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      3|        }                                                                        \
  |  |  |  |   76|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  938|      3|        return -1;
  939|      3|    }
  940|       |
  941|       |    /* socket TOX_AF_INET, but target IP NOT: can't send */
  942|  18.8k|    if (net_family_is_ipv4(net->family) && !net_family_is_ipv4(ipp_copy.ip.family)) {
  ------------------
  |  Branch (942:9): [True: 0, False: 18.8k]
  |  Branch (942:44): [True: 0, False: 0]
  ------------------
  943|       |        // TODO(iphydf): Make this an error. Occasionally we try to send to an
  944|       |        // all-zero ip_port.
  945|      0|        LOGGER_WARNING(net->log, "attempted to send message with network family %d (probably IPv6) on IPv4 socket",
  ------------------
  |  |   82|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  946|      0|                       ipp_copy.ip.family.value);
  947|      0|        return -1;
  948|      0|    }
  949|       |
  950|  18.8k|    if (net_family_is_ipv4(ipp_copy.ip.family) && net_family_is_ipv6(net->family)) {
  ------------------
  |  Branch (950:9): [True: 952, False: 17.9k]
  |  Branch (950:51): [True: 952, False: 0]
  ------------------
  951|       |        /* must convert to IPV4-in-IPV6 address */
  952|    952|        IP6 ip6;
  953|       |
  954|       |        /* there should be a macro for this in a standards compliant
  955|       |         * environment, not found */
  956|    952|        ip6.uint32[0] = 0;
  957|    952|        ip6.uint32[1] = 0;
  958|    952|        ip6.uint32[2] = net_htonl(0xFFFF);
  959|    952|        ip6.uint32[3] = ipp_copy.ip.ip.v4.uint32;
  960|       |
  961|    952|        ipp_copy.ip.family = net_family_ipv6();
  962|    952|        ipp_copy.ip.ip.v6 = ip6;
  963|    952|    }
  964|       |
  965|  18.8k|    Network_Addr addr;
  966|       |
  967|  18.8k|    if (net_family_is_ipv4(ipp_copy.ip.family)) {
  ------------------
  |  Branch (967:9): [True: 0, False: 18.8k]
  ------------------
  968|      0|        struct sockaddr_in *const addr4 = (struct sockaddr_in *)&addr.addr;
  969|       |
  970|      0|        addr.size = sizeof(struct sockaddr_in);
  971|      0|        addr4->sin_family = AF_INET;
  972|      0|        addr4->sin_port = ipp_copy.port;
  973|      0|        fill_addr4(&ipp_copy.ip.ip.v4, &addr4->sin_addr);
  974|  18.8k|    } else if (net_family_is_ipv6(ipp_copy.ip.family)) {
  ------------------
  |  Branch (974:16): [True: 18.8k, False: 14]
  ------------------
  975|  18.8k|        struct sockaddr_in6 *const addr6 = (struct sockaddr_in6 *)&addr.addr;
  976|       |
  977|  18.8k|        addr.size = sizeof(struct sockaddr_in6);
  978|  18.8k|        addr6->sin6_family = AF_INET6;
  979|  18.8k|        addr6->sin6_port = ipp_copy.port;
  980|  18.8k|        fill_addr6(&ipp_copy.ip.ip.v6, &addr6->sin6_addr);
  981|       |
  982|  18.8k|        addr6->sin6_flowinfo = 0;
  983|  18.8k|        addr6->sin6_scope_id = 0;
  984|  18.8k|    } else {
  985|     14|        LOGGER_ERROR(net->log, "unknown address type: %d", ipp_copy.ip.family.value);
  ------------------
  |  |   83|     14|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     14|    do {                                                                         \
  |  |  |  |   73|     14|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     28|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     14|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     14|        }                                                                        \
  |  |  |  |   76|     14|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  986|     14|        return -1;
  987|     14|    }
  988|       |
  989|  18.8k|    const long res = net_sendto(net->ns, net->sock, packet.data, packet.length, &addr, &ipp_copy);
  990|  18.8k|    loglogdata(net->log, "O=>", packet.data, packet.length, ip_port, res);
  991|       |
  992|  18.8k|    assert(res <= INT_MAX);
  993|      0|    return (int)res;
  994|  18.8k|}
sendpacket:
 1002|  18.9k|{
 1003|  18.9k|    const Packet packet = {data, length};
 1004|  18.9k|    return send_packet(net, ip_port, packet);
 1005|  18.9k|}
networking_registerhandler:
 1076|  59.5k|{
 1077|  59.5k|    net->packethandlers[byte].function = cb;
 1078|  59.5k|    net->packethandlers[byte].object = object;
 1079|  59.5k|}
networking_poll:
 1082|  12.0k|{
 1083|  12.0k|    if (net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (1083:9): [True: 0, False: 12.0k]
  ------------------
 1084|       |        /* Socket not initialized */
 1085|      0|        return;
 1086|      0|    }
 1087|       |
 1088|  12.0k|    IP_Port ip_port;
 1089|  12.0k|    uint8_t data[MAX_UDP_PACKET_SIZE] = {0};
 1090|  12.0k|    uint32_t length;
 1091|       |
 1092|  21.5k|    while (receivepacket(net->ns, net->mem, net->log, net->sock, &ip_port, data, &length) != -1) {
  ------------------
  |  Branch (1092:12): [True: 9.55k, False: 12.0k]
  ------------------
 1093|  9.55k|        if (length < 1) {
  ------------------
  |  Branch (1093:13): [True: 7.11k, False: 2.44k]
  ------------------
 1094|  7.11k|            continue;
 1095|  7.11k|        }
 1096|       |
 1097|  2.44k|        const Packet_Handler *const handler = &net->packethandlers[data[0]];
 1098|       |
 1099|  2.44k|        if (handler->function == nullptr) {
  ------------------
  |  |   66|  2.44k|#define nullptr NULL
  ------------------
  |  Branch (1099:13): [True: 158, False: 2.28k]
  ------------------
 1100|       |            // TODO(https://github.com/TokTok/c-toxcore/issues/1115): Make this
 1101|       |            // a warning or error again.
 1102|    158|            LOGGER_DEBUG(net->log, "[%02u] -- Packet has no handler", data[0]);
  ------------------
  |  |   80|    158|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    158|    do {                                                                         \
  |  |  |  |   73|    158|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    316|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|    158|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1103|    158|            continue;
 1104|    158|        }
 1105|       |
 1106|  2.28k|        handler->function(handler->object, &ip_port, data, length, userdata);
 1107|  2.28k|    }
 1108|  12.0k|}
new_networking_ex:
 1123|    687|{
 1124|       |    /* If both from and to are 0, use default port range
 1125|       |     * If one is 0 and the other is non-0, use the non-0 value as only port
 1126|       |     * If from > to, swap
 1127|       |     */
 1128|    687|    if (port_from == 0 && port_to == 0) {
  ------------------
  |  Branch (1128:9): [True: 687, False: 0]
  |  Branch (1128:27): [True: 687, False: 0]
  ------------------
 1129|    687|        port_from = TOX_PORTRANGE_FROM;
  ------------------
  |  |  201|    687|#define TOX_PORTRANGE_FROM 33445
  ------------------
 1130|    687|        port_to = TOX_PORTRANGE_TO;
  ------------------
  |  |  202|    687|#define TOX_PORTRANGE_TO   33545
  ------------------
 1131|    687|    } else if (port_from == 0 && port_to != 0) {
  ------------------
  |  Branch (1131:16): [True: 0, False: 0]
  |  Branch (1131:34): [True: 0, False: 0]
  ------------------
 1132|      0|        port_from = port_to;
 1133|      0|    } else if (port_from != 0 && port_to == 0) {
  ------------------
  |  Branch (1133:16): [True: 0, False: 0]
  |  Branch (1133:34): [True: 0, False: 0]
  ------------------
 1134|      0|        port_to = port_from;
 1135|      0|    } else if (port_from > port_to) {
  ------------------
  |  Branch (1135:16): [True: 0, False: 0]
  ------------------
 1136|      0|        const uint16_t temp_port = port_from;
 1137|      0|        port_from = port_to;
 1138|      0|        port_to = temp_port;
 1139|      0|    }
 1140|       |
 1141|    687|    if (error != nullptr) {
  ------------------
  |  |   66|    687|#define nullptr NULL
  ------------------
  |  Branch (1141:9): [True: 687, False: 0]
  ------------------
 1142|    687|        *error = 2;
 1143|    687|    }
 1144|       |
 1145|       |    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
 1146|    687|    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1146:9): [True: 687, False: 0]
  |  Branch (1146:44): [True: 0, False: 687]
  ------------------
 1147|      0|        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1148|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1149|      0|    }
 1150|       |
 1151|    687|    Networking_Core *temp = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
 1152|       |
 1153|    687|    if (temp == nullptr) {
  ------------------
  |  |   66|    687|#define nullptr NULL
  ------------------
  |  Branch (1153:9): [True: 1, False: 686]
  ------------------
 1154|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 1155|      1|    }
 1156|       |
 1157|    686|    temp->ns = ns;
 1158|    686|    temp->log = log;
 1159|    686|    temp->mem = mem;
 1160|    686|    temp->family = ip->family;
 1161|    686|    temp->port = 0;
 1162|       |
 1163|       |    /* Initialize our socket. */
 1164|       |    /* add log message what we're creating */
 1165|    686|    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  213|    686|#define TOX_SOCK_DGRAM 2
  ------------------
                  temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  216|    686|#define TOX_PROTO_UDP 2
  ------------------
 1166|       |
 1167|       |    /* Check for socket error. */
 1168|    686|    if (!sock_valid(temp->sock)) {
  ------------------
  |  Branch (1168:9): [True: 0, False: 686]
  ------------------
 1169|      0|        const int neterror = net_error();
 1170|      0|        char *strerror = net_new_strerror(neterror);
 1171|      0|        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, strerror);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1172|      0|        net_kill_strerror(strerror);
 1173|      0|        mem_delete(mem, temp);
 1174|       |
 1175|      0|        if (error != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1175:13): [True: 0, False: 0]
  ------------------
 1176|      0|            *error = 1;
 1177|      0|        }
 1178|       |
 1179|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1180|      0|    }
 1181|       |
 1182|       |    /* Functions to increase the size of the send and receive UDP buffers.
 1183|       |     */
 1184|    686|    int n = 1024 * 1024 * 2;
 1185|       |
 1186|    686|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1186:9): [True: 0, False: 686]
  ------------------
 1187|      0|        LOGGER_ERROR(log, "failed to set socket option %d", SO_RCVBUF);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1188|      0|    }
 1189|       |
 1190|    686|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_SNDBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1190:9): [True: 0, False: 686]
  ------------------
 1191|      0|        LOGGER_ERROR(log, "failed to set socket option %d", SO_SNDBUF);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1192|      0|    }
 1193|       |
 1194|       |    /* Enable broadcast on socket */
 1195|    686|    int broadcast = 1;
 1196|       |
 1197|    686|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) != 0) {
  ------------------
  |  Branch (1197:9): [True: 0, False: 686]
  ------------------
 1198|      0|        LOGGER_ERROR(log, "failed to set socket option %d", SO_BROADCAST);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1199|      0|    }
 1200|       |
 1201|       |    /* iOS UDP sockets are weird and apparently can SIGPIPE */
 1202|    686|    if (!set_socket_nosigpipe(ns, temp->sock)) {
  ------------------
  |  Branch (1202:9): [True: 0, False: 686]
  ------------------
 1203|      0|        kill_networking(temp);
 1204|       |
 1205|      0|        if (error != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1205:13): [True: 0, False: 0]
  ------------------
 1206|      0|            *error = 1;
 1207|      0|        }
 1208|       |
 1209|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1210|      0|    }
 1211|       |
 1212|       |    /* Set socket nonblocking. */
 1213|    686|    if (!set_socket_nonblock(ns, temp->sock)) {
  ------------------
  |  Branch (1213:9): [True: 0, False: 686]
  ------------------
 1214|      0|        kill_networking(temp);
 1215|       |
 1216|      0|        if (error != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1216:13): [True: 0, False: 0]
  ------------------
 1217|      0|            *error = 1;
 1218|      0|        }
 1219|       |
 1220|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1221|      0|    }
 1222|       |
 1223|       |    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
 1224|    686|    uint16_t *portptr = nullptr;
  ------------------
  |  |   66|    686|#define nullptr NULL
  ------------------
 1225|    686|    Network_Addr addr;
 1226|       |
 1227|    686|    memset(&addr.addr, 0, sizeof(struct sockaddr_storage));
 1228|       |
 1229|    686|    if (net_family_is_ipv4(temp->family)) {
  ------------------
  |  Branch (1229:9): [True: 0, False: 686]
  ------------------
 1230|      0|        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr.addr;
 1231|       |
 1232|      0|        addr.size = sizeof(struct sockaddr_in);
 1233|      0|        addr4->sin_family = AF_INET;
 1234|      0|        addr4->sin_port = 0;
 1235|      0|        fill_addr4(&ip->ip.v4, &addr4->sin_addr);
 1236|       |
 1237|      0|        portptr = &addr4->sin_port;
 1238|    686|    } else if (net_family_is_ipv6(temp->family)) {
  ------------------
  |  Branch (1238:16): [True: 686, False: 0]
  ------------------
 1239|    686|        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr.addr;
 1240|       |
 1241|    686|        addr.size = sizeof(struct sockaddr_in6);
 1242|    686|        addr6->sin6_family = AF_INET6;
 1243|    686|        addr6->sin6_port = 0;
 1244|    686|        fill_addr6(&ip->ip.v6, &addr6->sin6_addr);
 1245|       |
 1246|    686|        addr6->sin6_flowinfo = 0;
 1247|    686|        addr6->sin6_scope_id = 0;
 1248|       |
 1249|    686|        portptr = &addr6->sin6_port;
 1250|    686|    } else {
 1251|      0|        mem_delete(mem, temp);
 1252|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1253|      0|    }
 1254|       |
 1255|    686|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1255:9): [True: 686, False: 0]
  ------------------
 1256|    686|        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);
 1257|       |
 1258|    686|        if (is_dualstack) {
  ------------------
  |  Branch (1258:13): [True: 686, False: 0]
  ------------------
 1259|    686|            LOGGER_TRACE(log, "Dual-stack socket: enabled");
  ------------------
  |  |   79|    686|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    686|    do {                                                                         \
  |  |  |  |   73|    686|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  1.37k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|    686|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1260|    686|        } else {
 1261|      0|            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1262|      0|        }
 1263|       |
 1264|    686|#ifndef ESP_PLATFORM
 1265|       |        /* multicast local nodes */
 1266|    686|        struct ipv6_mreq mreq;
 1267|    686|        memset(&mreq, 0, sizeof(mreq));
 1268|    686|        mreq.ipv6mr_multiaddr.s6_addr[ 0] = 0xFF;
 1269|    686|        mreq.ipv6mr_multiaddr.s6_addr[ 1] = 0x02;
 1270|    686|        mreq.ipv6mr_multiaddr.s6_addr[15] = 0x01;
 1271|    686|        mreq.ipv6mr_interface = 0;
 1272|       |
 1273|    686|        const int res = net_setsockopt(ns, temp->sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
 1274|       |
 1275|    686|        int neterror = net_error();
 1276|    686|        char *strerror = net_new_strerror(neterror);
 1277|       |
 1278|    686|        if (res < 0) {
  ------------------
  |  Branch (1278:13): [True: 0, False: 686]
  ------------------
 1279|      0|            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, strerror);
  ------------------
  |  |   81|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1280|    686|        } else {
 1281|    686|            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, strerror);
  ------------------
  |  |   79|    686|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    686|    do {                                                                         \
  |  |  |  |   73|    686|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  1.37k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|    686|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1282|    686|        }
 1283|       |
 1284|    686|        net_kill_strerror(strerror);
 1285|    686|#endif
 1286|    686|    }
 1287|       |
 1288|       |    /* A hanging program or a different user might block the standard port.
 1289|       |     * As long as it isn't a parameter coming from the commandline,
 1290|       |     * try a few ports after it, to see if we can find a "free" one.
 1291|       |     *
 1292|       |     * If we go on without binding, the first sendto() automatically binds to
 1293|       |     * a free port chosen by the system (i.e. anything from 1024 to 65535).
 1294|       |     *
 1295|       |     * Returning NULL after bind fails has both advantages and disadvantages:
 1296|       |     * advantage:
 1297|       |     *   we can rely on getting the port in the range 33445..33450, which
 1298|       |     *   enables us to tell joe user to open their firewall to a small range
 1299|       |     *
 1300|       |     * disadvantage:
 1301|       |     *   some clients might not test return of tox_new(), blindly assuming that
 1302|       |     *   it worked ok (which it did previously without a successful bind)
 1303|       |     */
 1304|    686|    uint16_t port_to_try = port_from;
 1305|    686|    *portptr = net_htons(port_to_try);
 1306|       |
 1307|    686|    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
  ------------------
  |  Branch (1307:38): [True: 686, False: 0]
  ------------------
 1308|    686|        const int res = net_bind(ns, temp->sock, &addr);
 1309|       |
 1310|    686|        if (res == 0) {
  ------------------
  |  Branch (1310:13): [True: 686, False: 0]
  ------------------
 1311|    686|            temp->port = *portptr;
 1312|       |
 1313|    686|            Ip_Ntoa ip_str;
 1314|    686|            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
  ------------------
  |  |   80|    686|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    686|    do {                                                                         \
  |  |  |  |   73|    686|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  1.37k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|    686|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1315|    686|                         net_ntohs(temp->port));
 1316|       |
 1317|       |            /* errno isn't reset on success, only set on failure, the failed
 1318|       |             * binds with parallel clients yield a -EPERM to the outside if
 1319|       |             * errno isn't cleared here */
 1320|    686|            if (tries > 0) {
  ------------------
  |  Branch (1320:17): [True: 686, False: 0]
  ------------------
 1321|    686|                errno = 0;
 1322|    686|            }
 1323|       |
 1324|    686|            if (error != nullptr) {
  ------------------
  |  |   66|    686|#define nullptr NULL
  ------------------
  |  Branch (1324:17): [True: 686, False: 0]
  ------------------
 1325|    686|                *error = 0;
 1326|    686|            }
 1327|       |
 1328|    686|            return temp;
 1329|    686|        }
 1330|       |
 1331|      0|        ++port_to_try;
 1332|       |
 1333|      0|        if (port_to_try > port_to) {
  ------------------
  |  Branch (1333:13): [True: 0, False: 0]
  ------------------
 1334|      0|            port_to_try = port_from;
 1335|      0|        }
 1336|       |
 1337|      0|        *portptr = net_htons(port_to_try);
 1338|      0|    }
 1339|       |
 1340|      0|    Ip_Ntoa ip_str;
 1341|      0|    int neterror = net_error();
 1342|      0|    char *strerror = net_new_strerror(neterror);
 1343|      0|    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u", neterror, strerror,
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1344|      0|                 net_ip_ntoa(ip, &ip_str), port_from, port_to);
 1345|      0|    net_kill_strerror(strerror);
 1346|      0|    kill_networking(temp);
 1347|       |
 1348|      0|    if (error != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1348:9): [True: 0, False: 0]
  ------------------
 1349|      0|        *error = 1;
 1350|      0|    }
 1351|       |
 1352|      0|    return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1353|    686|}
new_networking_no_udp:
 1356|    277|{
 1357|       |    /* this is the easiest way to completely disable UDP without changing too much code. */
 1358|    277|    Networking_Core *net = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
 1359|       |
 1360|    277|    if (net == nullptr) {
  ------------------
  |  |   66|    277|#define nullptr NULL
  ------------------
  |  Branch (1360:9): [True: 1, False: 276]
  ------------------
 1361|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 1362|      1|    }
 1363|       |
 1364|    276|    net->ns = ns;
 1365|    276|    net->log = log;
 1366|    276|    net->mem = mem;
 1367|       |
 1368|    276|    return net;
 1369|    277|}
kill_networking:
 1373|    962|{
 1374|    962|    if (net == nullptr) {
  ------------------
  |  |   66|    962|#define nullptr NULL
  ------------------
  |  Branch (1374:9): [True: 0, False: 962]
  ------------------
 1375|      0|        return;
 1376|      0|    }
 1377|       |
 1378|    962|    if (!net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (1378:9): [True: 686, False: 276]
  ------------------
 1379|       |        /* Socket is initialized, so we close it. */
 1380|    686|        kill_sock(net->ns, net->sock);
 1381|    686|    }
 1382|       |
 1383|    962|    mem_delete(net->mem, net);
 1384|    962|}
ip_equal:
 1388|      5|{
 1389|      5|    if (a == nullptr || b == nullptr) {
  ------------------
  |  |   66|     10|#define nullptr NULL
  ------------------
                  if (a == nullptr || b == nullptr) {
  ------------------
  |  |   66|      5|#define nullptr NULL
  ------------------
  |  Branch (1389:9): [True: 0, False: 5]
  |  Branch (1389:25): [True: 0, False: 5]
  ------------------
 1390|      0|        return false;
 1391|      0|    }
 1392|       |
 1393|       |    /* same family */
 1394|      5|    if (a->family.value == b->family.value) {
  ------------------
  |  Branch (1394:9): [True: 5, False: 0]
  ------------------
 1395|      5|        if (net_family_is_ipv4(a->family) || net_family_is_tcp_ipv4(a->family)) {
  ------------------
  |  Branch (1395:13): [True: 5, False: 0]
  |  Branch (1395:46): [True: 0, False: 0]
  ------------------
 1396|      5|            struct in_addr addr_a;
 1397|      5|            struct in_addr addr_b;
 1398|      5|            fill_addr4(&a->ip.v4, &addr_a);
 1399|      5|            fill_addr4(&b->ip.v4, &addr_b);
 1400|      5|            return addr_a.s_addr == addr_b.s_addr;
 1401|      5|        }
 1402|       |
 1403|      0|        if (net_family_is_ipv6(a->family) || net_family_is_tcp_ipv6(a->family)) {
  ------------------
  |  Branch (1403:13): [True: 0, False: 0]
  |  Branch (1403:46): [True: 0, False: 0]
  ------------------
 1404|      0|            return a->ip.v6.uint64[0] == b->ip.v6.uint64[0] &&
  ------------------
  |  Branch (1404:20): [True: 0, False: 0]
  ------------------
 1405|      0|                   a->ip.v6.uint64[1] == b->ip.v6.uint64[1];
  ------------------
  |  Branch (1405:20): [True: 0, False: 0]
  ------------------
 1406|      0|        }
 1407|       |
 1408|      0|        return false;
 1409|      0|    }
 1410|       |
 1411|       |    /* different family: check on the IPv6 one if it is the IPv4 one embedded */
 1412|      0|    if (net_family_is_ipv4(a->family) && net_family_is_ipv6(b->family)) {
  ------------------
  |  Branch (1412:9): [True: 0, False: 0]
  |  Branch (1412:42): [True: 0, False: 0]
  ------------------
 1413|      0|        if (ipv6_ipv4_in_v6(&b->ip.v6)) {
  ------------------
  |  Branch (1413:13): [True: 0, False: 0]
  ------------------
 1414|      0|            struct in_addr addr_a;
 1415|      0|            fill_addr4(&a->ip.v4, &addr_a);
 1416|      0|            return addr_a.s_addr == b->ip.v6.uint32[3];
 1417|      0|        }
 1418|      0|    } else if (net_family_is_ipv6(a->family) && net_family_is_ipv4(b->family)) {
  ------------------
  |  Branch (1418:16): [True: 0, False: 0]
  |  Branch (1418:49): [True: 0, False: 0]
  ------------------
 1419|      0|        if (ipv6_ipv4_in_v6(&a->ip.v6)) {
  ------------------
  |  Branch (1419:13): [True: 0, False: 0]
  ------------------
 1420|      0|            struct in_addr addr_b;
 1421|      0|            fill_addr4(&b->ip.v4, &addr_b);
 1422|      0|            return a->ip.v6.uint32[3] == addr_b.s_addr;
 1423|      0|        }
 1424|      0|    }
 1425|       |
 1426|      0|    return false;
 1427|      0|}
ipport_equal:
 1430|      5|{
 1431|      5|    if (a == nullptr || b == nullptr) {
  ------------------
  |  |   66|     10|#define nullptr NULL
  ------------------
                  if (a == nullptr || b == nullptr) {
  ------------------
  |  |   66|      5|#define nullptr NULL
  ------------------
  |  Branch (1431:9): [True: 0, False: 5]
  |  Branch (1431:25): [True: 0, False: 5]
  ------------------
 1432|      0|        return false;
 1433|      0|    }
 1434|       |
 1435|      5|    if (a->port == 0 || (a->port != b->port)) {
  ------------------
  |  Branch (1435:9): [True: 0, False: 5]
  |  Branch (1435:25): [True: 0, False: 5]
  ------------------
 1436|      0|        return false;
 1437|      0|    }
 1438|       |
 1439|      5|    return ip_equal(&a->ip, &b->ip);
 1440|      5|}
ip_reset:
 1444|  32.6k|{
 1445|  32.6k|    if (ip == nullptr) {
  ------------------
  |  |   66|  32.6k|#define nullptr NULL
  ------------------
  |  Branch (1445:9): [True: 0, False: 32.6k]
  ------------------
 1446|      0|        return;
 1447|      0|    }
 1448|       |
 1449|  32.6k|    *ip = empty_ip;
 1450|  32.6k|}
ip_init:
 1464|    965|{
 1465|    965|    if (ip == nullptr) {
  ------------------
  |  |   66|    965|#define nullptr NULL
  ------------------
  |  Branch (1465:9): [True: 0, False: 965]
  ------------------
 1466|      0|        return;
 1467|      0|    }
 1468|       |
 1469|    965|    *ip = empty_ip;
 1470|    965|    ip->family = ipv6enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (1470:18): [True: 965, False: 0]
  ------------------
 1471|    965|}
ip_isset:
 1475|  2.38M|{
 1476|  2.38M|    if (ip == nullptr) {
  ------------------
  |  |   66|  2.38M|#define nullptr NULL
  ------------------
  |  Branch (1476:9): [True: 0, False: 2.38M]
  ------------------
 1477|      0|        return false;
 1478|      0|    }
 1479|       |
 1480|  2.38M|    return !net_family_is_unspec(ip->family);
 1481|  2.38M|}
ipport_copy:
 1509|    221|{
 1510|    221|    if (source == nullptr || target == nullptr) {
  ------------------
  |  |   66|    442|#define nullptr NULL
  ------------------
                  if (source == nullptr || target == nullptr) {
  ------------------
  |  |   66|    221|#define nullptr NULL
  ------------------
  |  Branch (1510:9): [True: 0, False: 221]
  |  Branch (1510:30): [True: 0, False: 221]
  ------------------
 1511|      0|        return;
 1512|      0|    }
 1513|       |
 1514|    221|    *target = *source;
 1515|    221|}
ip_parse_addr:
 1545|    261|{
 1546|    261|    if (address == nullptr || ip == nullptr) {
  ------------------
  |  |   66|    522|#define nullptr NULL
  ------------------
                  if (address == nullptr || ip == nullptr) {
  ------------------
  |  |   66|    261|#define nullptr NULL
  ------------------
  |  Branch (1546:9): [True: 0, False: 261]
  |  Branch (1546:31): [True: 0, False: 261]
  ------------------
 1547|      0|        return false;
 1548|      0|    }
 1549|       |
 1550|    261|    if (net_family_is_ipv4(ip->family)) {
  ------------------
  |  Branch (1550:9): [True: 261, False: 0]
  ------------------
 1551|    261|        struct in_addr addr;
 1552|    261|        assert(make_family(ip->family) == AF_INET);
 1553|      0|        fill_addr4(&ip->ip.v4, &addr);
 1554|    261|        return inet_ntop4(&addr, address, length) != nullptr;
  ------------------
  |  |   66|    261|#define nullptr NULL
  ------------------
 1555|    261|    }
 1556|       |
 1557|      0|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1557:9): [True: 0, False: 0]
  ------------------
 1558|      0|        struct in6_addr addr;
 1559|      0|        assert(make_family(ip->family) == AF_INET6);
 1560|      0|        fill_addr6(&ip->ip.v6, &addr);
 1561|      0|        return inet_ntop6(&addr, address, length) != nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1562|      0|    }
 1563|       |
 1564|      0|    return false;
 1565|      0|}
addr_parse_ip:
 1568|  2.14k|{
 1569|  2.14k|    if (address == nullptr || to == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                  if (address == nullptr || to == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (1569:9): [True: 0, False: 2.14k]
  |  Branch (1569:31): [True: 0, False: 2.14k]
  ------------------
 1570|      0|        return false;
 1571|      0|    }
 1572|       |
 1573|  2.14k|    struct in_addr addr4;
 1574|       |
 1575|  2.14k|    if (inet_pton4(address, &addr4) == 1) {
  ------------------
  |  Branch (1575:9): [True: 2.14k, False: 0]
  ------------------
 1576|  2.14k|        to->family = net_family_ipv4();
 1577|  2.14k|        get_ip4(&to->ip.v4, &addr4);
 1578|  2.14k|        return true;
 1579|  2.14k|    }
 1580|       |
 1581|      0|    struct in6_addr addr6;
 1582|       |
 1583|      0|    if (inet_pton6(address, &addr6) == 1) {
  ------------------
  |  Branch (1583:9): [True: 0, False: 0]
  ------------------
 1584|      0|        to->family = net_family_ipv6();
 1585|      0|        get_ip6(&to->ip.v6, &addr6);
 1586|      0|        return true;
 1587|      0|    }
 1588|       |
 1589|      0|    return false;
 1590|      0|}
addr_resolve_or_parse_ip:
 1708|    278|{
 1709|    278|    if (addr_resolve(ns, address, to, extra) == 0) {
  ------------------
  |  Branch (1709:9): [True: 278, False: 0]
  ------------------
 1710|    278|        if (!addr_parse_ip(address, to)) {
  ------------------
  |  Branch (1710:13): [True: 0, False: 278]
  ------------------
 1711|      0|            return false;
 1712|      0|        }
 1713|    278|    }
 1714|       |
 1715|    278|    return true;
 1716|    278|}
net_connect:
 1719|    548|{
 1720|    548|    struct sockaddr_storage addr = {0};
 1721|    548|    size_t addrsize;
 1722|       |
 1723|    548|    if (net_family_is_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (1723:9): [True: 548, False: 0]
  ------------------
 1724|    548|        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr;
 1725|       |
 1726|    548|        addrsize = sizeof(struct sockaddr_in);
 1727|    548|        addr4->sin_family = AF_INET;
 1728|    548|        fill_addr4(&ip_port->ip.ip.v4, &addr4->sin_addr);
 1729|    548|        addr4->sin_port = ip_port->port;
 1730|    548|    } else if (net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (1730:16): [True: 0, False: 0]
  ------------------
 1731|      0|        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr;
 1732|       |
 1733|      0|        addrsize = sizeof(struct sockaddr_in6);
 1734|      0|        addr6->sin6_family = AF_INET6;
 1735|      0|        fill_addr6(&ip_port->ip.ip.v6, &addr6->sin6_addr);
 1736|      0|        addr6->sin6_port = ip_port->port;
 1737|      0|    } else {
 1738|      0|        Ip_Ntoa ip_str;
 1739|      0|        LOGGER_ERROR(log, "cannot connect to %s:%d which is neither IPv4 nor IPv6",
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1740|      0|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port));
 1741|      0|        return false;
 1742|      0|    }
 1743|       |
 1744|    548|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
 1745|    548|    if ((true)) {
  ------------------
  |  Branch (1745:9): [Folded - Ignored]
  ------------------
 1746|    548|        return true;
 1747|    548|    }
 1748|      0|#endif
 1749|       |
 1750|      0|    Ip_Ntoa ip_str;
 1751|      0|    LOGGER_DEBUG(log, "connecting socket %d to %s:%d",
  ------------------
  |  |   80|      0|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1752|      0|                 (int)sock.sock, net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port));
 1753|      0|    errno = 0;
 1754|       |
 1755|      0|    if (connect(sock.sock, (struct sockaddr *)&addr, addrsize) == -1) {
  ------------------
  |  Branch (1755:9): [True: 0, False: 0]
  ------------------
 1756|      0|        const int error = net_error();
 1757|       |
 1758|       |        // Non-blocking socket: "Operation in progress" means it's connecting.
 1759|      0|        if (!should_ignore_connect_error(error)) {
  ------------------
  |  Branch (1759:13): [True: 0, False: 0]
  ------------------
 1760|      0|            char *net_strerror = net_new_strerror(error);
 1761|      0|            LOGGER_ERROR(log, "failed to connect to %s:%d: %d (%s)",
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1762|      0|                         net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), error, net_strerror);
 1763|      0|            net_kill_strerror(net_strerror);
 1764|      0|            return false;
 1765|      0|        }
 1766|      0|    }
 1767|       |
 1768|      0|    return true;
 1769|      0|}
net_getipport:
 1772|  1.86k|{
 1773|       |    // Try parsing as IP address first.
 1774|  1.86k|    IP_Port parsed = {{{0}}};
 1775|       |    // Initialise to nullptr. In error paths, at least we initialise the out
 1776|       |    // parameter.
 1777|  1.86k|    *res = nullptr;
  ------------------
  |  |   66|  1.86k|#define nullptr NULL
  ------------------
 1778|       |
 1779|  1.86k|    if (addr_parse_ip(node, &parsed.ip)) {
  ------------------
  |  Branch (1779:9): [True: 1.86k, False: 0]
  ------------------
 1780|  1.86k|        IP_Port *tmp = (IP_Port *)mem_alloc(mem, sizeof(IP_Port));
 1781|       |
 1782|  1.86k|        if (tmp == nullptr) {
  ------------------
  |  |   66|  1.86k|#define nullptr NULL
  ------------------
  |  Branch (1782:13): [True: 992, False: 874]
  ------------------
 1783|    992|            return -1;
 1784|    992|        }
 1785|       |
 1786|    874|        tmp[0] = parsed;
 1787|    874|        *res = tmp;
 1788|    874|        return 1;
 1789|  1.86k|    }
 1790|       |
 1791|      0|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
 1792|      0|    if ((true)) {
  ------------------
  |  Branch (1792:9): [Folded - Ignored]
  ------------------
 1793|      0|        *res = (IP_Port *)mem_alloc(mem, sizeof(IP_Port));
 1794|      0|        assert(*res != nullptr);
 1795|      0|        IP_Port *ip_port = *res;
 1796|      0|        ip_port->ip.ip.v4.uint32 = net_htonl(0x7F000003); // 127.0.0.3
 1797|      0|        ip_port->ip.family = *make_tox_family(AF_INET);
 1798|       |
 1799|      0|        return 1;
 1800|      0|    }
 1801|      0|#endif
 1802|       |
 1803|       |    // It's not an IP address, so now we try doing a DNS lookup.
 1804|      0|    struct addrinfo *infos;
 1805|      0|    const int ret = getaddrinfo(node, nullptr, nullptr, &infos);
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
                  const int ret = getaddrinfo(node, nullptr, nullptr, &infos);
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1806|       |
 1807|      0|    if (ret != 0) {
  ------------------
  |  Branch (1807:9): [True: 0, False: 0]
  ------------------
 1808|      0|        return -1;
 1809|      0|    }
 1810|       |
 1811|       |    // Used to avoid calloc parameter overflow
 1812|      0|    const size_t max_count = min_u64(SIZE_MAX, INT32_MAX) / sizeof(IP_Port);
 1813|      0|    const int type = make_socktype(tox_type);
 1814|      0|    size_t count = 0;
 1815|       |
 1816|      0|    for (struct addrinfo *cur = infos; count < max_count && cur != nullptr; cur = cur->ai_next) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1816:40): [True: 0, False: 0]
  |  Branch (1816:61): [True: 0, False: 0]
  ------------------
 1817|      0|        if (cur->ai_socktype && type > 0 && cur->ai_socktype != type) {
  ------------------
  |  Branch (1817:13): [True: 0, False: 0]
  |  Branch (1817:33): [True: 0, False: 0]
  |  Branch (1817:45): [True: 0, False: 0]
  ------------------
 1818|      0|            continue;
 1819|      0|        }
 1820|       |
 1821|      0|        if (cur->ai_family != AF_INET && cur->ai_family != AF_INET6) {
  ------------------
  |  Branch (1821:13): [True: 0, False: 0]
  |  Branch (1821:42): [True: 0, False: 0]
  ------------------
 1822|      0|            continue;
 1823|      0|        }
 1824|       |
 1825|      0|        ++count;
 1826|      0|    }
 1827|       |
 1828|      0|    assert(count <= max_count);
 1829|       |
 1830|      0|    if (count == 0) {
  ------------------
  |  Branch (1830:9): [True: 0, False: 0]
  ------------------
 1831|      0|        freeaddrinfo(infos);
 1832|      0|        return 0;
 1833|      0|    }
 1834|       |
 1835|      0|    *res = (IP_Port *)mem_valloc(mem, count, sizeof(IP_Port));
 1836|       |
 1837|      0|    if (*res == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1837:9): [True: 0, False: 0]
  ------------------
 1838|      0|        freeaddrinfo(infos);
 1839|      0|        return -1;
 1840|      0|    }
 1841|       |
 1842|      0|    IP_Port *ip_port = *res;
 1843|       |
 1844|      0|    for (struct addrinfo *cur = infos; cur != nullptr; cur = cur->ai_next) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1844:40): [True: 0, False: 0]
  ------------------
 1845|      0|        if (cur->ai_socktype && type > 0 && cur->ai_socktype != type) {
  ------------------
  |  Branch (1845:13): [True: 0, False: 0]
  |  Branch (1845:33): [True: 0, False: 0]
  |  Branch (1845:45): [True: 0, False: 0]
  ------------------
 1846|      0|            continue;
 1847|      0|        }
 1848|       |
 1849|      0|        if (cur->ai_family == AF_INET) {
  ------------------
  |  Branch (1849:13): [True: 0, False: 0]
  ------------------
 1850|      0|            const struct sockaddr_in *addr = (const struct sockaddr_in *)(const void *)cur->ai_addr;
 1851|      0|            memcpy(&ip_port->ip.ip.v4, &addr->sin_addr, sizeof(IP4));
 1852|      0|        } else if (cur->ai_family == AF_INET6) {
  ------------------
  |  Branch (1852:20): [True: 0, False: 0]
  ------------------
 1853|      0|            const struct sockaddr_in6 *addr = (const struct sockaddr_in6 *)(const void *)cur->ai_addr;
 1854|      0|            memcpy(&ip_port->ip.ip.v6, &addr->sin6_addr, sizeof(IP6));
 1855|      0|        } else {
 1856|      0|            continue;
 1857|      0|        }
 1858|       |
 1859|      0|        const Family *const family = make_tox_family(cur->ai_family);
 1860|      0|        assert(family != nullptr);
 1861|       |
 1862|      0|        if (family == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1862:13): [True: 0, False: 0]
  ------------------
 1863|      0|            freeaddrinfo(infos);
 1864|      0|            return -1;
 1865|      0|        }
 1866|       |
 1867|      0|        ip_port->ip.family = *family;
 1868|       |
 1869|      0|        ++ip_port;
 1870|      0|    }
 1871|       |
 1872|      0|    freeaddrinfo(infos);
 1873|       |
 1874|      0|    return count;
 1875|      0|}
net_freeipport:
 1878|  1.86k|{
 1879|  1.86k|    mem_delete(mem, ip_ports);
 1880|  1.86k|}
bind_to_port:
 1883|    145|{
 1884|    145|    Network_Addr addr = {{0}};
 1885|       |
 1886|    145|    if (net_family_is_ipv4(family)) {
  ------------------
  |  Branch (1886:9): [True: 0, False: 145]
  ------------------
 1887|      0|        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr.addr;
 1888|       |
 1889|      0|        addr.size = sizeof(struct sockaddr_in);
 1890|      0|        addr4->sin_family = AF_INET;
 1891|      0|        addr4->sin_port = net_htons(port);
 1892|    145|    } else if (net_family_is_ipv6(family)) {
  ------------------
  |  Branch (1892:16): [True: 145, False: 0]
  ------------------
 1893|    145|        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr.addr;
 1894|       |
 1895|    145|        addr.size = sizeof(struct sockaddr_in6);
 1896|    145|        addr6->sin6_family = AF_INET6;
 1897|    145|        addr6->sin6_port = net_htons(port);
 1898|    145|    } else {
 1899|      0|        return false;
 1900|      0|    }
 1901|       |
 1902|    145|    return net_bind(ns, sock, &addr) == 0;
 1903|    145|}
net_socket:
 1906|  1.37k|{
 1907|  1.37k|    const int platform_domain = make_family(domain);
 1908|  1.37k|    const int platform_type = make_socktype(type);
 1909|  1.37k|    const int platform_prot = make_proto(protocol);
 1910|  1.37k|    const Socket sock = {ns->funcs->socket(ns->obj, platform_domain, platform_type, platform_prot)};
 1911|  1.37k|    return sock;
 1912|  1.37k|}
net_socket_data_recv_buffer:
 1915|  50.4k|{
 1916|  50.4k|    const int count = ns->funcs->recvbuf(ns->obj, sock.sock);
 1917|  50.4k|    return (uint16_t)max_s32(0, min_s32(count, UINT16_MAX));
 1918|  50.4k|}
net_htonl:
 1921|    954|{
 1922|    954|    return htonl(hostlong);
 1923|    954|}
net_htons:
 1926|  25.5k|{
 1927|  25.5k|    return htons(hostshort);
 1928|  25.5k|}
net_ntohs:
 1936|    261|{
 1937|    261|    return ntohs(hostshort);
 1938|    261|}
net_pack_u16:
 1947|     30|{
 1948|     30|    bytes[0] = (v >> 8) & 0xff;
 1949|     30|    bytes[1] = v & 0xff;
 1950|     30|    return sizeof(v);
 1951|     30|}
net_pack_u32:
 1954|     15|{
 1955|     15|    uint8_t *p = bytes;
 1956|     15|    p += net_pack_u16(p, (v >> 16) & 0xffff);
 1957|     15|    p += net_pack_u16(p, v & 0xffff);
 1958|     15|    return p - bytes;
 1959|     15|}
net_pack_u64:
 1962|      5|{
 1963|      5|    uint8_t *p = bytes;
 1964|      5|    p += net_pack_u32(p, (v >> 32) & 0xffffffff);
 1965|      5|    p += net_pack_u32(p, v & 0xffffffff);
 1966|      5|    return p - bytes;
 1967|      5|}
net_unpack_bool:
 1970|     15|{
 1971|     15|    *v = bytes[0] != 0;
 1972|     15|    return 1;
 1973|     15|}
net_unpack_u16:
 1976|    586|{
 1977|    586|    const uint8_t hi = bytes[0];
 1978|    586|    const uint8_t lo = bytes[1];
 1979|    586|    *v = ((uint16_t)hi << 8) | lo;
 1980|    586|    return sizeof(*v);
 1981|    586|}
net_unpack_u32:
 1984|     24|{
 1985|     24|    const uint8_t *p = bytes;
 1986|     24|    uint16_t hi;
 1987|     24|    uint16_t lo;
 1988|     24|    p += net_unpack_u16(p, &hi);
 1989|     24|    p += net_unpack_u16(p, &lo);
 1990|     24|    *v = ((uint32_t)hi << 16) | lo;
 1991|     24|    return p - bytes;
 1992|     24|}
net_unpack_u64:
 1995|      1|{
 1996|      1|    const uint8_t *p = bytes;
 1997|      1|    uint32_t hi;
 1998|      1|    uint32_t lo;
 1999|      1|    p += net_unpack_u32(p, &hi);
 2000|      1|    p += net_unpack_u32(p, &lo);
 2001|      1|    *v = ((uint64_t)hi << 32) | lo;
 2002|      1|    return p - bytes;
 2003|      1|}
ipv6_ipv4_in_v6:
 2006|      1|{
 2007|      1|    return a->uint64[0] == 0 && a->uint32[2] == net_htonl(0xffff);
  ------------------
  |  Branch (2007:12): [True: 1, False: 0]
  |  Branch (2007:33): [True: 0, False: 1]
  ------------------
 2008|      1|}
net_error:
 2011|  27.5k|{
 2012|       |#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
 2013|       |    return WSAGetLastError();
 2014|       |#else
 2015|  27.5k|    return errno;
 2016|  27.5k|#endif
 2017|  27.5k|}
net_new_strerror:
 2061|  16.2k|{
 2062|  16.2k|    char tmp[256];
 2063|       |
 2064|  16.2k|    errno = 0;
 2065|       |
 2066|  16.2k|    const char *retstr = net_strerror_r(error, tmp, sizeof(tmp));
 2067|  16.2k|    const size_t retstr_len = strlen(retstr);
 2068|       |
 2069|  16.2k|    char *str = (char *)malloc(retstr_len + 1);
 2070|       |
 2071|  16.2k|    if (str == nullptr) {
  ------------------
  |  |   66|  16.2k|#define nullptr NULL
  ------------------
  |  Branch (2071:9): [True: 0, False: 16.2k]
  ------------------
 2072|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2073|      0|    }
 2074|       |
 2075|  16.2k|    memcpy(str, retstr, retstr_len + 1);
 2076|       |
 2077|  16.2k|    return str;
 2078|  16.2k|}
net_kill_strerror:
 2082|  16.2k|{
 2083|       |#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
 2084|       |    LocalFree((char *)strerror);
 2085|       |#else
 2086|  16.2k|    free(strerror);
 2087|  16.2k|#endif
 2088|  16.2k|}
network.c:loglogdata:
  776|  46.6k|{
  777|  46.6k|    if (res < 0) { /* Windows doesn't necessarily know `%zu` */
  ------------------
  |  Branch (777:9): [True: 14.8k, False: 31.8k]
  ------------------
  778|  14.8k|        Ip_Ntoa ip_str;
  779|  14.8k|        const int error = net_error();
  780|  14.8k|        char *strerror = net_new_strerror(error);
  781|  14.8k|        LOGGER_TRACE(log, "[%02x = %-20s] %s %3u%c %s:%u (%u: %s) | %08x%08x...%02x",
  ------------------
  |  |   79|  14.8k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  14.8k|    do {                                                                         \
  |  |  |  |   73|  14.8k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  29.7k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  14.8k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  782|  14.8k|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  783|  14.8k|                     min_u16(buflen, 999), 'E',
  784|  14.8k|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), error,
  785|  14.8k|                     strerror, data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  786|  14.8k|        net_kill_strerror(strerror);
  787|  31.8k|    } else if ((res > 0) && ((size_t)res <= buflen)) {
  ------------------
  |  Branch (787:16): [True: 24.3k, False: 7.49k]
  |  Branch (787:29): [True: 24.3k, False: 0]
  ------------------
  788|  24.3k|        Ip_Ntoa ip_str;
  789|  24.3k|        LOGGER_TRACE(log, "[%02x = %-20s] %s %3u%c %s:%u (%u: %s) | %08x%08x...%02x",
  ------------------
  |  |   79|  24.3k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  24.3k|    do {                                                                         \
  |  |  |  |   73|  24.3k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  48.6k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (74:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  24.3k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  790|  24.3k|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  791|  24.3k|                     min_u16(res, 999), (size_t)res < buflen ? '<' : '=',
  792|  24.3k|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
  793|  24.3k|                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  794|  24.3k|    } else { /* empty or overwrite */
  795|  7.49k|        Ip_Ntoa ip_str;
  796|  7.49k|        LOGGER_TRACE(log, "[%02x = %-20s] %s %lu%c%u %s:%u (%u: %s) | %08x%08x...%02x",
  ------------------
  |  |   79|  7.49k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  7.49k|    do {                                                                         \
  |  |  |  |   73|  7.49k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  14.9k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (74:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  7.49k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  797|  7.49k|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  798|  7.49k|                     res, res == 0 ? '!' : '>', buflen,
  799|  7.49k|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
  800|  7.49k|                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  801|  7.49k|    }
  802|  46.6k|}
network.c:net_setsockopt:
  625|  2.88k|{
  626|  2.88k|    return ns->funcs->setsockopt(ns->obj, sock.sock, level, optname, optval, optlen);
  627|  2.88k|}
network.c:net_getsockopt:
  631|    831|{
  632|    831|    return ns->funcs->getsockopt(ns->obj, sock.sock, level, optname, optval, optlen);
  633|    831|}
network.c:fill_addr4:
  333|    819|{
  334|    819|    addr->s_addr = ip->uint32;
  335|    819|}
network.c:fill_addr6:
  339|  19.5k|{
  340|  19.5k|    memcpy(addr->s6_addr, ip->uint8, sizeof(ip->uint8));
  341|  19.5k|}
network.c:net_sendto:
  816|  18.8k|{
  817|  18.8k|    return ns->funcs->sendto(ns->obj, sock.sock, buf, len, addr);
  818|  18.8k|}
network.c:receivepacket:
 1014|  21.5k|{
 1015|  21.5k|    memset(ip_port, 0, sizeof(IP_Port));
 1016|  21.5k|    Network_Addr addr = {{0}};
 1017|  21.5k|    addr.size = sizeof(addr.addr);
 1018|  21.5k|    *length = 0;
 1019|       |
 1020|  21.5k|    const int fail_or_len = net_recvfrom(ns, sock, data, MAX_UDP_PACKET_SIZE, &addr);
  ------------------
  |  |   98|  21.5k|#define MAX_UDP_PACKET_SIZE 2048
  ------------------
 1021|       |
 1022|  21.5k|    if (fail_or_len < 0) {
  ------------------
  |  Branch (1022:9): [True: 12.0k, False: 9.55k]
  ------------------
 1023|  12.0k|        const int error = net_error();
 1024|       |
 1025|  12.0k|        if (!should_ignore_recv_error(error)) {
  ------------------
  |  Branch (1025:13): [True: 672, False: 11.3k]
  ------------------
 1026|    672|            char *strerror = net_new_strerror(error);
 1027|    672|            LOGGER_ERROR(log, "unexpected error reading from socket: %u, %s", error, strerror);
  ------------------
  |  |   83|    672|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    672|    do {                                                                         \
  |  |  |  |   73|    672|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  1.34k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    672|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    672|        }                                                                        \
  |  |  |  |   76|    672|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1028|    672|            net_kill_strerror(strerror);
 1029|    672|        }
 1030|       |
 1031|  12.0k|        return -1; /* Nothing received. */
 1032|  12.0k|    }
 1033|       |
 1034|  9.55k|    *length = (uint32_t)fail_or_len;
 1035|       |
 1036|  9.55k|    if (addr.addr.ss_family == AF_INET) {
  ------------------
  |  Branch (1036:9): [True: 9.55k, False: 0]
  ------------------
 1037|  9.55k|        const struct sockaddr_in *addr_in = (const struct sockaddr_in *)&addr.addr;
 1038|       |
 1039|  9.55k|        const Family *const family = make_tox_family(addr_in->sin_family);
 1040|  9.55k|        assert(family != nullptr);
 1041|       |
 1042|  9.55k|        if (family == nullptr) {
  ------------------
  |  |   66|  9.55k|#define nullptr NULL
  ------------------
  |  Branch (1042:13): [True: 0, False: 9.55k]
  ------------------
 1043|      0|            return -1;
 1044|      0|        }
 1045|       |
 1046|  9.55k|        ip_port->ip.family = *family;
 1047|  9.55k|        get_ip4(&ip_port->ip.ip.v4, &addr_in->sin_addr);
 1048|  9.55k|        ip_port->port = addr_in->sin_port;
 1049|  9.55k|    } else if (addr.addr.ss_family == AF_INET6) {
  ------------------
  |  Branch (1049:16): [True: 0, False: 0]
  ------------------
 1050|      0|        const struct sockaddr_in6 *addr_in6 = (const struct sockaddr_in6 *)&addr.addr;
 1051|      0|        const Family *const family = make_tox_family(addr_in6->sin6_family);
 1052|      0|        assert(family != nullptr);
 1053|       |
 1054|      0|        if (family == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1054:13): [True: 0, False: 0]
  ------------------
 1055|      0|            return -1;
 1056|      0|        }
 1057|       |
 1058|      0|        ip_port->ip.family = *family;
 1059|      0|        get_ip6(&ip_port->ip.ip.v6, &addr_in6->sin6_addr);
 1060|      0|        ip_port->port = addr_in6->sin6_port;
 1061|       |
 1062|      0|        if (ipv6_ipv4_in_v6(&ip_port->ip.ip.v6)) {
  ------------------
  |  Branch (1062:13): [True: 0, False: 0]
  ------------------
 1063|      0|            ip_port->ip.family = net_family_ipv4();
 1064|      0|            ip_port->ip.ip.v4.uint32 = ip_port->ip.ip.v6.uint32[3];
 1065|      0|        }
 1066|      0|    } else {
 1067|      0|        return -1;
 1068|      0|    }
 1069|       |
 1070|  9.55k|    loglogdata(log, "=>O", data, MAX_UDP_PACKET_SIZE, ip_port, *length);
  ------------------
  |  |   98|  9.55k|#define MAX_UDP_PACKET_SIZE 2048
  ------------------
 1071|       |
 1072|  9.55k|    return 0;
 1073|  9.55k|}
network.c:net_recvfrom:
  831|  21.5k|{
  832|  21.5k|    return ns->funcs->recvfrom(ns->obj, sock.sock, buf, len, addr);
  833|  21.5k|}
network.c:should_ignore_recv_error:
  120|  12.0k|{
  121|  12.0k|    return err == EWOULDBLOCK;
  122|  12.0k|}
network.c:net_bind:
  842|    831|{
  843|    831|    return ns->funcs->bind(ns->obj, sock.sock, addr);
  844|    831|}
network.c:make_family:
  272|  1.64k|{
  273|  1.64k|    switch (tox_family.value) {
  274|    809|        case TOX_AF_INET:
  ------------------
  |  |  207|    809|#define TOX_AF_INET 2
  ------------------
  |  Branch (274:9): [True: 809, False: 831]
  ------------------
  275|    809|            return AF_INET;
  276|       |
  277|    831|        case TOX_AF_INET6:
  ------------------
  |  |  208|    831|#define TOX_AF_INET6 10
  ------------------
  |  Branch (277:9): [True: 831, False: 809]
  ------------------
  278|    831|            return AF_INET6;
  279|       |
  280|      0|        case TOX_AF_UNSPEC:
  ------------------
  |  |  206|      0|#define TOX_AF_UNSPEC 0
  ------------------
  |  Branch (280:9): [True: 0, False: 1.64k]
  ------------------
  281|      0|            return AF_UNSPEC;
  282|       |
  283|      0|        default:
  ------------------
  |  Branch (283:9): [True: 0, False: 1.64k]
  ------------------
  284|      0|            return tox_family.value;
  285|  1.64k|    }
  286|  1.64k|}
network.c:inet_ntop4:
  131|    261|{
  132|    261|    return inet_ntop(AF_INET, addr, buf, bufsize);
  133|    261|}
network.c:inet_pton4:
  143|  2.14k|{
  144|  2.14k|    return inet_pton(AF_INET, addr_string, addrbuf);
  145|  2.14k|}
network.c:get_ip4:
  317|  11.6k|{
  318|  11.6k|    static_assert(sizeof(result->uint32) == sizeof(addr->s_addr),
  ------------------
  |  |   70|  11.6k|#define static_assert _Static_assert
  ------------------
  319|  11.6k|                  "Tox and operating system don't agree on size of IPv4 addresses");
  320|  11.6k|    result->uint32 = addr->s_addr;
  321|  11.6k|}
network.c:addr_resolve:
 1615|    278|{
 1616|    278|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
 1617|    278|    if ((true)) {
  ------------------
  |  Branch (1617:9): [Folded - Ignored]
  ------------------
 1618|    278|        return 0;
 1619|    278|    }
 1620|      0|#endif
 1621|       |
 1622|      0|    if (address == nullptr || to == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
                  if (address == nullptr || to == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1622:9): [True: 0, False: 0]
  |  Branch (1622:31): [True: 0, False: 0]
  ------------------
 1623|      0|        return 0;
 1624|      0|    }
 1625|       |
 1626|      0|    const Family tox_family = to->family;
 1627|      0|    const int family = make_family(tox_family);
 1628|       |
 1629|      0|    struct addrinfo hints;
 1630|      0|    memset(&hints, 0, sizeof(hints));
 1631|      0|    hints.ai_family   = family;
 1632|      0|    hints.ai_socktype = SOCK_DGRAM; // type of socket Tox uses.
 1633|       |
 1634|      0|    struct addrinfo *server = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1635|       |
 1636|      0|    const int rc = getaddrinfo(address, nullptr, &hints, &server);
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1637|       |
 1638|       |    // Lookup failed.
 1639|      0|    if (rc != 0) {
  ------------------
  |  Branch (1639:9): [True: 0, False: 0]
  ------------------
 1640|      0|        return 0;
 1641|      0|    }
 1642|       |
 1643|      0|    IP ip4;
 1644|      0|    ip_init(&ip4, false); // ipv6enabled = false
 1645|      0|    IP ip6;
 1646|      0|    ip_init(&ip6, true); // ipv6enabled = true
 1647|       |
 1648|      0|    int result = 0;
 1649|      0|    bool done = false;
 1650|       |
 1651|      0|    for (struct addrinfo *walker = server; walker != nullptr && !done; walker = walker->ai_next) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1651:44): [True: 0, False: 0]
  |  Branch (1651:65): [True: 0, False: 0]
  ------------------
 1652|      0|        switch (walker->ai_family) {
  ------------------
  |  Branch (1652:17): [True: 0, False: 0]
  ------------------
 1653|      0|            case AF_INET: {
  ------------------
  |  Branch (1653:13): [True: 0, False: 0]
  ------------------
 1654|      0|                if (walker->ai_family == family) { /* AF_INET requested, done */
  ------------------
  |  Branch (1654:21): [True: 0, False: 0]
  ------------------
 1655|      0|                    const struct sockaddr_in *addr = (const struct sockaddr_in *)(const void *)walker->ai_addr;
 1656|      0|                    get_ip4(&to->ip.v4, &addr->sin_addr);
 1657|      0|                    result = TOX_ADDR_RESOLVE_INET;
  ------------------
  |  | 1593|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
 1658|      0|                    done = true;
 1659|      0|                } else if ((result & TOX_ADDR_RESOLVE_INET) == 0) { /* AF_UNSPEC requested, store away */
  ------------------
  |  | 1593|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
  |  Branch (1659:28): [True: 0, False: 0]
  ------------------
 1660|      0|                    const struct sockaddr_in *addr = (const struct sockaddr_in *)(const void *)walker->ai_addr;
 1661|      0|                    get_ip4(&ip4.ip.v4, &addr->sin_addr);
 1662|      0|                    result |= TOX_ADDR_RESOLVE_INET;
  ------------------
  |  | 1593|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
 1663|      0|                }
 1664|       |
 1665|      0|                break; /* switch */
 1666|      0|            }
 1667|       |
 1668|      0|            case AF_INET6: {
  ------------------
  |  Branch (1668:13): [True: 0, False: 0]
  ------------------
 1669|      0|                if (walker->ai_family == family) { /* AF_INET6 requested, done */
  ------------------
  |  Branch (1669:21): [True: 0, False: 0]
  ------------------
 1670|      0|                    if (walker->ai_addrlen == sizeof(struct sockaddr_in6)) {
  ------------------
  |  Branch (1670:25): [True: 0, False: 0]
  ------------------
 1671|      0|                        const struct sockaddr_in6 *addr = (const struct sockaddr_in6 *)(void *)walker->ai_addr;
 1672|      0|                        get_ip6(&to->ip.v6, &addr->sin6_addr);
 1673|      0|                        result = TOX_ADDR_RESOLVE_INET6;
  ------------------
  |  | 1594|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
 1674|      0|                        done = true;
 1675|      0|                    }
 1676|      0|                } else if ((result & TOX_ADDR_RESOLVE_INET6) == 0) { /* AF_UNSPEC requested, store away */
  ------------------
  |  | 1594|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
  |  Branch (1676:28): [True: 0, False: 0]
  ------------------
 1677|      0|                    if (walker->ai_addrlen == sizeof(struct sockaddr_in6)) {
  ------------------
  |  Branch (1677:25): [True: 0, False: 0]
  ------------------
 1678|      0|                        const struct sockaddr_in6 *addr = (const struct sockaddr_in6 *)(void *)walker->ai_addr;
 1679|      0|                        get_ip6(&ip6.ip.v6, &addr->sin6_addr);
 1680|      0|                        result |= TOX_ADDR_RESOLVE_INET6;
  ------------------
  |  | 1594|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
 1681|      0|                    }
 1682|      0|                }
 1683|       |
 1684|      0|                break; /* switch */
 1685|      0|            }
 1686|      0|        }
 1687|      0|    }
 1688|       |
 1689|      0|    if (family == AF_UNSPEC) {
  ------------------
  |  Branch (1689:9): [True: 0, False: 0]
  ------------------
 1690|      0|        if ((result & TOX_ADDR_RESOLVE_INET6) != 0) {
  ------------------
  |  | 1594|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
  |  Branch (1690:13): [True: 0, False: 0]
  ------------------
 1691|      0|            ip_copy(to, &ip6);
 1692|       |
 1693|      0|            if ((result & TOX_ADDR_RESOLVE_INET) != 0 && (extra != nullptr)) {
  ------------------
  |  | 1593|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
                          if ((result & TOX_ADDR_RESOLVE_INET) != 0 && (extra != nullptr)) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1693:17): [True: 0, False: 0]
  |  Branch (1693:58): [True: 0, False: 0]
  ------------------
 1694|      0|                ip_copy(extra, &ip4);
 1695|      0|            }
 1696|      0|        } else if ((result & TOX_ADDR_RESOLVE_INET) != 0) {
  ------------------
  |  | 1593|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
  |  Branch (1696:20): [True: 0, False: 0]
  ------------------
 1697|      0|            ip_copy(to, &ip4);
 1698|      0|        } else {
 1699|      0|            result = 0;
 1700|      0|        }
 1701|      0|    }
 1702|       |
 1703|      0|    freeaddrinfo(server);
 1704|      0|    return result;
 1705|      0|}
network.c:make_tox_family:
  299|  9.55k|{
  300|  9.55k|    switch (family) {
  301|  9.55k|        case AF_INET:
  ------------------
  |  Branch (301:9): [True: 9.55k, False: 0]
  ------------------
  302|  9.55k|            return &family_ipv4;
  303|       |
  304|      0|        case AF_INET6:
  ------------------
  |  Branch (304:9): [True: 0, False: 9.55k]
  ------------------
  305|      0|            return &family_ipv6;
  306|       |
  307|      0|        case AF_UNSPEC:
  ------------------
  |  Branch (307:9): [True: 0, False: 9.55k]
  ------------------
  308|      0|            return &family_unspec;
  309|       |
  310|      0|        default:
  ------------------
  |  Branch (310:9): [True: 0, False: 9.55k]
  ------------------
  311|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  312|  9.55k|    }
  313|  9.55k|}
network.c:make_socktype:
  258|  1.37k|{
  259|  1.37k|    switch (type) {
  260|    693|        case TOX_SOCK_STREAM:
  ------------------
  |  |  212|    693|#define TOX_SOCK_STREAM 1
  ------------------
  |  Branch (260:9): [True: 693, False: 686]
  ------------------
  261|    693|            return SOCK_STREAM;
  262|       |
  263|    686|        case TOX_SOCK_DGRAM:
  ------------------
  |  |  213|    686|#define TOX_SOCK_DGRAM 2
  ------------------
  |  Branch (263:9): [True: 686, False: 693]
  ------------------
  264|    686|            return SOCK_DGRAM;
  265|       |
  266|      0|        default:
  ------------------
  |  Branch (266:9): [True: 0, False: 1.37k]
  ------------------
  267|      0|            return type;
  268|  1.37k|    }
  269|  1.37k|}
network.c:make_proto:
  244|  1.37k|{
  245|  1.37k|    switch (proto) {
  246|    693|        case TOX_PROTO_TCP:
  ------------------
  |  |  215|    693|#define TOX_PROTO_TCP 1
  ------------------
  |  Branch (246:9): [True: 693, False: 686]
  ------------------
  247|    693|            return IPPROTO_TCP;
  248|       |
  249|    686|        case TOX_PROTO_UDP:
  ------------------
  |  |  216|    686|#define TOX_PROTO_UDP 2
  ------------------
  |  Branch (249:9): [True: 686, False: 693]
  ------------------
  250|    686|            return IPPROTO_UDP;
  251|       |
  252|      0|        default:
  ------------------
  |  Branch (252:9): [True: 0, False: 1.37k]
  ------------------
  253|      0|            return proto;
  254|  1.37k|    }
  255|  1.37k|}
network.c:net_strerror_r:
 2050|  16.2k|{
 2051|  16.2k|    const int fmt_error = strerror_r(error, tmp, tmp_size);
 2052|       |
 2053|  16.2k|    if (fmt_error != 0) {
  ------------------
  |  Branch (2053:9): [True: 0, False: 16.2k]
  ------------------
 2054|      0|        snprintf(tmp, tmp_size, "error %d (strerror_r failed with error %d, errno %d)", error, fmt_error, errno);
 2055|      0|    }
 2056|       |
 2057|  16.2k|    return tmp;
 2058|  16.2k|}

send_onion_response:
  288|      6|{
  289|      6|    if (length > ONION_RESPONSE_MAX_DATA_SIZE || length == 0) {
  ------------------
  |  |   49|     12|#define ONION_RESPONSE_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (1 + ONION_RETURN_3))
  |  |  ------------------
  |  |  |  |   37|      6|#define ONION_MAX_PACKET_SIZE 1400
  |  |  ------------------
  |  |               #define ONION_RESPONSE_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (1 + ONION_RETURN_3))
  |  |  ------------------
  |  |  |  |   41|      6|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      6|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|      6|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (289:9): [True: 0, False: 6]
  |  Branch (289:50): [True: 0, False: 6]
  ------------------
  290|      0|        return -1;
  291|      0|    }
  292|       |
  293|      6|    VLA(uint8_t, packet, 1 + RETURN_3 + length);
  ------------------
  |  |   62|      6|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      6|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  294|      6|    packet[0] = NET_PACKET_ONION_RECV_3;
  295|      6|    memcpy(packet + 1, ret, RETURN_3);
  ------------------
  |  |   21|      6|#define RETURN_3 ONION_RETURN_3
  |  |  ------------------
  |  |  |  |   41|      6|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      6|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|      6|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  296|      6|    memcpy(packet + 1 + RETURN_3, data, length);
  ------------------
  |  |   21|      6|#define RETURN_3 ONION_RETURN_3
  |  |  ------------------
  |  |  |  |   41|      6|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      6|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|      6|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  297|       |
  298|      6|    if ((uint32_t)sendpacket(net, dest, packet, SIZEOF_VLA(packet)) != SIZEOF_VLA(packet)) {
  ------------------
  |  |   29|      6|#define SIZEOF_VLA sizeof
  ------------------
                  if ((uint32_t)sendpacket(net, dest, packet, SIZEOF_VLA(packet)) != SIZEOF_VLA(packet)) {
  ------------------
  |  |   29|      6|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (298:9): [True: 0, False: 6]
  ------------------
  299|      0|        return -1;
  300|      0|    }
  301|       |
  302|      6|    return 0;
  303|      6|}
onion_send_1:
  341|     42|{
  342|     42|    if (len > ONION_MAX_PACKET_SIZE + SIZE_IPPORT - (1 + CRYPTO_NONCE_SIZE + ONION_RETURN_1)) {
  ------------------
  |  |   37|     42|#define ONION_MAX_PACKET_SIZE 1400
  ------------------
                  if (len > ONION_MAX_PACKET_SIZE + SIZE_IPPORT - (1 + CRYPTO_NONCE_SIZE + ONION_RETURN_1)) {
  ------------------
  |  |  228|     42|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|     42|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|     42|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|     42|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                  if (len > ONION_MAX_PACKET_SIZE + SIZE_IPPORT - (1 + CRYPTO_NONCE_SIZE + ONION_RETURN_1)) {
  ------------------
  |  |   66|     42|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  if (len > ONION_MAX_PACKET_SIZE + SIZE_IPPORT - (1 + CRYPTO_NONCE_SIZE + ONION_RETURN_1)) {
  ------------------
  |  |   39|     42|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     42|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |  228|     42|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  226|     42|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  225|     42|#define SIZE_IP6 16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  227|     42|#define SIZE_PORT 2
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     42|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  |  Branch (342:9): [True: 0, False: 42]
  ------------------
  343|      0|        return 1;
  344|      0|    }
  345|       |
  346|     42|    if (len <= SIZE_IPPORT + SEND_BASE * 2) {
  ------------------
  |  |  228|     42|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|     42|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|     42|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|     42|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                  if (len <= SIZE_IPPORT + SEND_BASE * 2) {
  ------------------
  |  |   23|     42|#define SEND_BASE ONION_SEND_BASE
  |  |  ------------------
  |  |  |  |   43|     42|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     42|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     42|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     42|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     42|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     42|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     42|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (346:9): [True: 1, False: 41]
  ------------------
  347|      1|        return 1;
  348|      1|    }
  349|       |
  350|     41|    IP_Port send_to;
  351|       |
  352|     41|    if (ipport_unpack(&send_to, plain, len, false) == -1) {
  ------------------
  |  Branch (352:9): [True: 38, False: 3]
  ------------------
  353|     38|        return 1;
  354|     38|    }
  355|       |
  356|      3|    uint8_t ip_port[SIZE_IPPORT];
  357|      3|    ipport_pack(ip_port, source);
  358|       |
  359|      3|    uint8_t data[ONION_MAX_PACKET_SIZE] = {0};
  360|      3|    data[0] = NET_PACKET_ONION_SEND_1;
  361|      3|    memcpy(data + 1, nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      3|#define CRYPTO_NONCE_SIZE              24
  ------------------
  362|      3|    memcpy(data + 1 + CRYPTO_NONCE_SIZE, plain + SIZE_IPPORT, len - SIZE_IPPORT);
  ------------------
  |  |   66|      3|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  memcpy(data + 1 + CRYPTO_NONCE_SIZE, plain + SIZE_IPPORT, len - SIZE_IPPORT);
  ------------------
  |  |  228|      3|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      3|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      3|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      3|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                  memcpy(data + 1 + CRYPTO_NONCE_SIZE, plain + SIZE_IPPORT, len - SIZE_IPPORT);
  ------------------
  |  |  228|      3|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      3|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      3|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      3|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
  363|      3|    uint16_t data_len = 1 + CRYPTO_NONCE_SIZE + (len - SIZE_IPPORT);
  ------------------
  |  |   66|      3|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  uint16_t data_len = 1 + CRYPTO_NONCE_SIZE + (len - SIZE_IPPORT);
  ------------------
  |  |  228|      3|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      3|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      3|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      3|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
  364|      3|    uint8_t *ret_part = data + data_len;
  365|      3|    random_nonce(onion->rng, ret_part);
  366|      3|    len = encrypt_data_symmetric(onion->secret_symmetric_key, ret_part, ip_port, SIZE_IPPORT,
  ------------------
  |  |  228|      3|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      3|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      3|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      3|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
  367|      3|                                 ret_part + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      3|#define CRYPTO_NONCE_SIZE              24
  ------------------
  368|       |
  369|      3|    if (len != SIZE_IPPORT + CRYPTO_MAC_SIZE) {
  ------------------
  |  |  228|      3|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      3|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      3|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      3|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                  if (len != SIZE_IPPORT + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   61|      3|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (369:9): [True: 0, False: 3]
  ------------------
  370|      0|        return 1;
  371|      0|    }
  372|       |
  373|      3|    data_len += CRYPTO_NONCE_SIZE + len;
  ------------------
  |  |   66|      3|#define CRYPTO_NONCE_SIZE              24
  ------------------
  374|       |
  375|      3|    if ((uint32_t)sendpacket(onion->net, &send_to, data, data_len) != data_len) {
  ------------------
  |  Branch (375:9): [True: 1, False: 2]
  ------------------
  376|      1|        return 1;
  377|      1|    }
  378|       |
  379|      2|    return 0;
  380|      3|}
set_callback_handle_recv_1:
  666|    290|{
  667|    290|    onion->recv_1_function = function;
  668|    290|    onion->callback_object = object;
  669|    290|}
new_onion:
  672|    946|{
  673|    946|    if (dht == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (673:9): [True: 0, False: 946]
  ------------------
  674|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  675|      0|    }
  676|       |
  677|    946|    Onion *onion = (Onion *)mem_alloc(mem, sizeof(Onion));
  678|       |
  679|    946|    if (onion == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (679:9): [True: 3, False: 943]
  ------------------
  680|      3|        return nullptr;
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  681|      3|    }
  682|       |
  683|    943|    onion->log = log;
  684|    943|    onion->dht = dht;
  685|    943|    onion->net = dht_get_net(dht);
  686|    943|    onion->mono_time = mono_time;
  687|    943|    onion->rng = rng;
  688|    943|    onion->mem = mem;
  689|    943|    new_symmetric_key(rng, onion->secret_symmetric_key);
  690|    943|    onion->timestamp = mono_time_get(onion->mono_time);
  691|       |
  692|    943|    const uint8_t *secret_key = dht_get_self_secret_key(dht);
  693|    943|    onion->shared_keys_1 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   33|    943|#define KEYS_TIMEOUT 600
  ------------------
                  onion->shared_keys_1 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   32|    943|#define MAX_KEYS_PER_SLOT 4
  ------------------
  694|    943|    onion->shared_keys_2 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   33|    943|#define KEYS_TIMEOUT 600
  ------------------
                  onion->shared_keys_2 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   32|    943|#define MAX_KEYS_PER_SLOT 4
  ------------------
  695|    943|    onion->shared_keys_3 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   33|    943|#define KEYS_TIMEOUT 600
  ------------------
                  onion->shared_keys_3 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   32|    943|#define MAX_KEYS_PER_SLOT 4
  ------------------
  696|       |
  697|    943|    if (onion->shared_keys_1 == nullptr ||
  ------------------
  |  |   66|  1.88k|#define nullptr NULL
  ------------------
  |  Branch (697:9): [True: 4, False: 939]
  ------------------
  698|    943|        onion->shared_keys_2 == nullptr ||
  ------------------
  |  |   66|  1.88k|#define nullptr NULL
  ------------------
  |  Branch (698:9): [True: 1, False: 938]
  ------------------
  699|    943|        onion->shared_keys_3 == nullptr) {
  ------------------
  |  |   66|    938|#define nullptr NULL
  ------------------
  |  Branch (699:9): [True: 1, False: 937]
  ------------------
  700|      6|        kill_onion(onion);
  701|      6|        return nullptr;
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  702|      6|    }
  703|       |
  704|       |
  705|    937|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, &handle_send_initial, onion);
  706|    937|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, &handle_send_1, onion);
  707|    937|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, &handle_send_2, onion);
  708|       |
  709|    937|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, &handle_recv_3, onion);
  710|    937|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, &handle_recv_2, onion);
  711|    937|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, &handle_recv_1, onion);
  712|       |
  713|    937|    return onion;
  714|    943|}
kill_onion:
  717|    952|{
  718|    952|    if (onion == nullptr) {
  ------------------
  |  |   66|    952|#define nullptr NULL
  ------------------
  |  Branch (718:9): [True: 9, False: 943]
  ------------------
  719|      9|        return;
  720|      9|    }
  721|       |
  722|    943|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
  723|    943|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
  724|    943|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
  725|       |
  726|    943|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
  727|    943|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
  728|    943|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
  729|       |
  730|    943|    crypto_memzero(onion->secret_symmetric_key, sizeof(onion->secret_symmetric_key));
  731|       |
  732|    943|    shared_key_cache_free(onion->shared_keys_1);
  733|    943|    shared_key_cache_free(onion->shared_keys_2);
  734|    943|    shared_key_cache_free(onion->shared_keys_3);
  735|       |
  736|    943|    mem_delete(onion->mem, onion);
  737|    943|}
onion.c:ipport_pack:
   85|      5|{
   86|      5|    ip_pack(data, &source->ip);
   87|      5|    memcpy(data + SIZE_IP, &source->port, SIZE_PORT);
  ------------------
  |  |  226|      5|#define SIZE_IP (1 + SIZE_IP6)
  |  |  ------------------
  |  |  |  |  225|      5|#define SIZE_IP6 16
  |  |  ------------------
  ------------------
                  memcpy(data + SIZE_IP, &source->port, SIZE_PORT);
  ------------------
  |  |  227|      5|#define SIZE_PORT 2
  ------------------
   88|      5|}
onion.c:ip_pack:
   48|      5|{
   49|      5|    data[0] = source->family.value;
   50|       |
   51|      5|    if (net_family_is_ipv4(source->family) || net_family_is_tox_tcp_ipv4(source->family)) {
  ------------------
  |  Branch (51:9): [True: 4, False: 1]
  |  Branch (51:47): [True: 0, False: 1]
  ------------------
   52|      4|        memset(data + 1, 0, SIZE_IP6);
  ------------------
  |  |  225|      4|#define SIZE_IP6 16
  ------------------
   53|      4|        memcpy(data + 1, source->ip.v4.uint8, SIZE_IP4);
  ------------------
  |  |  224|      4|#define SIZE_IP4 4
  ------------------
   54|      4|    } else {
   55|      1|        memcpy(data + 1, source->ip.v6.uint8, SIZE_IP6);
  ------------------
  |  |  225|      1|#define SIZE_IP6 16
  ------------------
   56|      1|    }
   57|      5|}
onion.c:ipport_unpack:
   93|    150|{
   94|    150|    if (data_size < (SIZE_IP + SIZE_PORT)) {
  ------------------
  |  |  226|    150|#define SIZE_IP (1 + SIZE_IP6)
  |  |  ------------------
  |  |  |  |  225|    150|#define SIZE_IP6 16
  |  |  ------------------
  ------------------
                  if (data_size < (SIZE_IP + SIZE_PORT)) {
  ------------------
  |  |  227|    150|#define SIZE_PORT 2
  ------------------
  |  Branch (94:9): [True: 0, False: 150]
  ------------------
   95|      0|        return -1;
   96|      0|    }
   97|       |
   98|    150|    if (ip_unpack(&target->ip, data, data_size, disable_family_check) == -1) {
  ------------------
  |  Branch (98:9): [True: 51, False: 99]
  ------------------
   99|     51|        return -1;
  100|     51|    }
  101|       |
  102|     99|    memcpy(&target->port, data + SIZE_IP, SIZE_PORT);
  ------------------
  |  |  226|     99|#define SIZE_IP (1 + SIZE_IP6)
  |  |  ------------------
  |  |  |  |  225|     99|#define SIZE_IP6 16
  |  |  ------------------
  ------------------
                  memcpy(&target->port, data + SIZE_IP, SIZE_PORT);
  ------------------
  |  |  227|     99|#define SIZE_PORT 2
  ------------------
  103|     99|    return 0;
  104|    150|}
onion.c:ip_unpack:
   62|    150|{
   63|    150|    if (data_size < (1 + SIZE_IP6)) {
  ------------------
  |  |  225|    150|#define SIZE_IP6 16
  ------------------
  |  Branch (63:9): [True: 0, False: 150]
  ------------------
   64|      0|        return -1;
   65|      0|    }
   66|       |
   67|       |    // TODO(iphydf): Validate input.
   68|    150|    target->family.value = data[0];
   69|       |
   70|    150|    if (net_family_is_ipv4(target->family) || net_family_is_tox_tcp_ipv4(target->family)) {
  ------------------
  |  Branch (70:9): [True: 53, False: 97]
  |  Branch (70:47): [True: 5, False: 92]
  ------------------
   71|     58|        memcpy(target->ip.v4.uint8, data + 1, SIZE_IP4);
  ------------------
  |  |  224|     58|#define SIZE_IP4 4
  ------------------
   72|     92|    } else {
   73|     92|        memcpy(target->ip.v6.uint8, data + 1, SIZE_IP6);
  ------------------
  |  |  225|     92|#define SIZE_IP6 16
  ------------------
   74|     92|    }
   75|       |
   76|    150|    const bool valid = disable_family_check ||
  ------------------
  |  Branch (76:24): [True: 91, False: 59]
  ------------------
   77|    150|                 net_family_is_ipv4(target->family) ||
  ------------------
  |  Branch (77:18): [True: 6, False: 53]
  ------------------
   78|    150|                 net_family_is_ipv6(target->family);
  ------------------
  |  Branch (78:18): [True: 2, False: 51]
  ------------------
   79|       |
   80|    150|    return valid ? 0 : -1;
  ------------------
  |  Branch (80:12): [True: 99, False: 51]
  ------------------
   81|    150|}
onion.c:handle_send_initial:
  308|     17|{
  309|     17|    Onion *onion = (Onion *)object;
  310|       |
  311|     17|    if (length > ONION_MAX_PACKET_SIZE) {
  ------------------
  |  |   37|     17|#define ONION_MAX_PACKET_SIZE 1400
  ------------------
  |  Branch (311:9): [True: 3, False: 14]
  ------------------
  312|      3|        return 1;
  313|      3|    }
  314|       |
  315|     14|    if (length <= 1 + SEND_1) {
  ------------------
  |  |   26|     14|#define SEND_1 ONION_SEND_1
  |  |  ------------------
  |  |  |  |   46|     14|#define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     14|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|     14|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     14|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     14|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     14|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     14|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     14|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     14|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (315:9): [True: 11, False: 3]
  ------------------
  316|     11|        return 1;
  317|     11|    }
  318|       |
  319|      3|    change_symmetric_key(onion);
  320|       |
  321|      3|    uint8_t plain[ONION_MAX_PACKET_SIZE];
  322|      3|    const uint8_t *public_key = packet + 1 + CRYPTO_NONCE_SIZE;
  ------------------
  |  |   66|      3|#define CRYPTO_NONCE_SIZE              24
  ------------------
  323|      3|    const uint8_t *shared_key = shared_key_cache_lookup(onion->shared_keys_1, public_key);
  324|       |
  325|      3|    if (shared_key == nullptr) {
  ------------------
  |  |   66|      3|#define nullptr NULL
  ------------------
  |  Branch (325:9): [True: 0, False: 3]
  ------------------
  326|       |        /* Error looking up/deriving the shared key */
  327|      0|        return 1;
  328|      0|    }
  329|       |
  330|      3|    const int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   66|      3|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  const int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      3|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  331|      3|                                     length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE), plain);
  ------------------
  |  |   66|      3|#define CRYPTO_NONCE_SIZE              24
  ------------------
                                                   length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE), plain);
  ------------------
  |  |   40|      3|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  332|       |
  333|      3|    if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)) {
  ------------------
  |  |   66|      3|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)) {
  ------------------
  |  |   40|      3|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)) {
  ------------------
  |  |   61|      3|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (333:9): [True: 0, False: 3]
  ------------------
  334|      0|        return 1;
  335|      0|    }
  336|       |
  337|      3|    return onion_send_1(onion, plain, len, source, packet + 1);
  338|      3|}
onion.c:change_symmetric_key:
   38|    113|{
   39|    113|    if (mono_time_is_timeout(onion->mono_time, onion->timestamp, KEY_REFRESH_INTERVAL)) {
  ------------------
  |  |   28|    113|#define KEY_REFRESH_INTERVAL (2 * 60 * 60)
  ------------------
  |  Branch (39:9): [True: 0, False: 113]
  ------------------
   40|      0|        new_symmetric_key(onion->rng, onion->secret_symmetric_key);
   41|      0|        onion->timestamp = mono_time_get(onion->mono_time);
   42|      0|    }
   43|    113|}
onion.c:handle_send_1:
  384|     19|{
  385|     19|    Onion *onion = (Onion *)object;
  386|       |
  387|     19|    if (length > ONION_MAX_PACKET_SIZE) {
  ------------------
  |  |   37|     19|#define ONION_MAX_PACKET_SIZE 1400
  ------------------
  |  Branch (387:9): [True: 3, False: 16]
  ------------------
  388|      3|        return 1;
  389|      3|    }
  390|       |
  391|     16|    if (length <= 1 + SEND_2) {
  ------------------
  |  |   25|     16|#define SEND_2 ONION_SEND_2
  |  |  ------------------
  |  |  |  |   45|     16|#define ONION_SEND_2 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*2 + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     16|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_SEND_2 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*2 + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|     16|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     16|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     16|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     16|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     16|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     16|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     16|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_SEND_2 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*2 + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|     16|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     16|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     16|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     16|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     16|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     16|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     16|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (391:9): [True: 10, False: 6]
  ------------------
  392|     10|        return 1;
  393|     10|    }
  394|       |
  395|      6|    change_symmetric_key(onion);
  396|       |
  397|      6|    uint8_t plain[ONION_MAX_PACKET_SIZE];
  398|      6|    const uint8_t *public_key = packet + 1 + CRYPTO_NONCE_SIZE;
  ------------------
  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  ------------------
  399|      6|    const uint8_t *shared_key = shared_key_cache_lookup(onion->shared_keys_2, public_key);
  400|       |
  401|      6|    if (shared_key == nullptr) {
  ------------------
  |  |   66|      6|#define nullptr NULL
  ------------------
  |  Branch (401:9): [True: 0, False: 6]
  ------------------
  402|       |        /* Error looking up/deriving the shared key */
  403|      0|        return 1;
  404|      0|    }
  405|       |
  406|      6|    int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  407|      6|                                     length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_1), plain);
  ------------------
  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  ------------------
                                                   length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_1), plain);
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                   length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_1), plain);
  ------------------
  |  |   19|      6|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|      6|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  408|       |
  409|      6|    if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_1 + CRYPTO_MAC_SIZE)) {
  ------------------
  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_1 + CRYPTO_MAC_SIZE)) {
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_1 + CRYPTO_MAC_SIZE)) {
  ------------------
  |  |   19|      6|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|      6|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_1 + CRYPTO_MAC_SIZE)) {
  ------------------
  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (409:9): [True: 0, False: 6]
  ------------------
  410|      0|        return 1;
  411|      0|    }
  412|       |
  413|      6|    IP_Port send_to;
  414|       |
  415|      6|    if (ipport_unpack(&send_to, plain, len, false) == -1) {
  ------------------
  |  Branch (415:9): [True: 5, False: 1]
  ------------------
  416|      5|        return 1;
  417|      5|    }
  418|       |
  419|      1|    uint8_t data[ONION_MAX_PACKET_SIZE] = {0};
  420|      1|    data[0] = NET_PACKET_ONION_SEND_2;
  421|      1|    memcpy(data + 1, packet + 1, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  422|      1|    memcpy(data + 1 + CRYPTO_NONCE_SIZE, plain + SIZE_IPPORT, len - SIZE_IPPORT);
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  memcpy(data + 1 + CRYPTO_NONCE_SIZE, plain + SIZE_IPPORT, len - SIZE_IPPORT);
  ------------------
  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                  memcpy(data + 1 + CRYPTO_NONCE_SIZE, plain + SIZE_IPPORT, len - SIZE_IPPORT);
  ------------------
  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
  423|      1|    uint16_t data_len = 1 + CRYPTO_NONCE_SIZE + (len - SIZE_IPPORT);
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  uint16_t data_len = 1 + CRYPTO_NONCE_SIZE + (len - SIZE_IPPORT);
  ------------------
  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
  424|      1|    uint8_t *ret_part = data + data_len;
  425|      1|    random_nonce(onion->rng, ret_part);
  426|      1|    uint8_t ret_data[RETURN_1 + SIZE_IPPORT];
  427|      1|    ipport_pack(ret_data, source);
  428|      1|    memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_1), RETURN_1);
  ------------------
  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                  memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_1), RETURN_1);
  ------------------
  |  |   19|      1|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_1), RETURN_1);
  ------------------
  |  |   19|      1|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  429|      1|    len = encrypt_data_symmetric(onion->secret_symmetric_key, ret_part, ret_data, sizeof(ret_data),
  430|      1|                                 ret_part + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  431|       |
  432|      1|    if (len != RETURN_2 - CRYPTO_NONCE_SIZE) {
  ------------------
  |  |   20|      1|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      1|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (len != RETURN_2 - CRYPTO_NONCE_SIZE) {
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  |  Branch (432:9): [True: 0, False: 1]
  ------------------
  433|      0|        return 1;
  434|      0|    }
  435|       |
  436|      1|    data_len += CRYPTO_NONCE_SIZE + len;
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  437|       |
  438|      1|    if ((uint32_t)sendpacket(onion->net, &send_to, data, data_len) != data_len) {
  ------------------
  |  Branch (438:9): [True: 0, False: 1]
  ------------------
  439|      0|        return 1;
  440|      0|    }
  441|       |
  442|      1|    return 0;
  443|      1|}
onion.c:handle_send_2:
  447|     17|{
  448|     17|    Onion *onion = (Onion *)object;
  449|       |
  450|     17|    if (length > ONION_MAX_PACKET_SIZE) {
  ------------------
  |  |   37|     17|#define ONION_MAX_PACKET_SIZE 1400
  ------------------
  |  Branch (450:9): [True: 3, False: 14]
  ------------------
  451|      3|        return 1;
  452|      3|    }
  453|       |
  454|     14|    if (length <= 1 + SEND_3) {
  ------------------
  |  |   24|     14|#define SEND_3 ONION_SEND_3
  |  |  ------------------
  |  |  |  |   44|     14|#define ONION_SEND_3 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     14|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_SEND_3 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|     14|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     14|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     14|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     14|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     14|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     14|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     14|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_SEND_3 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     14|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     14|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     14|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     14|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     14|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     14|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     14|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|     14|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|     14|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|     14|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|     14|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|     14|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|     14|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|     14|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (454:9): [True: 10, False: 4]
  ------------------
  455|     10|        return 1;
  456|     10|    }
  457|       |
  458|      4|    change_symmetric_key(onion);
  459|       |
  460|      4|    uint8_t plain[ONION_MAX_PACKET_SIZE];
  461|      4|    const uint8_t *public_key = packet + 1 + CRYPTO_NONCE_SIZE;
  ------------------
  |  |   66|      4|#define CRYPTO_NONCE_SIZE              24
  ------------------
  462|      4|    const uint8_t *shared_key = shared_key_cache_lookup(onion->shared_keys_3, public_key);
  463|       |
  464|      4|    if (shared_key == nullptr) {
  ------------------
  |  |   66|      4|#define nullptr NULL
  ------------------
  |  Branch (464:9): [True: 0, False: 4]
  ------------------
  465|       |        /* Error looking up/deriving the shared key */
  466|      0|        return 1;
  467|      0|    }
  468|       |
  469|      4|    int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   66|      4|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      4|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  470|      4|                                     length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2), plain);
  ------------------
  |  |   66|      4|#define CRYPTO_NONCE_SIZE              24
  ------------------
                                                   length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2), plain);
  ------------------
  |  |   40|      4|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                   length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2), plain);
  ------------------
  |  |   20|      4|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      4|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      4|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      4|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      4|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      4|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      4|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      4|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      4|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      4|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      4|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      4|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      4|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      4|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      4|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  471|       |
  472|      4|    if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2 + CRYPTO_MAC_SIZE)) {
  ------------------
  |  |   66|      4|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2 + CRYPTO_MAC_SIZE)) {
  ------------------
  |  |   40|      4|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2 + CRYPTO_MAC_SIZE)) {
  ------------------
  |  |   20|      4|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      4|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      4|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      4|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      4|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      4|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      4|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      4|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      4|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      4|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      4|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      4|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      4|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      4|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      4|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2 + CRYPTO_MAC_SIZE)) {
  ------------------
  |  |   61|      4|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (472:9): [True: 0, False: 4]
  ------------------
  473|      0|        return 1;
  474|      0|    }
  475|       |
  476|      4|    assert(len > SIZE_IPPORT);
  477|       |
  478|      4|    const uint8_t packet_id = plain[SIZE_IPPORT];
  ------------------
  |  |  228|      4|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      4|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      4|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      4|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
  479|       |
  480|      4|    if (packet_id != NET_PACKET_ANNOUNCE_REQUEST && packet_id != NET_PACKET_ANNOUNCE_REQUEST_OLD &&
  ------------------
  |  Branch (480:9): [True: 3, False: 1]
  |  Branch (480:53): [True: 2, False: 1]
  ------------------
  481|      4|            packet_id != NET_PACKET_ONION_DATA_REQUEST) {
  ------------------
  |  Branch (481:13): [True: 1, False: 1]
  ------------------
  482|      1|        return 1;
  483|      1|    }
  484|       |
  485|      3|    IP_Port send_to;
  486|       |
  487|      3|    if (ipport_unpack(&send_to, plain, len, false) == -1) {
  ------------------
  |  Branch (487:9): [True: 2, False: 1]
  ------------------
  488|      2|        return 1;
  489|      2|    }
  490|       |
  491|      1|    uint8_t data[ONION_MAX_PACKET_SIZE] = {0};
  492|      1|    memcpy(data, plain + SIZE_IPPORT, len - SIZE_IPPORT);
  ------------------
  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                  memcpy(data, plain + SIZE_IPPORT, len - SIZE_IPPORT);
  ------------------
  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
  493|      1|    uint16_t data_len = len - SIZE_IPPORT;
  ------------------
  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
  494|      1|    uint8_t *ret_part = data + (len - SIZE_IPPORT);
  ------------------
  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
  495|      1|    random_nonce(onion->rng, ret_part);
  496|      1|    uint8_t ret_data[RETURN_2 + SIZE_IPPORT];
  497|      1|    ipport_pack(ret_data, source);
  498|      1|    memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_2), RETURN_2);
  ------------------
  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                  memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_2), RETURN_2);
  ------------------
  |  |   20|      1|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      1|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_2), RETURN_2);
  ------------------
  |  |   20|      1|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      1|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  499|      1|    len = encrypt_data_symmetric(onion->secret_symmetric_key, ret_part, ret_data, sizeof(ret_data),
  500|      1|                                 ret_part + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  501|       |
  502|      1|    if (len != RETURN_3 - CRYPTO_NONCE_SIZE) {
  ------------------
  |  |   21|      1|#define RETURN_3 ONION_RETURN_3
  |  |  ------------------
  |  |  |  |   41|      1|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      1|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (len != RETURN_3 - CRYPTO_NONCE_SIZE) {
  ------------------
  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  ------------------
  |  Branch (502:9): [True: 0, False: 1]
  ------------------
  503|      0|        return 1;
  504|      0|    }
  505|       |
  506|      1|    data_len += RETURN_3;
  ------------------
  |  |   21|      1|#define RETURN_3 ONION_RETURN_3
  |  |  ------------------
  |  |  |  |   41|      1|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      1|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  507|       |
  508|      1|    if ((uint32_t)sendpacket(onion->net, &send_to, data, data_len) != data_len) {
  ------------------
  |  Branch (508:9): [True: 0, False: 1]
  ------------------
  509|      0|        return 1;
  510|      0|    }
  511|       |
  512|      1|    return 0;
  513|      1|}
onion.c:handle_recv_3:
  518|     26|{
  519|     26|    Onion *onion = (Onion *)object;
  520|       |
  521|     26|    if (length > ONION_MAX_PACKET_SIZE) {
  ------------------
  |  |   37|     26|#define ONION_MAX_PACKET_SIZE 1400
  ------------------
  |  Branch (521:9): [True: 3, False: 23]
  ------------------
  522|      3|        return 1;
  523|      3|    }
  524|       |
  525|     23|    if (length <= 1 + RETURN_3) {
  ------------------
  |  |   21|     23|#define RETURN_3 ONION_RETURN_3
  |  |  ------------------
  |  |  |  |   41|     23|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     23|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     23|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     23|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     23|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     23|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     23|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     23|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     23|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     23|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     23|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     23|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     23|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     23|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|     23|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|     23|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|     23|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|     23|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|     23|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|     23|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|     23|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (525:9): [True: 10, False: 13]
  ------------------
  526|     10|        return 1;
  527|     10|    }
  528|       |
  529|     13|    const uint8_t packet_id = packet[1 + RETURN_3];
  ------------------
  |  |   21|     13|#define RETURN_3 ONION_RETURN_3
  |  |  ------------------
  |  |  |  |   41|     13|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     13|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     13|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     13|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     13|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     13|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     13|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     13|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     13|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     13|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     13|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     13|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     13|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     13|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|     13|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|     13|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|     13|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|     13|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|     13|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|     13|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|     13|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  530|       |
  531|     13|    if (packet_id != NET_PACKET_ANNOUNCE_RESPONSE && packet_id != NET_PACKET_ANNOUNCE_RESPONSE_OLD &&
  ------------------
  |  Branch (531:9): [True: 10, False: 3]
  |  Branch (531:54): [True: 8, False: 2]
  ------------------
  532|     13|            packet_id != NET_PACKET_ONION_DATA_RESPONSE) {
  ------------------
  |  Branch (532:13): [True: 7, False: 1]
  ------------------
  533|      7|        return 1;
  534|      7|    }
  535|       |
  536|      6|    change_symmetric_key(onion);
  537|       |
  538|      6|    uint8_t plain[SIZE_IPPORT + RETURN_2];
  539|      6|    const int len = decrypt_data_symmetric(onion->secret_symmetric_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  ------------------
  540|      6|                                     SIZE_IPPORT + RETURN_2 + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                                                   SIZE_IPPORT + RETURN_2 + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   20|      6|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      6|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      6|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                                                   SIZE_IPPORT + RETURN_2 + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  ------------------
  541|       |
  542|      6|    if ((uint32_t)len != sizeof(plain)) {
  ------------------
  |  Branch (542:9): [True: 0, False: 6]
  ------------------
  543|      0|        return 1;
  544|      0|    }
  545|       |
  546|      6|    IP_Port send_to;
  547|       |
  548|      6|    if (ipport_unpack(&send_to, plain, len, false) == -1) {
  ------------------
  |  Branch (548:9): [True: 4, False: 2]
  ------------------
  549|      4|        return 1;
  550|      4|    }
  551|       |
  552|      2|    uint8_t data[ONION_MAX_PACKET_SIZE] = {0};
  553|      2|    data[0] = NET_PACKET_ONION_RECV_2;
  554|      2|    memcpy(data + 1, plain + SIZE_IPPORT, RETURN_2);
  ------------------
  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                  memcpy(data + 1, plain + SIZE_IPPORT, RETURN_2);
  ------------------
  |  |   20|      2|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      2|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      2|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  555|      2|    memcpy(data + 1 + RETURN_2, packet + 1 + RETURN_3, length - (1 + RETURN_3));
  ------------------
  |  |   20|      2|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      2|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      2|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  memcpy(data + 1 + RETURN_2, packet + 1 + RETURN_3, length - (1 + RETURN_3));
  ------------------
  |  |   21|      2|#define RETURN_3 ONION_RETURN_3
  |  |  ------------------
  |  |  |  |   41|      2|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      2|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|      2|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  memcpy(data + 1 + RETURN_2, packet + 1 + RETURN_3, length - (1 + RETURN_3));
  ------------------
  |  |   21|      2|#define RETURN_3 ONION_RETURN_3
  |  |  ------------------
  |  |  |  |   41|      2|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      2|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|      2|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  556|      2|    const uint16_t data_len = 1 + RETURN_2 + (length - (1 + RETURN_3));
  ------------------
  |  |   20|      2|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      2|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      2|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  const uint16_t data_len = 1 + RETURN_2 + (length - (1 + RETURN_3));
  ------------------
  |  |   21|      2|#define RETURN_3 ONION_RETURN_3
  |  |  ------------------
  |  |  |  |   41|      2|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      2|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|      2|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|      2|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|      2|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|      2|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|      2|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  557|       |
  558|      2|    if ((uint32_t)sendpacket(onion->net, &send_to, data, data_len) != data_len) {
  ------------------
  |  Branch (558:9): [True: 0, False: 2]
  ------------------
  559|      0|        return 1;
  560|      0|    }
  561|       |
  562|      2|    return 0;
  563|      2|}
onion.c:handle_recv_2:
  567|     18|{
  568|     18|    Onion *onion = (Onion *)object;
  569|       |
  570|     18|    if (length > ONION_MAX_PACKET_SIZE) {
  ------------------
  |  |   37|     18|#define ONION_MAX_PACKET_SIZE 1400
  ------------------
  |  Branch (570:9): [True: 1, False: 17]
  ------------------
  571|      1|        return 1;
  572|      1|    }
  573|       |
  574|     17|    if (length <= 1 + RETURN_2) {
  ------------------
  |  |   20|     17|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|     17|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     17|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     17|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     17|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     17|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     17|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     17|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|     17|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     17|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     17|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     17|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     17|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     17|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     17|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (574:9): [True: 3, False: 14]
  ------------------
  575|      3|        return 1;
  576|      3|    }
  577|       |
  578|     14|    const uint8_t packet_id = packet[1 + RETURN_2];
  ------------------
  |  |   20|     14|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|     14|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     14|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     14|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     14|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     14|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     14|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     14|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|     14|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     14|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     14|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     14|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     14|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     14|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     14|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  579|       |
  580|     14|    if (packet_id != NET_PACKET_ANNOUNCE_RESPONSE && packet_id != NET_PACKET_ANNOUNCE_RESPONSE_OLD &&
  ------------------
  |  Branch (580:9): [True: 13, False: 1]
  |  Branch (580:54): [True: 12, False: 1]
  ------------------
  581|     14|            packet_id != NET_PACKET_ONION_DATA_RESPONSE) {
  ------------------
  |  Branch (581:13): [True: 11, False: 1]
  ------------------
  582|     11|        return 1;
  583|     11|    }
  584|       |
  585|      3|    change_symmetric_key(onion);
  586|       |
  587|      3|    uint8_t plain[SIZE_IPPORT + RETURN_1];
  588|      3|    const int len = decrypt_data_symmetric(onion->secret_symmetric_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      3|#define CRYPTO_NONCE_SIZE              24
  ------------------
  589|      3|                                     SIZE_IPPORT + RETURN_1 + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |  228|      3|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      3|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      3|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      3|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                                                   SIZE_IPPORT + RETURN_1 + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   19|      3|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|      3|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      3|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      3|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      3|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      3|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      3|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      3|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                                                   SIZE_IPPORT + RETURN_1 + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   61|      3|#define CRYPTO_MAC_SIZE                16
  ------------------
  590|       |
  591|      3|    if ((uint32_t)len != sizeof(plain)) {
  ------------------
  |  Branch (591:9): [True: 0, False: 3]
  ------------------
  592|      0|        return 1;
  593|      0|    }
  594|       |
  595|      3|    IP_Port send_to;
  596|       |
  597|      3|    if (ipport_unpack(&send_to, plain, len, false) == -1) {
  ------------------
  |  Branch (597:9): [True: 2, False: 1]
  ------------------
  598|      2|        return 1;
  599|      2|    }
  600|       |
  601|      1|    uint8_t data[ONION_MAX_PACKET_SIZE] = {0};
  602|      1|    data[0] = NET_PACKET_ONION_RECV_1;
  603|      1|    memcpy(data + 1, plain + SIZE_IPPORT, RETURN_1);
  ------------------
  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                  memcpy(data + 1, plain + SIZE_IPPORT, RETURN_1);
  ------------------
  |  |   19|      1|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  604|      1|    memcpy(data + 1 + RETURN_1, packet + 1 + RETURN_2, length - (1 + RETURN_2));
  ------------------
  |  |   19|      1|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  memcpy(data + 1 + RETURN_1, packet + 1 + RETURN_2, length - (1 + RETURN_2));
  ------------------
  |  |   20|      1|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      1|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  memcpy(data + 1 + RETURN_1, packet + 1 + RETURN_2, length - (1 + RETURN_2));
  ------------------
  |  |   20|      1|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      1|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  605|      1|    const uint16_t data_len = 1 + RETURN_1 + (length - (1 + RETURN_2));
  ------------------
  |  |   19|      1|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  const uint16_t data_len = 1 + RETURN_1 + (length - (1 + RETURN_2));
  ------------------
  |  |   20|      1|#define RETURN_2 ONION_RETURN_2
  |  |  ------------------
  |  |  |  |   40|      1|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  606|       |
  607|      1|    if ((uint32_t)sendpacket(onion->net, &send_to, data, data_len) != data_len) {
  ------------------
  |  Branch (607:9): [True: 0, False: 1]
  ------------------
  608|      0|        return 1;
  609|      0|    }
  610|       |
  611|      1|    return 0;
  612|      1|}
onion.c:handle_recv_1:
  616|    141|{
  617|    141|    Onion *onion = (Onion *)object;
  618|       |
  619|    141|    if (length > ONION_MAX_PACKET_SIZE) {
  ------------------
  |  |   37|    141|#define ONION_MAX_PACKET_SIZE 1400
  ------------------
  |  Branch (619:9): [True: 3, False: 138]
  ------------------
  620|      3|        return 1;
  621|      3|    }
  622|       |
  623|    138|    if (length <= 1 + RETURN_1) {
  ------------------
  |  |   19|    138|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|    138|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|    138|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|    138|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|    138|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|    138|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|    138|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|    138|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (623:9): [True: 16, False: 122]
  ------------------
  624|     16|        return 1;
  625|     16|    }
  626|       |
  627|    122|    const uint8_t packet_id = packet[1 + RETURN_1];
  ------------------
  |  |   19|    122|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|    122|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|    122|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|    122|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|    122|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|    122|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|    122|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|    122|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  628|       |
  629|    122|    if (packet_id != NET_PACKET_ANNOUNCE_RESPONSE && packet_id != NET_PACKET_ANNOUNCE_RESPONSE_OLD &&
  ------------------
  |  Branch (629:9): [True: 83, False: 39]
  |  Branch (629:54): [True: 43, False: 40]
  ------------------
  630|    122|            packet_id != NET_PACKET_ONION_DATA_RESPONSE) {
  ------------------
  |  Branch (630:13): [True: 31, False: 12]
  ------------------
  631|     31|        return 1;
  632|     31|    }
  633|       |
  634|     91|    change_symmetric_key(onion);
  635|       |
  636|     91|    uint8_t plain[SIZE_IPPORT];
  637|     91|    const int len = decrypt_data_symmetric(onion->secret_symmetric_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|     91|#define CRYPTO_NONCE_SIZE              24
  ------------------
  638|     91|                                     SIZE_IPPORT + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |  228|     91|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|     91|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|     91|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|     91|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
                                                   SIZE_IPPORT + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   61|     91|#define CRYPTO_MAC_SIZE                16
  ------------------
  639|       |
  640|     91|    if ((uint32_t)len != SIZE_IPPORT) {
  ------------------
  |  |  228|     91|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  226|     91|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  ------------------
  |  |  |  |  |  |  225|     91|#define SIZE_IP6 16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  ------------------
  |  |  |  |  227|     91|#define SIZE_PORT 2
  |  |  ------------------
  ------------------
  |  Branch (640:9): [True: 0, False: 91]
  ------------------
  641|      0|        return 1;
  642|      0|    }
  643|       |
  644|     91|    IP_Port send_to;
  645|       |
  646|     91|    if (ipport_unpack(&send_to, plain, len, true) == -1) {
  ------------------
  |  Branch (646:9): [True: 0, False: 91]
  ------------------
  647|      0|        return 1;
  648|      0|    }
  649|       |
  650|     91|    const uint16_t data_len = length - (1 + RETURN_1);
  ------------------
  |  |   19|     91|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|     91|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     91|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     91|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     91|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     91|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     91|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     91|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  651|       |
  652|     91|    if (onion->recv_1_function != nullptr &&
  ------------------
  |  |   66|    182|#define nullptr NULL
  ------------------
  |  Branch (652:9): [True: 24, False: 67]
  ------------------
  653|     91|            !net_family_is_ipv4(send_to.ip.family) &&
  ------------------
  |  Branch (653:13): [True: 14, False: 10]
  ------------------
  654|     91|            !net_family_is_ipv6(send_to.ip.family)) {
  ------------------
  |  Branch (654:13): [True: 13, False: 1]
  ------------------
  655|     13|        return onion->recv_1_function(onion->callback_object, &send_to, packet + (1 + RETURN_1), data_len);
  ------------------
  |  |   19|     13|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|     13|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     13|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     13|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     13|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     13|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     13|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     13|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  656|     13|    }
  657|       |
  658|     78|    if ((uint32_t)sendpacket(onion->net, &send_to, packet + (1 + RETURN_1), data_len) != data_len) {
  ------------------
  |  |   19|     78|#define RETURN_1 ONION_RETURN_1
  |  |  ------------------
  |  |  |  |   39|     78|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     78|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     78|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     78|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     78|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     78|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     78|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (658:9): [True: 30, False: 48]
  ------------------
  659|     30|        return 1;
  660|     30|    }
  661|       |
  662|     48|    return 0;
  663|     78|}

onion_announce_extra_data_callback:
   69|    935|{
   70|    935|    onion_a->extra_data_max_size = extra_data_max_size;
   71|    935|    onion_a->extra_data_callback = extra_data_callback;
   72|    935|    onion_a->extra_data_object = extra_data_object;
   73|    935|}
new_onion_announce:
  646|    946|{
  647|    946|    if (dht == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (647:9): [True: 0, False: 946]
  ------------------
  648|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  649|      0|    }
  650|       |
  651|    946|    Onion_Announce *onion_a = (Onion_Announce *)mem_alloc(mem, sizeof(Onion_Announce));
  652|       |
  653|    946|    if (onion_a == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (653:9): [True: 5, False: 941]
  ------------------
  654|      5|        return nullptr;
  ------------------
  |  |   66|      5|#define nullptr NULL
  ------------------
  655|      5|    }
  656|       |
  657|    941|    onion_a->log = log;
  658|    941|    onion_a->rng = rng;
  659|    941|    onion_a->mem = mem;
  660|    941|    onion_a->mono_time = mono_time;
  661|    941|    onion_a->dht = dht;
  662|    941|    onion_a->net = dht_get_net(dht);
  663|    941|    onion_a->extra_data_max_size = 0;
  664|    941|    onion_a->extra_data_callback = nullptr;
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
  665|    941|    onion_a->extra_data_object = nullptr;
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
  666|    941|    new_hmac_key(rng, onion_a->hmac_key);
  667|       |
  668|    941|    onion_a->shared_keys_recv = shared_key_cache_new(mono_time, mem, dht_get_self_secret_key(dht), KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   37|    941|#define KEYS_TIMEOUT 600
  ------------------
                  onion_a->shared_keys_recv = shared_key_cache_new(mono_time, mem, dht_get_self_secret_key(dht), KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   36|    941|#define MAX_KEYS_PER_SLOT 4
  ------------------
  669|    941|    if (onion_a->shared_keys_recv == nullptr) {
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
  |  Branch (669:9): [True: 1, False: 940]
  ------------------
  670|      1|        kill_onion_announce(onion_a);
  671|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  672|      1|    }
  673|       |
  674|    940|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, &handle_announce_request, onion_a);
  675|    940|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, &handle_announce_request_old, onion_a);
  676|    940|    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, &handle_data_request, onion_a);
  677|       |
  678|    940|    return onion_a;
  679|    941|}
kill_onion_announce:
  682|    947|{
  683|    947|    if (onion_a == nullptr) {
  ------------------
  |  |   66|    947|#define nullptr NULL
  ------------------
  |  Branch (683:9): [True: 6, False: 941]
  ------------------
  684|      6|        return;
  685|      6|    }
  686|       |
  687|    941|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
  688|    941|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
  689|    941|    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    941|#define nullptr NULL
  ------------------
  690|       |
  691|    941|    crypto_memzero(onion_a->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  136|    941|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  692|    941|    shared_key_cache_free(onion_a->shared_keys_recv);
  693|       |
  694|    941|    mem_delete(onion_a->mem, onion_a);
  695|    941|}
onion_announce.c:handle_announce_request:
  585|     33|{
  586|     33|    Onion_Announce *onion_a = (Onion_Announce *)object;
  587|       |
  588|     33|    if (length != ANNOUNCE_REQUEST_MIN_SIZE_RECV) {
  ------------------
  |  |   24|     33|#define ANNOUNCE_REQUEST_MIN_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   24|     33|#define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     33|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     33|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   18|     33|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   10|     33|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  131|     33|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     33|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     33|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     33|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     33|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ANNOUNCE_REQUEST_MIN_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   41|     33|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     33|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     33|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     33|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     33|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     33|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     33|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     33|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     33|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     33|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     33|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     33|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     33|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     33|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|     33|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|     33|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|     33|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|     33|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|     33|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|     33|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|     33|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (588:9): [True: 31, False: 2]
  ------------------
  589|     31|        return handle_gca_announce_request(onion_a, source, packet, length);
  590|     31|    }
  591|       |
  592|      2|    return handle_announce_request_common(onion_a, source, packet, length, NET_PACKET_ANNOUNCE_RESPONSE,
  593|      2|                                          ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
  ------------------
  |  |   18|      2|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|      2|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      2|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                                                        ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
  ------------------
  |  |   40|      2|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                        ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
  ------------------
  |  |   21|      2|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
  594|      2|                                          true, 0, nullptr);
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
  595|     33|}
onion_announce.c:handle_gca_announce_request:
  568|     31|{
  569|     31|    if (length > ANNOUNCE_REQUEST_MAX_SIZE_RECV || length <= ANNOUNCE_REQUEST_MIN_SIZE_RECV) {
  ------------------
  |  |   25|     62|#define ANNOUNCE_REQUEST_MAX_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MAX_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   25|     31|#define ONION_ANNOUNCE_REQUEST_MAX_SIZE (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_MAX_EXTRA_DATA_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   24|     31|#define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     31|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     31|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   18|     31|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   10|     31|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  131|     31|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     31|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     31|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   21|     31|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     31|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MAX_SIZE (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_MAX_EXTRA_DATA_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   19|     31|#define ONION_MAX_EXTRA_DATA_SIZE 136
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ANNOUNCE_REQUEST_MAX_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MAX_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   41|     31|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     31|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     31|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     31|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     31|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     31|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     31|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     31|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     31|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     31|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     31|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     31|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     31|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     31|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|     31|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|     31|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|     31|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|     31|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|     31|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|     31|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|     31|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (length > ANNOUNCE_REQUEST_MAX_SIZE_RECV || length <= ANNOUNCE_REQUEST_MIN_SIZE_RECV) {
  ------------------
  |  |   24|     28|#define ANNOUNCE_REQUEST_MIN_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   24|     28|#define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     28|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     28|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   18|     28|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   10|     28|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  131|     28|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     28|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     28|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     28|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     28|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ANNOUNCE_REQUEST_MIN_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   41|     28|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     28|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     28|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     28|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     28|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     28|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     28|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     28|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     28|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     28|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     28|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     28|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     28|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     28|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|     28|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|     28|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|     28|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|     28|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|     28|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|     28|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|     28|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (569:9): [True: 3, False: 28]
  |  Branch (569:52): [True: 11, False: 17]
  ------------------
  570|     14|        return 1;
  571|     14|    }
  572|       |
  573|     17|    if (onion_a->extra_data_callback == nullptr) {
  ------------------
  |  |   66|     17|#define nullptr NULL
  ------------------
  |  Branch (573:9): [True: 0, False: 17]
  ------------------
  574|      0|        return 1;
  575|      0|    }
  576|       |
  577|     17|    return handle_announce_request_common(onion_a, source, packet, length, NET_PACKET_ANNOUNCE_RESPONSE,
  578|     17|                                          ONION_MINIMAL_SIZE + length - ANNOUNCE_REQUEST_MIN_SIZE_RECV,
  ------------------
  |  |   33|     17|#define ONION_MINIMAL_SIZE (ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH)
  |  |  ------------------
  |  |  |  |   18|     17|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   10|     17|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  131|     17|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_MINIMAL_SIZE (ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH)
  |  |  ------------------
  |  |  |  |   40|     17|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define ONION_MINIMAL_SIZE (ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH)
  |  |  ------------------
  |  |  |  |   21|     17|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  ------------------
  ------------------
                                                        ONION_MINIMAL_SIZE + length - ANNOUNCE_REQUEST_MIN_SIZE_RECV,
  ------------------
  |  |   24|     17|#define ANNOUNCE_REQUEST_MIN_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   24|     17|#define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     17|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     17|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   18|     17|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   10|     17|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  131|     17|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     17|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     17|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     17|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     17|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ANNOUNCE_REQUEST_MIN_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   41|     17|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     17|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     17|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     17|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     17|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     17|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     17|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     17|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     17|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     17|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     17|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     17|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     17|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     17|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|     17|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|     17|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|     17|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|     17|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|     17|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|     17|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|     17|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  579|     17|                                          true, onion_a->extra_data_max_size, onion_a->extra_data_callback);
  580|     17|}
onion_announce.c:handle_announce_request_common:
  435|     20|{
  436|     20|    const uint8_t *packet_public_key = packet + 1 + CRYPTO_NONCE_SIZE;
  ------------------
  |  |   66|     20|#define CRYPTO_NONCE_SIZE              24
  ------------------
  437|     20|    const uint8_t *shared_key = shared_key_cache_lookup(onion_a->shared_keys_recv, packet_public_key);
  438|       |
  439|     20|    if (shared_key == nullptr) {
  ------------------
  |  |   66|     20|#define nullptr NULL
  ------------------
  |  Branch (439:9): [True: 0, False: 20]
  ------------------
  440|       |        /* Error looking up/deriving the shared key */
  441|      0|        return 1;
  442|      0|    }
  443|       |
  444|     20|    uint8_t *plain = (uint8_t *)mem_balloc(onion_a->mem, plain_size);
  445|       |
  446|     20|    if (plain == nullptr) {
  ------------------
  |  |   66|     20|#define nullptr NULL
  ------------------
  |  Branch (446:9): [True: 0, False: 20]
  ------------------
  447|      0|        return 1;
  448|      0|    }
  449|       |
  450|     20|    const int decrypted_len = decrypt_data_symmetric(shared_key, packet + 1,
  451|     20|                              packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE, plain_size + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   66|     20|#define CRYPTO_NONCE_SIZE              24
  ------------------
                                            packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE, plain_size + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   40|     20|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                            packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE, plain_size + CRYPTO_MAC_SIZE, plain);
  ------------------
  |  |   61|     20|#define CRYPTO_MAC_SIZE                16
  ------------------
  452|       |
  453|     20|    if ((uint32_t)decrypted_len != plain_size) {
  ------------------
  |  Branch (453:9): [True: 0, False: 20]
  ------------------
  454|      0|        mem_delete(onion_a->mem, plain);
  455|      0|        return 1;
  456|      0|    }
  457|       |
  458|     20|    const uint16_t ping_id_data_len = CRYPTO_PUBLIC_KEY_SIZE + sizeof(*source);
  ------------------
  |  |   40|     20|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  459|     20|    uint8_t ping_id_data[CRYPTO_PUBLIC_KEY_SIZE + sizeof(*source)];
  460|     20|    memcpy(ping_id_data, packet_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|     20|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  461|     20|    memcpy(ping_id_data + CRYPTO_PUBLIC_KEY_SIZE, source, sizeof(*source));
  ------------------
  |  |   40|     20|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  462|       |
  463|     20|    const uint8_t *data_public_key = plain + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   18|     20|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|     20|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     20|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  const uint8_t *data_public_key = plain + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|     20|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  464|       |
  465|     20|    int index;
  466|       |
  467|     20|    if (check_timed_auth(onion_a->mono_time, PING_ID_TIMEOUT, onion_a->hmac_key,
  ------------------
  |  |   22|     20|#define PING_ID_TIMEOUT ONION_ANNOUNCE_TIMEOUT
  |  |  ------------------
  |  |  |  |   17|     20|#define ONION_ANNOUNCE_TIMEOUT 300
  |  |  ------------------
  ------------------
  |  Branch (467:9): [True: 1, False: 19]
  ------------------
  468|     20|                         ping_id_data, ping_id_data_len, plain)) {
  469|      1|        index = add_to_entries(onion_a, source, packet_public_key, data_public_key,
  470|      1|                               packet + (length - ONION_RETURN_3));
  ------------------
  |  |   41|      1|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   40|      1|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  471|     19|    } else {
  472|     19|        index = in_entries(onion_a, plain + ONION_PING_ID_SIZE);
  ------------------
  |  |   18|     19|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|     19|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     19|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  473|     19|    }
  474|       |
  475|       |    /* Respond with a announce response packet */
  476|     20|    Node_format nodes_list[MAX_SENT_NODES];
  477|     20|    const unsigned int num_nodes =
  478|     20|        get_close_nodes(onion_a->dht, plain + ONION_PING_ID_SIZE, nodes_list, net_family_unspec(), ip_is_lan(&source->ip), false);
  ------------------
  |  |   18|     20|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|     20|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     20|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  479|       |
  480|     20|    assert(num_nodes <= UINT8_MAX);
  481|       |
  482|      0|    uint8_t nonce[CRYPTO_NONCE_SIZE];
  483|     20|    random_nonce(onion_a->rng, nonce);
  484|       |
  485|     20|    const uint16_t nodes_offset = 1 + ONION_PING_ID_SIZE + (want_node_count ? 1 : 0);
  ------------------
  |  |   18|     20|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|     20|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     20|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (485:61): [True: 19, False: 1]
  ------------------
  486|     20|    const uint16_t response_size = nodes_offset
  487|     20|                                   + MAX_SENT_NODES * PACKED_NODE_SIZE_IP6
  ------------------
  |  |   54|     20|#define MAX_SENT_NODES 4
  ------------------
                                                 + MAX_SENT_NODES * PACKED_NODE_SIZE_IP6
  ------------------
  |  |   86|     20|#define PACKED_NODE_SIZE_IP6 (1 + SIZE_IP6 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |  225|     20|#define SIZE_IP6 16
  |  |  ------------------
  |  |               #define PACKED_NODE_SIZE_IP6 (1 + SIZE_IP6 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   40|     20|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  488|     20|                                   + max_extra_size;
  489|     20|    uint8_t *response = (uint8_t *)mem_balloc(onion_a->mem, response_size);
  490|       |
  491|     20|    if (response == nullptr) {
  ------------------
  |  |   66|     20|#define nullptr NULL
  ------------------
  |  Branch (491:9): [True: 0, False: 20]
  ------------------
  492|      0|        mem_delete(onion_a->mem, plain);
  493|      0|        return 1;
  494|      0|    }
  495|       |
  496|     20|    uint8_t ping_id[TIMED_AUTH_SIZE];
  497|     20|    generate_timed_auth(onion_a->mono_time, PING_ID_TIMEOUT, onion_a->hmac_key,
  ------------------
  |  |   22|     20|#define PING_ID_TIMEOUT ONION_ANNOUNCE_TIMEOUT
  |  |  ------------------
  |  |  |  |   17|     20|#define ONION_ANNOUNCE_TIMEOUT 300
  |  |  ------------------
  ------------------
  498|     20|                        ping_id_data, ping_id_data_len, ping_id);
  499|       |
  500|     20|    make_announce_payload_helper(onion_a, ping_id, response, index, packet_public_key, data_public_key);
  501|       |
  502|     20|    int nodes_length = 0;
  503|       |
  504|     20|    if (num_nodes != 0) {
  ------------------
  |  Branch (504:9): [True: 0, False: 20]
  ------------------
  505|      0|        nodes_length = pack_nodes(onion_a->log, response + nodes_offset, sizeof(nodes_list), nodes_list,
  506|      0|                                  (uint16_t)num_nodes);
  507|       |
  508|      0|        if (nodes_length <= 0) {
  ------------------
  |  Branch (508:13): [True: 0, False: 0]
  ------------------
  509|      0|            LOGGER_WARNING(onion_a->log, "Failed to pack nodes");
  ------------------
  |  |   82|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  510|      0|            mem_delete(onion_a->mem, response);
  511|      0|            mem_delete(onion_a->mem, plain);
  512|      0|            return 1;
  513|      0|        }
  514|      0|    }
  515|       |
  516|     20|    uint16_t offset = nodes_offset + nodes_length;
  517|       |
  518|     20|    if (want_node_count) {
  ------------------
  |  Branch (518:9): [True: 19, False: 1]
  ------------------
  519|     19|        response[1 + ONION_PING_ID_SIZE] = (uint8_t)num_nodes;
  ------------------
  |  |   18|     19|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|     19|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     19|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  520|     19|    }
  521|       |
  522|     20|    const int extra_size = pack_extra_data_callback == nullptr ? 0
  ------------------
  |  |   66|     20|#define nullptr NULL
  ------------------
  |  Branch (522:28): [True: 3, False: 17]
  ------------------
  523|     20|                           : pack_extra_data_callback(onion_a->extra_data_object,
  524|     17|                                   onion_a->log, onion_a->mono_time, num_nodes,
  525|     17|                                   plain + ONION_MINIMAL_SIZE, length - ANNOUNCE_REQUEST_MIN_SIZE_RECV,
  ------------------
  |  |   33|     17|#define ONION_MINIMAL_SIZE (ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH)
  |  |  ------------------
  |  |  |  |   18|     17|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   10|     17|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  131|     17|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_MINIMAL_SIZE (ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH)
  |  |  ------------------
  |  |  |  |   40|     17|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define ONION_MINIMAL_SIZE (ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH)
  |  |  ------------------
  |  |  |  |   21|     17|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  ------------------
  ------------------
                                                 plain + ONION_MINIMAL_SIZE, length - ANNOUNCE_REQUEST_MIN_SIZE_RECV,
  ------------------
  |  |   24|     17|#define ANNOUNCE_REQUEST_MIN_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   24|     17|#define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     17|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     17|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   18|     17|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   10|     17|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  131|     17|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     17|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     17|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     17|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     17|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ANNOUNCE_REQUEST_MIN_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   41|     17|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     17|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     17|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     17|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     17|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     17|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     17|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     17|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     17|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     17|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     17|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     17|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     17|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     17|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|     17|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|     17|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|     17|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|     17|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|     17|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|     17|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|     17|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  526|     17|                                   response, response_size, offset);
  527|       |
  528|     20|    if (extra_size == -1) {
  ------------------
  |  Branch (528:9): [True: 14, False: 6]
  ------------------
  529|     14|        mem_delete(onion_a->mem, response);
  530|     14|        mem_delete(onion_a->mem, plain);
  531|     14|        return 1;
  532|     14|    }
  533|       |
  534|      6|    offset += extra_size;
  535|       |
  536|      6|    uint8_t data[ONION_ANNOUNCE_RESPONSE_MAX_SIZE];
  537|      6|    const int len = encrypt_data_symmetric(shared_key, nonce, response, offset,
  538|      6|                                           data + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   21|      6|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
                                                         data + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  ------------------
  539|       |
  540|      6|    if (len != offset + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (540:9): [True: 0, False: 6]
  ------------------
  541|      0|        LOGGER_ERROR(onion_a->log, "Failed to encrypt announce response");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  542|      0|        mem_delete(onion_a->mem, response);
  543|      0|        mem_delete(onion_a->mem, plain);
  544|      0|        return 1;
  545|      0|    }
  546|       |
  547|      6|    data[0] = response_packet_id;
  548|      6|    memcpy(data + 1, plain + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   18|      6|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|      6|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      6|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  memcpy(data + 1, plain + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(data + 1, plain + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  549|      6|           ONION_ANNOUNCE_SENDBACK_DATA_LENGTH);
  ------------------
  |  |   21|      6|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
  550|      6|    memcpy(data + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH, nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   21|      6|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
                  memcpy(data + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH, nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  ------------------
  551|       |
  552|      6|    if (send_onion_response(onion_a->net, source, data,
  ------------------
  |  Branch (552:9): [True: 0, False: 6]
  ------------------
  553|      6|                            1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + len,
  ------------------
  |  |   21|      6|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
                                          1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + len,
  ------------------
  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  ------------------
  554|      6|                            packet + (length - ONION_RETURN_3)) == -1) {
  ------------------
  |  |   41|      6|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   40|      6|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      6|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      6|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      6|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      6|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      6|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  555|      0|        mem_delete(onion_a->mem, response);
  556|      0|        mem_delete(onion_a->mem, plain);
  557|      0|        return 1;
  558|      0|    }
  559|       |
  560|      6|    mem_delete(onion_a->mem, response);
  561|      6|    mem_delete(onion_a->mem, plain);
  562|      6|    return 0;
  563|      6|}
onion_announce.c:add_to_entries:
  355|      1|{
  356|      1|    int pos = in_entries(onion_a, public_key);
  357|       |
  358|      1|    if (pos == -1) {
  ------------------
  |  Branch (358:9): [True: 1, False: 0]
  ------------------
  359|    161|        for (unsigned i = 0; i < ONION_ANNOUNCE_MAX_ENTRIES; ++i) {
  ------------------
  |  |   16|    161|#define ONION_ANNOUNCE_MAX_ENTRIES 160
  ------------------
  |  Branch (359:30): [True: 160, False: 1]
  ------------------
  360|    160|            if (mono_time_is_timeout(onion_a->mono_time, onion_a->entries[i].announce_time, ONION_ANNOUNCE_TIMEOUT)) {
  ------------------
  |  |   17|    160|#define ONION_ANNOUNCE_TIMEOUT 300
  ------------------
  |  Branch (360:17): [True: 160, False: 0]
  ------------------
  361|    160|                pos = i;
  362|    160|            }
  363|    160|        }
  364|      1|    }
  365|       |
  366|      1|    if (pos == -1) {
  ------------------
  |  Branch (366:9): [True: 0, False: 1]
  ------------------
  367|      0|        if (id_closest(dht_get_self_public_key(onion_a->dht), public_key, onion_a->entries[0].public_key) == 1) {
  ------------------
  |  Branch (367:13): [True: 0, False: 0]
  ------------------
  368|      0|            pos = 0;
  369|      0|        }
  370|      0|    }
  371|       |
  372|      1|    if (pos == -1) {
  ------------------
  |  Branch (372:9): [True: 0, False: 1]
  ------------------
  373|      0|        return -1;
  374|      0|    }
  375|       |
  376|      1|    memcpy(onion_a->entries[pos].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  377|      1|    onion_a->entries[pos].ret_ip_port = *ret_ip_port;
  378|      1|    memcpy(onion_a->entries[pos].ret, ret, ONION_RETURN_3);
  ------------------
  |  |   41|      1|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   40|      1|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      1|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      1|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      1|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      1|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      1|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      1|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      1|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  379|      1|    memcpy(onion_a->entries[pos].data_public_key, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  380|      1|    onion_a->entries[pos].announce_time = mono_time_get(onion_a->mono_time);
  381|       |
  382|      1|    sort_onion_announce_list(onion_a->mem, onion_a->mono_time,
  383|      1|                             onion_a->entries, ONION_ANNOUNCE_MAX_ENTRIES,
  ------------------
  |  |   16|      1|#define ONION_ANNOUNCE_MAX_ENTRIES 160
  ------------------
  384|      1|                             dht_get_self_public_key(onion_a->dht));
  385|      1|    return in_entries(onion_a, public_key);
  386|      1|}
onion_announce.c:sort_onion_announce_list:
  323|      1|{
  324|       |    // Pass comp_public_key to qsort with each Client_data entry, so the
  325|       |    // comparison function can use it as the base of comparison.
  326|      1|    Cmp_Data *cmp_list = (Cmp_Data *)mem_valloc(mem, length, sizeof(Cmp_Data));
  327|       |
  328|      1|    if (cmp_list == nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (328:9): [True: 0, False: 1]
  ------------------
  329|      0|        return;
  330|      0|    }
  331|       |
  332|    161|    for (uint32_t i = 0; i < length; ++i) {
  ------------------
  |  Branch (332:26): [True: 160, False: 1]
  ------------------
  333|    160|        cmp_list[i].mono_time = mono_time;
  334|    160|        cmp_list[i].base_public_key = comp_public_key;
  335|    160|        cmp_list[i].entry = list[i];
  336|    160|    }
  337|       |
  338|      1|    qsort(cmp_list, length, sizeof(Cmp_Data), cmp_entry);
  339|       |
  340|    161|    for (uint32_t i = 0; i < length; ++i) {
  ------------------
  |  Branch (340:26): [True: 160, False: 1]
  ------------------
  341|    160|        list[i] = cmp_list[i].entry;
  342|    160|    }
  343|       |
  344|      1|    mem_delete(mem, cmp_list);
  345|      1|}
onion_announce.c:cmp_entry:
  284|    560|{
  285|    560|    const Cmp_Data *cmp1 = (const Cmp_Data *)a;
  286|    560|    const Cmp_Data *cmp2 = (const Cmp_Data *)b;
  287|    560|    const Onion_Announce_Entry entry1 = cmp1->entry;
  288|    560|    const Onion_Announce_Entry entry2 = cmp2->entry;
  289|    560|    const uint8_t *cmp_public_key = cmp1->base_public_key;
  290|       |
  291|    560|    const bool t1 = mono_time_is_timeout(cmp1->mono_time, entry1.announce_time, ONION_ANNOUNCE_TIMEOUT);
  ------------------
  |  |   17|    560|#define ONION_ANNOUNCE_TIMEOUT 300
  ------------------
  292|    560|    const bool t2 = mono_time_is_timeout(cmp1->mono_time, entry2.announce_time, ONION_ANNOUNCE_TIMEOUT);
  ------------------
  |  |   17|    560|#define ONION_ANNOUNCE_TIMEOUT 300
  ------------------
  293|       |
  294|    560|    if (t1 && t2) {
  ------------------
  |  Branch (294:9): [True: 560, False: 0]
  |  Branch (294:15): [True: 559, False: 1]
  ------------------
  295|    559|        return 0;
  296|    559|    }
  297|       |
  298|      1|    if (t1) {
  ------------------
  |  Branch (298:9): [True: 1, False: 0]
  ------------------
  299|      1|        return -1;
  300|      1|    }
  301|       |
  302|      0|    if (t2) {
  ------------------
  |  Branch (302:9): [True: 0, False: 0]
  ------------------
  303|      0|        return 1;
  304|      0|    }
  305|       |
  306|      0|    const int closest = id_closest(cmp_public_key, entry1.public_key, entry2.public_key);
  307|       |
  308|      0|    if (closest == 1) {
  ------------------
  |  Branch (308:9): [True: 0, False: 0]
  ------------------
  309|      0|        return 1;
  310|      0|    }
  311|       |
  312|      0|    if (closest == 2) {
  ------------------
  |  Branch (312:9): [True: 0, False: 0]
  ------------------
  313|      0|        return -1;
  314|      0|    }
  315|       |
  316|      0|    return 0;
  317|      0|}
onion_announce.c:in_entries:
  265|     28|{
  266|  4.50k|    for (unsigned int i = 0; i < ONION_ANNOUNCE_MAX_ENTRIES; ++i) {
  ------------------
  |  |   16|  4.50k|#define ONION_ANNOUNCE_MAX_ENTRIES 160
  ------------------
  |  Branch (266:30): [True: 4.48k, False: 27]
  ------------------
  267|  4.48k|        if (!mono_time_is_timeout(onion_a->mono_time, onion_a->entries[i].announce_time, ONION_ANNOUNCE_TIMEOUT)
  ------------------
  |  |   17|  4.48k|#define ONION_ANNOUNCE_TIMEOUT 300
  ------------------
  |  Branch (267:13): [True: 1, False: 4.47k]
  ------------------
  268|  4.48k|                && pk_equal(onion_a->entries[i].public_key, public_key)) {
  ------------------
  |  Branch (268:20): [True: 1, False: 0]
  ------------------
  269|      1|            return i;
  270|      1|        }
  271|  4.48k|    }
  272|       |
  273|     27|    return -1;
  274|     28|}
onion_announce.c:make_announce_payload_helper:
  391|     20|{
  392|     20|    if (index < 0) {
  ------------------
  |  Branch (392:9): [True: 19, False: 1]
  ------------------
  393|     19|        response[0] = 0;
  394|     19|        memcpy(response + 1, ping_id, ONION_PING_ID_SIZE);
  ------------------
  |  |   18|     19|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|     19|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|     19|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  395|     19|        return;
  396|     19|    }
  397|       |
  398|      1|    if (pk_equal(onion_a->entries[index].public_key, packet_public_key)) {
  ------------------
  |  Branch (398:9): [True: 1, False: 0]
  ------------------
  399|      1|        if (!pk_equal(onion_a->entries[index].data_public_key, data_public_key)) {
  ------------------
  |  Branch (399:13): [True: 0, False: 1]
  ------------------
  400|      0|            response[0] = 0;
  401|      0|            memcpy(response + 1, ping_id, ONION_PING_ID_SIZE);
  ------------------
  |  |   18|      0|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|      0|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      0|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  402|      1|        } else {
  403|      1|            response[0] = 2;
  404|      1|            memcpy(response + 1, ping_id, ONION_PING_ID_SIZE);
  ------------------
  |  |   18|      1|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|      1|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      1|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  405|      1|        }
  406|      1|    } else {
  407|      0|        response[0] = 1;
  408|      0|        memcpy(response + 1, onion_a->entries[index].data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  409|      0|    }
  410|      1|}
onion_announce.c:handle_announce_request_old:
  601|     11|{
  602|     11|    Onion_Announce *onion_a = (Onion_Announce *)object;
  603|       |
  604|     11|    if (length != ANNOUNCE_REQUEST_SIZE_RECV) {
  ------------------
  |  |   28|     11|#define ANNOUNCE_REQUEST_SIZE_RECV (ONION_ANNOUNCE_REQUEST_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   31|     11|#define ONION_ANNOUNCE_REQUEST_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     11|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     11|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   18|     11|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   10|     11|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  131|     11|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     11|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     11|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     11|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_REQUEST_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     11|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ANNOUNCE_REQUEST_SIZE_RECV (ONION_ANNOUNCE_REQUEST_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   41|     11|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     11|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     11|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     11|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     11|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     11|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     11|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     11|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     11|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     11|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     11|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     11|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     11|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     11|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|     11|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|     11|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|     11|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|     11|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|     11|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|     11|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|     11|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (604:9): [True: 10, False: 1]
  ------------------
  605|     10|        return 1;
  606|     10|    }
  607|       |
  608|      1|    return handle_announce_request_common(onion_a, source, packet, length, NET_PACKET_ANNOUNCE_RESPONSE_OLD,
  609|      1|                                          ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
  ------------------
  |  |   18|      1|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|      1|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      1|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                                                        ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                        ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
  ------------------
  |  |   21|      1|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
  610|      1|                                          false, 0, nullptr);
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  611|     11|}
onion_announce.c:handle_data_request:
  616|     15|{
  617|     15|    const Onion_Announce *onion_a = (const Onion_Announce *)object;
  618|       |
  619|     15|    if (length <= DATA_REQUEST_MIN_SIZE_RECV) {
  ------------------
  |  |   31|     15|#define DATA_REQUEST_MIN_SIZE_RECV (DATA_REQUEST_MIN_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   30|     15|#define DATA_REQUEST_MIN_SIZE ONION_DATA_REQUEST_MIN_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   35|     15|#define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     15|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     15|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define DATA_REQUEST_MIN_SIZE_RECV (DATA_REQUEST_MIN_SIZE + ONION_RETURN_3)
  |  |  ------------------
  |  |  |  |   41|     15|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     15|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|     15|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|     15|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|     15|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|     15|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     15|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     15|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|     15|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|     15|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|     15|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|     15|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|     15|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     15|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   39|     15|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|     15|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|     15|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|     15|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|     15|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|     15|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|     15|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (619:9): [True: 5, False: 10]
  ------------------
  620|      5|        return 1;
  621|      5|    }
  622|       |
  623|     10|    if (length > ONION_MAX_PACKET_SIZE) {
  ------------------
  |  |   37|     10|#define ONION_MAX_PACKET_SIZE 1400
  ------------------
  |  Branch (623:9): [True: 3, False: 7]
  ------------------
  624|      3|        return 1;
  625|      3|    }
  626|       |
  627|      7|    const int index = in_entries(onion_a, packet + 1);
  628|       |
  629|      7|    if (index == -1) {
  ------------------
  |  Branch (629:9): [True: 7, False: 0]
  ------------------
  630|      7|        return 1;
  631|      7|    }
  632|       |
  633|      0|    VLA(uint8_t, data, length - (CRYPTO_PUBLIC_KEY_SIZE + ONION_RETURN_3));
  ------------------
  |  |   62|      0|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      0|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  634|      0|    data[0] = NET_PACKET_ONION_DATA_RESPONSE;
  635|      0|    memcpy(data + 1, packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, length - (1 + CRYPTO_PUBLIC_KEY_SIZE + ONION_RETURN_3));
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(data + 1, packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, length - (1 + CRYPTO_PUBLIC_KEY_SIZE + ONION_RETURN_3));
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(data + 1, packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, length - (1 + CRYPTO_PUBLIC_KEY_SIZE + ONION_RETURN_3));
  ------------------
  |  |   41|      0|#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |  228|      0|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  226|      0|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  225|      0|#define SIZE_IP6 16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  ------------------
  |  |  |  |  |  |  227|      0|#define SIZE_PORT 2
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  |  |               #define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)
  |  |  ------------------
  |  |  |  |   40|      0|#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |  228|      0|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  226|      0|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  225|      0|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  227|      0|#define SIZE_PORT 2
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
  |  |  |  |  ------------------
  |  |  |  |  |  |   39|      0|#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  228|      0|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  226|      0|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  225|      0|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  227|      0|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  636|       |
  637|      0|    if (send_onion_response(onion_a->net, &onion_a->entries[index].ret_ip_port, data, SIZEOF_VLA(data),
  ------------------
  |  |   29|      0|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (637:9): [True: 0, False: 0]
  ------------------
  638|      0|                            onion_a->entries[index].ret) == -1) {
  639|      0|        return 1;
  640|      0|    }
  641|       |
  642|      0|    return 0;
  643|      0|}

onion_get_friend_count:
  154|  72.6k|{
  155|  72.6k|    return onion_c->num_friends;
  156|  72.6k|}
onion_get_friend:
  159|  2.26k|{
  160|  2.26k|    return &onion_c->friends_list[friend_num];
  161|  2.26k|}
onion_friend_is_groupchat:
  189|  2.26k|{
  190|  2.26k|    return onion_friend->is_groupchat;
  191|  2.26k|}
onion_get_dht:
  194|    943|{
  195|    943|    return onion_c->dht;
  196|    943|}
onion_get_net_crypto:
  199|    943|{
  200|    943|    return onion_c->c;
  201|    943|}
onion_add_bs_path_node:
  217|    466|{
  218|    466|    if (!net_family_is_ipv4(ip_port->ip.family) && !net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (218:9): [True: 0, False: 466]
  |  Branch (218:52): [True: 0, False: 0]
  ------------------
  219|      0|        return false;
  220|      0|    }
  221|       |
  222|    466|    for (unsigned int i = 0; i < MAX_PATH_NODES; ++i) {
  ------------------
  |  |   44|    466|#define MAX_PATH_NODES 32
  ------------------
  |  Branch (222:30): [True: 466, False: 0]
  ------------------
  223|    466|        if (pk_equal(public_key, onion_c->path_nodes_bs[i].public_key)) {
  ------------------
  |  Branch (223:13): [True: 466, False: 0]
  ------------------
  224|    466|            return true;
  225|    466|        }
  226|    466|    }
  227|       |
  228|      0|    onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].ip_port = *ip_port;
  ------------------
  |  |   44|      0|#define MAX_PATH_NODES 32
  ------------------
  229|      0|    memcpy(onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].public_key, public_key,
  ------------------
  |  |   44|      0|#define MAX_PATH_NODES 32
  ------------------
  230|      0|           CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  231|       |
  232|      0|    const uint16_t last = onion_c->path_nodes_index_bs;
  233|      0|    ++onion_c->path_nodes_index_bs;
  234|       |
  235|      0|    if (onion_c->path_nodes_index_bs < last) {
  ------------------
  |  Branch (235:9): [True: 0, False: 0]
  ------------------
  236|      0|        onion_c->path_nodes_index_bs = MAX_PATH_NODES + 1;
  ------------------
  |  |   44|      0|#define MAX_PATH_NODES 32
  ------------------
  237|      0|    }
  238|       |
  239|      0|    return true;
  240|    466|}
onion_friend_num:
 1445|    133|{
 1446|    316|    for (unsigned int i = 0; i < onion_c->num_friends; ++i) {
  ------------------
  |  Branch (1446:30): [True: 184, False: 132]
  ------------------
 1447|    184|        if (!onion_c->friends_list[i].is_valid) {
  ------------------
  |  Branch (1447:13): [True: 0, False: 184]
  ------------------
 1448|      0|            continue;
 1449|      0|        }
 1450|       |
 1451|    184|        if (pk_equal(public_key, onion_c->friends_list[i].real_public_key)) {
  ------------------
  |  Branch (1451:13): [True: 1, False: 183]
  ------------------
 1452|      1|            return i;
 1453|      1|        }
 1454|    184|    }
 1455|       |
 1456|    132|    return -1;
 1457|    133|}
onion_addfriend:
 1489|    121|{
 1490|    121|    const int num = onion_friend_num(onion_c, public_key);
 1491|       |
 1492|    121|    if (num != -1) {
  ------------------
  |  Branch (1492:9): [True: 0, False: 121]
  ------------------
 1493|      0|        return num;
 1494|      0|    }
 1495|       |
 1496|    121|    unsigned int index = -1;
 1497|       |
 1498|    289|    for (unsigned int i = 0; i < onion_c->num_friends; ++i) {
  ------------------
  |  Branch (1498:30): [True: 168, False: 121]
  ------------------
 1499|    168|        if (!onion_c->friends_list[i].is_valid) {
  ------------------
  |  Branch (1499:13): [True: 0, False: 168]
  ------------------
 1500|      0|            index = i;
 1501|      0|            break;
 1502|      0|        }
 1503|    168|    }
 1504|       |
 1505|    121|    if (index == (uint32_t) -1) {
  ------------------
  |  Branch (1505:9): [True: 121, False: 0]
  ------------------
 1506|    121|        if (realloc_onion_friends(onion_c, onion_c->num_friends + 1) == -1) {
  ------------------
  |  Branch (1506:13): [True: 0, False: 121]
  ------------------
 1507|      0|            return -1;
 1508|      0|        }
 1509|       |
 1510|    121|        index = onion_c->num_friends;
 1511|    121|        onion_c->friends_list[onion_c->num_friends] = empty_onion_friend;
 1512|    121|        ++onion_c->num_friends;
 1513|    121|    }
 1514|       |
 1515|    121|    onion_c->friends_list[index].is_valid = true;
 1516|    121|    memcpy(onion_c->friends_list[index].real_public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    121|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1517|    121|    crypto_new_keypair(onion_c->rng, onion_c->friends_list[index].temp_public_key,
 1518|    121|                       onion_c->friends_list[index].temp_secret_key);
 1519|    121|    return index;
 1520|    121|}
onion_delfriend:
 1528|    121|{
 1529|    121|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1529:9): [True: 0, False: 121]
  ------------------
 1530|      0|        return -1;
 1531|      0|    }
 1532|       |
 1533|       |#if 0
 1534|       |
 1535|       |    if (onion_c->friends_list[friend_num].know_dht_public_key) {
 1536|       |        dht_delfriend(onion_c->dht, onion_c->friends_list[friend_num].dht_public_key, 0);
 1537|       |    }
 1538|       |
 1539|       |#endif
 1540|       |
 1541|    121|    crypto_memzero(&onion_c->friends_list[friend_num], sizeof(Onion_Friend));
 1542|    121|    unsigned int i;
 1543|       |
 1544|    242|    for (i = onion_c->num_friends; i != 0; --i) {
  ------------------
  |  Branch (1544:36): [True: 199, False: 43]
  ------------------
 1545|    199|        if (onion_c->friends_list[i - 1].is_valid) {
  ------------------
  |  Branch (1545:13): [True: 78, False: 121]
  ------------------
 1546|     78|            break;
 1547|     78|        }
 1548|    199|    }
 1549|       |
 1550|    121|    if (onion_c->num_friends != i) {
  ------------------
  |  Branch (1550:9): [True: 43, False: 78]
  ------------------
 1551|     43|        onion_c->num_friends = i;
 1552|     43|        realloc_onion_friends(onion_c, onion_c->num_friends);
 1553|     43|    }
 1554|       |
 1555|    121|    return friend_num;
 1556|    121|}
recv_tcp_relay_handler:
 1568|    121|{
 1569|    121|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1569:9): [True: 0, False: 121]
  ------------------
 1570|      0|        return -1;
 1571|      0|    }
 1572|       |
 1573|    121|    onion_c->friends_list[friend_num].tcp_relay_node_callback = callback;
 1574|    121|    onion_c->friends_list[friend_num].tcp_relay_node_callback_object = object;
 1575|    121|    onion_c->friends_list[friend_num].tcp_relay_node_callback_number = number;
 1576|    121|    return 0;
 1577|    121|}
onion_dht_pk_callback:
 1589|    121|{
 1590|    121|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1590:9): [True: 0, False: 121]
  ------------------
 1591|      0|        return -1;
 1592|      0|    }
 1593|       |
 1594|    121|    onion_c->friends_list[friend_num].dht_pk_callback = function;
 1595|    121|    onion_c->friends_list[friend_num].dht_pk_callback_object = object;
 1596|    121|    onion_c->friends_list[friend_num].dht_pk_callback_number = number;
 1597|    121|    return 0;
 1598|    121|}
onion_set_friend_dht_pubkey:
 1606|      2|{
 1607|      2|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1607:9): [True: 0, False: 2]
  ------------------
 1608|      0|        return -1;
 1609|      0|    }
 1610|       |
 1611|      2|    if (!onion_c->friends_list[friend_num].is_valid) {
  ------------------
  |  Branch (1611:9): [True: 0, False: 2]
  ------------------
 1612|      0|        return -1;
 1613|      0|    }
 1614|       |
 1615|      2|    if (onion_c->friends_list[friend_num].know_dht_public_key) {
  ------------------
  |  Branch (1615:9): [True: 1, False: 1]
  ------------------
 1616|      1|        if (pk_equal(dht_key, onion_c->friends_list[friend_num].dht_public_key)) {
  ------------------
  |  Branch (1616:13): [True: 1, False: 0]
  ------------------
 1617|      1|            return -1;
 1618|      1|        }
 1619|      1|    }
 1620|       |
 1621|      1|    onion_c->friends_list[friend_num].know_dht_public_key = true;
 1622|      1|    memcpy(onion_c->friends_list[friend_num].dht_public_key, dht_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1623|       |
 1624|      1|    return 0;
 1625|      2|}
oniondata_registerhandler:
 1843|  2.81k|{
 1844|  2.81k|    onion_c->onion_data_handlers[byte].function = cb;
 1845|  2.81k|    onion_c->onion_data_handlers[byte].object = object;
 1846|  2.81k|}
onion_group_announce_register:
 1849|  1.87k|{
 1850|  1.87k|    onion_c->group_announce_response = func;
 1851|  1.87k|    onion_c->group_announce_response_user_data = user_data;
 1852|  1.87k|}
onion_connection_status:
 2020|  87.9k|{
 2021|  87.9k|    if (onion_c->onion_connected >= ONION_CONNECTION_SECONDS) {
  ------------------
  |  | 2016|  87.9k|#define ONION_CONNECTION_SECONDS 3
  ------------------
  |  Branch (2021:9): [True: 0, False: 87.9k]
  ------------------
 2022|      0|        if (onion_c->udp_connected) {
  ------------------
  |  Branch (2022:13): [True: 0, False: 0]
  ------------------
 2023|      0|            return ONION_CONNECTION_STATUS_UDP;
 2024|      0|        }
 2025|       |
 2026|      0|        return ONION_CONNECTION_STATUS_TCP;
 2027|      0|    }
 2028|       |
 2029|  87.9k|    return ONION_CONNECTION_STATUS_NONE;
 2030|  87.9k|}
do_onion_client:
 2033|  72.6k|{
 2034|  72.6k|    if (onion_c->last_run == mono_time_get(onion_c->mono_time)) {
  ------------------
  |  Branch (2034:9): [True: 57.4k, False: 15.2k]
  ------------------
 2035|  57.4k|        return;
 2036|  57.4k|    }
 2037|       |
 2038|  15.2k|    if (mono_time_is_timeout(onion_c->mono_time, onion_c->first_run, ONION_CONNECTION_SECONDS)) {
  ------------------
  |  | 2016|  15.2k|#define ONION_CONNECTION_SECONDS 3
  ------------------
  |  Branch (2038:9): [True: 14.7k, False: 499]
  ------------------
 2039|  14.7k|        populate_path_nodes(onion_c);
 2040|  14.7k|        do_announce(onion_c);
 2041|  14.7k|    }
 2042|       |
 2043|  15.2k|    if (onion_isconnected(onion_c)) {
  ------------------
  |  Branch (2043:9): [True: 0, False: 15.2k]
  ------------------
 2044|      0|        if (mono_time_is_timeout(onion_c->mono_time, onion_c->last_time_connected, ONION_CONNECTED_TIMEOUT)) {
  ------------------
  |  | 2017|      0|#define ONION_CONNECTED_TIMEOUT 10
  ------------------
  |  Branch (2044:13): [True: 0, False: 0]
  ------------------
 2045|      0|            reset_friend_run_counts(onion_c);
 2046|      0|        }
 2047|       |
 2048|      0|        onion_c->last_time_connected = mono_time_get(onion_c->mono_time);
 2049|       |
 2050|      0|        if (onion_c->onion_connected < ONION_CONNECTION_SECONDS * 2) {
  ------------------
  |  | 2016|      0|#define ONION_CONNECTION_SECONDS 3
  ------------------
  |  Branch (2050:13): [True: 0, False: 0]
  ------------------
 2051|      0|            ++onion_c->onion_connected;
 2052|      0|        }
 2053|  15.2k|    } else {
 2054|  15.2k|        if (onion_c->onion_connected != 0) {
  ------------------
  |  Branch (2054:13): [True: 0, False: 15.2k]
  ------------------
 2055|      0|            --onion_c->onion_connected;
 2056|      0|        }
 2057|  15.2k|    }
 2058|       |
 2059|  15.2k|    onion_c->udp_connected = dht_non_lan_connected(onion_c->dht);
 2060|       |
 2061|  15.2k|    if (mono_time_is_timeout(onion_c->mono_time, onion_c->first_run, ONION_CONNECTION_SECONDS * 2)) {
  ------------------
  |  | 2016|  15.2k|#define ONION_CONNECTION_SECONDS 3
  ------------------
  |  Branch (2061:9): [True: 14.2k, False: 1.02k]
  ------------------
 2062|  14.2k|        set_tcp_onion_status(nc_get_tcp_c(onion_c->c), !onion_c->udp_connected);
 2063|  14.2k|    }
 2064|       |
 2065|  15.2k|    if (onion_connection_status(onion_c) != ONION_CONNECTION_STATUS_NONE) {
  ------------------
  |  Branch (2065:9): [True: 0, False: 15.2k]
  ------------------
 2066|      0|        for (unsigned i = 0; i < onion_c->num_friends; ++i) {
  ------------------
  |  Branch (2066:30): [True: 0, False: 0]
  ------------------
 2067|      0|            do_friend(onion_c, i);
 2068|      0|        }
 2069|      0|    }
 2070|       |
 2071|  15.2k|    if (onion_c->last_run == 0) {
  ------------------
  |  Branch (2071:9): [True: 914, False: 14.3k]
  ------------------
 2072|    914|        onion_c->first_run = mono_time_get(onion_c->mono_time);
 2073|    914|    }
 2074|       |
 2075|  15.2k|    onion_c->last_run = mono_time_get(onion_c->mono_time);
 2076|  15.2k|}
new_onion_client:
 2079|    946|{
 2080|    946|    if (c == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (2080:9): [True: 0, False: 946]
  ------------------
 2081|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2082|      0|    }
 2083|       |
 2084|    946|    Onion_Client *onion_c = (Onion_Client *)mem_alloc(mem, sizeof(Onion_Client));
 2085|       |
 2086|    946|    if (onion_c == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (2086:9): [True: 2, False: 944]
  ------------------
 2087|      2|        return nullptr;
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
 2088|      2|    }
 2089|       |
 2090|    944|    onion_c->announce_ping_array = ping_array_new(mem, ANNOUNCE_ARRAY_SIZE, ANNOUNCE_TIMEOUT);
  ------------------
  |  |   23|    944|#define ANNOUNCE_ARRAY_SIZE 256
  ------------------
                  onion_c->announce_ping_array = ping_array_new(mem, ANNOUNCE_ARRAY_SIZE, ANNOUNCE_TIMEOUT);
  ------------------
  |  |   24|    944|#define ANNOUNCE_TIMEOUT 10
  ------------------
 2091|       |
 2092|    944|    if (onion_c->announce_ping_array == nullptr) {
  ------------------
  |  |   66|    944|#define nullptr NULL
  ------------------
  |  Branch (2092:9): [True: 1, False: 943]
  ------------------
 2093|      1|        mem_delete(mem, onion_c);
 2094|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
 2095|      1|    }
 2096|       |
 2097|    943|    onion_c->mono_time = mono_time;
 2098|    943|    onion_c->logger = logger;
 2099|    943|    onion_c->rng = rng;
 2100|    943|    onion_c->mem = mem;
 2101|    943|    onion_c->dht = nc_get_dht(c);
 2102|    943|    onion_c->net = dht_get_net(onion_c->dht);
 2103|    943|    onion_c->c = c;
 2104|    943|    new_symmetric_key(rng, onion_c->secret_symmetric_key);
 2105|    943|    crypto_new_keypair(rng, onion_c->temp_public_key, onion_c->temp_secret_key);
 2106|    943|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, &handle_announce_response, onion_c);
 2107|    943|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, &handle_announce_response_old, onion_c);
 2108|    943|    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, &handle_data_response, onion_c);
 2109|    943|    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, &handle_dhtpk_announce, onion_c);
  ------------------
  |  |   58|    943|#define ONION_DATA_DHTPK CRYPTO_PACKET_DHTPK
  |  |  ------------------
  |  |  |  |   81|    943|#define CRYPTO_PACKET_DHTPK         156
  |  |  ------------------
  ------------------
 2110|    943|    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, &handle_dht_dhtpk, onion_c);
  ------------------
  |  |   81|    943|#define CRYPTO_PACKET_DHTPK         156
  ------------------
 2111|    943|    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), &handle_tcp_onion, onion_c);
 2112|       |
 2113|    943|    return onion_c;
 2114|    944|}
kill_onion_client:
 2117|    946|{
 2118|    946|    if (onion_c == nullptr) {
  ------------------
  |  |   66|    946|#define nullptr NULL
  ------------------
  |  Branch (2118:9): [True: 3, False: 943]
  ------------------
 2119|      3|        return;
 2120|      3|    }
 2121|       |
 2122|    943|    const Memory *mem = onion_c->mem;
 2123|       |
 2124|    943|    ping_array_kill(onion_c->announce_ping_array);
 2125|    943|    realloc_onion_friends(onion_c, 0);
 2126|    943|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
 2127|    943|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
 2128|    943|    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
 2129|    943|    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   58|    943|#define ONION_DATA_DHTPK CRYPTO_PACKET_DHTPK
  |  |  ------------------
  |  |  |  |   81|    943|#define CRYPTO_PACKET_DHTPK         156
  |  |  ------------------
  ------------------
                  oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
 2130|    943|    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   81|    943|#define CRYPTO_PACKET_DHTPK         156
  ------------------
                  cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
 2131|    943|    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
                  set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), nullptr, nullptr);
  ------------------
  |  |   66|    943|#define nullptr NULL
  ------------------
 2132|    943|    crypto_memzero(onion_c, sizeof(Onion_Client));
 2133|    943|    mem_delete(mem, onion_c);
 2134|    943|}
onion_client.c:onion_node_timed_out:
  411|   177k|{
  412|   177k|    return node->timestamp == 0
  ------------------
  |  Branch (412:12): [True: 177k, False: 0]
  ------------------
  413|   177k|           || (node->pings_since_last_response >= ONION_NODE_MAX_PINGS
  ------------------
  |  |   42|      0|#define ONION_NODE_MAX_PINGS 3
  ------------------
  |  Branch (413:16): [True: 0, False: 0]
  ------------------
  414|      0|               && mono_time_is_timeout(mono_time, node->last_pinged, ONION_NODE_TIMEOUT));
  ------------------
  |  |   22|      0|#define ONION_NODE_TIMEOUT ONION_NODE_PING_INTERVAL
  |  |  ------------------
  |  |  |  |   21|      0|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  ------------------
  |  Branch (414:19): [True: 0, False: 0]
  ------------------
  415|   177k|}
onion_client.c:realloc_onion_friends:
 1466|  1.10k|{
 1467|  1.10k|    if (num == 0) {
  ------------------
  |  Branch (1467:9): [True: 986, False: 121]
  ------------------
 1468|    986|        mem_delete(onion_c->mem, onion_c->friends_list);
 1469|    986|        onion_c->friends_list = nullptr;
  ------------------
  |  |   66|    986|#define nullptr NULL
  ------------------
 1470|    986|        return 0;
 1471|    986|    }
 1472|       |
 1473|    121|    Onion_Friend *newonion_friends = (Onion_Friend *)mem_vrealloc(onion_c->mem, onion_c->friends_list, num, sizeof(Onion_Friend));
 1474|       |
 1475|    121|    if (newonion_friends == nullptr) {
  ------------------
  |  |   66|    121|#define nullptr NULL
  ------------------
  |  Branch (1475:9): [True: 0, False: 121]
  ------------------
 1476|      0|        return -1;
 1477|      0|    }
 1478|       |
 1479|    121|    onion_c->friends_list = newonion_friends;
 1480|    121|    return 0;
 1481|    121|}
onion_client.c:populate_path_nodes:
 1695|  14.7k|{
 1696|  14.7k|    Node_format node_list[MAX_FRIEND_CLIENTS];
 1697|       |
 1698|  14.7k|    const unsigned int num_nodes = randfriends_nodes(onion_c->dht, node_list, MAX_FRIEND_CLIENTS);
  ------------------
  |  |   43|  14.7k|#define MAX_FRIEND_CLIENTS 8
  ------------------
 1699|       |
 1700|  14.7k|    for (unsigned int i = 0; i < num_nodes; ++i) {
  ------------------
  |  Branch (1700:30): [True: 0, False: 14.7k]
  ------------------
 1701|      0|        onion_add_path_node(onion_c, &node_list[i].ip_port, node_list[i].public_key);
 1702|      0|    }
 1703|  14.7k|}
onion_client.c:do_announce:
 1862|  14.7k|{
 1863|  14.7k|    unsigned int count = 0;
 1864|  14.7k|    Onion_Node *node_list = onion_c->clients_announce_list;
 1865|       |
 1866|   191k|    for (unsigned int i = 0; i < MAX_ONION_CLIENTS_ANNOUNCE; ++i) {
  ------------------
  |  |   20|   191k|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (1866:30): [True: 177k, False: 14.7k]
  ------------------
 1867|   177k|        if (onion_node_timed_out(&node_list[i], onion_c->mono_time)) {
  ------------------
  |  Branch (1867:13): [True: 177k, False: 0]
  ------------------
 1868|   177k|            continue;
 1869|   177k|        }
 1870|       |
 1871|      0|        ++count;
 1872|       |
 1873|       |        /* Don't announce ourselves the first time this is run to new peers */
 1874|      0|        if (node_list[i].last_pinged == 0) {
  ------------------
  |  Branch (1874:13): [True: 0, False: 0]
  ------------------
 1875|      0|            node_list[i].last_pinged = 1;
 1876|      0|            continue;
 1877|      0|        }
 1878|       |
 1879|      0|        if (node_list[i].pings_since_last_response >= ONION_NODE_MAX_PINGS) {
  ------------------
  |  |   42|      0|#define ONION_NODE_MAX_PINGS 3
  ------------------
  |  Branch (1879:13): [True: 0, False: 0]
  ------------------
 1880|      0|            continue;
 1881|      0|        }
 1882|       |
 1883|       |
 1884|      0|        unsigned int interval = ANNOUNCE_INTERVAL_NOT_ANNOUNCED;
  ------------------
  |  | 1854|      0|#define ANNOUNCE_INTERVAL_NOT_ANNOUNCED 3
  ------------------
 1885|       |
 1886|      0|        if (node_list[i].is_stored != 0
  ------------------
  |  Branch (1886:13): [True: 0, False: 0]
  ------------------
 1887|      0|                && path_exists(onion_c->mono_time, &onion_c->onion_paths_self, node_list[i].path_used)) {
  ------------------
  |  Branch (1887:20): [True: 0, False: 0]
  ------------------
 1888|      0|            interval = ANNOUNCE_INTERVAL_ANNOUNCED;
  ------------------
  |  | 1855|      0|#define ANNOUNCE_INTERVAL_ANNOUNCED ONION_NODE_PING_INTERVAL
  |  |  ------------------
  |  |  |  |   21|      0|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  ------------------
 1889|       |
 1890|      0|            const uint32_t pathnum = node_list[i].path_used % NUMBER_ONION_PATHS;
  ------------------
  |  |   28|      0|#define NUMBER_ONION_PATHS 6
  ------------------
 1891|       |
 1892|       |            /* A node/path is considered "stable", and can be pinged less
 1893|       |             * aggressively, if it has survived for at least TIME_TO_STABLE
 1894|       |             * and the latest packets sent to it are not timing out.
 1895|       |             */
 1896|      0|            if (mono_time_is_timeout(onion_c->mono_time, node_list[i].added_time, TIME_TO_STABLE)
  ------------------
  |  | 1857|      0|#define TIME_TO_STABLE (ONION_NODE_PING_INTERVAL * 6)
  |  |  ------------------
  |  |  |  |   21|      0|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  ------------------
  |  Branch (1896:17): [True: 0, False: 0]
  ------------------
 1897|      0|                    && !(node_list[i].pings_since_last_response > 0
  ------------------
  |  Branch (1897:26): [True: 0, False: 0]
  ------------------
 1898|      0|                         && mono_time_is_timeout(onion_c->mono_time, node_list[i].last_pinged, ONION_NODE_TIMEOUT))
  ------------------
  |  |   22|      0|#define ONION_NODE_TIMEOUT ONION_NODE_PING_INTERVAL
  |  |  ------------------
  |  |  |  |   21|      0|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  ------------------
  |  Branch (1898:29): [True: 0, False: 0]
  ------------------
 1899|      0|                    && mono_time_is_timeout(onion_c->mono_time, onion_c->onion_paths_self.path_creation_time[pathnum], TIME_TO_STABLE)
  ------------------
  |  | 1857|      0|#define TIME_TO_STABLE (ONION_NODE_PING_INTERVAL * 6)
  |  |  ------------------
  |  |  |  |   21|      0|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  ------------------
  |  Branch (1899:24): [True: 0, False: 0]
  ------------------
 1900|      0|                    && !(onion_c->onion_paths_self.last_path_used_times[pathnum] > 0
  ------------------
  |  Branch (1900:26): [True: 0, False: 0]
  ------------------
 1901|      0|                         && mono_time_is_timeout(onion_c->mono_time, onion_c->onion_paths_self.last_path_used[pathnum], ONION_PATH_TIMEOUT))) {
  ------------------
  |  |   35|      0|#define ONION_PATH_TIMEOUT 10
  ------------------
  |  Branch (1901:29): [True: 0, False: 0]
  ------------------
 1902|      0|                interval = ANNOUNCE_INTERVAL_STABLE;
  ------------------
  |  | 1858|      0|#define ANNOUNCE_INTERVAL_STABLE (ONION_NODE_PING_INTERVAL * 8)
  |  |  ------------------
  |  |  |  |   21|      0|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  ------------------
 1903|      0|            }
 1904|      0|        }
 1905|       |
 1906|      0|        if (mono_time_is_timeout(onion_c->mono_time, node_list[i].last_pinged, interval)
  ------------------
  |  Branch (1906:13): [True: 0, False: 0]
  ------------------
 1907|      0|                || mono_time_is_timeout(onion_c->mono_time, onion_c->last_announce, ONION_NODE_PING_INTERVAL)) {
  ------------------
  |  |   21|      0|#define ONION_NODE_PING_INTERVAL 15
  ------------------
  |  Branch (1907:20): [True: 0, False: 0]
  ------------------
 1908|      0|            uint32_t path_to_use = node_list[i].path_used;
 1909|       |
 1910|      0|            if (node_list[i].pings_since_last_response == ONION_NODE_MAX_PINGS - 1
  ------------------
  |  |   42|      0|#define ONION_NODE_MAX_PINGS 3
  ------------------
  |  Branch (1910:17): [True: 0, False: 0]
  ------------------
 1911|      0|                    && mono_time_is_timeout(onion_c->mono_time, node_list[i].added_time, TIME_TO_STABLE)) {
  ------------------
  |  | 1857|      0|#define TIME_TO_STABLE (ONION_NODE_PING_INTERVAL * 6)
  |  |  ------------------
  |  |  |  |   21|      0|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  ------------------
  |  Branch (1911:24): [True: 0, False: 0]
  ------------------
 1912|       |                /* Last chance for a long-lived node - try a random path */
 1913|      0|                path_to_use = -1;
 1914|      0|            }
 1915|       |
 1916|      0|            if (client_send_announce_request(onion_c, 0, &node_list[i].ip_port, node_list[i].public_key,
  ------------------
  |  Branch (1916:17): [True: 0, False: 0]
  ------------------
 1917|      0|                                             node_list[i].ping_id, path_to_use) == 0) {
 1918|      0|                node_list[i].last_pinged = mono_time_get(onion_c->mono_time);
 1919|      0|                ++node_list[i].pings_since_last_response;
 1920|      0|                onion_c->last_announce = mono_time_get(onion_c->mono_time);
 1921|      0|            }
 1922|      0|        }
 1923|      0|    }
 1924|       |
 1925|  14.7k|    if (count == MAX_ONION_CLIENTS_ANNOUNCE) {
  ------------------
  |  |   20|  14.7k|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (1925:9): [True: 0, False: 14.7k]
  ------------------
 1926|      0|        onion_c->last_populated = mono_time_get(onion_c->mono_time);
 1927|      0|        return;
 1928|      0|    }
 1929|       |
 1930|       |    // check if list needs to be re-populated
 1931|  14.7k|    if (count <= MAX_ONION_CLIENTS_ANNOUNCE / 2
  ------------------
  |  |   20|  14.7k|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (1931:9): [True: 14.7k, False: 0]
  ------------------
 1932|  14.7k|            || mono_time_is_timeout(onion_c->mono_time, onion_c->last_populated, ANNOUNCE_POPULATE_TIMEOUT)) {
  ------------------
  |  | 1712|      0|#define ANNOUNCE_POPULATE_TIMEOUT (60 * 10)
  ------------------
  |  Branch (1932:16): [True: 0, False: 0]
  ------------------
 1933|  14.7k|        uint16_t num_nodes;
 1934|  14.7k|        const Node_format *path_nodes;
 1935|       |
 1936|  14.7k|        if (onion_c->path_nodes_index == 0) {
  ------------------
  |  Branch (1936:13): [True: 14.7k, False: 0]
  ------------------
 1937|  14.7k|            num_nodes = min_u16(onion_c->path_nodes_index_bs, MAX_PATH_NODES);
  ------------------
  |  |   44|  14.7k|#define MAX_PATH_NODES 32
  ------------------
 1938|  14.7k|            path_nodes = onion_c->path_nodes_bs;
 1939|  14.7k|        } else {
 1940|      0|            num_nodes = min_u16(onion_c->path_nodes_index, MAX_PATH_NODES);
  ------------------
  |  |   44|      0|#define MAX_PATH_NODES 32
  ------------------
 1941|      0|            path_nodes = onion_c->path_nodes;
 1942|      0|        }
 1943|       |
 1944|  14.7k|        if (num_nodes == 0) {
  ------------------
  |  Branch (1944:13): [True: 14.7k, False: 0]
  ------------------
 1945|  14.7k|            return;
 1946|  14.7k|        }
 1947|       |
 1948|      0|        for (unsigned int i = 0; i < (MAX_ONION_CLIENTS_ANNOUNCE / 2); ++i) {
  ------------------
  |  |   20|      0|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (1948:34): [True: 0, False: 0]
  ------------------
 1949|      0|            const uint32_t num = random_range_u32(onion_c->rng, num_nodes);
 1950|      0|            client_send_announce_request(onion_c, 0, &path_nodes[num].ip_port, path_nodes[num].public_key, nullptr, -1);
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1951|      0|        }
 1952|      0|    }
 1953|  14.7k|}
onion_client.c:onion_isconnected:
 1961|  15.2k|{
 1962|  15.2k|    unsigned int num = 0;
 1963|  15.2k|    unsigned int announced = 0;
 1964|       |
 1965|  15.2k|    if (mono_time_is_timeout(onion_c->mono_time, onion_c->last_packet_recv, ONION_OFFLINE_TIMEOUT)) {
  ------------------
  |  |   54|  15.2k|#define ONION_OFFLINE_TIMEOUT (ONION_NODE_PING_INTERVAL * (ONION_NODE_MAX_PINGS+2))
  |  |  ------------------
  |  |  |  |   21|  15.2k|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  |  |               #define ONION_OFFLINE_TIMEOUT (ONION_NODE_PING_INTERVAL * (ONION_NODE_MAX_PINGS+2))
  |  |  ------------------
  |  |  |  |   42|  15.2k|#define ONION_NODE_MAX_PINGS 3
  |  |  ------------------
  ------------------
  |  Branch (1965:9): [True: 15.2k, False: 0]
  ------------------
 1966|  15.2k|        onion_c->last_populated = 0;
 1967|  15.2k|        return false;
 1968|  15.2k|    }
 1969|       |
 1970|      0|    if (onion_c->path_nodes_index == 0) {
  ------------------
  |  Branch (1970:9): [True: 0, False: 0]
  ------------------
 1971|      0|        onion_c->last_populated = 0;
 1972|      0|        return false;
 1973|      0|    }
 1974|       |
 1975|      0|    for (unsigned int i = 0; i < MAX_ONION_CLIENTS_ANNOUNCE; ++i) {
  ------------------
  |  |   20|      0|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (1975:30): [True: 0, False: 0]
  ------------------
 1976|      0|        if (!onion_node_timed_out(&onion_c->clients_announce_list[i], onion_c->mono_time)) {
  ------------------
  |  Branch (1976:13): [True: 0, False: 0]
  ------------------
 1977|      0|            ++num;
 1978|       |
 1979|      0|            if (onion_c->clients_announce_list[i].is_stored != 0) {
  ------------------
  |  Branch (1979:17): [True: 0, False: 0]
  ------------------
 1980|      0|                ++announced;
 1981|      0|            }
 1982|      0|        }
 1983|      0|    }
 1984|       |
 1985|      0|    unsigned int pnodes = onion_c->path_nodes_index;
 1986|       |
 1987|      0|    if (pnodes > MAX_ONION_CLIENTS_ANNOUNCE) {
  ------------------
  |  |   20|      0|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (1987:9): [True: 0, False: 0]
  ------------------
 1988|      0|        pnodes = MAX_ONION_CLIENTS_ANNOUNCE;
  ------------------
  |  |   20|      0|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
 1989|      0|    }
 1990|       |
 1991|       |    /* Consider ourselves online if we are announced to half or more nodes
 1992|       |     * we are connected to */
 1993|      0|    if (num != 0 && announced != 0) {
  ------------------
  |  Branch (1993:9): [True: 0, False: 0]
  |  Branch (1993:21): [True: 0, False: 0]
  ------------------
 1994|      0|        if ((num / 2) <= announced && (pnodes / 2) <= num) {
  ------------------
  |  Branch (1994:13): [True: 0, False: 0]
  |  Branch (1994:39): [True: 0, False: 0]
  ------------------
 1995|      0|            return true;
 1996|      0|        }
 1997|      0|    }
 1998|       |
 1999|      0|    onion_c->last_populated = 0;
 2000|       |
 2001|      0|    return false;
 2002|      0|}
onion_client.c:handle_announce_response:
  933|     17|{
  934|     17|    Onion_Client *onion_c = (Onion_Client *)object;
  935|       |
  936|     17|    if (length < ONION_ANNOUNCE_RESPONSE_MIN_SIZE || length > ONION_ANNOUNCE_RESPONSE_MAX_SIZE) {
  ------------------
  |  |   27|     34|#define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   21|     17|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     17|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   18|     17|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   10|     17|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  131|     17|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     17|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                  if (length < ONION_ANNOUNCE_RESPONSE_MIN_SIZE || length > ONION_ANNOUNCE_RESPONSE_MAX_SIZE) {
  ------------------
  |  |   28|     13|#define ONION_ANNOUNCE_RESPONSE_MAX_SIZE (ONION_ANNOUNCE_RESPONSE_MIN_SIZE + ONION_MAX_EXTRA_DATA_SIZE * MAX_SENT_NODES)
  |  |  ------------------
  |  |  |  |   27|     13|#define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     13|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     13|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   18|     13|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   10|     13|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  131|     13|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     13|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MAX_SIZE (ONION_ANNOUNCE_RESPONSE_MIN_SIZE + ONION_MAX_EXTRA_DATA_SIZE * MAX_SENT_NODES)
  |  |  ------------------
  |  |  |  |   19|     13|#define ONION_MAX_EXTRA_DATA_SIZE 136
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MAX_SIZE (ONION_ANNOUNCE_RESPONSE_MIN_SIZE + ONION_MAX_EXTRA_DATA_SIZE * MAX_SENT_NODES)
  |  |  ------------------
  |  |  |  |   54|     13|#define MAX_SENT_NODES 4
  |  |  ------------------
  ------------------
  |  Branch (936:9): [True: 4, False: 13]
  |  Branch (936:54): [True: 3, False: 10]
  ------------------
  937|      7|        return 1;
  938|      7|    }
  939|       |
  940|     10|    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
  941|     10|    IP_Port ip_port;
  942|     10|    uint32_t path_num;
  943|     10|    const uint32_t num = check_sendback(onion_c, packet + 1, public_key, &ip_port, &path_num);
  944|       |
  945|     10|    if (num > onion_c->num_friends) {
  ------------------
  |  Branch (945:9): [True: 10, False: 0]
  ------------------
  946|     10|        return 1;
  947|     10|    }
  948|       |
  949|      0|    uint8_t plain[1 + ONION_PING_ID_SIZE + ONION_ANNOUNCE_RESPONSE_MAX_SIZE - ONION_ANNOUNCE_RESPONSE_MIN_SIZE];
  950|      0|    const int plain_size = 1 + ONION_PING_ID_SIZE + length - ONION_ANNOUNCE_RESPONSE_MIN_SIZE;
  ------------------
  |  |   18|      0|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|      0|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      0|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  const int plain_size = 1 + ONION_PING_ID_SIZE + length - ONION_ANNOUNCE_RESPONSE_MIN_SIZE;
  ------------------
  |  |   27|      0|#define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   18|      0|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   10|      0|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  131|      0|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  951|      0|    int len;
  952|       |
  953|      0|    if (num == 0) {
  ------------------
  |  Branch (953:9): [True: 0, False: 0]
  ------------------
  954|      0|        len = decrypt_data(public_key, nc_get_self_secret_key(onion_c->c),
  955|      0|                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
  956|      0|                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
                                         packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
  957|      0|                           length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
                                         length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
  958|      0|    } else {
  959|      0|        if (!onion_c->friends_list[num - 1].is_valid) {
  ------------------
  |  Branch (959:13): [True: 0, False: 0]
  ------------------
  960|      0|            return 1;
  961|      0|        }
  962|       |
  963|      0|        len = decrypt_data(public_key, onion_c->friends_list[num - 1].temp_secret_key,
  964|      0|                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
  965|      0|                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
                                         packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
  966|      0|                           length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
                                         length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
  967|      0|    }
  968|       |
  969|      0|    if ((uint32_t)len != plain_size) {
  ------------------
  |  Branch (969:9): [True: 0, False: 0]
  ------------------
  970|      0|        return 1;
  971|      0|    }
  972|       |
  973|      0|    const uint32_t path_used = set_path_timeouts(onion_c, num, path_num);
  974|       |
  975|      0|    if (client_add_to_list(onion_c, num, public_key, &ip_port, plain[0], plain + 1, path_used) == -1) {
  ------------------
  |  Branch (975:9): [True: 0, False: 0]
  ------------------
  976|      0|        return 1;
  977|      0|    }
  978|       |
  979|      0|    uint16_t len_nodes = 0;
  980|      0|    const uint8_t nodes_count = plain[1 + ONION_PING_ID_SIZE];
  ------------------
  |  |   18|      0|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|      0|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      0|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  981|       |
  982|      0|    if (nodes_count > 0) {
  ------------------
  |  Branch (982:9): [True: 0, False: 0]
  ------------------
  983|      0|        if (nodes_count > MAX_SENT_NODES) {
  ------------------
  |  |   54|      0|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (983:13): [True: 0, False: 0]
  ------------------
  984|      0|            return 1;
  985|      0|        }
  986|       |
  987|      0|        Node_format nodes[MAX_SENT_NODES];
  988|      0|        const int num_nodes = unpack_nodes(nodes, nodes_count, &len_nodes, plain + 2 + ONION_PING_ID_SIZE,
  ------------------
  |  |   18|      0|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|      0|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      0|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  989|      0|                                           plain_size - 2 - ONION_PING_ID_SIZE, false);
  ------------------
  |  |   18|      0|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|      0|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      0|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  990|       |
  991|      0|        if (num_nodes < 0) {
  ------------------
  |  Branch (991:13): [True: 0, False: 0]
  ------------------
  992|      0|            return 1;
  993|      0|        }
  994|       |
  995|      0|        if (client_ping_nodes(onion_c, num, nodes, num_nodes, source) == -1) {
  ------------------
  |  Branch (995:13): [True: 0, False: 0]
  ------------------
  996|      0|            return 1;
  997|      0|        }
  998|      0|    }
  999|       |
 1000|      0|    if (len_nodes + 1 < length - ONION_ANNOUNCE_RESPONSE_MIN_SIZE) {
  ------------------
  |  |   27|      0|#define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   18|      0|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   10|      0|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  131|      0|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|      0|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  |  Branch (1000:9): [True: 0, False: 0]
  ------------------
 1001|      0|        const uint16_t offset = 2 + ONION_PING_ID_SIZE + len_nodes;
  ------------------
  |  |   18|      0|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|      0|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      0|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1002|       |
 1003|      0|        if (plain_size < offset) {
  ------------------
  |  Branch (1003:13): [True: 0, False: 0]
  ------------------
 1004|      0|            return 1;
 1005|      0|        }
 1006|       |
 1007|      0|        if (!handle_group_announce_response(onion_c, num, plain + offset, plain_size - offset)) {
  ------------------
  |  Branch (1007:13): [True: 0, False: 0]
  ------------------
 1008|      0|            return 1;
 1009|      0|        }
 1010|      0|    }
 1011|       |
 1012|       |    // TODO(irungentoo): LAN vs non LAN ips?, if we are connected only to LAN, are we offline?
 1013|      0|    onion_c->last_packet_recv = mono_time_get(onion_c->mono_time);
 1014|       |
 1015|      0|    return 0;
 1016|      0|}
onion_client.c:check_sendback:
  604|     22|{
  605|     22|    uint64_t sback;
  606|     22|    memcpy(&sback, sendback, sizeof(uint64_t));
  607|     22|    uint8_t data[sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + sizeof(IP_Port) + sizeof(uint32_t)];
  608|       |
  609|     22|    if (ping_array_check(onion_c->announce_ping_array, onion_c->mono_time, data, sizeof(data), sback) != sizeof(data)) {
  ------------------
  |  Branch (609:9): [True: 22, False: 0]
  ------------------
  610|     22|        return -1;
  611|     22|    }
  612|       |
  613|      0|    memcpy(ret_pubkey, data + sizeof(uint32_t), CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  614|      0|    memcpy(ret_ip_port, data + sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE, sizeof(IP_Port));
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  615|      0|    memcpy(path_num, data + sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + sizeof(IP_Port), sizeof(uint32_t));
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  616|       |
  617|      0|    uint32_t num;
  618|      0|    memcpy(&num, data, sizeof(uint32_t));
  619|      0|    return num;
  620|     22|}
onion_client.c:handle_announce_response_old:
 1022|     23|{
 1023|     23|    Onion_Client *onion_c = (Onion_Client *)object;
 1024|       |
 1025|     23|    if (length < ONION_ANNOUNCE_RESPONSE_MIN_SIZE || length > ONION_ANNOUNCE_RESPONSE_MAX_SIZE) {
  ------------------
  |  |   27|     46|#define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   21|     23|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     23|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   18|     23|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   10|     23|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  131|     23|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     23|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                  if (length < ONION_ANNOUNCE_RESPONSE_MIN_SIZE || length > ONION_ANNOUNCE_RESPONSE_MAX_SIZE) {
  ------------------
  |  |   28|     15|#define ONION_ANNOUNCE_RESPONSE_MAX_SIZE (ONION_ANNOUNCE_RESPONSE_MIN_SIZE + ONION_MAX_EXTRA_DATA_SIZE * MAX_SENT_NODES)
  |  |  ------------------
  |  |  |  |   27|     15|#define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     15|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|     15|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   18|     15|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   10|     15|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  131|     15|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|     15|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MAX_SIZE (ONION_ANNOUNCE_RESPONSE_MIN_SIZE + ONION_MAX_EXTRA_DATA_SIZE * MAX_SENT_NODES)
  |  |  ------------------
  |  |  |  |   19|     15|#define ONION_MAX_EXTRA_DATA_SIZE 136
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MAX_SIZE (ONION_ANNOUNCE_RESPONSE_MIN_SIZE + ONION_MAX_EXTRA_DATA_SIZE * MAX_SENT_NODES)
  |  |  ------------------
  |  |  |  |   54|     15|#define MAX_SENT_NODES 4
  |  |  ------------------
  ------------------
  |  Branch (1025:9): [True: 8, False: 15]
  |  Branch (1025:54): [True: 3, False: 12]
  ------------------
 1026|     11|        return 1;
 1027|     11|    }
 1028|       |
 1029|     12|    const uint16_t len_nodes = length - ONION_ANNOUNCE_RESPONSE_MIN_SIZE;
  ------------------
  |  |   27|     12|#define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   21|     12|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     12|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   18|     12|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   10|     12|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  131|     12|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     12|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
 1030|       |
 1031|     12|    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
 1032|     12|    IP_Port ip_port;
 1033|     12|    uint32_t path_num;
 1034|     12|    const uint32_t num = check_sendback(onion_c, packet + 1, public_key, &ip_port, &path_num);
 1035|       |
 1036|     12|    if (num > onion_c->num_friends) {
  ------------------
  |  Branch (1036:9): [True: 12, False: 0]
  ------------------
 1037|     12|        return 1;
 1038|     12|    }
 1039|       |
 1040|      0|    VLA(uint8_t, plain, 1 + ONION_PING_ID_SIZE + len_nodes);
  ------------------
  |  |   62|      0|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      0|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 1041|      0|    int len;
 1042|       |
 1043|      0|    if (num == 0) {
  ------------------
  |  Branch (1043:9): [True: 0, False: 0]
  ------------------
 1044|      0|        len = decrypt_data(public_key, nc_get_self_secret_key(onion_c->c),
 1045|      0|                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
 1046|      0|                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
                                         packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
 1047|      0|                           length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
                                         length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
 1048|      0|    } else {
 1049|      0|        if (!onion_c->friends_list[num - 1].is_valid) {
  ------------------
  |  Branch (1049:13): [True: 0, False: 0]
  ------------------
 1050|      0|            return 1;
 1051|      0|        }
 1052|       |
 1053|      0|        len = decrypt_data(public_key, onion_c->friends_list[num - 1].temp_secret_key,
 1054|      0|                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
 1055|      0|                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
                                         packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
 1056|      0|                           length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |   21|      0|#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))
  ------------------
                                         length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |   66|      0|#define CRYPTO_NONCE_SIZE              24
  ------------------
 1057|      0|    }
 1058|       |
 1059|      0|    if ((uint32_t)len != SIZEOF_VLA(plain)) {
  ------------------
  |  |   29|      0|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (1059:9): [True: 0, False: 0]
  ------------------
 1060|      0|        return 1;
 1061|      0|    }
 1062|       |
 1063|      0|    const uint32_t path_used = set_path_timeouts(onion_c, num, path_num);
 1064|       |
 1065|      0|    if (client_add_to_list(onion_c, num, public_key, &ip_port, plain[0], plain + 1, path_used) == -1) {
  ------------------
  |  Branch (1065:9): [True: 0, False: 0]
  ------------------
 1066|      0|        return 1;
 1067|      0|    }
 1068|       |
 1069|      0|    if (len_nodes != 0) {
  ------------------
  |  Branch (1069:9): [True: 0, False: 0]
  ------------------
 1070|      0|        Node_format nodes[MAX_SENT_NODES];
 1071|      0|        const int num_nodes = unpack_nodes(nodes, MAX_SENT_NODES, nullptr, plain + 1 + ONION_PING_ID_SIZE, len_nodes, false);
  ------------------
  |  |   54|      0|#define MAX_SENT_NODES 4
  ------------------
                      const int num_nodes = unpack_nodes(nodes, MAX_SENT_NODES, nullptr, plain + 1 + ONION_PING_ID_SIZE, len_nodes, false);
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
                      const int num_nodes = unpack_nodes(nodes, MAX_SENT_NODES, nullptr, plain + 1 + ONION_PING_ID_SIZE, len_nodes, false);
  ------------------
  |  |   18|      0|#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
  |  |  ------------------
  |  |  |  |   10|      0|#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |  131|      0|#define CRYPTO_HMAC_SIZE               32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1072|       |
 1073|      0|        if (num_nodes <= 0) {
  ------------------
  |  Branch (1073:13): [True: 0, False: 0]
  ------------------
 1074|      0|            return 1;
 1075|      0|        }
 1076|       |
 1077|      0|        if (client_ping_nodes(onion_c, num, nodes, num_nodes, source) == -1) {
  ------------------
  |  Branch (1077:13): [True: 0, False: 0]
  ------------------
 1078|      0|            return 1;
 1079|      0|        }
 1080|      0|    }
 1081|       |
 1082|       |    // TODO(irungentoo): LAN vs non LAN ips?, if we are connected only to LAN, are we offline?
 1083|      0|    onion_c->last_packet_recv = mono_time_get(onion_c->mono_time);
 1084|      0|    return 0;
 1085|      0|}
onion_client.c:handle_data_response:
 1092|    251|{
 1093|    251|    Onion_Client *onion_c = (Onion_Client *)object;
 1094|       |
 1095|    251|    if (length <= (ONION_DATA_RESPONSE_MIN_SIZE + DATA_IN_RESPONSE_MIN_SIZE)) {
  ------------------
  |  |   33|    251|#define ONION_DATA_RESPONSE_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|    251|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define ONION_DATA_RESPONSE_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   40|    251|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define ONION_DATA_RESPONSE_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|    251|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
                  if (length <= (ONION_DATA_RESPONSE_MIN_SIZE + DATA_IN_RESPONSE_MIN_SIZE)) {
  ------------------
  |  | 1087|    251|#define DATA_IN_RESPONSE_MIN_SIZE ONION_DATA_IN_RESPONSE_MIN_SIZE
  |  |  ------------------
  |  |  |  |  178|    251|#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    251|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|    251|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1095:9): [True: 11, False: 240]
  ------------------
 1096|     11|        return 1;
 1097|     11|    }
 1098|       |
 1099|    240|    if (length > MAX_DATA_REQUEST_SIZE) {
  ------------------
  |  |   36|    240|#define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  ------------------
  |  |  |  |   48|    240|#define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  ------------------
  |  |  |  |  |  |   37|    240|#define ONION_MAX_PACKET_SIZE 1400
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  ------------------
  |  |  |  |  |  |   46|    240|#define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|    240|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   43|    240|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   40|    240|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  228|    240|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  226|    240|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|    240|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  227|    240|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|    240|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  ------------------
  |  |  |  |   35|    240|#define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    240|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   66|    240|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    240|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|    240|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1099:9): [True: 3, False: 237]
  ------------------
 1100|      3|        return 1;
 1101|      3|    }
 1102|       |
 1103|    237|    VLA(uint8_t, temp_plain, length - ONION_DATA_RESPONSE_MIN_SIZE);
  ------------------
  |  |   62|    237|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|    237|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 1104|    237|    int len = decrypt_data(packet + 1 + CRYPTO_NONCE_SIZE, onion_c->temp_secret_key, packet + 1,
  ------------------
  |  |   66|    237|#define CRYPTO_NONCE_SIZE              24
  ------------------
 1105|    237|                           packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   66|    237|#define CRYPTO_NONCE_SIZE              24
  ------------------
                                         packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|    237|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1106|    237|                           length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE), temp_plain);
  ------------------
  |  |   66|    237|#define CRYPTO_NONCE_SIZE              24
  ------------------
                                         length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE), temp_plain);
  ------------------
  |  |   40|    237|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1107|       |
 1108|    237|    if ((uint32_t)len != SIZEOF_VLA(temp_plain)) {
  ------------------
  |  |   29|    237|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (1108:9): [True: 0, False: 237]
  ------------------
 1109|      0|        return 1;
 1110|      0|    }
 1111|       |
 1112|    237|    VLA(uint8_t, plain, SIZEOF_VLA(temp_plain) - DATA_IN_RESPONSE_MIN_SIZE);
  ------------------
  |  |   62|    237|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|    237|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 1113|    237|    len = decrypt_data(temp_plain, nc_get_self_secret_key(onion_c->c),
 1114|    237|                       packet + 1, temp_plain + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|    237|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1115|    237|                       SIZEOF_VLA(temp_plain) - CRYPTO_PUBLIC_KEY_SIZE, plain);
  ------------------
  |  |   29|    237|#define SIZEOF_VLA sizeof
  ------------------
                                     SIZEOF_VLA(temp_plain) - CRYPTO_PUBLIC_KEY_SIZE, plain);
  ------------------
  |  |   40|    237|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1116|       |
 1117|    237|    if ((uint32_t)len != SIZEOF_VLA(plain)) {
  ------------------
  |  |   29|    237|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (1117:9): [True: 0, False: 237]
  ------------------
 1118|      0|        return 1;
 1119|      0|    }
 1120|       |
 1121|    237|    if (onion_c->onion_data_handlers[plain[0]].function == nullptr) {
  ------------------
  |  |   66|    237|#define nullptr NULL
  ------------------
  |  Branch (1121:9): [True: 23, False: 214]
  ------------------
 1122|     23|        return 1;
 1123|     23|    }
 1124|       |
 1125|    214|    return onion_c->onion_data_handlers[plain[0]].function(onion_c->onion_data_handlers[plain[0]].object, temp_plain, plain,
 1126|    214|            SIZEOF_VLA(plain), userdata);
  ------------------
  |  |   29|    214|#define SIZEOF_VLA sizeof
  ------------------
 1127|    237|}
onion_client.c:handle_dhtpk_announce:
 1134|     18|{
 1135|     18|    Onion_Client *onion_c = (Onion_Client *)object;
 1136|       |
 1137|     18|    if (length < DHTPK_DATA_MIN_LENGTH) {
  ------------------
  |  | 1129|     18|#define DHTPK_DATA_MIN_LENGTH (1 + sizeof(uint64_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   40|     18|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (1137:9): [True: 3, False: 15]
  ------------------
 1138|      3|        return 1;
 1139|      3|    }
 1140|       |
 1141|     15|    if (length > DHTPK_DATA_MAX_LENGTH) {
  ------------------
  |  | 1130|     15|#define DHTPK_DATA_MAX_LENGTH (DHTPK_DATA_MIN_LENGTH + sizeof(Node_format)*MAX_SENT_NODES)
  |  |  ------------------
  |  |  |  | 1129|     15|#define DHTPK_DATA_MIN_LENGTH (1 + sizeof(uint64_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     15|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define DHTPK_DATA_MAX_LENGTH (DHTPK_DATA_MIN_LENGTH + sizeof(Node_format)*MAX_SENT_NODES)
  |  |  ------------------
  |  |  |  |   54|     15|#define MAX_SENT_NODES 4
  |  |  ------------------
  ------------------
  |  Branch (1141:9): [True: 3, False: 12]
  ------------------
 1142|      3|        return 1;
 1143|      3|    }
 1144|       |
 1145|     12|    const int friend_num = onion_friend_num(onion_c, source_pubkey);
 1146|       |
 1147|     12|    if (friend_num == -1) {
  ------------------
  |  Branch (1147:9): [True: 11, False: 1]
  ------------------
 1148|     11|        return 1;
 1149|     11|    }
 1150|       |
 1151|      1|    uint64_t no_replay;
 1152|      1|    net_unpack_u64(data + 1, &no_replay);
 1153|       |
 1154|      1|    if (no_replay <= onion_c->friends_list[friend_num].last_noreplay) {
  ------------------
  |  Branch (1154:9): [True: 0, False: 1]
  ------------------
 1155|      0|        return 1;
 1156|      0|    }
 1157|       |
 1158|      1|    onion_c->friends_list[friend_num].last_noreplay = no_replay;
 1159|       |
 1160|      1|    if (onion_c->friends_list[friend_num].dht_pk_callback != nullptr) {
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  |  Branch (1160:9): [True: 1, False: 0]
  ------------------
 1161|      1|        onion_c->friends_list[friend_num].dht_pk_callback(onion_c->friends_list[friend_num].dht_pk_callback_object,
 1162|      1|                onion_c->friends_list[friend_num].dht_pk_callback_number, data + 1 + sizeof(uint64_t), userdata);
 1163|      1|    }
 1164|       |
 1165|      1|    onion_set_friend_dht_pubkey(onion_c, friend_num, data + 1 + sizeof(uint64_t));
 1166|       |
 1167|      1|    const uint16_t len_nodes = length - DHTPK_DATA_MIN_LENGTH;
  ------------------
  |  | 1129|      1|#define DHTPK_DATA_MIN_LENGTH (1 + sizeof(uint64_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 1168|       |
 1169|      1|    if (len_nodes != 0) {
  ------------------
  |  Branch (1169:9): [True: 1, False: 0]
  ------------------
 1170|      1|        Node_format nodes[MAX_SENT_NODES];
 1171|      1|        const int num_nodes = unpack_nodes(nodes, MAX_SENT_NODES, nullptr, data + 1 + sizeof(uint64_t) + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   54|      1|#define MAX_SENT_NODES 4
  ------------------
                      const int num_nodes = unpack_nodes(nodes, MAX_SENT_NODES, nullptr, data + 1 + sizeof(uint64_t) + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
                      const int num_nodes = unpack_nodes(nodes, MAX_SENT_NODES, nullptr, data + 1 + sizeof(uint64_t) + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      1|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1172|      1|                                           len_nodes, true);
 1173|       |
 1174|      1|        if (num_nodes <= 0) {
  ------------------
  |  Branch (1174:13): [True: 1, False: 0]
  ------------------
 1175|      1|            return 1;
 1176|      1|        }
 1177|       |
 1178|      0|        for (int i = 0; i < num_nodes; ++i) {
  ------------------
  |  Branch (1178:25): [True: 0, False: 0]
  ------------------
 1179|      0|            const Family family = nodes[i].ip_port.ip.family;
 1180|       |
 1181|      0|            if (net_family_is_ipv4(family) || net_family_is_ipv6(family)) {
  ------------------
  |  Branch (1181:17): [True: 0, False: 0]
  |  Branch (1181:47): [True: 0, False: 0]
  ------------------
 1182|      0|                dht_getnodes(onion_c->dht, &nodes[i].ip_port, nodes[i].public_key, onion_c->friends_list[friend_num].dht_public_key);
 1183|      0|            } else if (net_family_is_tcp_ipv4(family) || net_family_is_tcp_ipv6(family)) {
  ------------------
  |  Branch (1183:24): [True: 0, False: 0]
  |  Branch (1183:58): [True: 0, False: 0]
  ------------------
 1184|      0|                if (onion_c->friends_list[friend_num].tcp_relay_node_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1184:21): [True: 0, False: 0]
  ------------------
 1185|      0|                    void *obj = onion_c->friends_list[friend_num].tcp_relay_node_callback_object;
 1186|      0|                    const uint32_t number = onion_c->friends_list[friend_num].tcp_relay_node_callback_number;
 1187|      0|                    onion_c->friends_list[friend_num].tcp_relay_node_callback(obj, number, &nodes[i].ip_port, nodes[i].public_key);
 1188|      0|                }
 1189|      0|            }
 1190|      0|        }
 1191|      0|    }
 1192|       |
 1193|      0|    return 0;
 1194|      1|}
onion_client.c:handle_dht_dhtpk:
 1354|      6|{
 1355|      6|    Onion_Client *onion_c = (Onion_Client *)object;
 1356|       |
 1357|      6|    if (length < DHTPK_DATA_MIN_LENGTH + DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE) {
  ------------------
  |  | 1129|      6|#define DHTPK_DATA_MIN_LENGTH (1 + sizeof(uint64_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
                  if (length < DHTPK_DATA_MIN_LENGTH + DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE) {
  ------------------
  |  | 1087|      6|#define DATA_IN_RESPONSE_MIN_SIZE ONION_DATA_IN_RESPONSE_MIN_SIZE
  |  |  ------------------
  |  |  |  |  178|      6|#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      6|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (length < DHTPK_DATA_MIN_LENGTH + DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE) {
  ------------------
  |  |   66|      6|#define CRYPTO_NONCE_SIZE              24
  ------------------
  |  Branch (1357:9): [True: 1, False: 5]
  ------------------
 1358|      1|        return 1;
 1359|      1|    }
 1360|       |
 1361|      5|    if (length > DHTPK_DATA_MAX_LENGTH + DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE) {
  ------------------
  |  | 1130|      5|#define DHTPK_DATA_MAX_LENGTH (DHTPK_DATA_MIN_LENGTH + sizeof(Node_format)*MAX_SENT_NODES)
  |  |  ------------------
  |  |  |  | 1129|      5|#define DHTPK_DATA_MIN_LENGTH (1 + sizeof(uint64_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      5|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define DHTPK_DATA_MAX_LENGTH (DHTPK_DATA_MIN_LENGTH + sizeof(Node_format)*MAX_SENT_NODES)
  |  |  ------------------
  |  |  |  |   54|      5|#define MAX_SENT_NODES 4
  |  |  ------------------
  ------------------
                  if (length > DHTPK_DATA_MAX_LENGTH + DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE) {
  ------------------
  |  | 1087|      5|#define DATA_IN_RESPONSE_MIN_SIZE ONION_DATA_IN_RESPONSE_MIN_SIZE
  |  |  ------------------
  |  |  |  |  178|      5|#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      5|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      5|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (length > DHTPK_DATA_MAX_LENGTH + DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE) {
  ------------------
  |  |   66|      5|#define CRYPTO_NONCE_SIZE              24
  ------------------
  |  Branch (1361:9): [True: 1, False: 4]
  ------------------
 1362|      1|        return 1;
 1363|      1|    }
 1364|       |
 1365|      4|    uint8_t plain[DHTPK_DATA_MAX_LENGTH];
 1366|      4|    const int len = decrypt_data(packet, nc_get_self_secret_key(onion_c->c),
 1367|      4|                                 packet + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      4|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1368|      4|                                 packet + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   40|      4|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                               packet + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      4|#define CRYPTO_NONCE_SIZE              24
  ------------------
 1369|      4|                                 length - (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |   40|      4|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                               length - (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE), plain);
  ------------------
  |  |   66|      4|#define CRYPTO_NONCE_SIZE              24
  ------------------
 1370|       |
 1371|      4|    if (len != length - (DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE)) {
  ------------------
  |  | 1087|      4|#define DATA_IN_RESPONSE_MIN_SIZE ONION_DATA_IN_RESPONSE_MIN_SIZE
  |  |  ------------------
  |  |  |  |  178|      4|#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      4|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   61|      4|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (len != length - (DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE)) {
  ------------------
  |  |   66|      4|#define CRYPTO_NONCE_SIZE              24
  ------------------
  |  Branch (1371:9): [True: 0, False: 4]
  ------------------
 1372|      0|        return 1;
 1373|      0|    }
 1374|       |
 1375|      4|    if (!pk_equal(source_pubkey, plain + 1 + sizeof(uint64_t))) {
  ------------------
  |  Branch (1375:9): [True: 3, False: 1]
  ------------------
 1376|      3|        return 1;
 1377|      3|    }
 1378|       |
 1379|      1|    return handle_dhtpk_announce(onion_c, packet, plain, len, userdata);
 1380|      4|}
onion_client.c:handle_tcp_onion:
 1198|      1|{
 1199|      1|    if (length == 0) {
  ------------------
  |  Branch (1199:9): [True: 0, False: 1]
  ------------------
 1200|      0|        return 1;
 1201|      0|    }
 1202|       |
 1203|      1|    IP_Port ip_port = {{{0}}};
 1204|      1|    ip_port.ip.family = net_family_tcp_server();
 1205|       |
 1206|      1|    if (data[0] == NET_PACKET_ANNOUNCE_RESPONSE) {
  ------------------
  |  Branch (1206:9): [True: 0, False: 1]
  ------------------
 1207|      0|        return handle_announce_response(object, &ip_port, data, length, userdata);
 1208|      0|    }
 1209|       |
 1210|      1|    if (data[0] == NET_PACKET_ANNOUNCE_RESPONSE_OLD) {
  ------------------
  |  Branch (1210:9): [True: 0, False: 1]
  ------------------
 1211|      0|        return handle_announce_response_old(object, &ip_port, data, length, userdata);
 1212|      0|    }
 1213|       |
 1214|      1|    if (data[0] == NET_PACKET_ONION_DATA_RESPONSE) {
  ------------------
  |  Branch (1214:9): [True: 0, False: 1]
  ------------------
 1215|      0|        return handle_data_response(object, &ip_port, data, length, userdata);
 1216|      0|    }
 1217|       |
 1218|      1|    return 1;
 1219|      1|}

ping_send_request:
   47|    121|{
   48|    121|    uint8_t   pk[DHT_PING_SIZE];
   49|    121|    int       rc;
   50|    121|    uint64_t  ping_id;
   51|       |
   52|    121|    if (pk_equal(public_key, dht_get_self_public_key(ping->dht))) {
  ------------------
  |  Branch (52:9): [True: 0, False: 121]
  ------------------
   53|      0|        return;
   54|      0|    }
   55|       |
   56|       |
   57|       |    // generate key to encrypt ping_id with recipient privkey
   58|    121|    const uint8_t *shared_key = dht_get_shared_key_sent(ping->dht, public_key);
   59|       |    // Generate random ping_id.
   60|    121|    uint8_t data[PING_DATA_SIZE];
   61|    121|    pk_copy(data, public_key);
   62|    121|    memcpy(data + CRYPTO_PUBLIC_KEY_SIZE, ipp, sizeof(IP_Port));
  ------------------
  |  |   40|    121|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   63|    121|    ping_id = ping_array_add(ping->ping_array, ping->mono_time, ping->rng, data, sizeof(data));
   64|       |
   65|    121|    if (ping_id == 0) {
  ------------------
  |  Branch (65:9): [True: 36, False: 85]
  ------------------
   66|     36|        return;
   67|     36|    }
   68|       |
   69|     85|    uint8_t ping_plain[PING_PLAIN_SIZE];
   70|     85|    ping_plain[0] = NET_PACKET_PING_REQUEST;
   71|     85|    memcpy(ping_plain + 1, &ping_id, sizeof(ping_id));
   72|       |
   73|     85|    pk[0] = NET_PACKET_PING_REQUEST;
   74|     85|    pk_copy(pk + 1, dht_get_self_public_key(ping->dht));     // Our pubkey
   75|     85|    random_nonce(ping->rng, pk + 1 + CRYPTO_PUBLIC_KEY_SIZE); // Generate new nonce
  ------------------
  |  |   40|     85|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   76|       |
   77|       |
   78|     85|    rc = encrypt_data_symmetric(shared_key,
   79|     85|                                pk + 1 + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|     85|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   80|     85|                                ping_plain, sizeof(ping_plain),
   81|     85|                                pk + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   40|     85|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                              pk + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|     85|#define CRYPTO_NONCE_SIZE              24
  ------------------
   82|       |
   83|     85|    if (rc != PING_PLAIN_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   42|     85|#define PING_PLAIN_SIZE (1 + sizeof(uint64_t))
  ------------------
                  if (rc != PING_PLAIN_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   61|     85|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (83:9): [True: 0, False: 85]
  ------------------
   84|      0|        return;
   85|      0|    }
   86|       |
   87|       |    // We never check this return value and failures in sendpacket are already logged
   88|     85|    sendpacket(dht_get_net(ping->dht), ipp, pk, sizeof(pk));
   89|     85|}
ping_add:
  265|    295|{
  266|    295|    if (!ip_isset(&ip_port->ip)) {
  ------------------
  |  Branch (266:9): [True: 0, False: 295]
  ------------------
  267|      0|        return -1;
  268|      0|    }
  269|       |
  270|    295|    if (!node_addable_to_close_list(ping->dht, public_key, ip_port)) {
  ------------------
  |  Branch (270:9): [True: 0, False: 295]
  ------------------
  271|      0|        return -1;
  272|      0|    }
  273|       |
  274|    295|    if (in_list(dht_get_close_clientlist(ping->dht), LCLIENT_LIST, ping->mono_time, public_key, ip_port)) {
  ------------------
  |  |   49|    295|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   46|    295|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   45|    295|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|    295|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (274:9): [True: 0, False: 295]
  ------------------
  275|      0|        return -1;
  276|      0|    }
  277|       |
  278|    295|    IP_Port temp;
  279|       |
  280|    295|    if (dht_getfriendip(ping->dht, public_key, &temp) == 0) {
  ------------------
  |  Branch (280:9): [True: 2, False: 293]
  ------------------
  281|      2|        ping_send_request(ping, ip_port, public_key);
  282|      2|        return -1;
  283|      2|    }
  284|       |
  285|  1.11k|    for (unsigned int i = 0; i < MAX_TO_PING; ++i) {
  ------------------
  |  |   25|  1.11k|#define MAX_TO_PING 32
  ------------------
  |  Branch (285:30): [True: 1.11k, False: 0]
  ------------------
  286|  1.11k|        if (!ip_isset(&ping->to_ping[i].ip_port.ip)) {
  ------------------
  |  Branch (286:13): [True: 221, False: 891]
  ------------------
  287|    221|            memcpy(ping->to_ping[i].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    221|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  288|    221|            ipport_copy(&ping->to_ping[i].ip_port, ip_port);
  289|    221|            return 0;
  290|    221|        }
  291|       |
  292|    891|        if (pk_equal(ping->to_ping[i].public_key, public_key)) {
  ------------------
  |  Branch (292:13): [True: 72, False: 819]
  ------------------
  293|     72|            return -1;
  294|     72|        }
  295|    891|    }
  296|       |
  297|      0|    if (add_to_list(ping->to_ping, MAX_TO_PING, public_key, ip_port, dht_get_self_public_key(ping->dht))) {
  ------------------
  |  |   25|      0|#define MAX_TO_PING 32
  ------------------
  |  Branch (297:9): [True: 0, False: 0]
  ------------------
  298|      0|        return 0;
  299|      0|    }
  300|       |
  301|      0|    return -1;
  302|      0|}
ping_iterate:
  309|  2.26k|{
  310|  2.26k|    if (!mono_time_is_timeout(ping->mono_time, ping->last_to_ping, TIME_TO_PING)) {
  ------------------
  |  |   28|  2.26k|#define TIME_TO_PING 2
  ------------------
  |  Branch (310:9): [True: 27, False: 2.24k]
  ------------------
  311|     27|        return;
  312|     27|    }
  313|       |
  314|  2.24k|    if (!ip_isset(&ping->to_ping[0].ip_port.ip)) {
  ------------------
  |  Branch (314:9): [True: 2.19k, False: 49]
  ------------------
  315|  2.19k|        return;
  316|  2.19k|    }
  317|       |
  318|     49|    unsigned int i;
  319|       |
  320|    168|    for (i = 0; i < MAX_TO_PING; ++i) {
  ------------------
  |  |   25|    168|#define MAX_TO_PING 32
  ------------------
  |  Branch (320:17): [True: 168, False: 0]
  ------------------
  321|    168|        if (!ip_isset(&ping->to_ping[i].ip_port.ip)) {
  ------------------
  |  Branch (321:13): [True: 49, False: 119]
  ------------------
  322|     49|            break;
  323|     49|        }
  324|       |
  325|    119|        if (!node_addable_to_close_list(ping->dht, ping->to_ping[i].public_key, &ping->to_ping[i].ip_port)) {
  ------------------
  |  Branch (325:13): [True: 0, False: 119]
  ------------------
  326|      0|            continue;
  327|      0|        }
  328|       |
  329|    119|        ping_send_request(ping, &ping->to_ping[i].ip_port, ping->to_ping[i].public_key);
  330|    119|        ip_reset(&ping->to_ping[i].ip_port.ip);
  331|    119|    }
  332|       |
  333|     49|    if (i != 0) {
  ------------------
  |  Branch (333:9): [True: 49, False: 0]
  ------------------
  334|     49|        ping->last_to_ping = mono_time_get(ping->mono_time);
  335|     49|    }
  336|     49|}
ping_new:
  340|    961|{
  341|    961|    Ping *ping = (Ping *)mem_alloc(mem, sizeof(Ping));
  342|       |
  343|    961|    if (ping == nullptr) {
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
  |  Branch (343:9): [True: 1, False: 960]
  ------------------
  344|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  345|      1|    }
  346|       |
  347|    960|    ping->ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   22|    960|#define PING_NUM_MAX 512
  ------------------
                  ping->ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   57|    960|#define PING_TIMEOUT 5
  ------------------
  348|       |
  349|    960|    if (ping->ping_array == nullptr) {
  ------------------
  |  |   66|    960|#define nullptr NULL
  ------------------
  |  Branch (349:9): [True: 1, False: 959]
  ------------------
  350|      1|        mem_delete(mem, ping);
  351|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  352|      1|    }
  353|       |
  354|    959|    ping->mono_time = mono_time;
  355|    959|    ping->rng = rng;
  356|    959|    ping->dht = dht;
  357|    959|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, &handle_ping_request, dht);
  358|    959|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, &handle_ping_response, dht);
  359|       |
  360|    959|    return ping;
  361|    960|}
ping_kill:
  364|    961|{
  365|    961|    if (ping == nullptr) {
  ------------------
  |  |   66|    961|#define nullptr NULL
  ------------------
  |  Branch (365:9): [True: 2, False: 959]
  ------------------
  366|      2|        return;
  367|      2|    }
  368|       |
  369|    959|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    959|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|    959|#define nullptr NULL
  ------------------
  370|    959|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|    959|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|    959|#define nullptr NULL
  ------------------
  371|    959|    ping_array_kill(ping->ping_array);
  372|       |
  373|    959|    mem_delete(mem, ping);
  374|    959|}
ping.c:in_list:
  233|    295|{
  234|   302k|    for (unsigned int i = 0; i < length; ++i) {
  ------------------
  |  Branch (234:30): [True: 302k, False: 295]
  ------------------
  235|   302k|        if (pk_equal(list[i].public_key, public_key)) {
  ------------------
  |  Branch (235:13): [True: 2.04k, False: 300k]
  ------------------
  236|  2.04k|            const IPPTsPng *ipptp;
  237|       |
  238|  2.04k|            if (net_family_is_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (238:17): [True: 2.04k, False: 0]
  ------------------
  239|  2.04k|                ipptp = &list[i].assoc4;
  240|  2.04k|            } else {
  241|      0|                ipptp = &list[i].assoc6;
  242|      0|            }
  243|       |
  244|  2.04k|            if (!mono_time_is_timeout(mono_time, ipptp->timestamp, BAD_NODE_TIMEOUT)
  ------------------
  |  |   68|  2.04k|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   63|  2.04k|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   66|  2.04k|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   63|  2.04k|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   67|  2.04k|#define PING_ROUNDTRIP 2
  |  |  ------------------
  ------------------
  |  Branch (244:17): [True: 0, False: 2.04k]
  ------------------
  245|  2.04k|                    && ipport_equal(&ipptp->ip_port, ip_port)) {
  ------------------
  |  Branch (245:24): [True: 0, False: 0]
  ------------------
  246|      0|                return true;
  247|      0|            }
  248|  2.04k|        }
  249|   302k|    }
  250|       |
  251|    295|    return false;
  252|    295|}
ping.c:handle_ping_request:
  125|    420|{
  126|    420|    DHT *dht = (DHT *)object;
  127|       |
  128|    420|    if (length != DHT_PING_SIZE) {
  ------------------
  |  |   43|    420|#define DHT_PING_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + PING_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   40|    420|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define DHT_PING_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + PING_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|    420|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define DHT_PING_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + PING_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   42|    420|#define PING_PLAIN_SIZE (1 + sizeof(uint64_t))
  |  |  ------------------
  |  |               #define DHT_PING_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + PING_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|    420|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  |  Branch (128:9): [True: 75, False: 345]
  ------------------
  129|     75|        return 1;
  130|     75|    }
  131|       |
  132|    345|    Ping *ping = dht_get_ping(dht);
  133|       |
  134|    345|    if (pk_equal(packet + 1, dht_get_self_public_key(ping->dht))) {
  ------------------
  |  Branch (134:9): [True: 3, False: 342]
  ------------------
  135|      3|        return 1;
  136|      3|    }
  137|       |
  138|    342|    const uint8_t *shared_key = dht_get_shared_key_recv(dht, packet + 1);
  139|       |
  140|    342|    uint8_t ping_plain[PING_PLAIN_SIZE];
  141|       |
  142|       |    // Decrypt ping_id
  143|    342|    const int rc = decrypt_data_symmetric(shared_key,
  144|    342|                                          packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|    342|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  145|    342|                                          packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   40|    342|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                        packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|    342|#define CRYPTO_NONCE_SIZE              24
  ------------------
  146|    342|                                          PING_PLAIN_SIZE + CRYPTO_MAC_SIZE,
  ------------------
  |  |   42|    342|#define PING_PLAIN_SIZE (1 + sizeof(uint64_t))
  ------------------
                                                        PING_PLAIN_SIZE + CRYPTO_MAC_SIZE,
  ------------------
  |  |   61|    342|#define CRYPTO_MAC_SIZE                16
  ------------------
  147|    342|                                          ping_plain);
  148|       |
  149|    342|    if (rc != sizeof(ping_plain)) {
  ------------------
  |  Branch (149:9): [True: 0, False: 342]
  ------------------
  150|      0|        return 1;
  151|      0|    }
  152|       |
  153|    342|    if (ping_plain[0] != NET_PACKET_PING_REQUEST) {
  ------------------
  |  Branch (153:9): [True: 48, False: 294]
  ------------------
  154|     48|        return 1;
  155|     48|    }
  156|       |
  157|    294|    uint64_t ping_id;
  158|    294|    memcpy(&ping_id, ping_plain + 1, sizeof(ping_id));
  159|       |    // Send response
  160|    294|    ping_send_response(ping, source, packet + 1, ping_id, shared_key);
  161|    294|    ping_add(ping, packet + 1, source);
  162|       |
  163|    294|    return 0;
  164|    342|}
ping.c:ping_send_response:
   94|    294|{
   95|    294|    uint8_t pk[DHT_PING_SIZE];
   96|       |
   97|    294|    if (pk_equal(public_key, dht_get_self_public_key(ping->dht))) {
  ------------------
  |  Branch (97:9): [True: 0, False: 294]
  ------------------
   98|      0|        return 1;
   99|      0|    }
  100|       |
  101|    294|    uint8_t ping_plain[PING_PLAIN_SIZE];
  102|    294|    ping_plain[0] = NET_PACKET_PING_RESPONSE;
  103|    294|    memcpy(ping_plain + 1, &ping_id, sizeof(ping_id));
  104|       |
  105|    294|    pk[0] = NET_PACKET_PING_RESPONSE;
  106|    294|    pk_copy(pk + 1, dht_get_self_public_key(ping->dht));     // Our pubkey
  107|    294|    random_nonce(ping->rng, pk + 1 + CRYPTO_PUBLIC_KEY_SIZE); // Generate new nonce
  ------------------
  |  |   40|    294|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  108|       |
  109|       |    // Encrypt ping_id using recipient privkey
  110|    294|    const int rc = encrypt_data_symmetric(shared_encryption_key,
  111|    294|                                          pk + 1 + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|    294|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  112|    294|                                          ping_plain, sizeof(ping_plain),
  113|    294|                                          pk + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   40|    294|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                        pk + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   66|    294|#define CRYPTO_NONCE_SIZE              24
  ------------------
  114|       |
  115|    294|    if (rc != PING_PLAIN_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   42|    294|#define PING_PLAIN_SIZE (1 + sizeof(uint64_t))
  ------------------
                  if (rc != PING_PLAIN_SIZE + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   61|    294|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (115:9): [True: 0, False: 294]
  ------------------
  116|      0|        return 1;
  117|      0|    }
  118|       |
  119|    294|    return sendpacket(dht_get_net(ping->dht), ipp, pk, sizeof(pk));
  120|    294|}
ping.c:handle_ping_response:
  169|     13|{
  170|     13|    DHT      *dht = (DHT *)object;
  171|     13|    int       rc;
  172|       |
  173|     13|    if (length != DHT_PING_SIZE) {
  ------------------
  |  |   43|     13|#define DHT_PING_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + PING_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   40|     13|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  |  |               #define DHT_PING_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + PING_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   66|     13|#define CRYPTO_NONCE_SIZE              24
  |  |  ------------------
  |  |               #define DHT_PING_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + PING_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   42|     13|#define PING_PLAIN_SIZE (1 + sizeof(uint64_t))
  |  |  ------------------
  |  |               #define DHT_PING_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + PING_PLAIN_SIZE + CRYPTO_MAC_SIZE)
  |  |  ------------------
  |  |  |  |   61|     13|#define CRYPTO_MAC_SIZE                16
  |  |  ------------------
  ------------------
  |  Branch (173:9): [True: 10, False: 3]
  ------------------
  174|     10|        return 1;
  175|     10|    }
  176|       |
  177|      3|    Ping *ping = dht_get_ping(dht);
  178|       |
  179|      3|    if (pk_equal(packet + 1, dht_get_self_public_key(ping->dht))) {
  ------------------
  |  Branch (179:9): [True: 1, False: 2]
  ------------------
  180|      1|        return 1;
  181|      1|    }
  182|       |
  183|       |    // generate key to encrypt ping_id with recipient privkey
  184|      2|    const uint8_t *shared_key = dht_get_shared_key_sent(ping->dht, packet + 1);
  185|       |
  186|      2|    uint8_t ping_plain[PING_PLAIN_SIZE];
  187|       |    // Decrypt ping_id
  188|      2|    rc = decrypt_data_symmetric(shared_key,
  189|      2|                                packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
  ------------------
  |  |   40|      2|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  190|      2|                                packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   40|      2|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                              packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
  ------------------
  |  |   66|      2|#define CRYPTO_NONCE_SIZE              24
  ------------------
  191|      2|                                PING_PLAIN_SIZE + CRYPTO_MAC_SIZE,
  ------------------
  |  |   42|      2|#define PING_PLAIN_SIZE (1 + sizeof(uint64_t))
  ------------------
                                              PING_PLAIN_SIZE + CRYPTO_MAC_SIZE,
  ------------------
  |  |   61|      2|#define CRYPTO_MAC_SIZE                16
  ------------------
  192|      2|                                ping_plain);
  193|       |
  194|      2|    if (rc != sizeof(ping_plain)) {
  ------------------
  |  Branch (194:9): [True: 0, False: 2]
  ------------------
  195|      0|        return 1;
  196|      0|    }
  197|       |
  198|      2|    if (ping_plain[0] != NET_PACKET_PING_RESPONSE) {
  ------------------
  |  Branch (198:9): [True: 1, False: 1]
  ------------------
  199|      1|        return 1;
  200|      1|    }
  201|       |
  202|      1|    uint64_t   ping_id;
  203|      1|    memcpy(&ping_id, ping_plain + 1, sizeof(ping_id));
  204|      1|    uint8_t data[PING_DATA_SIZE];
  205|       |
  206|      1|    if (ping_array_check(ping->ping_array, ping->mono_time, data, sizeof(data), ping_id) != sizeof(data)) {
  ------------------
  |  Branch (206:9): [True: 1, False: 0]
  ------------------
  207|      1|        return 1;
  208|      1|    }
  209|       |
  210|      0|    if (!pk_equal(packet + 1, data)) {
  ------------------
  |  Branch (210:9): [True: 0, False: 0]
  ------------------
  211|      0|        return 1;
  212|      0|    }
  213|       |
  214|      0|    IP_Port ipp;
  215|      0|    memcpy(&ipp, data + CRYPTO_PUBLIC_KEY_SIZE, sizeof(IP_Port));
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  216|       |
  217|      0|    if (!ipport_equal(&ipp, source)) {
  ------------------
  |  Branch (217:9): [True: 0, False: 0]
  ------------------
  218|      0|        return 1;
  219|      0|    }
  220|       |
  221|      0|    addto_lists(dht, source, packet + 1);
  222|      0|    return 0;
  223|      0|}

ping_array_new:
   37|  2.85k|{
   38|  2.85k|    if (size == 0 || timeout == 0) {
  ------------------
  |  Branch (38:9): [True: 0, False: 2.85k]
  |  Branch (38:22): [True: 0, False: 2.85k]
  ------------------
   39|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   40|      0|    }
   41|       |
   42|  2.85k|    if ((size & (size - 1)) != 0) {
  ------------------
  |  Branch (42:9): [True: 0, False: 2.85k]
  ------------------
   43|       |        // Not a power of 2.
   44|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   45|      0|    }
   46|       |
   47|  2.85k|    Ping_Array *const empty_array = (Ping_Array *)mem_alloc(mem, sizeof(Ping_Array));
   48|       |
   49|  2.85k|    if (empty_array == nullptr) {
  ------------------
  |  |   66|  2.85k|#define nullptr NULL
  ------------------
  |  Branch (49:9): [True: 2, False: 2.85k]
  ------------------
   50|      2|        return nullptr;
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
   51|      2|    }
   52|       |
   53|  2.85k|    empty_array->mem = mem;
   54|  2.85k|    empty_array->entries = (Ping_Array_Entry *)mem_valloc(mem, size, sizeof(Ping_Array_Entry));
   55|       |
   56|  2.85k|    if (empty_array->entries == nullptr) {
  ------------------
  |  |   66|  2.85k|#define nullptr NULL
  ------------------
  |  Branch (56:9): [True: 1, False: 2.85k]
  ------------------
   57|      1|        mem_delete(mem, empty_array);
   58|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
   59|      1|    }
   60|       |
   61|  2.85k|    empty_array->last_deleted = 0;
   62|  2.85k|    empty_array->last_added = 0;
   63|  2.85k|    empty_array->total_size = size;
   64|  2.85k|    empty_array->timeout = timeout;
   65|  2.85k|    return empty_array;
   66|  2.85k|}
ping_array_kill:
   77|  2.86k|{
   78|  2.86k|    if (array == nullptr) {
  ------------------
  |  |   66|  2.86k|#define nullptr NULL
  ------------------
  |  Branch (78:9): [True: 7, False: 2.85k]
  ------------------
   79|      7|        return;
   80|      7|    }
   81|       |
   82|  3.54k|    while (array->last_deleted != array->last_added) {
  ------------------
  |  Branch (82:12): [True: 692, False: 2.85k]
  ------------------
   83|    692|        const uint32_t index = array->last_deleted % array->total_size;
   84|    692|        clear_entry(array, index);
   85|    692|        ++array->last_deleted;
   86|    692|    }
   87|       |
   88|  2.85k|    mem_delete(array->mem, array->entries);
   89|  2.85k|    mem_delete(array->mem, array);
   90|  2.85k|}
ping_array_add:
  110|    957|{
  111|    957|    ping_array_clear_timedout(array, mono_time);
  112|    957|    const uint32_t index = array->last_added % array->total_size;
  113|       |
  114|    957|    if (array->entries[index].data != nullptr) {
  ------------------
  |  |   66|    957|#define nullptr NULL
  ------------------
  |  Branch (114:9): [True: 0, False: 957]
  ------------------
  115|      0|        array->last_deleted = array->last_added - array->total_size;
  116|      0|        clear_entry(array, index);
  117|      0|    }
  118|       |
  119|    957|    array->entries[index].data = (uint8_t *)mem_balloc(array->mem, length);
  120|       |
  121|    957|    if (array->entries[index].data == nullptr) {
  ------------------
  |  |   66|    957|#define nullptr NULL
  ------------------
  |  Branch (121:9): [True: 187, False: 770]
  ------------------
  122|    187|        return 0;
  123|    187|    }
  124|       |
  125|    770|    memcpy(array->entries[index].data, data, length);
  126|    770|    array->entries[index].length = length;
  127|    770|    array->entries[index].ping_time = mono_time_get(mono_time);
  128|    770|    ++array->last_added;
  129|    770|    uint64_t ping_id = random_u64(rng);
  130|    770|    ping_id /= array->total_size;
  131|    770|    ping_id *= array->total_size;
  132|    770|    ping_id += index;
  133|       |
  134|    770|    if (ping_id == 0) {
  ------------------
  |  Branch (134:9): [True: 35, False: 735]
  ------------------
  135|     35|        ping_id += array->total_size;
  136|     35|    }
  137|       |
  138|    770|    array->entries[index].ping_id = ping_id;
  139|    770|    return ping_id;
  140|    957|}
ping_array_check:
  144|     40|{
  145|     40|    if (ping_id == 0) {
  ------------------
  |  Branch (145:9): [True: 4, False: 36]
  ------------------
  146|      4|        return -1;
  147|      4|    }
  148|       |
  149|     36|    const uint32_t index = ping_id % array->total_size;
  150|       |
  151|     36|    if (array->entries[index].ping_id != ping_id) {
  ------------------
  |  Branch (151:9): [True: 31, False: 5]
  ------------------
  152|     31|        return -1;
  153|     31|    }
  154|       |
  155|      5|    if (mono_time_is_timeout(mono_time, array->entries[index].ping_time, array->timeout)) {
  ------------------
  |  Branch (155:9): [True: 0, False: 5]
  ------------------
  156|      0|        return -1;
  157|      0|    }
  158|       |
  159|      5|    if (array->entries[index].length > length) {
  ------------------
  |  Branch (159:9): [True: 0, False: 5]
  ------------------
  160|      0|        return -1;
  161|      0|    }
  162|       |
  163|       |    // TODO(iphydf): This can't happen? If it indeed can't, turn it into an assert.
  164|      5|    if (array->entries[index].data == nullptr) {
  ------------------
  |  |   66|      5|#define nullptr NULL
  ------------------
  |  Branch (164:9): [True: 0, False: 5]
  ------------------
  165|      0|        return -1;
  166|      0|    }
  167|       |
  168|      5|    memcpy(data, array->entries[index].data, array->entries[index].length);
  169|      5|    const uint32_t len = array->entries[index].length;
  170|      5|    clear_entry(array, index);
  171|      5|    return len;
  172|      5|}
ping_array.c:clear_entry:
   70|    775|{
   71|    775|    const Ping_Array_Entry empty = {nullptr};
  ------------------
  |  |   66|    775|#define nullptr NULL
  ------------------
   72|    775|    mem_delete(array->mem, array->entries[index].data);
   73|    775|    array->entries[index] = empty;
   74|    775|}
ping_array.c:ping_array_clear_timedout:
   95|    957|{
   96|  1.03k|    while (array->last_deleted != array->last_added) {
  ------------------
  |  Branch (96:12): [True: 644, False: 391]
  ------------------
   97|    644|        const uint32_t index = array->last_deleted % array->total_size;
   98|       |
   99|    644|        if (!mono_time_is_timeout(mono_time, array->entries[index].ping_time, array->timeout)) {
  ------------------
  |  Branch (99:13): [True: 566, False: 78]
  ------------------
  100|    566|            break;
  101|    566|        }
  102|       |
  103|     78|        clear_entry(array, index);
  104|     78|        ++array->last_deleted;
  105|     78|    }
  106|    957|}

shared_key_cache_new:
   47|  6.63k|{
   48|  6.63k|    if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   66|  13.2k|#define nullptr NULL
  ------------------
                  if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   66|  13.2k|#define nullptr NULL
  ------------------
  |  Branch (48:9): [True: 0, False: 6.63k]
  |  Branch (48:33): [True: 0, False: 6.63k]
  |  Branch (48:63): [True: 0, False: 6.63k]
  |  Branch (48:79): [True: 0, False: 6.63k]
  ------------------
   49|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   50|      0|    }
   51|       |
   52|       |    // Time must not be zero, since we use that as special value for empty slots
   53|  6.63k|    if (mono_time_get(mono_time) == 0) {
  ------------------
  |  Branch (53:9): [True: 0, False: 6.63k]
  ------------------
   54|       |        // Fail loudly in debug environments
   55|      0|        assert(false);
   56|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   57|      0|    }
   58|       |
   59|  6.63k|    Shared_Key_Cache *res = (Shared_Key_Cache *)mem_alloc(mem, sizeof(Shared_Key_Cache));
   60|  6.63k|    if (res == nullptr) {
  ------------------
  |  |   66|  6.63k|#define nullptr NULL
  ------------------
  |  Branch (60:9): [True: 16, False: 6.61k]
  ------------------
   61|     16|        return nullptr;
  ------------------
  |  |   66|     16|#define nullptr NULL
  ------------------
   62|     16|    }
   63|       |
   64|  6.61k|    res->self_secret_key = self_secret_key;
   65|  6.61k|    res->mono_time = mono_time;
   66|  6.61k|    res->mem = mem;
   67|  6.61k|    res->keys_per_slot = keys_per_slot;
   68|       |    // We take one byte from the public key for each bucket and store keys_per_slot elements there
   69|  6.61k|    const size_t cache_size = 256 * keys_per_slot;
   70|  6.61k|    res->keys = (Shared_Key *)mem_valloc(mem, cache_size, sizeof(Shared_Key));
   71|       |
   72|  6.61k|    if (res->keys == nullptr) {
  ------------------
  |  |   66|  6.61k|#define nullptr NULL
  ------------------
  |  Branch (72:9): [True: 11, False: 6.60k]
  ------------------
   73|     11|        mem_delete(mem, res);
   74|     11|        return nullptr;
  ------------------
  |  |   66|     11|#define nullptr NULL
  ------------------
   75|     11|    }
   76|       |
   77|  6.60k|    crypto_memlock(res->keys, cache_size * sizeof(Shared_Key));
   78|       |
   79|  6.60k|    return res;
   80|  6.61k|}
shared_key_cache_free:
   83|  6.63k|{
   84|  6.63k|    if (cache == nullptr) {
  ------------------
  |  |   66|  6.63k|#define nullptr NULL
  ------------------
  |  Branch (84:9): [True: 26, False: 6.60k]
  ------------------
   85|     26|        return;
   86|     26|    }
   87|       |
   88|  6.60k|    const size_t cache_size = 256 * cache->keys_per_slot;
   89|       |    // Don't leave key material in memory
   90|  6.60k|    crypto_memzero(cache->keys, cache_size * sizeof (Shared_Key));
   91|  6.60k|    crypto_memunlock(cache->keys, cache_size * sizeof (Shared_Key));
   92|  6.60k|    mem_delete(cache->mem, cache->keys);
   93|  6.60k|    mem_delete(cache->mem, cache);
   94|  6.60k|}
shared_key_cache_lookup:
   98|  1.31k|{
   99|       |    // caching the time is not necessary, but calls to mono_time_get(...) are not free
  100|  1.31k|    const uint64_t cur_time = mono_time_get(cache->mono_time);
  101|       |    // We can't use the first and last bytes because they are masked in curve25519. Selected 8 for good alignment.
  102|  1.31k|    const uint8_t bucket_idx = public_key[8];
  103|  1.31k|    Shared_Key* bucket_start = &cache->keys[bucket_idx*cache->keys_per_slot];
  104|       |
  105|  1.31k|    const uint8_t* found = nullptr;
  ------------------
  |  |   66|  1.31k|#define nullptr NULL
  ------------------
  106|       |
  107|       |    // Perform lookup
  108|  5.90k|    for(size_t i = 0; i < cache->keys_per_slot; ++i) {
  ------------------
  |  Branch (108:23): [True: 4.82k, False: 1.08k]
  ------------------
  109|  4.82k|        if (shared_key_is_empty(&bucket_start[i])) {
  ------------------
  |  Branch (109:13): [True: 3.02k, False: 1.79k]
  ------------------
  110|  3.02k|            continue;
  111|  3.02k|        }
  112|       |
  113|  1.79k|        if (pk_equal(public_key, bucket_start[i].public_key)) {
  ------------------
  |  Branch (113:13): [True: 230, False: 1.56k]
  ------------------
  114|    230|            found = bucket_start[i].shared_key;
  115|    230|            bucket_start[i].time_last_requested = cur_time;
  116|    230|            break;
  117|    230|        }
  118|  1.79k|    }
  119|       |
  120|       |    // Perform housekeeping for this bucket
  121|  6.55k|    for (size_t i = 0; i < cache->keys_per_slot; ++i) {
  ------------------
  |  Branch (121:24): [True: 5.24k, False: 1.31k]
  ------------------
  122|  5.24k|        if (shared_key_is_empty(&bucket_start[i])) {
  ------------------
  |  Branch (122:13): [True: 3.31k, False: 1.92k]
  ------------------
  123|  3.31k|            continue;
  124|  3.31k|        }
  125|       |
  126|  1.92k|        const bool timed_out = (bucket_start[i].time_last_requested + cache->timeout) < cur_time;
  127|  1.92k|        if (timed_out) {
  ------------------
  |  Branch (127:13): [True: 108, False: 1.81k]
  ------------------
  128|    108|            shared_key_set_empty(&bucket_start[i]);
  129|    108|        }
  130|  1.92k|    }
  131|       |
  132|  1.31k|    if (found == nullptr) {
  ------------------
  |  |   66|  1.31k|#define nullptr NULL
  ------------------
  |  Branch (132:9): [True: 1.08k, False: 230]
  ------------------
  133|       |        // Insert into cache
  134|       |
  135|  1.08k|        uint64_t oldest_timestamp = UINT64_MAX;
  136|  1.08k|        size_t oldest_index = 0;
  137|       |
  138|       |        /*
  139|       |         *  Find least recently used entry, unused entries are prioritised,
  140|       |         *  because their time_last_requested field is zeroed.
  141|       |         */
  142|  5.40k|        for (size_t i = 0; i < cache->keys_per_slot; ++i) {
  ------------------
  |  Branch (142:28): [True: 4.32k, False: 1.08k]
  ------------------
  143|  4.32k|            if (bucket_start[i].time_last_requested < oldest_timestamp) {
  ------------------
  |  Branch (143:17): [True: 1.35k, False: 2.97k]
  ------------------
  144|  1.35k|                oldest_timestamp = bucket_start[i].time_last_requested;
  145|  1.35k|                oldest_index = i;
  146|  1.35k|            }
  147|  4.32k|        }
  148|       |
  149|       |        // Compute the shared key for the cache
  150|  1.08k|        if (encrypt_precompute(public_key, cache->self_secret_key, bucket_start[oldest_index].shared_key) != 0) {
  ------------------
  |  Branch (150:13): [True: 0, False: 1.08k]
  ------------------
  151|       |            // Don't put anything in the cache on error
  152|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  153|      0|        }
  154|       |
  155|       |        // update cache entry
  156|  1.08k|        memcpy(bucket_start[oldest_index].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|  1.08k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  157|  1.08k|        bucket_start[oldest_index].time_last_requested = cur_time;
  158|  1.08k|        found = bucket_start[oldest_index].shared_key;
  159|  1.08k|    }
  160|       |
  161|  1.31k|    return found;
  162|  1.31k|}
shared_key_cache.c:shared_key_is_empty:
   31|  10.1k|static bool shared_key_is_empty(const Shared_Key *k) {
   32|  10.1k|    assert(k != nullptr);
   33|       |    /*
   34|       |     * Since time can never be 0, we use that to determine if a key slot is empty.
   35|       |     * Additionally this allows us to use crypto_memzero and leave the slot in a valid state.
   36|       |     */
   37|      0|    return k->time_last_requested == 0;
   38|  10.1k|}
shared_key_cache.c:shared_key_set_empty:
   41|    108|static void shared_key_set_empty(Shared_Key *k) {
   42|    108|    crypto_memzero(k, sizeof (Shared_Key));
   43|    108|    assert(shared_key_is_empty(k));
   44|    108|}

generate_timed_auth:
   24|     57|{
   25|     57|    VLA(uint8_t, to_hash, sizeof(uint64_t) + length);
  ------------------
  |  |   62|     57|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     57|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
   26|     57|    create_timed_auth_to_hash(mono_time, timeout, false, data, length, to_hash);
   27|     57|    crypto_hmac(timed_auth, key, to_hash, SIZEOF_VLA(to_hash));
  ------------------
  |  |   29|     57|#define SIZEOF_VLA sizeof
  ------------------
   28|     57|}
check_timed_auth:
   32|     46|{
   33|     46|    VLA(uint8_t, to_hash, sizeof(uint64_t) + length);
  ------------------
  |  |   62|     46|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     46|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
   34|       |
   35|    129|    for (uint8_t i = 0; i < 2; ++i) {
  ------------------
  |  Branch (35:25): [True: 91, False: 38]
  ------------------
   36|     91|        create_timed_auth_to_hash(mono_time, timeout, i != 0, data, length, to_hash);
   37|       |
   38|     91|        if (crypto_hmac_verify(timed_auth, key, to_hash, SIZEOF_VLA(to_hash))) {
  ------------------
  |  |   29|     91|#define SIZEOF_VLA sizeof
  ------------------
  |  Branch (38:13): [True: 8, False: 83]
  ------------------
   39|      8|            return true;
   40|      8|        }
   41|     91|    }
   42|       |
   43|     38|    return false;
   44|     46|}
timed_auth.c:create_timed_auth_to_hash:
   13|    148|{
   14|    148|    const uint64_t t = (mono_time_get(mono_time) / timeout) - (previous ? 1 : 0);
  ------------------
  |  Branch (14:64): [True: 45, False: 103]
  ------------------
   15|    148|    memcpy(to_hash, &t, sizeof(t));
   16|       |
   17|    148|    if (data != nullptr) {
  ------------------
  |  |   66|    148|#define nullptr NULL
  ------------------
  |  Branch (17:9): [True: 148, False: 0]
  ------------------
   18|    148|        memcpy(to_hash + sizeof(t), data, length);
   19|    148|    }
   20|    148|}

tox_new:
  629|    968|{
  630|    968|    struct Tox_Options *default_options = nullptr;
  ------------------
  |  |   66|    968|#define nullptr NULL
  ------------------
  631|       |
  632|    968|    if (options == nullptr) {
  ------------------
  |  |   66|    968|#define nullptr NULL
  ------------------
  |  Branch (632:9): [True: 0, False: 968]
  ------------------
  633|      0|        Tox_Err_Options_New err;
  634|      0|        default_options = tox_options_new(&err);
  635|       |
  636|      0|        switch (err) {
  ------------------
  |  Branch (636:17): [True: 0, False: 0]
  ------------------
  637|      0|            case TOX_ERR_OPTIONS_NEW_OK: {
  ------------------
  |  Branch (637:13): [True: 0, False: 0]
  ------------------
  638|      0|                break;
  639|      0|            }
  640|       |
  641|      0|            case TOX_ERR_OPTIONS_NEW_MALLOC: {
  ------------------
  |  Branch (641:13): [True: 0, False: 0]
  ------------------
  642|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  643|      0|                return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  644|      0|            }
  645|      0|        }
  646|      0|    }
  647|       |
  648|    968|    const struct Tox_Options *const opts = options != nullptr ? options : default_options;
  ------------------
  |  |   66|    968|#define nullptr NULL
  ------------------
  |  Branch (648:44): [True: 968, False: 0]
  ------------------
  649|    968|    assert(opts != nullptr);
  650|       |
  651|      0|    const Tox_System *sys = tox_options_get_operating_system(opts);
  652|    968|    const Tox_System default_system = tox_default_system();
  653|       |
  654|    968|    if (sys == nullptr) {
  ------------------
  |  |   66|    968|#define nullptr NULL
  ------------------
  |  Branch (654:9): [True: 0, False: 968]
  ------------------
  655|      0|        sys = &default_system;
  656|      0|    }
  657|       |
  658|    968|    if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   66|  1.93k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   66|  1.93k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   66|    968|#define nullptr NULL
  ------------------
  |  Branch (658:9): [True: 0, False: 968]
  |  Branch (658:32): [True: 0, False: 968]
  |  Branch (658:54): [True: 0, False: 968]
  ------------------
  659|       |        // TODO(iphydf): Not quite right, but similar.
  660|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  661|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  662|      0|    }
  663|       |
  664|    968|    Messenger_Options m_options = {0};
  665|       |
  666|    968|    bool load_savedata_sk = false;
  667|    968|    bool load_savedata_tox = false;
  668|       |
  669|    968|    if (tox_options_get_savedata_type(opts) != TOX_SAVEDATA_TYPE_NONE) {
  ------------------
  |  Branch (669:9): [True: 0, False: 968]
  ------------------
  670|      0|        if (tox_options_get_savedata_data(opts) == nullptr || tox_options_get_savedata_length(opts) == 0) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (670:13): [True: 0, False: 0]
  |  Branch (670:63): [True: 0, False: 0]
  ------------------
  671|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  672|      0|            tox_options_free(default_options);
  673|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  674|      0|        }
  675|      0|    }
  676|       |
  677|    968|    if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_SECRET_KEY) {
  ------------------
  |  Branch (677:9): [True: 0, False: 968]
  ------------------
  678|      0|        if (tox_options_get_savedata_length(opts) != TOX_SECRET_KEY_SIZE) {
  ------------------
  |  |  224|      0|#define TOX_SECRET_KEY_SIZE            32
  ------------------
  |  Branch (678:13): [True: 0, False: 0]
  ------------------
  679|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  680|      0|            tox_options_free(default_options);
  681|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  682|      0|        }
  683|       |
  684|      0|        load_savedata_sk = true;
  685|    968|    } else if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_TOX_SAVE) {
  ------------------
  |  Branch (685:16): [True: 0, False: 968]
  ------------------
  686|      0|        if (tox_options_get_savedata_length(opts) < TOX_ENC_SAVE_MAGIC_LENGTH) {
  ------------------
  |  |   10|      0|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (686:13): [True: 0, False: 0]
  ------------------
  687|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  688|      0|            tox_options_free(default_options);
  689|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  690|      0|        }
  691|       |
  692|      0|        if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |    9|      0|#define TOX_ENC_SAVE_MAGIC_NUMBER ((const uint8_t *)"toxEsave")
  ------------------
                      if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |   10|      0|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (692:13): [True: 0, False: 0]
  ------------------
  693|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_ENCRYPTED);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  694|      0|            tox_options_free(default_options);
  695|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  696|      0|        }
  697|       |
  698|      0|        load_savedata_tox = true;
  699|      0|    }
  700|       |
  701|    968|    m_options.ipv6enabled = tox_options_get_ipv6_enabled(opts);
  702|    968|    m_options.udp_disabled = !tox_options_get_udp_enabled(opts);
  703|    968|    m_options.port_range[0] = tox_options_get_start_port(opts);
  704|    968|    m_options.port_range[1] = tox_options_get_end_port(opts);
  705|    968|    m_options.tcp_server_port = tox_options_get_tcp_port(opts);
  706|    968|    m_options.hole_punching_enabled = tox_options_get_hole_punching_enabled(opts);
  707|    968|    m_options.local_discovery_enabled = tox_options_get_local_discovery_enabled(opts);
  708|    968|    m_options.dht_announcements_enabled = tox_options_get_dht_announcements_enabled(opts);
  709|       |
  710|    968|    if (m_options.udp_disabled) {
  ------------------
  |  Branch (710:9): [True: 0, False: 968]
  ------------------
  711|      0|        m_options.local_discovery_enabled = false;
  712|      0|    }
  713|       |
  714|    968|    Tox *tox = (Tox *)mem_alloc(sys->mem, sizeof(Tox));
  715|       |
  716|    968|    if (tox == nullptr) {
  ------------------
  |  |   66|    968|#define nullptr NULL
  ------------------
  |  Branch (716:9): [True: 1, False: 967]
  ------------------
  717|      1|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      1|    do {                              \
  |  |   35|      1|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      2|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 1, False: 0]
  |  |  ------------------
  |  |   36|      1|            *param = x;               \
  |  |   37|      1|        }                             \
  |  |   38|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  718|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  719|      1|    }
  720|       |
  721|    967|    tox->log_callback = tox_options_get_log_callback(opts);
  722|    967|    m_options.log_callback = tox_log_handler;
  723|    967|    m_options.log_context = tox;
  724|    967|    m_options.log_user_data = tox_options_get_log_user_data(opts);
  725|       |
  726|    967|    switch (tox_options_get_proxy_type(opts)) {
  727|    245|        case TOX_PROXY_TYPE_HTTP: {
  ------------------
  |  Branch (727:9): [True: 245, False: 722]
  ------------------
  728|    245|            m_options.proxy_info.proxy_type = TCP_PROXY_HTTP;
  729|    245|            break;
  730|      0|        }
  731|       |
  732|     33|        case TOX_PROXY_TYPE_SOCKS5: {
  ------------------
  |  Branch (732:9): [True: 33, False: 934]
  ------------------
  733|     33|            m_options.proxy_info.proxy_type = TCP_PROXY_SOCKS5;
  734|     33|            break;
  735|      0|        }
  736|       |
  737|    689|        case TOX_PROXY_TYPE_NONE: {
  ------------------
  |  Branch (737:9): [True: 689, False: 278]
  ------------------
  738|    689|            m_options.proxy_info.proxy_type = TCP_PROXY_NONE;
  739|    689|            break;
  740|      0|        }
  741|       |
  742|      0|        default: {
  ------------------
  |  Branch (742:9): [True: 0, False: 967]
  ------------------
  743|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_TYPE);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  744|      0|            tox_options_free(default_options);
  745|      0|            mem_delete(sys->mem, tox);
  746|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  747|      0|        }
  748|    967|    }
  749|       |
  750|    967|    tox->sys = *sys;
  751|       |
  752|    967|    if (m_options.proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (752:9): [True: 278, False: 689]
  ------------------
  753|    278|        if (tox_options_get_proxy_port(opts) == 0) {
  ------------------
  |  Branch (753:13): [True: 0, False: 278]
  ------------------
  754|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_PORT);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  755|      0|            tox_options_free(default_options);
  756|      0|            mem_delete(sys->mem, tox);
  757|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  758|      0|        }
  759|       |
  760|    278|        ip_init(&m_options.proxy_info.ip_port.ip, m_options.ipv6enabled);
  761|       |
  762|    278|        if (m_options.ipv6enabled) {
  ------------------
  |  Branch (762:13): [True: 278, False: 0]
  ------------------
  763|    278|            m_options.proxy_info.ip_port.ip.family = net_family_unspec();
  764|    278|        }
  765|       |
  766|    278|        const char *const proxy_host = tox_options_get_proxy_host(opts);
  767|       |
  768|    278|        if (proxy_host == nullptr
  ------------------
  |  |   66|    556|#define nullptr NULL
  ------------------
  |  Branch (768:13): [True: 0, False: 278]
  ------------------
  769|    278|                || !addr_resolve_or_parse_ip(tox->sys.ns, proxy_host, &m_options.proxy_info.ip_port.ip, nullptr)) {
  ------------------
  |  |   66|    278|#define nullptr NULL
  ------------------
  |  Branch (769:20): [True: 0, False: 278]
  ------------------
  770|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_HOST);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  771|       |            // TODO(irungentoo): TOX_ERR_NEW_PROXY_NOT_FOUND if domain.
  772|      0|            tox_options_free(default_options);
  773|      0|            mem_delete(sys->mem, tox);
  774|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  775|      0|        }
  776|       |
  777|    278|        m_options.proxy_info.ip_port.port = net_htons(tox_options_get_proxy_port(opts));
  778|    278|    }
  779|       |
  780|    967|    tox->mono_time = mono_time_new(tox->sys.mem, sys->mono_time_callback, sys->mono_time_user_data);
  781|       |
  782|    967|    if (tox->mono_time == nullptr) {
  ------------------
  |  |   66|    967|#define nullptr NULL
  ------------------
  |  Branch (782:9): [True: 2, False: 965]
  ------------------
  783|      2|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      2|    do {                              \
  |  |   35|      2|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      4|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 2, False: 0]
  |  |  ------------------
  |  |   36|      2|            *param = x;               \
  |  |   37|      2|        }                             \
  |  |   38|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  784|      2|        tox_options_free(default_options);
  785|      2|        mem_delete(sys->mem, tox);
  786|      2|        return nullptr;
  ------------------
  |  |   66|      2|#define nullptr NULL
  ------------------
  787|      2|    }
  788|       |
  789|    965|    if (tox_options_get_experimental_thread_safety(opts)) {
  ------------------
  |  Branch (789:9): [True: 0, False: 965]
  ------------------
  790|      0|        tox->mutex = (pthread_mutex_t *)mem_alloc(sys->mem, sizeof(pthread_mutex_t));
  791|       |
  792|      0|        if (tox->mutex == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (792:13): [True: 0, False: 0]
  ------------------
  793|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  794|      0|            tox_options_free(default_options);
  795|      0|            mem_delete(sys->mem, tox);
  796|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  797|      0|        }
  798|       |
  799|       |
  800|      0|        pthread_mutexattr_t attr;
  801|       |
  802|      0|        pthread_mutexattr_init(&attr);
  803|      0|        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
  804|      0|        pthread_mutex_init(tox->mutex, &attr);
  805|    965|    } else {
  806|    965|        tox->mutex = nullptr;
  ------------------
  |  |   66|    965|#define nullptr NULL
  ------------------
  807|    965|    }
  808|       |
  809|    965|    tox_lock(tox);
  810|       |
  811|    965|    Messenger_Error m_error;
  812|    965|    tox->m = new_messenger(tox->mono_time, tox->sys.mem, tox->sys.rng, tox->sys.ns, &m_options, &m_error);
  813|       |
  814|    965|    if (tox->m == nullptr) {
  ------------------
  |  |   66|    965|#define nullptr NULL
  ------------------
  |  Branch (814:9): [True: 32, False: 933]
  ------------------
  815|     32|        switch (m_error) {
  ------------------
  |  Branch (815:17): [True: 0, False: 32]
  ------------------
  816|      0|            case MESSENGER_ERROR_PORT:
  ------------------
  |  Branch (816:13): [True: 0, False: 32]
  ------------------
  817|      2|            case MESSENGER_ERROR_TCP_SERVER: {
  ------------------
  |  Branch (817:13): [True: 2, False: 30]
  ------------------
  818|      2|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PORT_ALLOC);
  ------------------
  |  |   34|      2|    do {                              \
  |  |   35|      2|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      4|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 2, False: 0]
  |  |  ------------------
  |  |   36|      2|            *param = x;               \
  |  |   37|      2|        }                             \
  |  |   38|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  819|      2|                break;
  820|      0|            }
  821|     30|            case MESSENGER_ERROR_OTHER:
  ------------------
  |  Branch (821:13): [True: 30, False: 2]
  ------------------
  822|     30|            case MESSENGER_ERROR_NONE: {
  ------------------
  |  Branch (822:13): [True: 0, False: 32]
  ------------------
  823|     30|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|     30|    do {                              \
  |  |   35|     30|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|     60|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 30, False: 0]
  |  |  ------------------
  |  |   36|     30|            *param = x;               \
  |  |   37|     30|        }                             \
  |  |   38|     30|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  824|     30|                break;
  825|     30|            }
  826|     32|        }
  827|       |
  828|     32|        mono_time_free(tox->sys.mem, tox->mono_time);
  829|     32|        tox_options_free(default_options);
  830|     32|        tox_unlock(tox);
  831|       |
  832|     32|        if (tox->mutex != nullptr) {
  ------------------
  |  |   66|     32|#define nullptr NULL
  ------------------
  |  Branch (832:13): [True: 0, False: 32]
  ------------------
  833|      0|            pthread_mutex_destroy(tox->mutex);
  834|      0|        }
  835|       |
  836|     32|        mem_delete(sys->mem, tox->mutex);
  837|     32|        mem_delete(sys->mem, tox);
  838|     32|        return nullptr;
  ------------------
  |  |   66|     32|#define nullptr NULL
  ------------------
  839|     32|    }
  840|       |
  841|    933|    if (new_groupchats(tox->mono_time, tox->m) == nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (841:9): [True: 0, False: 933]
  ------------------
  842|      0|        kill_messenger(tox->m);
  843|       |
  844|      0|        mono_time_free(tox->sys.mem, tox->mono_time);
  845|      0|        tox_options_free(default_options);
  846|      0|        tox_unlock(tox);
  847|       |
  848|      0|        if (tox->mutex != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (848:13): [True: 0, False: 0]
  ------------------
  849|      0|            pthread_mutex_destroy(tox->mutex);
  850|      0|        }
  851|       |
  852|      0|        mem_delete(sys->mem, tox->mutex);
  853|      0|        mem_delete(sys->mem, tox);
  854|       |
  855|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  856|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  857|      0|    }
  858|       |
  859|    933|    if (load_savedata_tox
  ------------------
  |  Branch (859:9): [True: 0, False: 933]
  ------------------
  860|    933|            && tox_load(tox, tox_options_get_savedata_data(opts), tox_options_get_savedata_length(opts)) == -1) {
  ------------------
  |  Branch (860:16): [True: 0, False: 0]
  ------------------
  861|      0|        kill_groupchats(tox->m->conferences_object);
  862|      0|        kill_messenger(tox->m);
  863|       |
  864|      0|        mono_time_free(tox->sys.mem, tox->mono_time);
  865|      0|        tox_options_free(default_options);
  866|      0|        tox_unlock(tox);
  867|       |
  868|      0|        if (tox->mutex != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (868:13): [True: 0, False: 0]
  ------------------
  869|      0|            pthread_mutex_destroy(tox->mutex);
  870|      0|        }
  871|       |
  872|      0|        mem_delete(sys->mem, tox->mutex);
  873|      0|        mem_delete(sys->mem, tox);
  874|       |
  875|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  876|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  877|      0|    }
  878|       |
  879|    933|    if (load_savedata_sk) {
  ------------------
  |  Branch (879:9): [True: 0, False: 933]
  ------------------
  880|      0|        load_secret_key(tox->m->net_crypto, tox_options_get_savedata_data(opts));
  881|      0|    }
  882|       |
  883|    933|    m_callback_namechange(tox->m, tox_friend_name_handler);
  884|    933|    m_callback_core_connection(tox->m, tox_self_connection_status_handler);
  885|    933|    m_callback_statusmessage(tox->m, tox_friend_status_message_handler);
  886|    933|    m_callback_userstatus(tox->m, tox_friend_status_handler);
  887|    933|    m_callback_connectionstatus(tox->m, tox_friend_connection_status_handler);
  888|    933|    m_callback_typingchange(tox->m, tox_friend_typing_handler);
  889|    933|    m_callback_read_receipt(tox->m, tox_friend_read_receipt_handler);
  890|    933|    m_callback_friendrequest(tox->m, tox_friend_request_handler);
  891|    933|    m_callback_friendmessage(tox->m, tox_friend_message_handler);
  892|    933|    callback_file_control(tox->m, tox_file_recv_control_handler);
  893|    933|    callback_file_reqchunk(tox->m, tox_file_chunk_request_handler);
  894|    933|    callback_file_sendrequest(tox->m, tox_file_recv_handler);
  895|    933|    callback_file_data(tox->m, tox_file_recv_chunk_handler);
  896|    933|    dht_callback_get_nodes_response(tox->m->dht, tox_dht_get_nodes_response_handler);
  897|    933|    g_callback_group_invite(tox->m->conferences_object, tox_conference_invite_handler);
  898|    933|    g_callback_group_connected(tox->m->conferences_object, tox_conference_connected_handler);
  899|    933|    g_callback_group_message(tox->m->conferences_object, tox_conference_message_handler);
  900|    933|    g_callback_group_title(tox->m->conferences_object, tox_conference_title_handler);
  901|    933|    g_callback_peer_name(tox->m->conferences_object, tox_conference_peer_name_handler);
  902|    933|    g_callback_peer_list_changed(tox->m->conferences_object, tox_conference_peer_list_changed_handler);
  903|    933|    custom_lossy_packet_registerhandler(tox->m, tox_friend_lossy_packet_handler);
  904|    933|    custom_lossless_packet_registerhandler(tox->m, tox_friend_lossless_packet_handler);
  905|       |
  906|    933|#ifndef VANILLA_NACL
  907|    933|    m_callback_group_invite(tox->m, tox_group_invite_handler);
  908|    933|    gc_callback_message(tox->m, tox_group_message_handler);
  909|    933|    gc_callback_private_message(tox->m, tox_group_private_message_handler);
  910|    933|    gc_callback_custom_packet(tox->m, tox_group_custom_packet_handler);
  911|    933|    gc_callback_custom_private_packet(tox->m, tox_group_custom_private_packet_handler);
  912|    933|    gc_callback_moderation(tox->m, tox_group_moderation_handler);
  913|    933|    gc_callback_nick_change(tox->m, tox_group_peer_name_handler);
  914|    933|    gc_callback_status_change(tox->m, tox_group_peer_status_handler);
  915|    933|    gc_callback_topic_change(tox->m, tox_group_topic_handler);
  916|    933|    gc_callback_peer_limit(tox->m, tox_group_peer_limit_handler);
  917|    933|    gc_callback_privacy_state(tox->m, tox_group_privacy_state_handler);
  918|    933|    gc_callback_topic_lock(tox->m, tox_group_topic_lock_handler);
  919|    933|    gc_callback_password(tox->m, tox_group_password_handler);
  920|    933|    gc_callback_peer_join(tox->m, tox_group_peer_join_handler);
  921|    933|    gc_callback_peer_exit(tox->m, tox_group_peer_exit_handler);
  922|    933|    gc_callback_self_join(tox->m, tox_group_self_join_handler);
  923|    933|    gc_callback_rejected(tox->m, tox_group_join_fail_handler);
  924|    933|    gc_callback_voice_state(tox->m, tox_group_voice_state_handler);
  925|    933|#endif
  926|       |
  927|    933|    tox_options_free(default_options);
  928|       |
  929|    933|    tox_unlock(tox);
  930|       |
  931|    933|    SET_ERROR_PARAMETER(error, TOX_ERR_NEW_OK);
  ------------------
  |  |   34|    933|    do {                              \
  |  |   35|    933|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|  1.86k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 933, False: 0]
  |  |  ------------------
  |  |   36|    933|            *param = x;               \
  |  |   37|    933|        }                             \
  |  |   38|    933|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  932|       |
  933|    933|    return tox;
  934|    933|}
tox_kill:
  937|    933|{
  938|    933|    if (tox == nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (938:9): [True: 0, False: 933]
  ------------------
  939|      0|        return;
  940|      0|    }
  941|       |
  942|    933|    tox_lock(tox);
  943|    933|    LOGGER_ASSERT(tox->m->log, tox->m->msi_packet == nullptr, "Attempted to kill tox while toxav is still alive");
  ------------------
  |  |   92|    933|    do {                                           \
  |  |   93|    933|        if (!(cond)) {                             \
  |  |  ------------------
  |  |  |  Branch (93:13): [True: 0, False: 933]
  |  |  ------------------
  |  |   94|      0|            LOGGER_ERROR(log, "Assertion failed"); \
  |  |  ------------------
  |  |  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   95|      0|            LOGGER_FATAL(log, __VA_ARGS__);        \
  |  |  ------------------
  |  |  |  |   86|      0|    do {                                \
  |  |  |  |   87|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |   88|      0|        abort();                        \
  |  |  |  |   89|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   96|      0|        }                                          \
  |  |   97|    933|    } while (0)
  |  |  ------------------
  |  |  |  Branch (97:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  944|    933|    kill_groupchats(tox->m->conferences_object);
  945|    933|    kill_messenger(tox->m);
  946|    933|    mono_time_free(tox->sys.mem, tox->mono_time);
  947|    933|    tox_unlock(tox);
  948|       |
  949|    933|    if (tox->mutex != nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (949:9): [True: 0, False: 933]
  ------------------
  950|      0|        pthread_mutex_destroy(tox->mutex);
  951|      0|        mem_delete(tox->sys.mem, tox->mutex);
  952|      0|    }
  953|       |
  954|    933|    mem_delete(tox->sys.mem, tox);
  955|    933|}
tox_bootstrap:
 1038|    933|{
 1039|    933|    IP_Port *root;
 1040|    933|    const int32_t count = resolve_bootstrap_node(tox, host, port, public_key, &root, error);
 1041|       |
 1042|    933|    if (count == -1) {
  ------------------
  |  Branch (1042:9): [True: 467, False: 466]
  ------------------
 1043|    467|        return false;
 1044|    467|    }
 1045|       |
 1046|    466|    tox_lock(tox);
 1047|    466|    assert(count >= 0);
 1048|      0|    bool onion_success = false;
 1049|       |    // UDP bootstrap is default success if it's disabled (because we don't even try).
 1050|    466|    bool udp_success = tox->m->options.udp_disabled;
 1051|       |
 1052|    932|    for (int32_t i = 0; i < count; ++i) {
  ------------------
  |  Branch (1052:25): [True: 466, False: 466]
  ------------------
 1053|    466|        root[i].port = net_htons(port);
 1054|       |
 1055|    466|        if (onion_add_bs_path_node(tox->m->onion_c, &root[i], public_key)) {
  ------------------
  |  Branch (1055:13): [True: 466, False: 0]
  ------------------
 1056|       |            // If UDP is enabled, the caller cares about whether any of the
 1057|       |            // bootstrap calls below will succeed. In TCP-only mode, adding
 1058|       |            // onion path nodes successfully is sufficient.
 1059|    466|            onion_success = true;
 1060|    466|        }
 1061|       |
 1062|    466|        if (!tox->m->options.udp_disabled) {
  ------------------
  |  Branch (1062:13): [True: 261, False: 205]
  ------------------
 1063|    261|            if (dht_bootstrap(tox->m->dht, &root[i], public_key)) {
  ------------------
  |  Branch (1063:17): [True: 210, False: 51]
  ------------------
 1064|       |                // If any of the bootstrap calls worked, we call it success.
 1065|    210|                udp_success = true;
 1066|    210|            }
 1067|    261|        }
 1068|    466|    }
 1069|       |
 1070|    466|    tox_unlock(tox);
 1071|       |
 1072|    466|    net_freeipport(tox->sys.mem, root);
 1073|       |
 1074|    466|    if (count == 0 || !onion_success || !udp_success) {
  ------------------
  |  Branch (1074:9): [True: 0, False: 466]
  |  Branch (1074:23): [True: 0, False: 466]
  |  Branch (1074:41): [True: 51, False: 415]
  ------------------
 1075|     51|        LOGGER_DEBUG(tox->m->log, "bootstrap node '%s' resolved to %d IP_Ports%s (onion: %s, UDP: %s)",
  ------------------
  |  |   80|     51|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     51|    do {                                                                         \
  |  |  |  |   73|     51|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    102|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (74:68): [True: 0, False: 0]
  |  |  |  |  |  Branch (74:68): [True: 0, False: 0]
  |  |  |  |  |  Branch (74:68): [True: 0, False: 0]
  |  |  |  |  |  Branch (74:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|     51|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1076|     51|                     host, count,
 1077|     51|                     count > 0 ? ", but failed to bootstrap with any of them" : "",
 1078|     51|                     onion_success ? "success" : "FAILURE",
 1079|     51|                     tox->m->options.udp_disabled ? "disabled" : (udp_success ? "success" : "FAILURE"));
 1080|     51|        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_HOST);
  ------------------
  |  |   34|     51|    do {                              \
  |  |   35|     51|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|    102|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 51]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|     51|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1081|     51|        return false;
 1082|     51|    }
 1083|       |
 1084|    415|    SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_OK);
  ------------------
  |  |   34|    415|    do {                              \
  |  |   35|    415|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|    830|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 415]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|    415|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1085|    415|    return true;
 1086|    466|}
tox_add_tcp_relay:
 1090|    933|{
 1091|    933|    IP_Port *root;
 1092|    933|    const int32_t count = resolve_bootstrap_node(tox, host, port, public_key, &root, error);
 1093|       |
 1094|    933|    if (count == -1) {
  ------------------
  |  Branch (1094:9): [True: 525, False: 408]
  ------------------
 1095|    525|        return false;
 1096|    525|    }
 1097|       |
 1098|    408|    tox_lock(tox);
 1099|    408|    assert(count >= 0);
 1100|       |
 1101|    816|    for (int32_t i = 0; i < count; ++i) {
  ------------------
  |  Branch (1101:25): [True: 408, False: 408]
  ------------------
 1102|    408|        root[i].port = net_htons(port);
 1103|       |
 1104|    408|        add_tcp_relay(tox->m->net_crypto, &root[i], public_key);
 1105|    408|    }
 1106|       |
 1107|    408|    tox_unlock(tox);
 1108|       |
 1109|    408|    net_freeipport(tox->sys.mem, root);
 1110|       |
 1111|    408|    if (count == 0) {
  ------------------
  |  Branch (1111:9): [True: 0, False: 408]
  ------------------
 1112|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_HOST);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1113|      0|        return false;
 1114|      0|    }
 1115|       |
 1116|    408|    SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_OK);
  ------------------
  |  |   34|    408|    do {                              \
  |  |   35|    408|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|    816|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 408]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|    408|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1117|    408|    return true;
 1118|    408|}
tox_callback_self_connection_status:
 1144|    933|{
 1145|    933|    assert(tox != nullptr);
 1146|      0|    tox->self_connection_status_callback = callback;
 1147|    933|}
tox_iterate:
 1164|  72.6k|{
 1165|  72.6k|    assert(tox != nullptr);
 1166|      0|    tox_lock(tox);
 1167|       |
 1168|  72.6k|    mono_time_update(tox->mono_time);
 1169|       |
 1170|  72.6k|    struct Tox_Userdata tox_data = { tox, user_data };
 1171|  72.6k|    do_messenger(tox->m, &tox_data);
 1172|  72.6k|    do_groupchats(tox->m->conferences_object, &tox_data);
 1173|       |
 1174|  72.6k|    tox_unlock(tox);
 1175|  72.6k|}
tox_friend_add_norequest:
 1402|    128|{
 1403|    128|    assert(tox != nullptr);
 1404|       |
 1405|    128|    if (public_key == nullptr) {
  ------------------
  |  |   66|    128|#define nullptr NULL
  ------------------
  |  Branch (1405:9): [True: 0, False: 128]
  ------------------
 1406|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_NULL);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1407|      0|        return UINT32_MAX;
 1408|      0|    }
 1409|       |
 1410|    128|    tox_lock(tox);
 1411|    128|    const int32_t ret = m_addfriend_norequest(tox->m, public_key);
 1412|       |
 1413|    128|    if (ret >= 0) {
  ------------------
  |  Branch (1413:9): [True: 121, False: 7]
  ------------------
 1414|    121|        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_OK);
  ------------------
  |  |   34|    121|    do {                              \
  |  |   35|    121|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|    242|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 121, False: 0]
  |  |  ------------------
  |  |   36|    121|            *param = x;               \
  |  |   37|    121|        }                             \
  |  |   38|    121|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1415|    121|        tox_unlock(tox);
 1416|    121|        return (uint32_t)ret;
 1417|    121|    }
 1418|       |
 1419|      7|    set_friend_error(tox->m->log, ret, error);
 1420|      7|    tox_unlock(tox);
 1421|      7|    return UINT32_MAX;
 1422|    128|}
tox_callback_friend_name:
 1571|    933|{
 1572|    933|    assert(tox != nullptr);
 1573|      0|    tox->friend_name_callback = callback;
 1574|    933|}
tox_callback_friend_status_message:
 1620|    933|{
 1621|    933|    assert(tox != nullptr);
 1622|      0|    tox->friend_status_message_callback = callback;
 1623|    933|}
tox_callback_friend_status:
 1642|    933|{
 1643|    933|    assert(tox != nullptr);
 1644|      0|    tox->friend_status_callback = callback;
 1645|    933|}
tox_callback_friend_connection_status:
 1664|    933|{
 1665|    933|    assert(tox != nullptr);
 1666|      0|    tox->friend_connection_status_callback = callback;
 1667|    933|}
tox_callback_friend_typing:
 1686|    933|{
 1687|    933|    assert(tox != nullptr);
 1688|      0|    tox->friend_typing_callback = callback;
 1689|    933|}
tox_callback_friend_read_receipt:
 1773|    933|{
 1774|    933|    assert(tox != nullptr);
 1775|      0|    tox->friend_read_receipt_callback = callback;
 1776|    933|}
tox_callback_friend_request:
 1779|    933|{
 1780|    933|    assert(tox != nullptr);
 1781|      0|    tox->friend_request_callback = callback;
 1782|    933|}
tox_callback_friend_message:
 1785|    933|{
 1786|    933|    assert(tox != nullptr);
 1787|      0|    tox->friend_message_callback = callback;
 1788|    933|}
tox_callback_file_recv_control:
 1915|    933|{
 1916|    933|    assert(tox != nullptr);
 1917|      0|    tox->file_recv_control_callback = callback;
 1918|    933|}
tox_callback_file_chunk_request:
 2060|    933|{
 2061|    933|    assert(tox != nullptr);
 2062|      0|    tox->file_chunk_request_callback = callback;
 2063|    933|}
tox_callback_file_recv:
 2066|    933|{
 2067|    933|    assert(tox != nullptr);
 2068|      0|    tox->file_recv_callback = callback;
 2069|    933|}
tox_callback_file_recv_chunk:
 2072|    933|{
 2073|    933|    assert(tox != nullptr);
 2074|      0|    tox->file_recv_chunk_callback = callback;
 2075|    933|}
tox_callback_conference_invite:
 2078|    933|{
 2079|    933|    assert(tox != nullptr);
 2080|      0|    tox->conference_invite_callback = callback;
 2081|    933|}
tox_callback_conference_connected:
 2084|    933|{
 2085|    933|    assert(tox != nullptr);
 2086|      0|    tox->conference_connected_callback = callback;
 2087|    933|}
tox_callback_conference_message:
 2090|    933|{
 2091|    933|    assert(tox != nullptr);
 2092|      0|    tox->conference_message_callback = callback;
 2093|    933|}
tox_callback_conference_title:
 2096|    933|{
 2097|    933|    assert(tox != nullptr);
 2098|      0|    tox->conference_title_callback = callback;
 2099|    933|}
tox_callback_conference_peer_name:
 2102|    933|{
 2103|    933|    assert(tox != nullptr);
 2104|      0|    tox->conference_peer_name_callback = callback;
 2105|    933|}
tox_callback_conference_peer_list_changed:
 2108|    933|{
 2109|    933|    assert(tox != nullptr);
 2110|      0|    tox->conference_peer_list_changed_callback = callback;
 2111|    933|}
tox_callback_friend_lossy_packet:
 2756|    933|{
 2757|    933|    assert(tox != nullptr);
 2758|       |
 2759|       |    /* start at PACKET_ID_RANGE_LOSSY_CUSTOM_START so ToxAV Packets are excluded */
 2760|  52.2k|    for (uint8_t i = PACKET_ID_RANGE_LOSSY_CUSTOM_START; i <= PACKET_ID_RANGE_LOSSY_END; ++i) {
  ------------------
  |  |   40|    933|#define PACKET_ID_RANGE_LOSSY_CUSTOM_START 200
  ------------------
                  for (uint8_t i = PACKET_ID_RANGE_LOSSY_CUSTOM_START; i <= PACKET_ID_RANGE_LOSSY_END; ++i) {
  ------------------
  |  |   42|  52.2k|#define PACKET_ID_RANGE_LOSSY_END 254
  ------------------
  |  Branch (2760:58): [True: 51.3k, False: 933]
  ------------------
 2761|  51.3k|        tox->friend_lossy_packet_callback_per_pktid[i] = callback;
 2762|  51.3k|    }
 2763|    933|}
tox_callback_friend_lossless_packet:
 2790|    933|{
 2791|    933|    assert(tox != nullptr);
 2792|       |
 2793|  30.7k|    for (uint8_t i = PACKET_ID_RANGE_LOSSLESS_CUSTOM_START; i <= PACKET_ID_RANGE_LOSSLESS_CUSTOM_END; ++i) {
  ------------------
  |  |   31|    933|#define PACKET_ID_RANGE_LOSSLESS_CUSTOM_START 160
  ------------------
                  for (uint8_t i = PACKET_ID_RANGE_LOSSLESS_CUSTOM_START; i <= PACKET_ID_RANGE_LOSSLESS_CUSTOM_END; ++i) {
  ------------------
  |  |   32|  30.7k|#define PACKET_ID_RANGE_LOSSLESS_CUSTOM_END 191
  ------------------
  |  Branch (2793:61): [True: 29.8k, False: 933]
  ------------------
 2794|  29.8k|        tox->friend_lossless_packet_callback_per_pktid[i] = callback;
 2795|  29.8k|    }
 2796|    933|}
tox.c:tox_log_handler:
   74|  16.9k|{
   75|  16.9k|    Tox *tox = (Tox *)context;
   76|  16.9k|    assert(tox != nullptr);
   77|       |
   78|  16.9k|    if (tox->log_callback != nullptr) {
  ------------------
  |  |   66|  16.9k|#define nullptr NULL
  ------------------
  |  Branch (78:9): [True: 16.9k, False: 0]
  ------------------
   79|  16.9k|        tox->log_callback(tox, (Tox_Log_Level)level, file, line, func, message, userdata);
   80|  16.9k|    }
   81|  16.9k|}
tox.c:tox_friend_request_handler:
  168|    128|{
  169|    128|    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;
  170|       |
  171|    128|    if (tox_data->tox->friend_request_callback != nullptr) {
  ------------------
  |  |   66|    128|#define nullptr NULL
  ------------------
  |  Branch (171:9): [True: 128, False: 0]
  ------------------
  172|    128|        tox_data->tox->friend_request_callback(tox_data->tox, public_key, message, length, tox_data->user_data);
  173|    128|    }
  174|    128|}
tox.c:resolve_bootstrap_node:
 1010|  1.86k|{
 1011|  1.86k|    assert(tox != nullptr);
 1012|      0|    assert(root != nullptr);
 1013|       |
 1014|  1.86k|    if (host == nullptr || public_key == nullptr) {
  ------------------
  |  |   66|  3.73k|#define nullptr NULL
  ------------------
                  if (host == nullptr || public_key == nullptr) {
  ------------------
  |  |   66|  1.86k|#define nullptr NULL
  ------------------
  |  Branch (1014:9): [True: 0, False: 1.86k]
  |  Branch (1014:28): [True: 0, False: 1.86k]
  ------------------
 1015|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_NULL);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1016|      0|        return -1;
 1017|      0|    }
 1018|       |
 1019|  1.86k|    if (port == 0) {
  ------------------
  |  Branch (1019:9): [True: 0, False: 1.86k]
  ------------------
 1020|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_PORT);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1021|      0|        return -1;
 1022|      0|    }
 1023|       |
 1024|  1.86k|    const int32_t count = net_getipport(tox->sys.mem, host, root, TOX_SOCK_DGRAM);
  ------------------
  |  |  213|  1.86k|#define TOX_SOCK_DGRAM 2
  ------------------
 1025|       |
 1026|  1.86k|    if (count < 1) {
  ------------------
  |  Branch (1026:9): [True: 992, False: 874]
  ------------------
 1027|    992|        LOGGER_DEBUG(tox->m->log, "could not resolve bootstrap node '%s'", host);
  ------------------
  |  |   80|    992|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    992|    do {                                                                         \
  |  |  |  |   73|    992|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  1.98k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|    992|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1028|    992|        net_freeipport(tox->sys.mem, *root);
 1029|    992|        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_HOST);
  ------------------
  |  |   34|    992|    do {                              \
  |  |   35|    992|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|  1.98k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 992]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|    992|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1030|    992|        return -1;
 1031|    992|    }
 1032|       |
 1033|    874|    assert(*root != nullptr);
 1034|      0|    return count;
 1035|  1.86k|}
tox.c:set_friend_error:
 1332|      7|{
 1333|      7|    switch (ret) {
 1334|      0|        case FAERR_TOOLONG: {
  ------------------
  |  Branch (1334:9): [True: 0, False: 7]
  ------------------
 1335|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_TOO_LONG);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1336|      0|            break;
 1337|      0|        }
 1338|       |
 1339|      0|        case FAERR_NOMESSAGE: {
  ------------------
  |  Branch (1339:9): [True: 0, False: 7]
  ------------------
 1340|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_NO_MESSAGE);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1341|      0|            break;
 1342|      0|        }
 1343|       |
 1344|      2|        case FAERR_OWNKEY: {
  ------------------
  |  Branch (1344:9): [True: 2, False: 5]
  ------------------
 1345|      2|            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_OWN_KEY);
  ------------------
  |  |   34|      2|    do {                              \
  |  |   35|      2|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      4|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 2, False: 0]
  |  |  ------------------
  |  |   36|      2|            *param = x;               \
  |  |   37|      2|        }                             \
  |  |   38|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1346|      2|            break;
 1347|      0|        }
 1348|       |
 1349|      0|        case FAERR_ALREADYSENT: {
  ------------------
  |  Branch (1349:9): [True: 0, False: 7]
  ------------------
 1350|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_ALREADY_SENT);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1351|      0|            break;
 1352|      0|        }
 1353|       |
 1354|      5|        case FAERR_BADCHECKSUM: {
  ------------------
  |  Branch (1354:9): [True: 5, False: 2]
  ------------------
 1355|      5|            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_BAD_CHECKSUM);
  ------------------
  |  |   34|      5|    do {                              \
  |  |   35|      5|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|     10|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 5, False: 0]
  |  |  ------------------
  |  |   36|      5|            *param = x;               \
  |  |   37|      5|        }                             \
  |  |   38|      5|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1356|      5|            break;
 1357|      0|        }
 1358|       |
 1359|      0|        case FAERR_SETNEWNOSPAM: {
  ------------------
  |  Branch (1359:9): [True: 0, False: 7]
  ------------------
 1360|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_SET_NEW_NOSPAM);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1361|      0|            break;
 1362|      0|        }
 1363|       |
 1364|      0|        case FAERR_NOMEM: {
  ------------------
  |  Branch (1364:9): [True: 0, False: 7]
  ------------------
 1365|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1366|      0|            break;
 1367|      0|        }
 1368|       |
 1369|      0|        default: {
  ------------------
  |  Branch (1369:9): [True: 0, False: 7]
  ------------------
 1370|       |            /* can't happen */
 1371|      0|            LOGGER_FATAL(log, "impossible return value: %d", ret);
  ------------------
  |  |   86|      0|    do {                                \
  |  |   87|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   88|      0|        abort();                        \
  |  |   89|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (89:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1372|      0|            break;
 1373|      0|        }
 1374|      7|    }
 1375|      7|}

tox_options_get_ipv6_enabled:
  139|    968|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    968|{ \
  141|    968|    return options->ns##name; \
  142|    968|} \
tox_options_set_ipv6_enabled:
  143|    971|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|    971|{ \
  145|    971|    options->ns##name = name; \
  146|    971|}
tox_options_get_udp_enabled:
  139|    968|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    968|{ \
  141|    968|    return options->ns##name; \
  142|    968|} \
tox_options_set_udp_enabled:
  143|    971|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|    971|{ \
  145|    971|    options->ns##name = name; \
  146|    971|}
tox_options_get_proxy_type:
  139|    967|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    967|{ \
  141|    967|    return options->ns##name; \
  142|    967|} \
tox_options_set_proxy_type:
  143|  1.29k|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|  1.29k|{ \
  145|  1.29k|    options->ns##name = name; \
  146|  1.29k|}
tox_options_get_proxy_host:
  139|    278|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    278|{ \
  141|    278|    return options->ns##name; \
  142|    278|} \
tox_options_set_proxy_host:
  143|    279|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|    279|{ \
  145|    279|    options->ns##name = name; \
  146|    279|}
tox_options_get_proxy_port:
  139|    556|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    556|{ \
  141|    556|    return options->ns##name; \
  142|    556|} \
tox_options_set_proxy_port:
  143|    279|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|    279|{ \
  145|    279|    options->ns##name = name; \
  146|    279|}
tox_options_get_start_port:
  139|    968|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    968|{ \
  141|    968|    return options->ns##name; \
  142|    968|} \
tox_options_get_end_port:
  139|    968|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    968|{ \
  141|    968|    return options->ns##name; \
  142|    968|} \
tox_options_get_tcp_port:
  139|    968|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    968|{ \
  141|    968|    return options->ns##name; \
  142|    968|} \
tox_options_set_tcp_port:
  143|    166|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|    166|{ \
  145|    166|    options->ns##name = name; \
  146|    166|}
tox_options_get_hole_punching_enabled:
  139|    968|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    968|{ \
  141|    968|    return options->ns##name; \
  142|    968|} \
tox_options_set_hole_punching_enabled:
  143|    971|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|    971|{ \
  145|    971|    options->ns##name = name; \
  146|    971|}
tox_options_get_savedata_type:
  139|  2.90k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.90k|{ \
  141|  2.90k|    return options->ns##name; \
  142|  2.90k|} \
tox_options_get_log_callback:
  139|    967|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    967|{ \
  141|    967|    return options->ns##name; \
  142|    967|} \
tox_options_set_log_callback:
  143|    971|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|    971|{ \
  145|    971|    options->ns##name = name; \
  146|    971|}
tox_options_get_log_user_data:
  139|    967|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    967|{ \
  141|    967|    return options->ns##name; \
  142|    967|} \
tox_options_get_local_discovery_enabled:
  139|    968|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    968|{ \
  141|    968|    return options->ns##name; \
  142|    968|} \
tox_options_set_local_discovery_enabled:
  143|    971|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|    971|{ \
  145|    971|    options->ns##name = name; \
  146|    971|}
tox_options_get_dht_announcements_enabled:
  139|    968|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    968|{ \
  141|    968|    return options->ns##name; \
  142|    968|} \
tox_options_set_dht_announcements_enabled:
  143|    971|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|    971|{ \
  145|    971|    options->ns##name = name; \
  146|    971|}
tox_options_get_experimental_thread_safety:
  139|    965|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    965|{ \
  141|    965|    return options->ns##name; \
  142|    965|} \
tox_options_set_experimental_thread_safety:
  143|    971|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|    971|{ \
  145|    971|    options->ns##name = name; \
  146|    971|}
tox_options_get_operating_system:
  139|    968|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|    968|{ \
  141|    968|    return options->ns##name; \
  142|    968|} \
tox_options_set_operating_system:
  143|    971|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|    971|{ \
  145|    971|    options->ns##name = name; \
  146|    971|}
tox_options_default:
  180|    971|{
  181|    971|    if (options != nullptr) {
  ------------------
  |  |   66|    971|#define nullptr NULL
  ------------------
  |  Branch (181:9): [True: 971, False: 0]
  ------------------
  182|    971|        const struct Tox_Options default_options = {0};
  183|    971|        *options = default_options;
  184|    971|        tox_options_set_ipv6_enabled(options, true);
  185|    971|        tox_options_set_udp_enabled(options, true);
  186|    971|        tox_options_set_proxy_type(options, TOX_PROXY_TYPE_NONE);
  187|    971|        tox_options_set_hole_punching_enabled(options, true);
  188|    971|        tox_options_set_local_discovery_enabled(options, true);
  189|    971|        tox_options_set_dht_announcements_enabled(options, true);
  190|    971|        tox_options_set_experimental_thread_safety(options, false);
  191|    971|    }
  192|    971|}
tox_options_new:
  195|    971|{
  196|    971|    struct Tox_Options *options = (struct Tox_Options *)calloc(1, sizeof(struct Tox_Options));
  197|       |
  198|    971|    if (options != nullptr) {
  ------------------
  |  |   66|    971|#define nullptr NULL
  ------------------
  |  Branch (198:9): [True: 971, False: 0]
  ------------------
  199|    971|        tox_options_default(options);
  200|    971|        SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_OK);
  ------------------
  |  |   13|    971|    do {                              \
  |  |   14|    971|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|  1.94k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (14:13): [True: 0, False: 971]
  |  |  ------------------
  |  |   15|      0|            *param = x;               \
  |  |   16|      0|        }                             \
  |  |   17|    971|    } while (0)
  |  |  ------------------
  |  |  |  Branch (17:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  201|    971|        return options;
  202|    971|    }
  203|       |
  204|      0|    SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_MALLOC);
  ------------------
  |  |   13|      0|    do {                              \
  |  |   14|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (14:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   15|      0|            *param = x;               \
  |  |   16|      0|        }                             \
  |  |   17|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (17:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  205|      0|    return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  206|    971|}
tox_options_free:
  209|  1.93k|{
  210|  1.93k|    free(options);
  211|  1.93k|}

tox_dispatch_new:
   36|    933|{
   37|    933|    Tox_Dispatch *dispatch = (Tox_Dispatch *)calloc(1, sizeof(Tox_Dispatch));
   38|       |
   39|    933|    if (dispatch == nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (39:9): [True: 0, False: 933]
  ------------------
   40|      0|        if (error != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (40:13): [True: 0, False: 0]
  ------------------
   41|      0|            *error = TOX_ERR_DISPATCH_NEW_MALLOC;
   42|      0|        }
   43|       |
   44|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   45|      0|    }
   46|       |
   47|    933|    *dispatch = (Tox_Dispatch) {
   48|    933|        nullptr
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
   49|    933|    };
   50|       |
   51|    933|    if (error != nullptr) {
  ------------------
  |  |   66|    933|#define nullptr NULL
  ------------------
  |  Branch (51:9): [True: 0, False: 933]
  ------------------
   52|      0|        *error = TOX_ERR_DISPATCH_NEW_OK;
   53|      0|    }
   54|       |
   55|    933|    return dispatch;
   56|    933|}
tox_dispatch_free:
   59|    933|{
   60|    933|    free(dispatch);
   61|    933|}
tox_events_callback_conference_connected:
   65|  1.86k|{
   66|  1.86k|    dispatch->conference_connected_callback = callback;
   67|  1.86k|}
tox_events_callback_conference_invite:
   70|    933|{
   71|    933|    dispatch->conference_invite_callback = callback;
   72|    933|}
tox_events_callback_conference_message:
   75|    933|{
   76|    933|    dispatch->conference_message_callback = callback;
   77|    933|}
tox_events_callback_conference_peer_list_changed:
   80|    933|{
   81|    933|    dispatch->conference_peer_list_changed_callback = callback;
   82|    933|}
tox_events_callback_conference_peer_name:
   85|    933|{
   86|    933|    dispatch->conference_peer_name_callback = callback;
   87|    933|}
tox_events_callback_conference_title:
   90|    933|{
   91|    933|    dispatch->conference_title_callback = callback;
   92|    933|}
tox_events_callback_file_chunk_request:
   95|    933|{
   96|    933|    dispatch->file_chunk_request_callback = callback;
   97|    933|}
tox_events_callback_file_recv:
  100|    933|{
  101|    933|    dispatch->file_recv_callback = callback;
  102|    933|}
tox_events_callback_file_recv_chunk:
  105|    933|{
  106|    933|    dispatch->file_recv_chunk_callback = callback;
  107|    933|}
tox_events_callback_file_recv_control:
  110|    933|{
  111|    933|    dispatch->file_recv_control_callback = callback;
  112|    933|}
tox_events_callback_friend_connection_status:
  115|    933|{
  116|    933|    dispatch->friend_connection_status_callback = callback;
  117|    933|}
tox_events_callback_friend_lossless_packet:
  120|    933|{
  121|    933|    dispatch->friend_lossless_packet_callback = callback;
  122|    933|}
tox_events_callback_friend_lossy_packet:
  125|    933|{
  126|    933|    dispatch->friend_lossy_packet_callback = callback;
  127|    933|}
tox_events_callback_friend_message:
  130|    933|{
  131|    933|    dispatch->friend_message_callback = callback;
  132|    933|}
tox_events_callback_friend_name:
  135|    933|{
  136|    933|    dispatch->friend_name_callback = callback;
  137|    933|}
tox_events_callback_friend_read_receipt:
  140|    933|{
  141|    933|    dispatch->friend_read_receipt_callback = callback;
  142|    933|}
tox_events_callback_friend_request:
  145|    933|{
  146|    933|    dispatch->friend_request_callback = callback;
  147|    933|}
tox_events_callback_friend_status:
  150|    933|{
  151|    933|    dispatch->friend_status_callback = callback;
  152|    933|}
tox_events_callback_friend_status_message:
  155|    933|{
  156|    933|    dispatch->friend_status_message_callback = callback;
  157|    933|}
tox_events_callback_friend_typing:
  160|    933|{
  161|    933|    dispatch->friend_typing_callback = callback;
  162|    933|}
tox_events_callback_self_connection_status:
  165|    933|{
  166|    933|    dispatch->self_connection_status_callback = callback;
  167|    933|}
tox_dispatch_invoke:
  464|  72.6k|{
  465|  72.6k|    tox_dispatch_invoke_conference_connected(dispatch, events, tox, user_data);
  466|  72.6k|    tox_dispatch_invoke_conference_invite(dispatch, events, tox, user_data);
  467|  72.6k|    tox_dispatch_invoke_conference_message(dispatch, events, tox, user_data);
  468|  72.6k|    tox_dispatch_invoke_conference_peer_list_changed(dispatch, events, tox, user_data);
  469|  72.6k|    tox_dispatch_invoke_conference_peer_name(dispatch, events, tox, user_data);
  470|  72.6k|    tox_dispatch_invoke_conference_title(dispatch, events, tox, user_data);
  471|  72.6k|    tox_dispatch_invoke_file_chunk_request(dispatch, events, tox, user_data);
  472|  72.6k|    tox_dispatch_invoke_file_recv(dispatch, events, tox, user_data);
  473|  72.6k|    tox_dispatch_invoke_file_recv_chunk(dispatch, events, tox, user_data);
  474|  72.6k|    tox_dispatch_invoke_file_recv_control(dispatch, events, tox, user_data);
  475|  72.6k|    tox_dispatch_invoke_friend_connection_status(dispatch, events, tox, user_data);
  476|  72.6k|    tox_dispatch_invoke_friend_lossless_packet(dispatch, events, tox, user_data);
  477|  72.6k|    tox_dispatch_invoke_friend_lossy_packet(dispatch, events, tox, user_data);
  478|  72.6k|    tox_dispatch_invoke_friend_message(dispatch, events, tox, user_data);
  479|  72.6k|    tox_dispatch_invoke_friend_name(dispatch, events, tox, user_data);
  480|  72.6k|    tox_dispatch_invoke_friend_read_receipt(dispatch, events, tox, user_data);
  481|  72.6k|    tox_dispatch_invoke_friend_request(dispatch, events, tox, user_data);
  482|  72.6k|    tox_dispatch_invoke_friend_status(dispatch, events, tox, user_data);
  483|  72.6k|    tox_dispatch_invoke_friend_status_message(dispatch, events, tox, user_data);
  484|  72.6k|    tox_dispatch_invoke_friend_typing(dispatch, events, tox, user_data);
  485|  72.6k|    tox_dispatch_invoke_self_connection_status(dispatch, events, tox, user_data);
  486|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_conference_connected:
  172|  72.6k|{
  173|  72.6k|    const uint32_t size = tox_events_get_conference_connected_size(events);
  174|       |
  175|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (175:26): [True: 0, False: 72.6k]
  ------------------
  176|      0|        if (dispatch->conference_connected_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (176:13): [True: 0, False: 0]
  ------------------
  177|      0|            dispatch->conference_connected_callback(
  178|      0|                tox, tox_events_get_conference_connected(events, i), user_data);
  179|      0|        }
  180|      0|    }
  181|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_conference_invite:
  186|  72.6k|{
  187|  72.6k|    const uint32_t size = tox_events_get_conference_invite_size(events);
  188|       |
  189|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (189:26): [True: 0, False: 72.6k]
  ------------------
  190|      0|        if (dispatch->conference_invite_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (190:13): [True: 0, False: 0]
  ------------------
  191|      0|            dispatch->conference_invite_callback(
  192|      0|                tox, tox_events_get_conference_invite(events, i), user_data);
  193|      0|        }
  194|      0|    }
  195|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_conference_message:
  200|  72.6k|{
  201|  72.6k|    const uint32_t size = tox_events_get_conference_message_size(events);
  202|       |
  203|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (203:26): [True: 0, False: 72.6k]
  ------------------
  204|      0|        if (dispatch->conference_message_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (204:13): [True: 0, False: 0]
  ------------------
  205|      0|            dispatch->conference_message_callback(
  206|      0|                tox, tox_events_get_conference_message(events, i), user_data);
  207|      0|        }
  208|      0|    }
  209|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_conference_peer_list_changed:
  214|  72.6k|{
  215|  72.6k|    const uint32_t size = tox_events_get_conference_peer_list_changed_size(events);
  216|       |
  217|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (217:26): [True: 0, False: 72.6k]
  ------------------
  218|      0|        if (dispatch->conference_peer_list_changed_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (218:13): [True: 0, False: 0]
  ------------------
  219|      0|            dispatch->conference_peer_list_changed_callback(
  220|      0|                tox, tox_events_get_conference_peer_list_changed(events, i), user_data);
  221|      0|        }
  222|      0|    }
  223|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_conference_peer_name:
  228|  72.6k|{
  229|  72.6k|    const uint32_t size = tox_events_get_conference_peer_name_size(events);
  230|       |
  231|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (231:26): [True: 0, False: 72.6k]
  ------------------
  232|      0|        if (dispatch->conference_peer_name_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (232:13): [True: 0, False: 0]
  ------------------
  233|      0|            dispatch->conference_peer_name_callback(
  234|      0|                tox, tox_events_get_conference_peer_name(events, i), user_data);
  235|      0|        }
  236|      0|    }
  237|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_conference_title:
  242|  72.6k|{
  243|  72.6k|    const uint32_t size = tox_events_get_conference_title_size(events);
  244|       |
  245|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (245:26): [True: 0, False: 72.6k]
  ------------------
  246|      0|        if (dispatch->conference_title_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (246:13): [True: 0, False: 0]
  ------------------
  247|      0|            dispatch->conference_title_callback(
  248|      0|                tox, tox_events_get_conference_title(events, i), user_data);
  249|      0|        }
  250|      0|    }
  251|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_file_chunk_request:
  256|  72.6k|{
  257|  72.6k|    const uint32_t size = tox_events_get_file_chunk_request_size(events);
  258|       |
  259|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (259:26): [True: 0, False: 72.6k]
  ------------------
  260|      0|        if (dispatch->file_chunk_request_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (260:13): [True: 0, False: 0]
  ------------------
  261|      0|            dispatch->file_chunk_request_callback(
  262|      0|                tox, tox_events_get_file_chunk_request(events, i), user_data);
  263|      0|        }
  264|      0|    }
  265|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_file_recv:
  270|  72.6k|{
  271|  72.6k|    const uint32_t size = tox_events_get_file_recv_size(events);
  272|       |
  273|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (273:26): [True: 0, False: 72.6k]
  ------------------
  274|      0|        if (dispatch->file_recv_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (274:13): [True: 0, False: 0]
  ------------------
  275|      0|            dispatch->file_recv_callback(
  276|      0|                tox, tox_events_get_file_recv(events, i), user_data);
  277|      0|        }
  278|      0|    }
  279|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_file_recv_chunk:
  284|  72.6k|{
  285|  72.6k|    const uint32_t size = tox_events_get_file_recv_chunk_size(events);
  286|       |
  287|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (287:26): [True: 0, False: 72.6k]
  ------------------
  288|      0|        if (dispatch->file_recv_chunk_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (288:13): [True: 0, False: 0]
  ------------------
  289|      0|            dispatch->file_recv_chunk_callback(
  290|      0|                tox, tox_events_get_file_recv_chunk(events, i), user_data);
  291|      0|        }
  292|      0|    }
  293|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_file_recv_control:
  298|  72.6k|{
  299|  72.6k|    const uint32_t size = tox_events_get_file_recv_control_size(events);
  300|       |
  301|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (301:26): [True: 0, False: 72.6k]
  ------------------
  302|      0|        if (dispatch->file_recv_control_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (302:13): [True: 0, False: 0]
  ------------------
  303|      0|            dispatch->file_recv_control_callback(
  304|      0|                tox, tox_events_get_file_recv_control(events, i), user_data);
  305|      0|        }
  306|      0|    }
  307|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_friend_connection_status:
  312|  72.6k|{
  313|  72.6k|    const uint32_t size = tox_events_get_friend_connection_status_size(events);
  314|       |
  315|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (315:26): [True: 0, False: 72.6k]
  ------------------
  316|      0|        if (dispatch->friend_connection_status_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (316:13): [True: 0, False: 0]
  ------------------
  317|      0|            dispatch->friend_connection_status_callback(
  318|      0|                tox, tox_events_get_friend_connection_status(events, i), user_data);
  319|      0|        }
  320|      0|    }
  321|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_friend_lossless_packet:
  326|  72.6k|{
  327|  72.6k|    const uint32_t size = tox_events_get_friend_lossless_packet_size(events);
  328|       |
  329|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (329:26): [True: 0, False: 72.6k]
  ------------------
  330|      0|        if (dispatch->friend_lossless_packet_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (330:13): [True: 0, False: 0]
  ------------------
  331|      0|            dispatch->friend_lossless_packet_callback(
  332|      0|                tox, tox_events_get_friend_lossless_packet(events, i), user_data);
  333|      0|        }
  334|      0|    }
  335|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_friend_lossy_packet:
  340|  72.6k|{
  341|  72.6k|    const uint32_t size = tox_events_get_friend_lossy_packet_size(events);
  342|       |
  343|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (343:26): [True: 0, False: 72.6k]
  ------------------
  344|      0|        if (dispatch->friend_lossy_packet_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (344:13): [True: 0, False: 0]
  ------------------
  345|      0|            dispatch->friend_lossy_packet_callback(
  346|      0|                tox, tox_events_get_friend_lossy_packet(events, i), user_data);
  347|      0|        }
  348|      0|    }
  349|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_friend_message:
  354|  72.6k|{
  355|  72.6k|    const uint32_t size = tox_events_get_friend_message_size(events);
  356|       |
  357|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (357:26): [True: 0, False: 72.6k]
  ------------------
  358|      0|        if (dispatch->friend_message_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (358:13): [True: 0, False: 0]
  ------------------
  359|      0|            dispatch->friend_message_callback(
  360|      0|                tox, tox_events_get_friend_message(events, i), user_data);
  361|      0|        }
  362|      0|    }
  363|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_friend_name:
  368|  72.6k|{
  369|  72.6k|    const uint32_t size = tox_events_get_friend_name_size(events);
  370|       |
  371|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (371:26): [True: 0, False: 72.6k]
  ------------------
  372|      0|        if (dispatch->friend_name_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (372:13): [True: 0, False: 0]
  ------------------
  373|      0|            dispatch->friend_name_callback(
  374|      0|                tox, tox_events_get_friend_name(events, i), user_data);
  375|      0|        }
  376|      0|    }
  377|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_friend_read_receipt:
  382|  72.6k|{
  383|  72.6k|    const uint32_t size = tox_events_get_friend_read_receipt_size(events);
  384|       |
  385|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (385:26): [True: 0, False: 72.6k]
  ------------------
  386|      0|        if (dispatch->friend_read_receipt_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (386:13): [True: 0, False: 0]
  ------------------
  387|      0|            dispatch->friend_read_receipt_callback(
  388|      0|                tox, tox_events_get_friend_read_receipt(events, i), user_data);
  389|      0|        }
  390|      0|    }
  391|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_friend_request:
  396|  72.6k|{
  397|  72.6k|    const uint32_t size = tox_events_get_friend_request_size(events);
  398|       |
  399|  72.8k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (399:26): [True: 128, False: 72.6k]
  ------------------
  400|    128|        if (dispatch->friend_request_callback != nullptr) {
  ------------------
  |  |   66|    128|#define nullptr NULL
  ------------------
  |  Branch (400:13): [True: 128, False: 0]
  ------------------
  401|    128|            dispatch->friend_request_callback(
  402|    128|                tox, tox_events_get_friend_request(events, i), user_data);
  403|    128|        }
  404|    128|    }
  405|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_friend_status:
  410|  72.6k|{
  411|  72.6k|    const uint32_t size = tox_events_get_friend_status_size(events);
  412|       |
  413|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (413:26): [True: 0, False: 72.6k]
  ------------------
  414|      0|        if (dispatch->friend_status_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (414:13): [True: 0, False: 0]
  ------------------
  415|      0|            dispatch->friend_status_callback(
  416|      0|                tox, tox_events_get_friend_status(events, i), user_data);
  417|      0|        }
  418|      0|    }
  419|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_friend_status_message:
  424|  72.6k|{
  425|  72.6k|    const uint32_t size = tox_events_get_friend_status_message_size(events);
  426|       |
  427|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (427:26): [True: 0, False: 72.6k]
  ------------------
  428|      0|        if (dispatch->friend_status_message_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (428:13): [True: 0, False: 0]
  ------------------
  429|      0|            dispatch->friend_status_message_callback(
  430|      0|                tox, tox_events_get_friend_status_message(events, i), user_data);
  431|      0|        }
  432|      0|    }
  433|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_friend_typing:
  438|  72.6k|{
  439|  72.6k|    const uint32_t size = tox_events_get_friend_typing_size(events);
  440|       |
  441|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (441:26): [True: 0, False: 72.6k]
  ------------------
  442|      0|        if (dispatch->friend_typing_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (442:13): [True: 0, False: 0]
  ------------------
  443|      0|            dispatch->friend_typing_callback(
  444|      0|                tox, tox_events_get_friend_typing(events, i), user_data);
  445|      0|        }
  446|      0|    }
  447|  72.6k|}
tox_dispatch.c:tox_dispatch_invoke_self_connection_status:
  452|  72.6k|{
  453|  72.6k|    const uint32_t size = tox_events_get_self_connection_status_size(events);
  454|       |
  455|  72.6k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (455:26): [True: 0, False: 72.6k]
  ------------------
  456|      0|        if (dispatch->self_connection_status_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (456:13): [True: 0, False: 0]
  ------------------
  457|      0|            dispatch->self_connection_status_callback(
  458|      0|                tox, tox_events_get_self_connection_status(events, i), user_data);
  459|      0|        }
  460|      0|    }
  461|  72.6k|}

tox_events_init:
   28|    933|{
   29|    933|    tox_callback_conference_connected(tox, tox_events_handle_conference_connected);
   30|    933|    tox_callback_conference_invite(tox, tox_events_handle_conference_invite);
   31|    933|    tox_callback_conference_message(tox, tox_events_handle_conference_message);
   32|    933|    tox_callback_conference_peer_list_changed(tox, tox_events_handle_conference_peer_list_changed);
   33|    933|    tox_callback_conference_peer_name(tox, tox_events_handle_conference_peer_name);
   34|    933|    tox_callback_conference_title(tox, tox_events_handle_conference_title);
   35|    933|    tox_callback_file_chunk_request(tox, tox_events_handle_file_chunk_request);
   36|    933|    tox_callback_file_recv_chunk(tox, tox_events_handle_file_recv_chunk);
   37|    933|    tox_callback_file_recv_control(tox, tox_events_handle_file_recv_control);
   38|    933|    tox_callback_file_recv(tox, tox_events_handle_file_recv);
   39|    933|    tox_callback_friend_connection_status(tox, tox_events_handle_friend_connection_status);
   40|    933|    tox_callback_friend_lossless_packet(tox, tox_events_handle_friend_lossless_packet);
   41|    933|    tox_callback_friend_lossy_packet(tox, tox_events_handle_friend_lossy_packet);
   42|    933|    tox_callback_friend_message(tox, tox_events_handle_friend_message);
   43|    933|    tox_callback_friend_name(tox, tox_events_handle_friend_name);
   44|    933|    tox_callback_friend_read_receipt(tox, tox_events_handle_friend_read_receipt);
   45|    933|    tox_callback_friend_request(tox, tox_events_handle_friend_request);
   46|    933|    tox_callback_friend_status_message(tox, tox_events_handle_friend_status_message);
   47|    933|    tox_callback_friend_status(tox, tox_events_handle_friend_status);
   48|    933|    tox_callback_friend_typing(tox, tox_events_handle_friend_typing);
   49|    933|    tox_callback_self_connection_status(tox, tox_events_handle_self_connection_status);
   50|    933|}
tox_events_iterate:
   53|  72.6k|{
   54|  72.6k|    Tox_Events_State state = {TOX_ERR_EVENTS_ITERATE_OK};
   55|  72.6k|    tox_iterate(tox, &state);
   56|       |
   57|  72.6k|    if (error != nullptr) {
  ------------------
  |  |   66|  72.6k|#define nullptr NULL
  ------------------
  |  Branch (57:9): [True: 72.6k, False: 0]
  ------------------
   58|  72.6k|        *error = state.error;
   59|  72.6k|    }
   60|       |
   61|  72.6k|    if (fail_hard && state.error != TOX_ERR_EVENTS_ITERATE_OK) {
  ------------------
  |  Branch (61:9): [True: 72.6k, False: 0]
  |  Branch (61:22): [True: 0, False: 72.6k]
  ------------------
   62|      0|        tox_events_free(state.events);
   63|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   64|      0|    }
   65|       |
   66|  72.6k|    return state.events;
   67|  72.6k|}
tox_events_pack:
   70|   290k|{
   71|   290k|    const uint32_t count = tox_events_get_conference_connected_size(events)
   72|   290k|                           + tox_events_get_conference_invite_size(events)
   73|   290k|                           + tox_events_get_conference_message_size(events)
   74|   290k|                           + tox_events_get_conference_peer_list_changed_size(events)
   75|   290k|                           + tox_events_get_conference_peer_name_size(events)
   76|   290k|                           + tox_events_get_conference_title_size(events)
   77|   290k|                           + tox_events_get_file_chunk_request_size(events)
   78|   290k|                           + tox_events_get_file_recv_chunk_size(events)
   79|   290k|                           + tox_events_get_file_recv_control_size(events)
   80|   290k|                           + tox_events_get_file_recv_size(events)
   81|   290k|                           + tox_events_get_friend_connection_status_size(events)
   82|   290k|                           + tox_events_get_friend_lossless_packet_size(events)
   83|   290k|                           + tox_events_get_friend_lossy_packet_size(events)
   84|   290k|                           + tox_events_get_friend_message_size(events)
   85|   290k|                           + tox_events_get_friend_name_size(events)
   86|   290k|                           + tox_events_get_friend_read_receipt_size(events)
   87|   290k|                           + tox_events_get_friend_request_size(events)
   88|   290k|                           + tox_events_get_friend_status_message_size(events)
   89|   290k|                           + tox_events_get_friend_status_size(events)
   90|   290k|                           + tox_events_get_friend_typing_size(events)
   91|   290k|                           + tox_events_get_self_connection_status_size(events);
   92|       |
   93|   290k|    return bin_pack_array(bp, count)
  ------------------
  |  Branch (93:12): [True: 290k, False: 0]
  ------------------
   94|   290k|           && tox_events_pack_conference_connected(events, bp)
  ------------------
  |  Branch (94:15): [True: 290k, False: 0]
  ------------------
   95|   290k|           && tox_events_pack_conference_invite(events, bp)
  ------------------
  |  Branch (95:15): [True: 290k, False: 0]
  ------------------
   96|   290k|           && tox_events_pack_conference_message(events, bp)
  ------------------
  |  Branch (96:15): [True: 290k, False: 0]
  ------------------
   97|   290k|           && tox_events_pack_conference_peer_list_changed(events, bp)
  ------------------
  |  Branch (97:15): [True: 290k, False: 0]
  ------------------
   98|   290k|           && tox_events_pack_conference_peer_name(events, bp)
  ------------------
  |  Branch (98:15): [True: 290k, False: 0]
  ------------------
   99|   290k|           && tox_events_pack_conference_title(events, bp)
  ------------------
  |  Branch (99:15): [True: 290k, False: 0]
  ------------------
  100|   290k|           && tox_events_pack_file_chunk_request(events, bp)
  ------------------
  |  Branch (100:15): [True: 290k, False: 0]
  ------------------
  101|   290k|           && tox_events_pack_file_recv_chunk(events, bp)
  ------------------
  |  Branch (101:15): [True: 290k, False: 0]
  ------------------
  102|   290k|           && tox_events_pack_file_recv_control(events, bp)
  ------------------
  |  Branch (102:15): [True: 290k, False: 0]
  ------------------
  103|   290k|           && tox_events_pack_file_recv(events, bp)
  ------------------
  |  Branch (103:15): [True: 290k, False: 0]
  ------------------
  104|   290k|           && tox_events_pack_friend_connection_status(events, bp)
  ------------------
  |  Branch (104:15): [True: 290k, False: 0]
  ------------------
  105|   290k|           && tox_events_pack_friend_lossless_packet(events, bp)
  ------------------
  |  Branch (105:15): [True: 290k, False: 0]
  ------------------
  106|   290k|           && tox_events_pack_friend_lossy_packet(events, bp)
  ------------------
  |  Branch (106:15): [True: 290k, False: 0]
  ------------------
  107|   290k|           && tox_events_pack_friend_message(events, bp)
  ------------------
  |  Branch (107:15): [True: 290k, False: 0]
  ------------------
  108|   290k|           && tox_events_pack_friend_name(events, bp)
  ------------------
  |  Branch (108:15): [True: 290k, False: 0]
  ------------------
  109|   290k|           && tox_events_pack_friend_read_receipt(events, bp)
  ------------------
  |  Branch (109:15): [True: 290k, False: 0]
  ------------------
  110|   290k|           && tox_events_pack_friend_request(events, bp)
  ------------------
  |  Branch (110:15): [True: 290k, False: 0]
  ------------------
  111|   290k|           && tox_events_pack_friend_status_message(events, bp)
  ------------------
  |  Branch (111:15): [True: 290k, False: 0]
  ------------------
  112|   290k|           && tox_events_pack_friend_status(events, bp)
  ------------------
  |  Branch (112:15): [True: 290k, False: 0]
  ------------------
  113|   290k|           && tox_events_pack_friend_typing(events, bp)
  ------------------
  |  Branch (113:15): [True: 290k, False: 0]
  ------------------
  114|   290k|           && tox_events_pack_self_connection_status(events, bp);
  ------------------
  |  Branch (114:15): [True: 290k, False: 0]
  ------------------
  115|   290k|}
tox_events_bytes_size:
  228|   145k|{
  229|   145k|    return bin_pack_obj_size(tox_events_bin_pack_handler, events);
  230|   145k|}
tox_events_get_bytes:
  233|   145k|{
  234|   145k|    bin_pack_obj(tox_events_bin_pack_handler, events, bytes, UINT32_MAX);
  235|   145k|}
tox_events_equal:
  267|  72.6k|{
  268|  72.6k|    assert(sys != nullptr);
  269|      0|    assert(sys->mem != nullptr);
  270|       |
  271|      0|    const uint32_t a_size = tox_events_bytes_size(a);
  272|  72.6k|    const uint32_t b_size = tox_events_bytes_size(b);
  273|       |
  274|  72.6k|    if (a_size != b_size) {
  ------------------
  |  Branch (274:9): [True: 0, False: 72.6k]
  ------------------
  275|      0|        return false;
  276|      0|    }
  277|       |
  278|  72.6k|    uint8_t *a_bytes = (uint8_t *)mem_balloc(sys->mem, a_size);
  279|  72.6k|    uint8_t *b_bytes = (uint8_t *)mem_balloc(sys->mem, b_size);
  280|       |
  281|  72.6k|    if (a_bytes == nullptr || b_bytes == nullptr) {
  ------------------
  |  |   66|   145k|#define nullptr NULL
  ------------------
                  if (a_bytes == nullptr || b_bytes == nullptr) {
  ------------------
  |  |   66|  72.6k|#define nullptr NULL
  ------------------
  |  Branch (281:9): [True: 0, False: 72.6k]
  |  Branch (281:31): [True: 0, False: 72.6k]
  ------------------
  282|      0|        mem_delete(sys->mem, b_bytes);
  283|      0|        mem_delete(sys->mem, a_bytes);
  284|      0|        return false;
  285|      0|    }
  286|       |
  287|  72.6k|    tox_events_get_bytes(a, a_bytes);
  288|  72.6k|    tox_events_get_bytes(b, b_bytes);
  289|       |
  290|  72.6k|    const bool ret = memcmp(a_bytes, b_bytes, a_size) == 0;
  291|       |
  292|  72.6k|    mem_delete(sys->mem, b_bytes);
  293|  72.6k|    mem_delete(sys->mem, a_bytes);
  294|       |
  295|  72.6k|    return ret;
  296|  72.6k|}
tox_events.c:tox_events_bin_pack_handler:
  223|   290k|{
  224|   290k|    return tox_events_pack((const Tox_Events *)obj, bp);
  225|   290k|}

tox_default_system:
   26|    968|{
   27|    968|    const Tox_System sys = {
   28|    968|        nullptr,  // mono_time_callback
  ------------------
  |  |   66|    968|#define nullptr NULL
  ------------------
   29|    968|        nullptr,  // mono_time_user_data
  ------------------
  |  |   66|    968|#define nullptr NULL
  ------------------
   30|    968|        system_random(),
   31|    968|        system_network(),
   32|    968|        system_memory(),
   33|    968|    };
   34|    968|    return sys;
   35|    968|}
tox_lock:
   38|  75.5k|{
   39|  75.5k|    if (tox->mutex != nullptr) {
  ------------------
  |  |   66|  75.5k|#define nullptr NULL
  ------------------
  |  Branch (39:9): [True: 0, False: 75.5k]
  ------------------
   40|      0|        pthread_mutex_lock(tox->mutex);
   41|      0|    }
   42|  75.5k|}
tox_unlock:
   45|  75.5k|{
   46|  75.5k|    if (tox->mutex != nullptr) {
  ------------------
  |  |   66|  75.5k|#define nullptr NULL
  ------------------
  |  Branch (46:9): [True: 0, False: 75.5k]
  ------------------
   47|      0|        pthread_mutex_unlock(tox->mutex);
   48|      0|    }
   49|  75.5k|}

create_recursive_mutex:
   56|    946|{
   57|    946|    pthread_mutexattr_t attr;
   58|       |
   59|    946|    if (pthread_mutexattr_init(&attr) != 0) {
  ------------------
  |  Branch (59:9): [True: 0, False: 946]
  ------------------
   60|      0|        return -1;
   61|      0|    }
   62|       |
   63|    946|    if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE) != 0) {
  ------------------
  |  Branch (63:9): [True: 0, False: 946]
  ------------------
   64|      0|        pthread_mutexattr_destroy(&attr);
   65|      0|        return -1;
   66|      0|    }
   67|       |
   68|       |    /* Create queue mutex */
   69|    946|    if (pthread_mutex_init(mutex, &attr) != 0) {
  ------------------
  |  Branch (69:9): [True: 0, False: 946]
  ------------------
   70|      0|        pthread_mutexattr_destroy(&attr);
   71|      0|        return -1;
   72|      0|    }
   73|       |
   74|    946|    pthread_mutexattr_destroy(&attr);
   75|       |
   76|    946|    return 0;
   77|    946|}
max_s32:
   89|  50.4k|{
   90|  50.4k|    return a > b ? a : b;
  ------------------
  |  Branch (90:12): [True: 0, False: 50.4k]
  ------------------
   91|  50.4k|}
min_s32:
  102|  50.4k|{
  103|  50.4k|    return a < b ? a : b;
  ------------------
  |  Branch (103:12): [True: 50.4k, False: 0]
  ------------------
  104|  50.4k|}
max_u32:
  115|     22|{
  116|     22|    return a > b ? a : b;
  ------------------
  |  Branch (116:12): [True: 1, False: 21]
  ------------------
  117|     22|}
min_u16:
  124|  14.9k|{
  125|  14.9k|    return a < b ? a : b;
  ------------------
  |  Branch (125:12): [True: 14.7k, False: 241]
  ------------------
  126|  14.9k|}
min_u32:
  128|     22|{
  129|     22|    return a < b ? a : b;
  ------------------
  |  Branch (129:12): [True: 13, False: 9]
  ------------------
  130|     22|}
min_u64:
  132|     22|{
  133|     22|    return a < b ? a : b;
  ------------------
  |  Branch (133:12): [True: 0, False: 22]
  ------------------
  134|     22|}

