fuzz_support.cc:_ZZN6detail15func_conversionIPFmP11Fuzz_SystemEXadL_ZN3$_08__invokeES2_EEEcvPFT_T0_DpT1_EImPvJEEEvENKUlSE_DpT_E_clIJEEEDaSE_SG_:
   31|  2.14k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFmP11Fuzz_SystemEXadL_ZN3$_08__invokeES2_EEE13static_casterIPvEcvT_IS2_EEv:
   22|  2.14k|        {
   23|  2.14k|            return static_cast<To>(obj);
   24|  2.14k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Null_SystemjjEXadL_ZN4$_218__invokeES3_jjEEEcvPFT_T0_DpT1_EIS1_S1_JjjEEEvENKUlS1_DpT_E_clIJjjEEEDaS1_SG_:
   31|  70.7k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Null_SystemjjEXadL_ZN4$_218__invokeES3_jjEEE13static_casterIS1_EcvT_IS3_EEv:
   22|  70.7k|        {
   23|  70.7k|            return static_cast<To>(obj);
   24|  70.7k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Null_SystemS1_jEXadL_ZN4$_228__invokeES3_S1_jEEEcvPFT_T0_DpT1_EIS1_S1_JS1_jEEEvENKUlS1_DpT_E_clIJS1_jEEEDaS1_SG_:
   31|  24.1k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Null_SystemS1_jEXadL_ZN4$_228__invokeES3_S1_jEEE13static_casterIS1_EcvT_IS3_EEv:
   22|  24.1k|        {
   23|  24.1k|            return static_cast<To>(obj);
   24|  24.1k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Null_SystemPvEXadL_ZN4$_238__invokeES2_S3_EEEcvPFT_T0_DpT1_EIvS3_JS3_EEEvENKUlS3_DpT_E_clIJS3_EEEDaS3_SG_:
   31|  87.5k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Null_SystemPvEXadL_ZN4$_238__invokeES2_S3_EEE13static_casterIS3_EcvT_IS2_EEv:
   22|  87.5k|        {
   23|  87.5k|            return static_cast<To>(obj);
   24|  87.5k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Null_SystemiEXadL_ZN4$_248__invokeES2_iEEEcvPFT_T0_DpT1_EIiPvJiEEEvENKUlSE_DpT_E_clIJiEEEDaSE_SG_:
   31|  2.14k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Null_SystemiEXadL_ZN4$_248__invokeES2_iEEE13static_casterIPvEcvT_IS2_EEv:
   22|  2.14k|        {
   23|  2.14k|            return static_cast<To>(obj);
   24|  2.14k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Null_SystemiPK12Network_AddrEXadL_ZN4$_268__invokeES2_iS5_EEEcvPFT_T0_DpT1_EIiPvJiS5_EEEvENKUlSH_DpT_E_clIJiS5_EEEDaSH_SJ_:
   31|  2.14k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Null_SystemiPK12Network_AddrEXadL_ZN4$_268__invokeES2_iS5_EEE13static_casterIPvEcvT_IS2_EEv:
   22|  2.14k|        {
   23|  2.14k|            return static_cast<To>(obj);
   24|  2.14k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Null_SystemiiiEXadL_ZN4$_338__invokeES2_iiiEEEcvPFT_T0_DpT1_EIiPvJiiiEEEvENKUlSE_DpT_E_clIJiiiEEEDaSE_SG_:
   31|  2.14k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Null_SystemiiiEXadL_ZN4$_338__invokeES2_iiiEEE13static_casterIPvEcvT_IS2_EEv:
   22|  2.14k|        {
   23|  2.14k|            return static_cast<To>(obj);
   24|  2.14k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Null_SystemibEXadL_ZN4$_348__invokeES2_ibEEEcvPFT_T0_DpT1_EIiPvJibEEEvENKUlSE_DpT_E_clIJibEEEDaSE_SG_:
   31|  2.14k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Null_SystemibEXadL_ZN4$_348__invokeES2_ibEEE13static_casterIPvEcvT_IS2_EEv:
   22|  2.14k|        {
   23|  2.14k|            return static_cast<To>(obj);
   24|  2.14k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Null_SystemiiiPvPmEXadL_ZN4$_358__invokeES2_iiiS3_S4_EEEcvPFT_T0_DpT1_EIiS3_JiiiS3_S4_EEEvENKUlS3_DpT_E_clIJiiiS3_S4_EEEDaS3_SH_:
   31|  2.14k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Null_SystemiiiPvPmEXadL_ZN4$_358__invokeES2_iiiS3_S4_EEE13static_casterIS3_EcvT_IS2_EEv:
   22|  2.14k|        {
   23|  2.14k|            return static_cast<To>(obj);
   24|  2.14k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Null_SystemiiiPKvmEXadL_ZN4$_368__invokeES2_iiiS4_mEEEcvPFT_T0_DpT1_EIiPvJiiiS4_mEEEvENKUlSG_DpT_E_clIJiiiS4_mEEEDaSG_SI_:
   31|  8.56k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Null_SystemiiiPKvmEXadL_ZN4$_368__invokeES2_iiiS4_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|  8.56k|        {
   23|  8.56k|            return static_cast<To>(obj);
   24|  8.56k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Null_SystemPhmEXadL_ZN4$_378__invokeES2_S3_mEEEcvPFT_T0_DpT1_EIvPvJS3_mEEEvENKUlSF_DpT_E_clIJS3_mEEEDaSF_SH_:
   31|  32.0k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Null_SystemPhmEXadL_ZN4$_378__invokeES2_S3_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|  32.0k|        {
   23|  32.0k|            return static_cast<To>(obj);
   24|  32.0k|        }

_ZN6SystemD2Ev:
   33|  2.14k|System::~System() { }
_ZN11Null_SystemC2Ev:
  273|  2.14k|{
  274|  2.14k|    sys->mono_time_callback = get_self_clock;
  275|  2.14k|    sys->mono_time_user_data = this;
  276|  2.14k|    sys->mem = mem.get();
  277|  2.14k|    sys->ns = ns.get();
  278|  2.14k|    sys->rng = rng.get();
  279|  2.14k|}
fuzz_support.cc:_ZNK3$_0clEP11Fuzz_System:
   25|  2.14k|static constexpr tox_mono_time_cb *get_self_clock = ![](Fuzz_System *self) { return self->clock; };
fuzz_support.cc:_ZNK4$_21clEP11Null_Systemjj:
  198|  70.7k|    ![](Null_System *self, uint32_t nmemb, uint32_t size) { return std::calloc(nmemb, size); },
fuzz_support.cc:_ZNK4$_22clEP11Null_SystemPvj:
  200|  24.1k|    ![](Null_System *self, void *ptr, uint32_t size) { return std::realloc(ptr, size); },
fuzz_support.cc:_ZNK4$_23clEP11Null_SystemPv:
  202|  87.5k|    ![](Null_System *self, void *ptr) { std::free(ptr); },
fuzz_support.cc:_ZNK4$_24clEP11Null_Systemi:
  206|  2.14k|    /* .close = */ ![](Null_System *self, int sock) { return 0; },
fuzz_support.cc:_ZNK4$_26clEP11Null_SystemiPK12Network_Addr:
  208|  2.14k|    /* .bind = */ ![](Null_System *self, int sock, const Network_Addr *addr) { return 0; },
fuzz_support.cc:_ZNK4$_33clEP11Null_Systemiii:
  233|  2.14k|    /* .socket = */ ![](Null_System *self, int domain, int type, int proto) { return 42; },
fuzz_support.cc:_ZNK4$_34clEP11Null_Systemib:
  234|  2.14k|    /* .socket_nonblock = */ ![](Null_System *self, int sock, bool nonblock) { return 0; },
fuzz_support.cc:_ZNK4$_35clEP11Null_SystemiiiPvPm:
  236|  2.14k|    ![](Null_System *self, int sock, int level, int optname, void *optval, size_t *optlen) {
  237|  2.14k|        std::memset(optval, 0, *optlen);
  238|  2.14k|        return 0;
  239|  2.14k|    },
fuzz_support.cc:_ZNK4$_36clEP11Null_SystemiiiPKvm:
  241|  8.56k|    ![](Null_System *self, int sock, int level, int optname, const void *optval, size_t optlen) {
  242|  8.56k|        return 0;
  243|  8.56k|    },
fuzz_support.cc:_ZNK4$_37clEP11Null_SystemPhm:
  255|  32.0k|    ![](Null_System *self, uint8_t *bytes, size_t length) {
  256|   853k|        for (size_t i = 0; i < length; ++i) {
  ------------------
  |  Branch (256:28): [True: 821k, False: 32.0k]
  ------------------
  257|   821k|            bytes[i] = simple_rng(self->seed) & 0xff;
  258|   821k|        }
  259|  32.0k|    },
fuzz_support.cc:_ZL10simple_rngRm:
  247|   821k|{
  248|       |    // https://nuclear.llnl.gov/CNP/rng/rngman/node4.html
  249|   821k|    seed = 2862933555777941757LL * seed + 3037000493LL;
  250|   821k|    return seed;
  251|   821k|}

_ZN9Fuzz_DataC2EPKhm:
   24|  2.14k|    {}
_ZN9Fuzz_Data7consumeEm:
   38|  2.14k|    {
   39|  2.14k|        const uint8_t *val = data;
   40|  2.14k|        data += count;
   41|  2.14k|        size -= count;
   42|  2.14k|        return val;
   43|  2.14k|    }

LLVMFuzzerTestOneInput:
   48|  2.14k|{
   49|  2.14k|    Fuzz_Data input{data, size};
   50|  2.14k|    TestSaveDataLoading(input);
   51|  2.14k|    return 0;  // Non-zero return values are reserved for future use.
   52|  2.14k|}
toxsave_harness.cc:_ZN12_GLOBAL__N_119TestSaveDataLoadingER9Fuzz_Data:
   12|  2.14k|{
   13|  2.14k|    Tox_Err_Options_New error_options;
   14|       |
   15|  2.14k|    struct Tox_Options *tox_options = tox_options_new(&error_options);
   16|       |
   17|  2.14k|    assert(tox_options != nullptr);
   18|      0|    assert(error_options == TOX_ERR_OPTIONS_NEW_OK);
   19|       |
   20|      0|    const size_t savedata_size = input.size;
   21|  2.14k|    CONSUME_OR_RETURN(const uint8_t *savedata, input, savedata_size);
  ------------------
  |  |   91|  2.14k|    if (INPUT.size < SIZE) {                 \
  |  |  ------------------
  |  |  |  Branch (91:9): [True: 0, False: 2.14k]
  |  |  ------------------
  |  |   92|      0|        return;                              \
  |  |   93|      0|    }                                        \
  |  |   94|  2.14k|    DECL = INPUT.consume(SIZE)
  ------------------
   22|       |
   23|  2.14k|    Null_System sys;
   24|  2.14k|    tox_options_set_operating_system(tox_options, sys.sys.get());
   25|       |
   26|       |    // pass test data to Tox
   27|  2.14k|    tox_options_set_savedata_data(tox_options, savedata, savedata_size);
   28|  2.14k|    tox_options_set_savedata_type(tox_options, TOX_SAVEDATA_TYPE_TOX_SAVE);
   29|       |
   30|  2.14k|    Tox *tox = tox_new(tox_options, nullptr);
   31|  2.14k|    tox_options_free(tox_options);
   32|  2.14k|    if (tox == nullptr) {
  ------------------
  |  Branch (32:9): [True: 636, False: 1.50k]
  ------------------
   33|       |        // Tox save was invalid, we're finished here
   34|    636|        return;
   35|    636|    }
   36|       |
   37|       |    // verify that the file can be saved again
   38|  1.50k|    std::vector<uint8_t> new_savedata(tox_get_savedata_size(tox));
   39|  1.50k|    tox_get_savedata(tox, new_savedata.data());
   40|       |
   41|  1.50k|    tox_kill(tox);
   42|  1.50k|}

cmp_init:
  791|  30.9k|                                         cmp_writer write) {
  792|  30.9k|  ctx->error = ERROR_NONE;
  793|  30.9k|  ctx->buf = buf;
  794|  30.9k|  ctx->read = read;
  795|  30.9k|  ctx->skip = skip;
  796|  30.9k|  ctx->write = write;
  797|  30.9k|}
cmp_write_pfix:
  814|  5.70k|bool cmp_write_pfix(cmp_ctx_t *ctx, uint8_t c) {
  815|  5.70k|  if (c <= 0x7F)
  ------------------
  |  Branch (815:7): [True: 5.70k, False: 0]
  ------------------
  816|  5.70k|    return write_fixed_value(ctx, c);
  817|       |
  818|      0|  ctx->error = INPUT_VALUE_TOO_LARGE_ERROR;
  819|      0|  return false;
  820|  5.70k|}
cmp_write_u8:
  893|    176|bool cmp_write_u8(cmp_ctx_t *ctx, uint8_t c) {
  894|    176|  if (!write_type_marker(ctx, U8_MARKER))
  ------------------
  |  Branch (894:7): [True: 0, False: 176]
  ------------------
  895|      0|    return false;
  896|       |
  897|    176|  return ctx->write(ctx, &c, sizeof(uint8_t));
  898|    176|}
cmp_write_u16:
  900|    408|bool cmp_write_u16(cmp_ctx_t *ctx, uint16_t s) {
  901|    408|  if (!write_type_marker(ctx, U16_MARKER))
  ------------------
  |  Branch (901:7): [True: 0, False: 408]
  ------------------
  902|      0|    return false;
  903|       |
  904|    408|  s = be16(s);
  905|       |
  906|    408|  return ctx->write(ctx, &s, sizeof(uint16_t));
  907|    408|}
cmp_write_u32:
  909|     12|bool cmp_write_u32(cmp_ctx_t *ctx, uint32_t i) {
  910|     12|  if (!write_type_marker(ctx, U32_MARKER))
  ------------------
  |  Branch (910:7): [True: 0, False: 12]
  ------------------
  911|      0|    return false;
  912|       |
  913|     12|  i = be32(i);
  914|       |
  915|     12|  return ctx->write(ctx, &i, sizeof(uint32_t));
  916|     12|}
cmp_write_uinteger:
  927|  6.30k|bool cmp_write_uinteger(cmp_ctx_t *ctx, uint64_t u) {
  928|  6.30k|  if (u <= 0x7F)
  ------------------
  |  Branch (928:7): [True: 5.70k, False: 596]
  ------------------
  929|  5.70k|    return cmp_write_pfix(ctx, (uint8_t)u);
  930|    596|  if (u <= 0xFF)
  ------------------
  |  Branch (930:7): [True: 176, False: 420]
  ------------------
  931|    176|    return cmp_write_u8(ctx, (uint8_t)u);
  932|    420|  if (u <= 0xFFFF)
  ------------------
  |  Branch (932:7): [True: 408, False: 12]
  ------------------
  933|    408|    return cmp_write_u16(ctx, (uint16_t)u);
  934|     12|  if (u <= 0xFFFFFFFF)
  ------------------
  |  Branch (934:7): [True: 12, False: 0]
  ------------------
  935|     12|    return cmp_write_u32(ctx, (uint32_t)u);
  936|       |
  937|      0|  return cmp_write_u64(ctx, u);
  938|     12|}
cmp_write_nil:
  994|    120|bool cmp_write_nil(cmp_ctx_t *ctx) {
  995|    120|  return write_type_marker(ctx, NIL_MARKER);
  996|    120|}
cmp_write_true:
  998|      4|bool cmp_write_true(cmp_ctx_t *ctx) {
  999|      4|  return write_type_marker(ctx, TRUE_MARKER);
 1000|      4|}
cmp_write_false:
 1002|    416|bool cmp_write_false(cmp_ctx_t *ctx) {
 1003|    416|  return write_type_marker(ctx, FALSE_MARKER);
 1004|    416|}
cmp_write_bool:
 1006|    420|bool cmp_write_bool(cmp_ctx_t *ctx, bool b) {
 1007|    420|  if (b)
  ------------------
  |  Branch (1007:7): [True: 4, False: 416]
  ------------------
 1008|      4|    return cmp_write_true(ctx);
 1009|       |
 1010|    416|  return cmp_write_false(ctx);
 1011|    420|}
cmp_write_bin8_marker:
 1161|  6.17k|bool cmp_write_bin8_marker(cmp_ctx_t *ctx, uint8_t size) {
 1162|  6.17k|  if (!write_type_marker(ctx, BIN8_MARKER))
  ------------------
  |  Branch (1162:7): [True: 0, False: 6.17k]
  ------------------
 1163|      0|    return false;
 1164|       |
 1165|  6.17k|  if (ctx->write(ctx, &size, sizeof(uint8_t)))
  ------------------
  |  Branch (1165:7): [True: 6.17k, False: 0]
  ------------------
 1166|  6.17k|    return true;
 1167|       |
 1168|      0|  ctx->error = LENGTH_WRITING_ERROR;
 1169|      0|  return false;
 1170|  6.17k|}
cmp_write_bin8:
 1172|  6.17k|bool cmp_write_bin8(cmp_ctx_t *ctx, const void *data, uint8_t size) {
 1173|  6.17k|  if (!cmp_write_bin8_marker(ctx, size))
  ------------------
  |  Branch (1173:7): [True: 0, False: 6.17k]
  ------------------
 1174|      0|    return false;
 1175|       |
 1176|  6.17k|  if (size == 0)
  ------------------
  |  Branch (1176:7): [True: 424, False: 5.75k]
  ------------------
 1177|    424|    return true;
 1178|       |
 1179|  5.75k|  if (ctx->write(ctx, data, size))
  ------------------
  |  Branch (1179:7): [True: 5.75k, False: 0]
  ------------------
 1180|  5.75k|    return true;
 1181|       |
 1182|      0|  ctx->error = DATA_WRITING_ERROR;
 1183|      0|  return false;
 1184|  5.75k|}
cmp_write_bin16_marker:
 1186|      4|bool cmp_write_bin16_marker(cmp_ctx_t *ctx, uint16_t size) {
 1187|      4|  if (!write_type_marker(ctx, BIN16_MARKER))
  ------------------
  |  Branch (1187:7): [True: 0, False: 4]
  ------------------
 1188|      0|    return false;
 1189|       |
 1190|      4|  size = be16(size);
 1191|       |
 1192|      4|  if (ctx->write(ctx, &size, sizeof(uint16_t)))
  ------------------
  |  Branch (1192:7): [True: 4, False: 0]
  ------------------
 1193|      4|    return true;
 1194|       |
 1195|      0|  ctx->error = LENGTH_WRITING_ERROR;
 1196|      0|  return false;
 1197|      4|}
cmp_write_bin16:
 1199|      4|bool cmp_write_bin16(cmp_ctx_t *ctx, const void *data, uint16_t size) {
 1200|      4|  if (!cmp_write_bin16_marker(ctx, size))
  ------------------
  |  Branch (1200:7): [True: 0, False: 4]
  ------------------
 1201|      0|    return false;
 1202|       |
 1203|      4|  if (size == 0)
  ------------------
  |  Branch (1203:7): [True: 0, False: 4]
  ------------------
 1204|      0|    return true;
 1205|       |
 1206|      4|  if (ctx->write(ctx, data, size))
  ------------------
  |  Branch (1206:7): [True: 4, False: 0]
  ------------------
 1207|      4|    return true;
 1208|       |
 1209|      0|  ctx->error = DATA_WRITING_ERROR;
 1210|      0|  return false;
 1211|      4|}
cmp_write_bin:
 1249|  6.18k|bool cmp_write_bin(cmp_ctx_t *ctx, const void *data, uint32_t size) {
 1250|  6.18k|  if (size <= 0xFF)
  ------------------
  |  Branch (1250:7): [True: 6.17k, False: 4]
  ------------------
 1251|  6.17k|    return cmp_write_bin8(ctx, data, (uint8_t)size);
 1252|      4|  if (size <= 0xFFFF)
  ------------------
  |  Branch (1252:7): [True: 4, False: 0]
  ------------------
 1253|      4|    return cmp_write_bin16(ctx, data, (uint16_t)size);
 1254|       |
 1255|      0|  return cmp_write_bin32(ctx, data, size);
 1256|      4|}
cmp_write_fixarray:
 1258|  6.92k|bool cmp_write_fixarray(cmp_ctx_t *ctx, uint8_t size) {
 1259|  6.92k|  if (size <= FIXARRAY_SIZE)
  ------------------
  |  Branch (1259:7): [True: 6.92k, False: 0]
  ------------------
 1260|  6.92k|    return write_fixed_value(ctx, FIXARRAY_MARKER | size);
 1261|       |
 1262|      0|  ctx->error = INPUT_VALUE_TOO_LARGE_ERROR;
 1263|      0|  return false;
 1264|  6.92k|}
cmp_write_array16:
 1266|     36|bool cmp_write_array16(cmp_ctx_t *ctx, uint16_t size) {
 1267|     36|  if (!write_type_marker(ctx, ARRAY16_MARKER))
  ------------------
  |  Branch (1267:7): [True: 0, False: 36]
  ------------------
 1268|      0|    return false;
 1269|       |
 1270|     36|  size = be16(size);
 1271|       |
 1272|     36|  if (ctx->write(ctx, &size, sizeof(uint16_t)))
  ------------------
  |  Branch (1272:7): [True: 36, False: 0]
  ------------------
 1273|     36|    return true;
 1274|       |
 1275|      0|  ctx->error = LENGTH_WRITING_ERROR;
 1276|      0|  return false;
 1277|     36|}
cmp_write_array:
 1292|  6.95k|bool cmp_write_array(cmp_ctx_t *ctx, uint32_t size) {
 1293|  6.95k|  if (size <= FIXARRAY_SIZE)
  ------------------
  |  Branch (1293:7): [True: 6.92k, False: 36]
  ------------------
 1294|  6.92k|    return cmp_write_fixarray(ctx, (uint8_t)size);
 1295|     36|  if (size <= 0xFFFF)
  ------------------
  |  Branch (1295:7): [True: 36, False: 0]
  ------------------
 1296|     36|    return cmp_write_array16(ctx, (uint16_t)size);
 1297|       |
 1298|      0|  return cmp_write_array32(ctx, size);
 1299|     36|}
cmp_read_uchar:
 2070|  30.1k|bool cmp_read_uchar(cmp_ctx_t *ctx, uint8_t *c) {
 2071|  30.1k|  cmp_object_t obj;
 2072|       |
 2073|  30.1k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2073:7): [True: 4.37k, False: 25.7k]
  ------------------
 2074|  4.37k|    return false;
 2075|       |
 2076|  25.7k|  switch (obj.type) {
 2077|  21.7k|    case CMP_TYPE_POSITIVE_FIXNUM:
  ------------------
  |  Branch (2077:5): [True: 21.7k, False: 4.00k]
  ------------------
 2078|  22.9k|    case CMP_TYPE_UINT8:
  ------------------
  |  Branch (2078:5): [True: 1.17k, False: 24.5k]
  ------------------
 2079|  22.9k|      *c = obj.as.u8;
 2080|  22.9k|      return true;
 2081|  1.88k|    case CMP_TYPE_NEGATIVE_FIXNUM:
  ------------------
  |  Branch (2081:5): [True: 1.88k, False: 23.8k]
  ------------------
 2082|  1.91k|    case CMP_TYPE_SINT8:
  ------------------
  |  Branch (2082:5): [True: 30, False: 25.7k]
  ------------------
 2083|  1.91k|      if (obj.as.s8 >= 0) {
  ------------------
  |  Branch (2083:11): [True: 30, False: 1.88k]
  ------------------
 2084|     30|        *c = (uint8_t)obj.as.s8;
 2085|     30|        return true;
 2086|     30|      }
 2087|  1.88k|      break;
 2088|  1.88k|    default:
  ------------------
  |  Branch (2088:5): [True: 918, False: 24.8k]
  ------------------
 2089|    918|      break;
 2090|  25.7k|  }
 2091|       |
 2092|  2.80k|  ctx->error = INVALID_TYPE_ERROR;
 2093|  2.80k|  return false;
 2094|  25.7k|}
cmp_read_ushort:
 2096|  57.0k|bool cmp_read_ushort(cmp_ctx_t *ctx, uint16_t *s) {
 2097|  57.0k|  cmp_object_t obj;
 2098|       |
 2099|  57.0k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2099:7): [True: 499, False: 56.5k]
  ------------------
 2100|    499|    return false;
 2101|       |
 2102|  56.5k|  switch (obj.type) {
 2103|  45.6k|    case CMP_TYPE_POSITIVE_FIXNUM:
  ------------------
  |  Branch (2103:5): [True: 45.6k, False: 10.9k]
  ------------------
 2104|  47.9k|    case CMP_TYPE_UINT8:
  ------------------
  |  Branch (2104:5): [True: 2.30k, False: 54.2k]
  ------------------
 2105|  47.9k|      *s = obj.as.u8;
 2106|  47.9k|      return true;
 2107|    728|    case CMP_TYPE_UINT16:
  ------------------
  |  Branch (2107:5): [True: 728, False: 55.8k]
  ------------------
 2108|    728|      *s = obj.as.u16;
 2109|    728|      return true;
 2110|     54|    case CMP_TYPE_NEGATIVE_FIXNUM:
  ------------------
  |  Branch (2110:5): [True: 54, False: 56.4k]
  ------------------
 2111|  4.59k|    case CMP_TYPE_SINT8:
  ------------------
  |  Branch (2111:5): [True: 4.54k, False: 52.0k]
  ------------------
 2112|  4.59k|      if (obj.as.s8 >= 0) {
  ------------------
  |  Branch (2112:11): [True: 4.52k, False: 68]
  ------------------
 2113|  4.52k|        *s = (uint8_t)obj.as.s8;
 2114|  4.52k|        return true;
 2115|  4.52k|      }
 2116|     68|      break;
 2117|    152|    case CMP_TYPE_SINT16:
  ------------------
  |  Branch (2117:5): [True: 152, False: 56.3k]
  ------------------
 2118|    152|      if (obj.as.s16 >= 0) {
  ------------------
  |  Branch (2118:11): [True: 117, False: 35]
  ------------------
 2119|    117|        *s = (uint16_t)obj.as.s16;
 2120|    117|        return true;
 2121|    117|      }
 2122|     35|      break;
 2123|  3.16k|    default:
  ------------------
  |  Branch (2123:5): [True: 3.16k, False: 53.3k]
  ------------------
 2124|  3.16k|      break;
 2125|  56.5k|  }
 2126|       |
 2127|  3.27k|  ctx->error = INVALID_TYPE_ERROR;
 2128|  3.27k|  return false;
 2129|  56.5k|}
cmp_read_uint:
 2131|  30.7k|bool cmp_read_uint(cmp_ctx_t *ctx, uint32_t *i) {
 2132|  30.7k|  cmp_object_t obj;
 2133|       |
 2134|  30.7k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2134:7): [True: 3.90k, False: 26.8k]
  ------------------
 2135|  3.90k|    return false;
 2136|       |
 2137|  26.8k|  switch (obj.type) {
 2138|  19.1k|    case CMP_TYPE_POSITIVE_FIXNUM:
  ------------------
  |  Branch (2138:5): [True: 19.1k, False: 7.69k]
  ------------------
 2139|  19.8k|    case CMP_TYPE_UINT8:
  ------------------
  |  Branch (2139:5): [True: 644, False: 26.2k]
  ------------------
 2140|  19.8k|      *i = obj.as.u8;
 2141|  19.8k|      return true;
 2142|    161|    case CMP_TYPE_UINT16:
  ------------------
  |  Branch (2142:5): [True: 161, False: 26.7k]
  ------------------
 2143|    161|      *i = obj.as.u16;
 2144|    161|      return true;
 2145|  4.85k|    case CMP_TYPE_UINT32:
  ------------------
  |  Branch (2145:5): [True: 4.85k, False: 22.0k]
  ------------------
 2146|  4.85k|      *i = obj.as.u32;
 2147|  4.85k|      return true;
 2148|    786|    case CMP_TYPE_NEGATIVE_FIXNUM:
  ------------------
  |  Branch (2148:5): [True: 786, False: 26.0k]
  ------------------
 2149|  1.24k|    case CMP_TYPE_SINT8:
  ------------------
  |  Branch (2149:5): [True: 459, False: 26.4k]
  ------------------
 2150|  1.24k|      if (obj.as.s8 >= 0) {
  ------------------
  |  Branch (2150:11): [True: 459, False: 786]
  ------------------
 2151|    459|        *i = (uint8_t)obj.as.s8;
 2152|    459|        return true;
 2153|    459|      }
 2154|    786|      break;
 2155|    786|    case CMP_TYPE_SINT16:
  ------------------
  |  Branch (2155:5): [True: 86, False: 26.7k]
  ------------------
 2156|     86|      if (obj.as.s16 >= 0) {
  ------------------
  |  Branch (2156:11): [True: 76, False: 10]
  ------------------
 2157|     76|        *i = (uint16_t)obj.as.s16;
 2158|     76|        return true;
 2159|     76|      }
 2160|     10|      break;
 2161|     52|    case CMP_TYPE_SINT32:
  ------------------
  |  Branch (2161:5): [True: 52, False: 26.8k]
  ------------------
 2162|     52|      if (obj.as.s32 >= 0) {
  ------------------
  |  Branch (2162:11): [True: 18, False: 34]
  ------------------
 2163|     18|        *i = (uint32_t)obj.as.s32;
 2164|     18|        return true;
 2165|     18|      }
 2166|     34|      break;
 2167|    654|    default:
  ------------------
  |  Branch (2167:5): [True: 654, False: 26.2k]
  ------------------
 2168|    654|      break;
 2169|  26.8k|  }
 2170|       |
 2171|  1.48k|  ctx->error = INVALID_TYPE_ERROR;
 2172|  1.48k|  return false;
 2173|  26.8k|}
cmp_read_nil:
 2285|    195|bool cmp_read_nil(cmp_ctx_t *ctx) {
 2286|    195|  cmp_object_t obj;
 2287|       |
 2288|    195|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2288:7): [True: 11, False: 184]
  ------------------
 2289|     11|    return false;
 2290|       |
 2291|    184|  if (obj.type == CMP_TYPE_NIL)
  ------------------
  |  Branch (2291:7): [True: 78, False: 106]
  ------------------
 2292|     78|    return true;
 2293|       |
 2294|    106|  ctx->error = INVALID_TYPE_ERROR;
 2295|    106|  return false;
 2296|    184|}
cmp_read_bool:
 2298|  22.6k|bool cmp_read_bool(cmp_ctx_t *ctx, bool *b) {
 2299|  22.6k|  cmp_object_t obj;
 2300|       |
 2301|  22.6k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2301:7): [True: 197, False: 22.4k]
  ------------------
 2302|    197|    return false;
 2303|       |
 2304|  22.4k|  if (obj.type != CMP_TYPE_BOOLEAN) {
  ------------------
  |  Branch (2304:7): [True: 2.09k, False: 20.3k]
  ------------------
 2305|  2.09k|    ctx->error = INVALID_TYPE_ERROR;
 2306|  2.09k|    return false;
 2307|  2.09k|  }
 2308|       |
 2309|  20.3k|  if (obj.as.boolean)
  ------------------
  |  Branch (2309:7): [True: 6.02k, False: 14.3k]
  ------------------
 2310|  6.02k|    *b = true;
 2311|  14.3k|  else
 2312|  14.3k|    *b = false;
 2313|       |
 2314|  20.3k|  return true;
 2315|  22.4k|}
cmp_read_bin_size:
 2378|  10.7k|bool cmp_read_bin_size(cmp_ctx_t *ctx, uint32_t *size) {
 2379|  10.7k|  cmp_object_t obj;
 2380|       |
 2381|  10.7k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2381:7): [True: 1.10k, False: 9.64k]
  ------------------
 2382|  1.10k|    return false;
 2383|       |
 2384|  9.64k|  switch (obj.type) {
 2385|  7.67k|    case CMP_TYPE_BIN8:
  ------------------
  |  Branch (2385:5): [True: 7.67k, False: 1.96k]
  ------------------
 2386|  8.00k|    case CMP_TYPE_BIN16:
  ------------------
  |  Branch (2386:5): [True: 322, False: 9.32k]
  ------------------
 2387|  8.01k|    case CMP_TYPE_BIN32:
  ------------------
  |  Branch (2387:5): [True: 12, False: 9.63k]
  ------------------
 2388|  8.01k|      *size = obj.as.bin_size;
 2389|  8.01k|      return true;
 2390|  1.63k|    default:
  ------------------
  |  Branch (2390:5): [True: 1.63k, False: 8.01k]
  ------------------
 2391|  1.63k|      ctx->error = INVALID_TYPE_ERROR;
 2392|  1.63k|      return false;
 2393|  9.64k|  }
 2394|  9.64k|}
cmp_read_array:
 2416|  84.0k|bool cmp_read_array(cmp_ctx_t *ctx, uint32_t *size) {
 2417|  84.0k|  cmp_object_t obj;
 2418|       |
 2419|  84.0k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2419:7): [True: 163, False: 83.8k]
  ------------------
 2420|    163|    return false;
 2421|       |
 2422|  83.8k|  switch (obj.type) {
 2423|  78.2k|    case CMP_TYPE_FIXARRAY:
  ------------------
  |  Branch (2423:5): [True: 78.2k, False: 5.58k]
  ------------------
 2424|  78.3k|    case CMP_TYPE_ARRAY16:
  ------------------
  |  Branch (2424:5): [True: 34, False: 83.8k]
  ------------------
 2425|  78.3k|    case CMP_TYPE_ARRAY32:
  ------------------
  |  Branch (2425:5): [True: 18, False: 83.8k]
  ------------------
 2426|  78.3k|      *size = obj.as.array_size;
 2427|  78.3k|      return true;
 2428|  5.53k|    default:
  ------------------
  |  Branch (2428:5): [True: 5.53k, False: 78.3k]
  ------------------
 2429|  5.53k|      ctx->error = INVALID_TYPE_ERROR;
 2430|  5.53k|      return false;
 2431|  83.8k|  }
 2432|  83.8k|}
cmp_read_object:
 2701|   235k|bool cmp_read_object(cmp_ctx_t *ctx, cmp_object_t *obj) {
 2702|   235k|  uint8_t type_marker = 0;
 2703|       |
 2704|   235k|  if (!read_type_marker(ctx, &type_marker))
  ------------------
  |  Branch (2704:7): [True: 2.75k, False: 232k]
  ------------------
 2705|  2.75k|    return false;
 2706|       |
 2707|   232k|  if (!type_marker_to_cmp_type(type_marker, &obj->type)) {
  ------------------
  |  Branch (2707:7): [True: 166, False: 232k]
  ------------------
 2708|    166|    ctx->error = INVALID_TYPE_ERROR;
 2709|    166|    return false;
 2710|    166|  }
 2711|       |
 2712|   232k|  return read_obj_data(ctx, type_marker, obj);
 2713|   232k|}
cmp.c:write_fixed_value:
  287|  12.6k|static bool write_fixed_value(cmp_ctx_t *ctx, uint8_t value) {
  288|  12.6k|  if (write_byte(ctx, value))
  ------------------
  |  Branch (288:7): [True: 12.6k, False: 0]
  ------------------
  289|  12.6k|    return true;
  290|       |
  291|      0|  ctx->error = FIXED_VALUE_WRITING_ERROR;
  292|      0|  return false;
  293|  12.6k|}
cmp.c:write_byte:
  248|  19.9k|static bool write_byte(cmp_ctx_t *ctx, uint8_t x) {
  249|  19.9k|  return (ctx->write(ctx, &x, sizeof(uint8_t)) == (sizeof(uint8_t)));
  250|  19.9k|}
cmp.c:write_type_marker:
  279|  7.35k|static bool write_type_marker(cmp_ctx_t *ctx, uint8_t marker) {
  280|  7.35k|  if (write_byte(ctx, marker))
  ------------------
  |  Branch (280:7): [True: 7.35k, False: 0]
  ------------------
  281|  7.35k|    return true;
  282|       |
  283|      0|  ctx->error = TYPE_MARKER_WRITING_ERROR;
  284|      0|  return false;
  285|  7.35k|}
cmp.c:sbe16:
  140|    330|static int16_t sbe16(int16_t x) {
  141|    330|  return (int16_t)be16((uint16_t)x);
  142|    330|}
cmp.c:sbe32:
  160|    308|static int32_t sbe32(int32_t x) {
  161|    308|  return (int32_t)be32((uint32_t)x);
  162|    308|}
cmp.c:sbe64:
  190|     80|static int64_t sbe64(int64_t x) {
  191|     80|  return (int64_t)be64((uint64_t)x);
  192|     80|}
cmp.c:be16:
  128|  3.03k|static uint16_t be16(uint16_t x) {
  129|  3.03k|  char *b = (char *)&x;
  130|       |
  131|  3.03k|  if (!is_bigendian()) {
  ------------------
  |  |  125|  3.03k|#define is_bigendian() ((*(const char *)&i_) == 0)
  ------------------
  |  Branch (131:7): [True: 3.03k, False: 0]
  ------------------
  132|  3.03k|    char swap = b[0];
  133|  3.03k|    b[0] = b[1];
  134|  3.03k|    b[1] = swap;
  135|  3.03k|  }
  136|       |
  137|  3.03k|  return x;
  138|  3.03k|}
cmp.c:be32:
  144|  8.45k|static uint32_t be32(uint32_t x) {
  145|  8.45k|  char *b = (char *)&x;
  146|       |
  147|  8.45k|  if (!is_bigendian()) {
  ------------------
  |  |  125|  8.45k|#define is_bigendian() ((*(const char *)&i_) == 0)
  ------------------
  |  Branch (147:7): [True: 8.45k, False: 0]
  ------------------
  148|  8.45k|    char swap = b[0];
  149|  8.45k|    b[0] = b[3];
  150|  8.45k|    b[3] = swap;
  151|       |
  152|  8.45k|    swap = b[1];
  153|  8.45k|    b[1] = b[2];
  154|  8.45k|    b[2] = swap;
  155|  8.45k|  }
  156|       |
  157|  8.45k|  return x;
  158|  8.45k|}
cmp.c:be64:
  164|    149|static uint64_t be64(uint64_t x) {
  165|    149|  char *b = (char *)&x;
  166|       |
  167|    149|  if (!is_bigendian()) {
  ------------------
  |  |  125|    149|#define is_bigendian() ((*(const char *)&i_) == 0)
  ------------------
  |  Branch (167:7): [True: 149, False: 0]
  ------------------
  168|    149|    char swap;
  169|       |
  170|    149|    swap = b[0];
  171|    149|    b[0] = b[7];
  172|    149|    b[7] = swap;
  173|       |
  174|    149|    swap = b[1];
  175|    149|    b[1] = b[6];
  176|    149|    b[6] = swap;
  177|       |
  178|    149|    swap = b[2];
  179|    149|    b[2] = b[5];
  180|    149|    b[5] = swap;
  181|       |
  182|    149|    swap = b[3];
  183|    149|    b[3] = b[4];
  184|    149|    b[4] = swap;
  185|    149|  }
  186|       |
  187|    149|  return x;
  188|    149|}
cmp.c:read_type_marker:
  270|   235k|static bool read_type_marker(cmp_ctx_t *ctx, uint8_t *marker) {
  271|   235k|  if (read_byte(ctx, marker)) {
  ------------------
  |  Branch (271:7): [True: 232k, False: 2.75k]
  ------------------
  272|   232k|    return true;
  273|   232k|  }
  274|       |
  275|  2.75k|  ctx->error = TYPE_MARKER_READING_ERROR;
  276|  2.75k|  return false;
  277|   235k|}
cmp.c:read_byte:
  244|   235k|static bool read_byte(cmp_ctx_t *ctx, uint8_t *x) {
  245|   235k|  return ctx->read(ctx, x, sizeof(uint8_t));
  246|   235k|}
cmp.c:type_marker_to_cmp_type:
  295|   232k|static bool type_marker_to_cmp_type(uint8_t type_marker, uint8_t *cmp_type) {
  296|   232k|  if (type_marker <= 0x7F) {
  ------------------
  |  Branch (296:7): [True: 91.1k, False: 141k]
  ------------------
  297|  91.1k|    *cmp_type = CMP_TYPE_POSITIVE_FIXNUM;
  298|  91.1k|    return true;
  299|  91.1k|  }
  300|       |
  301|   141k|  if (type_marker <= 0x8F) {
  ------------------
  |  Branch (301:7): [True: 576, False: 141k]
  ------------------
  302|    576|    *cmp_type = CMP_TYPE_FIXMAP;
  303|    576|    return true;
  304|    576|  }
  305|       |
  306|   141k|  if (type_marker <= 0x9F) {
  ------------------
  |  Branch (306:7): [True: 78.8k, False: 62.2k]
  ------------------
  307|  78.8k|    *cmp_type = CMP_TYPE_FIXARRAY;
  308|  78.8k|    return true;
  309|  78.8k|  }
  310|       |
  311|  62.2k|  if (type_marker <= 0xBF) {
  ------------------
  |  Branch (311:7): [True: 434, False: 61.8k]
  ------------------
  312|    434|    *cmp_type = CMP_TYPE_FIXSTR;
  313|    434|    return true;
  314|    434|  }
  315|       |
  316|  61.8k|  if (type_marker >= 0xE0) {
  ------------------
  |  Branch (316:7): [True: 2.87k, False: 58.9k]
  ------------------
  317|  2.87k|    *cmp_type = CMP_TYPE_NEGATIVE_FIXNUM;
  318|  2.87k|    return true;
  319|  2.87k|  }
  320|       |
  321|  58.9k|  switch (type_marker) {
  322|    244|    case NIL_MARKER:
  ------------------
  |  Branch (322:5): [True: 244, False: 58.7k]
  ------------------
  323|    244|      *cmp_type = CMP_TYPE_NIL;
  324|    244|      return true;
  325|  14.6k|    case FALSE_MARKER:
  ------------------
  |  Branch (325:5): [True: 14.6k, False: 44.3k]
  ------------------
  326|  14.6k|      *cmp_type = CMP_TYPE_BOOLEAN;
  327|  14.6k|      return true;
  328|  6.37k|    case TRUE_MARKER:
  ------------------
  |  Branch (328:5): [True: 6.37k, False: 52.5k]
  ------------------
  329|  6.37k|      *cmp_type = CMP_TYPE_BOOLEAN;
  330|  6.37k|      return true;
  331|  8.02k|    case BIN8_MARKER:
  ------------------
  |  Branch (331:5): [True: 8.02k, False: 50.9k]
  ------------------
  332|  8.02k|      *cmp_type = CMP_TYPE_BIN8;
  333|  8.02k|      return true;
  334|    495|    case BIN16_MARKER:
  ------------------
  |  Branch (334:5): [True: 495, False: 58.4k]
  ------------------
  335|    495|      *cmp_type = CMP_TYPE_BIN16;
  336|    495|      return true;
  337|  2.56k|    case BIN32_MARKER:
  ------------------
  |  Branch (337:5): [True: 2.56k, False: 56.3k]
  ------------------
  338|  2.56k|      *cmp_type = CMP_TYPE_BIN32;
  339|  2.56k|      return true;
  340|     96|    case EXT8_MARKER:
  ------------------
  |  Branch (340:5): [True: 96, False: 58.8k]
  ------------------
  341|     96|      *cmp_type = CMP_TYPE_EXT8;
  342|     96|      return true;
  343|    396|    case EXT16_MARKER:
  ------------------
  |  Branch (343:5): [True: 396, False: 58.5k]
  ------------------
  344|    396|      *cmp_type = CMP_TYPE_EXT16;
  345|    396|      return true;
  346|  2.50k|    case EXT32_MARKER:
  ------------------
  |  Branch (346:5): [True: 2.50k, False: 56.4k]
  ------------------
  347|  2.50k|      *cmp_type = CMP_TYPE_EXT32;
  348|  2.50k|      return true;
  349|    164|    case FLOAT_MARKER:
  ------------------
  |  Branch (349:5): [True: 164, False: 58.7k]
  ------------------
  350|    164|      *cmp_type = CMP_TYPE_FLOAT;
  351|    164|      return true;
  352|    122|    case DOUBLE_MARKER:
  ------------------
  |  Branch (352:5): [True: 122, False: 58.8k]
  ------------------
  353|    122|      *cmp_type = CMP_TYPE_DOUBLE;
  354|    122|      return true;
  355|  4.18k|    case U8_MARKER:
  ------------------
  |  Branch (355:5): [True: 4.18k, False: 54.7k]
  ------------------
  356|  4.18k|      *cmp_type = CMP_TYPE_UINT8;
  357|  4.18k|      return true;
  358|    994|    case U16_MARKER:
  ------------------
  |  Branch (358:5): [True: 994, False: 57.9k]
  ------------------
  359|    994|      *cmp_type = CMP_TYPE_UINT16;
  360|    994|      return true;
  361|  7.85k|    case U32_MARKER:
  ------------------
  |  Branch (361:5): [True: 7.85k, False: 51.0k]
  ------------------
  362|  7.85k|      *cmp_type = CMP_TYPE_UINT32;
  363|  7.85k|      return true;
  364|    261|    case U64_MARKER:
  ------------------
  |  Branch (364:5): [True: 261, False: 58.6k]
  ------------------
  365|    261|      *cmp_type = CMP_TYPE_UINT64;
  366|    261|      return true;
  367|  5.10k|    case S8_MARKER:
  ------------------
  |  Branch (367:5): [True: 5.10k, False: 53.8k]
  ------------------
  368|  5.10k|      *cmp_type = CMP_TYPE_SINT8;
  369|  5.10k|      return true;
  370|    374|    case S16_MARKER:
  ------------------
  |  Branch (370:5): [True: 374, False: 58.5k]
  ------------------
  371|    374|      *cmp_type = CMP_TYPE_SINT16;
  372|    374|      return true;
  373|    326|    case S32_MARKER:
  ------------------
  |  Branch (373:5): [True: 326, False: 58.6k]
  ------------------
  374|    326|      *cmp_type = CMP_TYPE_SINT32;
  375|    326|      return true;
  376|    522|    case S64_MARKER:
  ------------------
  |  Branch (376:5): [True: 522, False: 58.4k]
  ------------------
  377|    522|      *cmp_type = CMP_TYPE_SINT64;
  378|    522|      return true;
  379|    263|    case FIXEXT1_MARKER:
  ------------------
  |  Branch (379:5): [True: 263, False: 58.6k]
  ------------------
  380|    263|      *cmp_type = CMP_TYPE_FIXEXT1;
  381|    263|      return true;
  382|    177|    case FIXEXT2_MARKER:
  ------------------
  |  Branch (382:5): [True: 177, False: 58.7k]
  ------------------
  383|    177|      *cmp_type = CMP_TYPE_FIXEXT2;
  384|    177|      return true;
  385|    152|    case FIXEXT4_MARKER:
  ------------------
  |  Branch (385:5): [True: 152, False: 58.8k]
  ------------------
  386|    152|      *cmp_type = CMP_TYPE_FIXEXT4;
  387|    152|      return true;
  388|    185|    case FIXEXT8_MARKER:
  ------------------
  |  Branch (388:5): [True: 185, False: 58.7k]
  ------------------
  389|    185|      *cmp_type = CMP_TYPE_FIXEXT8;
  390|    185|      return true;
  391|    179|    case FIXEXT16_MARKER:
  ------------------
  |  Branch (391:5): [True: 179, False: 58.7k]
  ------------------
  392|    179|      *cmp_type = CMP_TYPE_FIXEXT16;
  393|    179|      return true;
  394|  1.04k|    case STR8_MARKER:
  ------------------
  |  Branch (394:5): [True: 1.04k, False: 57.9k]
  ------------------
  395|  1.04k|      *cmp_type = CMP_TYPE_STR8;
  396|  1.04k|      return true;
  397|    312|    case STR16_MARKER:
  ------------------
  |  Branch (397:5): [True: 312, False: 58.6k]
  ------------------
  398|    312|      *cmp_type = CMP_TYPE_STR16;
  399|    312|      return true;
  400|    304|    case STR32_MARKER:
  ------------------
  |  Branch (400:5): [True: 304, False: 58.6k]
  ------------------
  401|    304|      *cmp_type = CMP_TYPE_STR32;
  402|    304|      return true;
  403|    414|    case ARRAY16_MARKER:
  ------------------
  |  Branch (403:5): [True: 414, False: 58.5k]
  ------------------
  404|    414|      *cmp_type = CMP_TYPE_ARRAY16;
  405|    414|      return true;
  406|    159|    case ARRAY32_MARKER:
  ------------------
  |  Branch (406:5): [True: 159, False: 58.7k]
  ------------------
  407|    159|      *cmp_type = CMP_TYPE_ARRAY32;
  408|    159|      return true;
  409|    146|    case MAP16_MARKER:
  ------------------
  |  Branch (409:5): [True: 146, False: 58.8k]
  ------------------
  410|    146|      *cmp_type = CMP_TYPE_MAP16;
  411|    146|      return true;
  412|    231|    case MAP32_MARKER:
  ------------------
  |  Branch (412:5): [True: 231, False: 58.7k]
  ------------------
  413|    231|      *cmp_type = CMP_TYPE_MAP32;
  414|    231|      return true;
  415|    166|    default:
  ------------------
  |  Branch (415:5): [True: 166, False: 58.7k]
  ------------------
  416|    166|      return false;
  417|  58.9k|  }
  418|  58.9k|}
cmp.c:read_obj_data:
  592|   232k|                                          cmp_object_t *obj) {
  593|   232k|  switch (obj->type) {
  594|  91.1k|    case CMP_TYPE_POSITIVE_FIXNUM:
  ------------------
  |  Branch (594:5): [True: 91.1k, False: 141k]
  ------------------
  595|  91.1k|      obj->as.u8 = type_marker;
  596|  91.1k|      return true;
  597|  2.87k|    case CMP_TYPE_NEGATIVE_FIXNUM:
  ------------------
  |  Branch (597:5): [True: 2.87k, False: 229k]
  ------------------
  598|  2.87k|      obj->as.s8 = (int8_t)type_marker;
  599|  2.87k|      return true;
  600|    244|    case CMP_TYPE_NIL:
  ------------------
  |  Branch (600:5): [True: 244, False: 232k]
  ------------------
  601|    244|      obj->as.u8 = 0;
  602|    244|      return true;
  603|  20.9k|    case CMP_TYPE_BOOLEAN:
  ------------------
  |  Branch (603:5): [True: 20.9k, False: 211k]
  ------------------
  604|  20.9k|      switch (type_marker) {
  605|  6.37k|        case TRUE_MARKER:
  ------------------
  |  Branch (605:9): [True: 6.37k, False: 14.6k]
  ------------------
  606|  6.37k|          obj->as.boolean = true;
  607|  6.37k|          return true;
  608|  14.6k|        case FALSE_MARKER:
  ------------------
  |  Branch (608:9): [True: 14.6k, False: 6.37k]
  ------------------
  609|  14.6k|          obj->as.boolean = false;
  610|  14.6k|          return true;
  611|      0|        default:
  ------------------
  |  Branch (611:9): [True: 0, False: 20.9k]
  ------------------
  612|      0|          break;
  613|  20.9k|      }
  614|      0|      ctx->error = INTERNAL_ERROR;
  615|      0|      return false;
  616|  4.18k|    case CMP_TYPE_UINT8:
  ------------------
  |  Branch (616:5): [True: 4.18k, False: 228k]
  ------------------
  617|  4.18k|      if (!ctx->read(ctx, &obj->as.u8, sizeof(uint8_t))) {
  ------------------
  |  Branch (617:11): [True: 14, False: 4.17k]
  ------------------
  618|     14|        ctx->error = DATA_READING_ERROR;
  619|     14|        return false;
  620|     14|      }
  621|  4.17k|      return true;
  622|    994|    case CMP_TYPE_UINT16:
  ------------------
  |  Branch (622:5): [True: 994, False: 231k]
  ------------------
  623|    994|      if (!ctx->read(ctx, &obj->as.u16, sizeof(uint16_t))) {
  ------------------
  |  Branch (623:11): [True: 21, False: 973]
  ------------------
  624|     21|        ctx->error = DATA_READING_ERROR;
  625|     21|        return false;
  626|     21|      }
  627|    973|      obj->as.u16 = be16(obj->as.u16);
  628|    973|      return true;
  629|  7.85k|    case CMP_TYPE_UINT32:
  ------------------
  |  Branch (629:5): [True: 7.85k, False: 224k]
  ------------------
  630|  7.85k|      if (!ctx->read(ctx, &obj->as.u32, sizeof(uint32_t))) {
  ------------------
  |  Branch (630:11): [True: 2.56k, False: 5.29k]
  ------------------
  631|  2.56k|        ctx->error = DATA_READING_ERROR;
  632|  2.56k|        return false;
  633|  2.56k|      }
  634|  5.29k|      obj->as.u32 = be32(obj->as.u32);
  635|  5.29k|      return true;
  636|    261|    case CMP_TYPE_UINT64:
  ------------------
  |  Branch (636:5): [True: 261, False: 232k]
  ------------------
  637|    261|      if (!ctx->read(ctx, &obj->as.u64, sizeof(uint64_t))) {
  ------------------
  |  Branch (637:11): [True: 192, False: 69]
  ------------------
  638|    192|        ctx->error = DATA_READING_ERROR;
  639|    192|        return false;
  640|    192|      }
  641|     69|      obj->as.u64 = be64(obj->as.u64);
  642|     69|      return true;
  643|  5.10k|    case CMP_TYPE_SINT8:
  ------------------
  |  Branch (643:5): [True: 5.10k, False: 227k]
  ------------------
  644|  5.10k|      if (!ctx->read(ctx, &obj->as.s8, sizeof(int8_t))) {
  ------------------
  |  Branch (644:11): [True: 12, False: 5.09k]
  ------------------
  645|     12|        ctx->error = DATA_READING_ERROR;
  646|     12|        return false;
  647|     12|      }
  648|  5.09k|      return true;
  649|    374|    case CMP_TYPE_SINT16:
  ------------------
  |  Branch (649:5): [True: 374, False: 232k]
  ------------------
  650|    374|      if (!ctx->read(ctx, &obj->as.s16, sizeof(int16_t))) {
  ------------------
  |  Branch (650:11): [True: 44, False: 330]
  ------------------
  651|     44|        ctx->error = DATA_READING_ERROR;
  652|     44|        return false;
  653|     44|      }
  654|    330|      obj->as.s16 = sbe16(obj->as.s16);
  655|    330|      return true;
  656|    326|    case CMP_TYPE_SINT32:
  ------------------
  |  Branch (656:5): [True: 326, False: 232k]
  ------------------
  657|    326|      if (!ctx->read(ctx, &obj->as.s32, sizeof(int32_t))) {
  ------------------
  |  Branch (657:11): [True: 18, False: 308]
  ------------------
  658|     18|        ctx->error = DATA_READING_ERROR;
  659|     18|        return false;
  660|     18|      }
  661|    308|      obj->as.s32 = sbe32(obj->as.s32);
  662|    308|      return true;
  663|    522|    case CMP_TYPE_SINT64:
  ------------------
  |  Branch (663:5): [True: 522, False: 232k]
  ------------------
  664|    522|      if (!ctx->read(ctx, &obj->as.s64, sizeof(int64_t))) {
  ------------------
  |  Branch (664:11): [True: 442, False: 80]
  ------------------
  665|    442|        ctx->error = DATA_READING_ERROR;
  666|    442|        return false;
  667|    442|      }
  668|     80|      obj->as.s64 = sbe64(obj->as.s64);
  669|     80|      return true;
  670|    164|    case CMP_TYPE_FLOAT:
  ------------------
  |  Branch (670:5): [True: 164, False: 232k]
  ------------------
  671|    164|    {
  672|       |#ifndef CMP_NO_FLOAT
  673|       |      char bytes[4];
  674|       |
  675|       |      if (!ctx->read(ctx, bytes, 4)) {
  676|       |        ctx->error = DATA_READING_ERROR;
  677|       |        return false;
  678|       |      }
  679|       |      obj->as.flt = decode_befloat(bytes);
  680|       |      return true;
  681|       |#else /* CMP_NO_FLOAT */
  682|    164|      ctx->error = DISABLED_FLOATING_POINT_ERROR;
  683|    164|      return false;
  684|    522|#endif /* CMP_NO_FLOAT */
  685|    522|    }
  686|    122|    case CMP_TYPE_DOUBLE:
  ------------------
  |  Branch (686:5): [True: 122, False: 232k]
  ------------------
  687|    122|    {
  688|       |#ifndef CMP_NO_FLOAT
  689|       |      char bytes[8];
  690|       |
  691|       |      if (!ctx->read(ctx, bytes, 8)) {
  692|       |        ctx->error = DATA_READING_ERROR;
  693|       |        return false;
  694|       |      }
  695|       |      obj->as.dbl = decode_bedouble(bytes);
  696|       |      return true;
  697|       |#else /* CMP_NO_FLOAT */
  698|    122|      ctx->error = DISABLED_FLOATING_POINT_ERROR;
  699|    122|      return false;
  700|    522|#endif /* CMP_NO_FLOAT */
  701|    522|    }
  702|  8.02k|    case CMP_TYPE_BIN8:
  ------------------
  |  Branch (702:5): [True: 8.02k, False: 224k]
  ------------------
  703|  8.51k|    case CMP_TYPE_BIN16:
  ------------------
  |  Branch (703:5): [True: 495, False: 232k]
  ------------------
  704|  11.0k|    case CMP_TYPE_BIN32:
  ------------------
  |  Branch (704:5): [True: 2.56k, False: 230k]
  ------------------
  705|  11.0k|      return read_type_size(ctx, type_marker, obj->type, &obj->as.bin_size);
  706|    434|    case CMP_TYPE_FIXSTR:
  ------------------
  |  Branch (706:5): [True: 434, False: 232k]
  ------------------
  707|  1.48k|    case CMP_TYPE_STR8:
  ------------------
  |  Branch (707:5): [True: 1.04k, False: 231k]
  ------------------
  708|  1.79k|    case CMP_TYPE_STR16:
  ------------------
  |  Branch (708:5): [True: 312, False: 232k]
  ------------------
  709|  2.09k|    case CMP_TYPE_STR32:
  ------------------
  |  Branch (709:5): [True: 304, False: 232k]
  ------------------
  710|  2.09k|      return read_type_size(ctx, type_marker, obj->type, &obj->as.str_size);
  711|  78.8k|    case CMP_TYPE_FIXARRAY:
  ------------------
  |  Branch (711:5): [True: 78.8k, False: 153k]
  ------------------
  712|  79.2k|    case CMP_TYPE_ARRAY16:
  ------------------
  |  Branch (712:5): [True: 414, False: 232k]
  ------------------
  713|  79.4k|    case CMP_TYPE_ARRAY32:
  ------------------
  |  Branch (713:5): [True: 159, False: 232k]
  ------------------
  714|  79.4k|      return read_type_size(ctx, type_marker, obj->type, &obj->as.array_size);
  715|    576|    case CMP_TYPE_FIXMAP:
  ------------------
  |  Branch (715:5): [True: 576, False: 232k]
  ------------------
  716|    722|    case CMP_TYPE_MAP16:
  ------------------
  |  Branch (716:5): [True: 146, False: 232k]
  ------------------
  717|    953|    case CMP_TYPE_MAP32:
  ------------------
  |  Branch (717:5): [True: 231, False: 232k]
  ------------------
  718|    953|      return read_type_size(ctx, type_marker, obj->type, &obj->as.map_size);
  719|    263|    case CMP_TYPE_FIXEXT1:
  ------------------
  |  Branch (719:5): [True: 263, False: 232k]
  ------------------
  720|    263|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (720:11): [True: 57, False: 206]
  ------------------
  721|     57|        ctx->error = EXT_TYPE_READING_ERROR;
  722|     57|        return false;
  723|     57|      }
  724|    206|      obj->as.ext.size = 1;
  725|    206|      return true;
  726|    177|    case CMP_TYPE_FIXEXT2:
  ------------------
  |  Branch (726:5): [True: 177, False: 232k]
  ------------------
  727|    177|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (727:11): [True: 10, False: 167]
  ------------------
  728|     10|        ctx->error = EXT_TYPE_READING_ERROR;
  729|     10|        return false;
  730|     10|      }
  731|    167|      obj->as.ext.size = 2;
  732|    167|      return true;
  733|    152|    case CMP_TYPE_FIXEXT4:
  ------------------
  |  Branch (733:5): [True: 152, False: 232k]
  ------------------
  734|    152|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (734:11): [True: 10, False: 142]
  ------------------
  735|     10|        ctx->error = EXT_TYPE_READING_ERROR;
  736|     10|        return false;
  737|     10|      }
  738|    142|      obj->as.ext.size = 4;
  739|    142|      return true;
  740|    185|    case CMP_TYPE_FIXEXT8:
  ------------------
  |  Branch (740:5): [True: 185, False: 232k]
  ------------------
  741|    185|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (741:11): [True: 31, False: 154]
  ------------------
  742|     31|        ctx->error = EXT_TYPE_READING_ERROR;
  743|     31|        return false;
  744|     31|      }
  745|    154|      obj->as.ext.size = 8;
  746|    154|      return true;
  747|    179|    case CMP_TYPE_FIXEXT16:
  ------------------
  |  Branch (747:5): [True: 179, False: 232k]
  ------------------
  748|    179|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (748:11): [True: 40, False: 139]
  ------------------
  749|     40|        ctx->error = EXT_TYPE_READING_ERROR;
  750|     40|        return false;
  751|     40|      }
  752|    139|      obj->as.ext.size = 16;
  753|    139|      return true;
  754|     96|    case CMP_TYPE_EXT8:
  ------------------
  |  Branch (754:5): [True: 96, False: 232k]
  ------------------
  755|     96|      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
  ------------------
  |  Branch (755:11): [True: 11, False: 85]
  ------------------
  756|     11|        return false;
  757|     11|      }
  758|     85|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (758:11): [True: 2, False: 83]
  ------------------
  759|      2|        ctx->error = EXT_TYPE_READING_ERROR;
  760|      2|        return false;
  761|      2|      }
  762|     83|      return true;
  763|    396|    case CMP_TYPE_EXT16:
  ------------------
  |  Branch (763:5): [True: 396, False: 232k]
  ------------------
  764|    396|      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
  ------------------
  |  Branch (764:11): [True: 111, False: 285]
  ------------------
  765|    111|        return false;
  766|    111|      }
  767|    285|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (767:11): [True: 12, False: 273]
  ------------------
  768|     12|        ctx->error = EXT_TYPE_READING_ERROR;
  769|     12|        return false;
  770|     12|      }
  771|    273|      return true;
  772|  2.50k|    case CMP_TYPE_EXT32:
  ------------------
  |  Branch (772:5): [True: 2.50k, False: 230k]
  ------------------
  773|  2.50k|      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
  ------------------
  |  Branch (773:11): [True: 2.36k, False: 138]
  ------------------
  774|  2.36k|        return false;
  775|  2.36k|      }
  776|    138|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (776:11): [True: 34, False: 104]
  ------------------
  777|     34|        ctx->error = EXT_TYPE_READING_ERROR;
  778|     34|        return false;
  779|     34|      }
  780|    104|      return true;
  781|      0|    default:
  ------------------
  |  Branch (781:5): [True: 0, False: 232k]
  ------------------
  782|      0|      break;
  783|   232k|  }
  784|       |
  785|      0|  ctx->error = INVALID_TYPE_ERROR;
  786|      0|  return false;
  787|   232k|}
cmp.c:read_type_size:
  422|  96.5k|                                           uint32_t *size) {
  423|  96.5k|  uint8_t u8temp = 0;
  424|  96.5k|  uint16_t u16temp = 0;
  425|  96.5k|  uint32_t u32temp = 0;
  426|       |
  427|  96.5k|  switch (cmp_type) {
  428|      0|    case CMP_TYPE_POSITIVE_FIXNUM:
  ------------------
  |  Branch (428:5): [True: 0, False: 96.5k]
  ------------------
  429|      0|      *size = 0;
  430|      0|      return true;
  431|    576|    case CMP_TYPE_FIXMAP:
  ------------------
  |  Branch (431:5): [True: 576, False: 95.9k]
  ------------------
  432|    576|      *size = (type_marker & FIXMAP_SIZE);
  433|    576|      return true;
  434|  78.8k|    case CMP_TYPE_FIXARRAY:
  ------------------
  |  Branch (434:5): [True: 78.8k, False: 17.6k]
  ------------------
  435|  78.8k|      *size = (type_marker & FIXARRAY_SIZE);
  436|  78.8k|      return true;
  437|    434|    case CMP_TYPE_FIXSTR:
  ------------------
  |  Branch (437:5): [True: 434, False: 96.1k]
  ------------------
  438|    434|      *size = (type_marker & FIXSTR_SIZE);
  439|    434|      return true;
  440|      0|    case CMP_TYPE_NIL:
  ------------------
  |  Branch (440:5): [True: 0, False: 96.5k]
  ------------------
  441|      0|      *size = 0;
  442|      0|      return true;
  443|      0|    case CMP_TYPE_BOOLEAN:
  ------------------
  |  Branch (443:5): [True: 0, False: 96.5k]
  ------------------
  444|      0|      *size = 0;
  445|      0|      return true;
  446|  8.02k|    case CMP_TYPE_BIN8:
  ------------------
  |  Branch (446:5): [True: 8.02k, False: 88.5k]
  ------------------
  447|  8.02k|      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
  ------------------
  |  Branch (447:11): [True: 119, False: 7.90k]
  ------------------
  448|    119|        ctx->error = LENGTH_READING_ERROR;
  449|    119|        return false;
  450|    119|      }
  451|  7.90k|      *size = u8temp;
  452|  7.90k|      return true;
  453|    495|    case CMP_TYPE_BIN16:
  ------------------
  |  Branch (453:5): [True: 495, False: 96.0k]
  ------------------
  454|    495|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (454:11): [True: 19, False: 476]
  ------------------
  455|     19|        ctx->error = LENGTH_READING_ERROR;
  456|     19|        return false;
  457|     19|      }
  458|    476|      *size = be16(u16temp);
  459|    476|      return true;
  460|  2.56k|    case CMP_TYPE_BIN32:
  ------------------
  |  Branch (460:5): [True: 2.56k, False: 93.9k]
  ------------------
  461|  2.56k|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (461:11): [True: 450, False: 2.11k]
  ------------------
  462|    450|        ctx->error = LENGTH_READING_ERROR;
  463|    450|        return false;
  464|    450|      }
  465|  2.11k|      *size = be32(u32temp);
  466|  2.11k|      return true;
  467|     96|    case CMP_TYPE_EXT8:
  ------------------
  |  Branch (467:5): [True: 96, False: 96.4k]
  ------------------
  468|     96|      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
  ------------------
  |  Branch (468:11): [True: 11, False: 85]
  ------------------
  469|     11|        ctx->error = LENGTH_READING_ERROR;
  470|     11|        return false;
  471|     11|      }
  472|     85|      *size = u8temp;
  473|     85|      return true;
  474|    396|    case CMP_TYPE_EXT16:
  ------------------
  |  Branch (474:5): [True: 396, False: 96.1k]
  ------------------
  475|    396|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (475:11): [True: 111, False: 285]
  ------------------
  476|    111|        ctx->error = LENGTH_READING_ERROR;
  477|    111|        return false;
  478|    111|      }
  479|    285|      *size = be16(u16temp);
  480|    285|      return true;
  481|  2.50k|    case CMP_TYPE_EXT32:
  ------------------
  |  Branch (481:5): [True: 2.50k, False: 94.0k]
  ------------------
  482|  2.50k|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (482:11): [True: 2.36k, False: 138]
  ------------------
  483|  2.36k|        ctx->error = LENGTH_READING_ERROR;
  484|  2.36k|        return false;
  485|  2.36k|      }
  486|    138|      *size = be32(u32temp);
  487|    138|      return true;
  488|      0|    case CMP_TYPE_FLOAT:
  ------------------
  |  Branch (488:5): [True: 0, False: 96.5k]
  ------------------
  489|      0|      *size = 4;
  490|      0|      return true;
  491|      0|    case CMP_TYPE_DOUBLE:
  ------------------
  |  Branch (491:5): [True: 0, False: 96.5k]
  ------------------
  492|      0|      *size = 8;
  493|      0|      return true;
  494|      0|    case CMP_TYPE_UINT8:
  ------------------
  |  Branch (494:5): [True: 0, False: 96.5k]
  ------------------
  495|      0|      *size = 1;
  496|      0|      return true;
  497|      0|    case CMP_TYPE_UINT16:
  ------------------
  |  Branch (497:5): [True: 0, False: 96.5k]
  ------------------
  498|      0|      *size = 2;
  499|      0|      return true;
  500|      0|    case CMP_TYPE_UINT32:
  ------------------
  |  Branch (500:5): [True: 0, False: 96.5k]
  ------------------
  501|      0|      *size = 4;
  502|      0|      return true;
  503|      0|    case CMP_TYPE_UINT64:
  ------------------
  |  Branch (503:5): [True: 0, False: 96.5k]
  ------------------
  504|      0|      *size = 8;
  505|      0|      return true;
  506|      0|    case CMP_TYPE_SINT8:
  ------------------
  |  Branch (506:5): [True: 0, False: 96.5k]
  ------------------
  507|      0|      *size = 1;
  508|      0|      return true;
  509|      0|    case CMP_TYPE_SINT16:
  ------------------
  |  Branch (509:5): [True: 0, False: 96.5k]
  ------------------
  510|      0|      *size = 2;
  511|      0|      return true;
  512|      0|    case CMP_TYPE_SINT32:
  ------------------
  |  Branch (512:5): [True: 0, False: 96.5k]
  ------------------
  513|      0|      *size = 4;
  514|      0|      return true;
  515|      0|    case CMP_TYPE_SINT64:
  ------------------
  |  Branch (515:5): [True: 0, False: 96.5k]
  ------------------
  516|      0|      *size = 8;
  517|      0|      return true;
  518|      0|    case CMP_TYPE_FIXEXT1:
  ------------------
  |  Branch (518:5): [True: 0, False: 96.5k]
  ------------------
  519|      0|      *size = 1;
  520|      0|      return true;
  521|      0|    case CMP_TYPE_FIXEXT2:
  ------------------
  |  Branch (521:5): [True: 0, False: 96.5k]
  ------------------
  522|      0|      *size = 2;
  523|      0|      return true;
  524|      0|    case CMP_TYPE_FIXEXT4:
  ------------------
  |  Branch (524:5): [True: 0, False: 96.5k]
  ------------------
  525|      0|      *size = 4;
  526|      0|      return true;
  527|      0|    case CMP_TYPE_FIXEXT8:
  ------------------
  |  Branch (527:5): [True: 0, False: 96.5k]
  ------------------
  528|      0|      *size = 8;
  529|      0|      return true;
  530|      0|    case CMP_TYPE_FIXEXT16:
  ------------------
  |  Branch (530:5): [True: 0, False: 96.5k]
  ------------------
  531|      0|      *size = 16;
  532|      0|      return true;
  533|  1.04k|    case CMP_TYPE_STR8:
  ------------------
  |  Branch (533:5): [True: 1.04k, False: 95.5k]
  ------------------
  534|  1.04k|      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
  ------------------
  |  Branch (534:11): [True: 11, False: 1.03k]
  ------------------
  535|     11|        ctx->error = DATA_READING_ERROR;
  536|     11|        return false;
  537|     11|      }
  538|  1.03k|      *size = u8temp;
  539|  1.03k|      return true;
  540|    312|    case CMP_TYPE_STR16:
  ------------------
  |  Branch (540:5): [True: 312, False: 96.2k]
  ------------------
  541|    312|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (541:11): [True: 11, False: 301]
  ------------------
  542|     11|        ctx->error = DATA_READING_ERROR;
  543|     11|        return false;
  544|     11|      }
  545|    301|      *size = be16(u16temp);
  546|    301|      return true;
  547|    304|    case CMP_TYPE_STR32:
  ------------------
  |  Branch (547:5): [True: 304, False: 96.2k]
  ------------------
  548|    304|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (548:11): [True: 21, False: 283]
  ------------------
  549|     21|        ctx->error = DATA_READING_ERROR;
  550|     21|        return false;
  551|     21|      }
  552|    283|      *size = be32(u32temp);
  553|    283|      return true;
  554|    414|    case CMP_TYPE_ARRAY16:
  ------------------
  |  Branch (554:5): [True: 414, False: 96.1k]
  ------------------
  555|    414|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (555:11): [True: 315, False: 99]
  ------------------
  556|    315|        ctx->error = DATA_READING_ERROR;
  557|    315|        return false;
  558|    315|      }
  559|     99|      *size = be16(u16temp);
  560|     99|      return true;
  561|    159|    case CMP_TYPE_ARRAY32:
  ------------------
  |  Branch (561:5): [True: 159, False: 96.3k]
  ------------------
  562|    159|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (562:11): [True: 47, False: 112]
  ------------------
  563|     47|        ctx->error = DATA_READING_ERROR;
  564|     47|        return false;
  565|     47|      }
  566|    112|      *size = be32(u32temp);
  567|    112|      return true;
  568|    146|    case CMP_TYPE_MAP16:
  ------------------
  |  Branch (568:5): [True: 146, False: 96.4k]
  ------------------
  569|    146|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (569:11): [True: 26, False: 120]
  ------------------
  570|     26|        ctx->error = DATA_READING_ERROR;
  571|     26|        return false;
  572|     26|      }
  573|    120|      *size = be16(u16temp);
  574|    120|      return true;
  575|    231|    case CMP_TYPE_MAP32:
  ------------------
  |  Branch (575:5): [True: 231, False: 96.3k]
  ------------------
  576|    231|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (576:11): [True: 39, False: 192]
  ------------------
  577|     39|        ctx->error = DATA_READING_ERROR;
  578|     39|        return false;
  579|     39|      }
  580|    192|      *size = be32(u32temp);
  581|    192|      return true;
  582|      0|    case CMP_TYPE_NEGATIVE_FIXNUM:
  ------------------
  |  Branch (582:5): [True: 0, False: 96.5k]
  ------------------
  583|      0|      *size = 0;
  584|      0|      return true;
  585|      0|    default:
  ------------------
  |  Branch (585:5): [True: 0, False: 96.5k]
  ------------------
  586|      0|      ctx->error = INVALID_TYPE_ERROR;
  587|      0|      return false;
  588|  96.5k|  }
  589|  96.5k|}

dht_get_self_public_key:
  142|  4.01k|{
  143|  4.01k|    return dht->self_public_key;
  144|  4.01k|}
dht_get_self_secret_key:
  146|  8.56k|{
  147|  8.56k|    return dht->self_secret_key;
  148|  8.56k|}
dht_get_net:
  160|  36.3k|{
  161|  36.3k|    return dht->net;
  162|  36.3k|}
id_closest:
  216|    283|{
  217|  9.33k|    for (size_t i = 0; i < CRYPTO_PUBLIC_KEY_SIZE; ++i) {
  ------------------
  |  |   40|  9.33k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (217:24): [True: 9.05k, False: 283]
  ------------------
  218|  9.05k|        const uint8_t distance1 = pk[i] ^ pk1[i];
  219|  9.05k|        const uint8_t distance2 = pk[i] ^ pk2[i];
  220|       |
  221|  9.05k|        if (distance1 < distance2) {
  ------------------
  |  Branch (221:13): [True: 0, False: 9.05k]
  ------------------
  222|      0|            return 1;
  223|      0|        }
  224|       |
  225|  9.05k|        if (distance1 > distance2) {
  ------------------
  |  Branch (225:13): [True: 0, False: 9.05k]
  ------------------
  226|      0|            return 2;
  227|      0|        }
  228|  9.05k|    }
  229|       |
  230|    283|    return 0;
  231|    283|}
packed_node_size:
  350|  18.0k|{
  351|  18.0k|    if (net_family_is_ipv4(ip_family) || net_family_is_tcp_ipv4(ip_family)) {
  ------------------
  |  Branch (351:9): [True: 4.52k, False: 13.5k]
  |  Branch (351:42): [True: 0, False: 13.5k]
  ------------------
  352|  4.52k|        return PACKED_NODE_SIZE_IP4;
  ------------------
  |  |   85|  4.52k|#define PACKED_NODE_SIZE_IP4 (1 + SIZE_IP4 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |  224|  4.52k|#define SIZE_IP4 4
  |  |  ------------------
  |  |               #define PACKED_NODE_SIZE_IP4 (1 + SIZE_IP4 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   40|  4.52k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  353|  4.52k|    }
  354|       |
  355|  13.5k|    if (net_family_is_ipv6(ip_family) || net_family_is_tcp_ipv6(ip_family)) {
  ------------------
  |  Branch (355:9): [True: 4.52k, False: 9.04k]
  |  Branch (355:42): [True: 9.04k, False: 0]
  ------------------
  356|  13.5k|        return PACKED_NODE_SIZE_IP6;
  ------------------
  |  |   86|  13.5k|#define PACKED_NODE_SIZE_IP6 (1 + SIZE_IP6 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |  225|  13.5k|#define SIZE_IP6 16
  |  |  ------------------
  |  |               #define PACKED_NODE_SIZE_IP6 (1 + SIZE_IP6 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   40|  13.5k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  357|  13.5k|    }
  358|       |
  359|      0|    return -1;
  360|  13.5k|}
pack_ip_port:
  364|  2.57k|{
  365|  2.57k|    if (data == nullptr) {
  ------------------
  |  |   66|  2.57k|#define nullptr NULL
  ------------------
  |  Branch (365:9): [True: 0, False: 2.57k]
  ------------------
  366|      0|        return -1;
  367|      0|    }
  368|       |
  369|  2.57k|    bool is_ipv4;
  370|  2.57k|    uint8_t family;
  371|       |
  372|  2.57k|    if (net_family_is_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (372:9): [True: 1.86k, False: 708]
  ------------------
  373|       |        // TODO(irungentoo): use functions to convert endianness
  374|  1.86k|        is_ipv4 = true;
  375|  1.86k|        family = TOX_AF_INET;
  ------------------
  |  |  207|  1.86k|#define TOX_AF_INET 2
  ------------------
  376|  1.86k|    } else if (net_family_is_tcp_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (376:16): [True: 82, False: 626]
  ------------------
  377|     82|        is_ipv4 = true;
  378|     82|        family = TOX_TCP_INET;
  ------------------
  |  |  209|     82|#define TOX_TCP_INET 130
  ------------------
  379|    626|    } else if (net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (379:16): [True: 456, False: 170]
  ------------------
  380|    456|        is_ipv4 = false;
  381|    456|        family = TOX_AF_INET6;
  ------------------
  |  |  208|    456|#define TOX_AF_INET6 10
  ------------------
  382|    456|    } else if (net_family_is_tcp_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (382:16): [True: 170, False: 0]
  ------------------
  383|    170|        is_ipv4 = false;
  384|    170|        family = TOX_TCP_INET6;
  ------------------
  |  |  210|    170|#define TOX_TCP_INET6 138
  ------------------
  385|    170|    } else {
  386|      0|        Ip_Ntoa ip_str;
  387|       |        // TODO(iphydf): Find out why we're trying to pack invalid IPs, stop
  388|       |        // doing that, and turn this into an error.
  389|      0|        LOGGER_TRACE(logger, "cannot pack invalid IP: %s", net_ip_ntoa(&ip_port->ip, &ip_str));
  ------------------
  |  |   79|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  390|      0|        return -1;
  391|      0|    }
  392|       |
  393|  2.57k|    if (is_ipv4) {
  ------------------
  |  Branch (393:9): [True: 1.94k, False: 626]
  ------------------
  394|  1.94k|        const uint32_t size = 1 + SIZE_IP4 + sizeof(uint16_t);
  ------------------
  |  |  224|  1.94k|#define SIZE_IP4 4
  ------------------
  395|       |
  396|  1.94k|        if (size > length) {
  ------------------
  |  Branch (396:13): [True: 0, False: 1.94k]
  ------------------
  397|      0|            return -1;
  398|      0|        }
  399|       |
  400|  1.94k|        data[0] = family;
  401|  1.94k|        memcpy(data + 1, &ip_port->ip.ip.v4, SIZE_IP4);
  ------------------
  |  |  224|  1.94k|#define SIZE_IP4 4
  ------------------
  402|  1.94k|        memcpy(data + 1 + SIZE_IP4, &ip_port->port, sizeof(uint16_t));
  ------------------
  |  |  224|  1.94k|#define SIZE_IP4 4
  ------------------
  403|  1.94k|        return size;
  404|  1.94k|    } else {
  405|    626|        const uint32_t size = 1 + SIZE_IP6 + sizeof(uint16_t);
  ------------------
  |  |  225|    626|#define SIZE_IP6 16
  ------------------
  406|       |
  407|    626|        if (size > length) {
  ------------------
  |  Branch (407:13): [True: 0, False: 626]
  ------------------
  408|      0|            return -1;
  409|      0|        }
  410|       |
  411|    626|        data[0] = family;
  412|    626|        memcpy(data + 1, &ip_port->ip.ip.v6, SIZE_IP6);
  ------------------
  |  |  225|    626|#define SIZE_IP6 16
  ------------------
  413|    626|        memcpy(data + 1 + SIZE_IP6, &ip_port->port, sizeof(uint16_t));
  ------------------
  |  |  225|    626|#define SIZE_IP6 16
  ------------------
  414|    626|        return size;
  415|    626|    }
  416|  2.57k|}
unpack_ip_port:
  455|  9.90k|{
  456|  9.90k|    if (data == nullptr) {
  ------------------
  |  |   66|  9.90k|#define nullptr NULL
  ------------------
  |  Branch (456:9): [True: 0, False: 9.90k]
  ------------------
  457|      0|        return -1;
  458|      0|    }
  459|       |
  460|  9.90k|    bool is_ipv4;
  461|  9.90k|    Family host_family;
  462|       |
  463|  9.90k|    if (data[0] == TOX_AF_INET) {
  ------------------
  |  |  207|  9.90k|#define TOX_AF_INET 2
  ------------------
  |  Branch (463:9): [True: 7.21k, False: 2.68k]
  ------------------
  464|  7.21k|        is_ipv4 = true;
  465|  7.21k|        host_family = net_family_ipv4();
  466|  7.21k|    } else if (data[0] == TOX_TCP_INET) {
  ------------------
  |  |  209|  2.68k|#define TOX_TCP_INET 130
  ------------------
  |  Branch (466:16): [True: 476, False: 2.20k]
  ------------------
  467|    476|        if (!tcp_enabled) {
  ------------------
  |  Branch (467:13): [True: 53, False: 423]
  ------------------
  468|     53|            return -1;
  469|     53|        }
  470|       |
  471|    423|        is_ipv4 = true;
  472|    423|        host_family = net_family_tcp_ipv4();
  473|  2.20k|    } else if (data[0] == TOX_AF_INET6) {
  ------------------
  |  |  208|  2.20k|#define TOX_AF_INET6 10
  ------------------
  |  Branch (473:16): [True: 886, False: 1.32k]
  ------------------
  474|    886|        is_ipv4 = false;
  475|    886|        host_family = net_family_ipv6();
  476|  1.32k|    } else if (data[0] == TOX_TCP_INET6) {
  ------------------
  |  |  210|  1.32k|#define TOX_TCP_INET6 138
  ------------------
  |  Branch (476:16): [True: 227, False: 1.09k]
  ------------------
  477|    227|        if (!tcp_enabled) {
  ------------------
  |  Branch (477:13): [True: 77, False: 150]
  ------------------
  478|     77|            return -1;
  479|     77|        }
  480|       |
  481|    150|        is_ipv4 = false;
  482|    150|        host_family = net_family_tcp_ipv6();
  483|  1.09k|    } else {
  484|  1.09k|        return -1;
  485|  1.09k|    }
  486|       |
  487|  8.67k|    *ip_port = empty_ip_port;
  488|       |
  489|  8.67k|    if (is_ipv4) {
  ------------------
  |  Branch (489:9): [True: 7.64k, False: 1.03k]
  ------------------
  490|  7.64k|        const uint32_t size = 1 + SIZE_IP4 + sizeof(uint16_t);
  ------------------
  |  |  224|  7.64k|#define SIZE_IP4 4
  ------------------
  491|       |
  492|  7.64k|        if (size > length) {
  ------------------
  |  Branch (492:13): [True: 61, False: 7.58k]
  ------------------
  493|     61|            return -1;
  494|     61|        }
  495|       |
  496|  7.58k|        ip_port->ip.family = host_family;
  497|  7.58k|        memcpy(&ip_port->ip.ip.v4, data + 1, SIZE_IP4);
  ------------------
  |  |  224|  7.58k|#define SIZE_IP4 4
  ------------------
  498|  7.58k|        memcpy(&ip_port->port, data + 1 + SIZE_IP4, sizeof(uint16_t));
  ------------------
  |  |  224|  7.58k|#define SIZE_IP4 4
  ------------------
  499|  7.58k|        return size;
  500|  7.64k|    } else {
  501|  1.03k|        const uint32_t size = 1 + SIZE_IP6 + sizeof(uint16_t);
  ------------------
  |  |  225|  1.03k|#define SIZE_IP6 16
  ------------------
  502|       |
  503|  1.03k|        if (size > length) {
  ------------------
  |  Branch (503:13): [True: 141, False: 895]
  ------------------
  504|    141|            return -1;
  505|    141|        }
  506|       |
  507|    895|        ip_port->ip.family = host_family;
  508|    895|        memcpy(&ip_port->ip.ip.v6, data + 1, SIZE_IP6);
  ------------------
  |  |  225|    895|#define SIZE_IP6 16
  ------------------
  509|    895|        memcpy(&ip_port->port, data + 1 + SIZE_IP6, sizeof(uint16_t));
  ------------------
  |  |  225|    895|#define SIZE_IP6 16
  ------------------
  510|    895|        return size;
  511|  1.03k|    }
  512|  8.67k|}
pack_nodes:
  515|  4.73k|{
  516|  4.73k|    uint32_t packed_length = 0;
  517|       |
  518|  6.79k|    for (uint32_t i = 0; i < number && packed_length < length; ++i) {
  ------------------
  |  Branch (518:26): [True: 2.05k, False: 4.73k]
  |  Branch (518:40): [True: 2.05k, False: 0]
  ------------------
  519|  2.05k|        const int ipp_size = pack_ip_port(logger, data + packed_length, length - packed_length, &nodes[i].ip_port);
  520|       |
  521|  2.05k|        if (ipp_size == -1) {
  ------------------
  |  Branch (521:13): [True: 0, False: 2.05k]
  ------------------
  522|      0|            return -1;
  523|      0|        }
  524|       |
  525|  2.05k|        packed_length += ipp_size;
  526|       |
  527|  2.05k|        if (packed_length + CRYPTO_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |   40|  2.05k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (527:13): [True: 0, False: 2.05k]
  ------------------
  528|      0|            return -1;
  529|      0|        }
  530|       |
  531|  2.05k|        memcpy(data + packed_length, nodes[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|  2.05k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  532|  2.05k|        packed_length += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|  2.05k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  533|       |
  534|  2.05k|#ifndef NDEBUG
  535|  2.05k|        const uint32_t increment = ipp_size + CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|  2.05k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  536|  2.05k|        assert(increment == PACKED_NODE_SIZE_IP4 || increment == PACKED_NODE_SIZE_IP6);
  537|  2.05k|#endif
  538|  2.05k|    }
  539|       |
  540|  4.73k|    return packed_length;
  541|  4.73k|}
unpack_nodes:
  545|  1.99k|{
  546|  1.99k|    uint32_t num = 0;
  547|  1.99k|    uint32_t len_processed = 0;
  548|       |
  549|  9.97k|    while (num < max_num_nodes && len_processed < length) {
  ------------------
  |  Branch (549:12): [True: 9.74k, False: 232]
  |  Branch (549:35): [True: 9.27k, False: 473]
  ------------------
  550|  9.27k|        const int ipp_size = unpack_ip_port(&nodes[num].ip_port, data + len_processed, length - len_processed, tcp_enabled);
  551|       |
  552|  9.27k|        if (ipp_size == -1) {
  ------------------
  |  Branch (552:13): [True: 1.17k, False: 8.09k]
  ------------------
  553|  1.17k|            return -1;
  554|  1.17k|        }
  555|       |
  556|  8.09k|        len_processed += ipp_size;
  557|       |
  558|  8.09k|        if (len_processed + CRYPTO_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |   40|  8.09k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (558:13): [True: 111, False: 7.98k]
  ------------------
  559|    111|            return -1;
  560|    111|        }
  561|       |
  562|  7.98k|        memcpy(nodes[num].public_key, data + len_processed, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|  7.98k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  563|  7.98k|        len_processed += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|  7.98k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  564|  7.98k|        ++num;
  565|       |
  566|  7.98k|#ifndef NDEBUG
  567|  7.98k|        const uint32_t increment = ipp_size + CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|  7.98k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  568|  7.98k|        assert(increment == PACKED_NODE_SIZE_IP4 || increment == PACKED_NODE_SIZE_IP6);
  569|  7.98k|#endif
  570|  7.98k|    }
  571|       |
  572|    705|    if (processed_data_len != nullptr) {
  ------------------
  |  |   66|    705|#define nullptr NULL
  ------------------
  |  Branch (572:9): [True: 61, False: 644]
  ------------------
  573|     61|        *processed_data_len = len_processed;
  574|     61|    }
  575|       |
  576|    705|    return num;
  577|  1.99k|}
get_close_nodes:
  848|  4.28k|{
  849|  4.28k|    memset(nodes_list, 0, MAX_SENT_NODES * sizeof(Node_format));
  ------------------
  |  |   54|  4.28k|#define MAX_SENT_NODES 4
  ------------------
  850|  4.28k|    return get_somewhat_close_nodes(dht, public_key, nodes_list, sa_family,
  851|  4.28k|                                    is_lan, want_announce);
  852|  4.28k|}
dht_addfriend:
 1673|  4.28k|{
 1674|  4.28k|    const uint32_t friend_num = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);
 1675|       |
 1676|  4.28k|    if (friend_num != UINT32_MAX) { /* Is friend already in DHT? */
  ------------------
  |  Branch (1676:9): [True: 0, False: 4.28k]
  ------------------
 1677|      0|        DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
 1678|      0|        const uint32_t tmp_lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1679|       |
 1680|      0|        if (tmp_lock_token == 0) {
  ------------------
  |  Branch (1680:13): [True: 0, False: 0]
  ------------------
 1681|      0|            return -1;
 1682|      0|        }
 1683|       |
 1684|      0|        return 0;
 1685|      0|    }
 1686|       |
 1687|  4.28k|    DHT_Friend *const temp = (DHT_Friend *)mem_vrealloc(dht->mem, dht->friends_list, dht->num_friends + 1, sizeof(DHT_Friend));
 1688|       |
 1689|  4.28k|    if (temp == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
  |  Branch (1689:9): [True: 0, False: 4.28k]
  ------------------
 1690|      0|        return -1;
 1691|      0|    }
 1692|       |
 1693|  4.28k|    dht->friends_list = temp;
 1694|  4.28k|    DHT_Friend *const dht_friend = &dht->friends_list[dht->num_friends];
 1695|  4.28k|    *dht_friend = empty_dht_friend;
 1696|  4.28k|    memcpy(dht_friend->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|  4.28k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1697|       |
 1698|  4.28k|    dht_friend->nat.nat_ping_id = random_u64(dht->rng);
 1699|  4.28k|    ++dht->num_friends;
 1700|       |
 1701|  4.28k|    *lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1702|  4.28k|    assert(*lock_token != 0); // Friend was newly allocated
 1703|       |
 1704|      0|    dht_friend->num_to_bootstrap = get_close_nodes(dht, dht_friend->public_key, dht_friend->to_bootstrap, net_family_unspec(),
 1705|  4.28k|                                   true, false);
 1706|       |
 1707|  4.28k|    return 0;
 1708|  4.28k|}
cryptopacket_registerhandler:
 2532|  8.56k|{
 2533|  8.56k|    dht->cryptopackethandlers[byte].function = cb;
 2534|  8.56k|    dht->cryptopackethandlers[byte].object = object;
 2535|  8.56k|}
dht_callback_get_nodes_response:
 2582|  1.50k|{
 2583|  1.50k|    dht->get_nodes_response = function;
 2584|  1.50k|}
new_dht:
 2613|  2.14k|{
 2614|  2.14k|    if (net == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (2614:9): [True: 0, False: 2.14k]
  ------------------
 2615|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2616|      0|    }
 2617|       |
 2618|  2.14k|    DHT *const dht = (DHT *)mem_alloc(mem, sizeof(DHT));
 2619|       |
 2620|  2.14k|    if (dht == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (2620:9): [True: 0, False: 2.14k]
  ------------------
 2621|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2622|      0|    }
 2623|       |
 2624|  2.14k|    dht->ns = ns;
 2625|  2.14k|    dht->mono_time = mono_time;
 2626|  2.14k|    dht->cur_time = mono_time_get(mono_time);
 2627|  2.14k|    dht->log = log;
 2628|  2.14k|    dht->net = net;
 2629|  2.14k|    dht->rng = rng;
 2630|  2.14k|    dht->mem = mem;
 2631|       |
 2632|  2.14k|    dht->hole_punching_enabled = hole_punching_enabled;
 2633|  2.14k|    dht->lan_discovery_enabled = lan_discovery_enabled;
 2634|       |
 2635|  2.14k|    dht->ping = ping_new(mem, mono_time, rng, dht);
 2636|       |
 2637|  2.14k|    if (dht->ping == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (2637:9): [True: 0, False: 2.14k]
  ------------------
 2638|      0|        kill_dht(dht);
 2639|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2640|      0|    }
 2641|       |
 2642|  2.14k|    networking_registerhandler(dht->net, NET_PACKET_GET_NODES, &handle_getnodes, dht);
 2643|  2.14k|    networking_registerhandler(dht->net, NET_PACKET_SEND_NODES_IPV6, &handle_sendnodes_ipv6, dht);
 2644|  2.14k|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, &cryptopacket_handle, dht);
 2645|  2.14k|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, &handle_lan_discovery, dht);
 2646|  2.14k|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, &handle_nat_ping, dht);
  ------------------
  |  |   82|  2.14k|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
 2647|       |
 2648|  2.14k|#ifdef CHECK_ANNOUNCE_NODE
 2649|  2.14k|    networking_registerhandler(dht->net, NET_PACKET_DATA_SEARCH_RESPONSE, &handle_data_search_response, dht);
 2650|  2.14k|#endif
 2651|       |
 2652|  2.14k|    crypto_new_keypair(rng, dht->self_public_key, dht->self_secret_key);
 2653|       |
 2654|  2.14k|    dht->shared_keys_recv = shared_key_cache_new(mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   52|  2.14k|#define KEYS_TIMEOUT 600
  ------------------
                  dht->shared_keys_recv = shared_key_cache_new(mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   51|  2.14k|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2655|  2.14k|    dht->shared_keys_sent = shared_key_cache_new(mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   52|  2.14k|#define KEYS_TIMEOUT 600
  ------------------
                  dht->shared_keys_sent = shared_key_cache_new(mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   51|  2.14k|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2656|       |
 2657|  2.14k|    if (dht->shared_keys_recv == nullptr || dht->shared_keys_sent == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                  if (dht->shared_keys_recv == nullptr || dht->shared_keys_sent == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (2657:9): [True: 0, False: 2.14k]
  |  Branch (2657:45): [True: 0, False: 2.14k]
  ------------------
 2658|      0|        kill_dht(dht);
 2659|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2660|      0|    }
 2661|       |
 2662|       |
 2663|  2.14k|    dht->dht_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   60|  2.14k|#define DHT_PING_ARRAY_SIZE 512
  ------------------
                  dht->dht_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   57|  2.14k|#define PING_TIMEOUT 5
  ------------------
 2664|       |
 2665|  2.14k|    if (dht->dht_ping_array == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (2665:9): [True: 0, False: 2.14k]
  ------------------
 2666|      0|        kill_dht(dht);
 2667|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2668|      0|    }
 2669|       |
 2670|  6.42k|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
  ------------------
  |  |   75|  6.42k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2670:26): [True: 4.28k, False: 2.14k]
  ------------------
 2671|  4.28k|        uint8_t random_public_key_bytes[CRYPTO_PUBLIC_KEY_SIZE];
 2672|  4.28k|        uint8_t random_secret_key_bytes[CRYPTO_SECRET_KEY_SIZE];
 2673|       |
 2674|  4.28k|        crypto_new_keypair(rng, random_public_key_bytes, random_secret_key_bytes);
 2675|       |
 2676|  4.28k|        uint32_t token; // We don't intend to delete these ever, but need to pass the token
 2677|  4.28k|        if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                      if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
  |  Branch (2677:13): [True: 0, False: 4.28k]
  ------------------
 2678|      0|            kill_dht(dht);
 2679|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2680|      0|        }
 2681|  4.28k|    }
 2682|       |
 2683|  2.14k|    if (dht->num_friends != DHT_FAKE_FRIEND_NUMBER) {
  ------------------
  |  |   75|  2.14k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2683:9): [True: 0, False: 2.14k]
  ------------------
 2684|      0|        LOGGER_ERROR(log, "the RNG provided seems to be broken: it generated the same keypair twice");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2685|      0|        kill_dht(dht);
 2686|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2687|      0|    }
 2688|       |
 2689|  2.14k|    return dht;
 2690|  2.14k|}
kill_dht:
 2714|  2.14k|{
 2715|  2.14k|    if (dht == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (2715:9): [True: 0, False: 2.14k]
  ------------------
 2716|      0|        return;
 2717|      0|    }
 2718|       |
 2719|  2.14k|    networking_registerhandler(dht->net, NET_PACKET_GET_NODES, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_GET_NODES, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 2720|  2.14k|    networking_registerhandler(dht->net, NET_PACKET_SEND_NODES_IPV6, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_SEND_NODES_IPV6, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 2721|  2.14k|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 2722|  2.14k|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 2723|  2.14k|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   82|  2.14k|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 2724|       |
 2725|  2.14k|    shared_key_cache_free(dht->shared_keys_recv);
 2726|  2.14k|    shared_key_cache_free(dht->shared_keys_sent);
 2727|  2.14k|    ping_array_kill(dht->dht_ping_array);
 2728|  2.14k|    ping_kill(dht->mem, dht->ping);
 2729|  2.14k|    mem_delete(dht->mem, dht->friends_list);
 2730|  2.14k|    mem_delete(dht->mem, dht->loaded_nodes_list);
 2731|  2.14k|    crypto_memzero(dht->self_secret_key, sizeof(dht->self_secret_key));
 2732|  2.14k|    mem_delete(dht->mem, dht);
 2733|  2.14k|}
dht_size:
 2746|  4.52k|{
 2747|  4.52k|    uint32_t numv4 = 0;
 2748|  4.52k|    uint32_t numv6 = 0;
 2749|       |
 2750|  9.16k|    for (uint32_t i = 0; i < dht->loaded_num_nodes; ++i) {
  ------------------
  |  Branch (2750:26): [True: 4.64k, False: 4.52k]
  ------------------
 2751|  4.64k|        numv4 += net_family_is_ipv4(dht->loaded_nodes_list[i].ip_port.ip.family);
 2752|  4.64k|        numv6 += net_family_is_ipv6(dht->loaded_nodes_list[i].ip_port.ip.family);
 2753|  4.64k|    }
 2754|       |
 2755|  4.63M|    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
  ------------------
  |  |   49|  4.63M|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   46|  4.63M|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   45|  4.63M|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|  4.63M|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2755:26): [True: 4.62M, False: 4.52k]
  ------------------
 2756|  4.62M|        numv4 += dht->close_clientlist[i].assoc4.timestamp != 0;
 2757|  4.62M|        numv6 += dht->close_clientlist[i].assoc6.timestamp != 0;
 2758|  4.62M|    }
 2759|       |
 2760|  13.5k|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER && i < dht->num_friends; ++i) {
  ------------------
  |  |   75|  27.1k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2760:26): [True: 9.04k, False: 4.52k]
  |  Branch (2760:56): [True: 9.04k, False: 0]
  ------------------
 2761|  9.04k|        const DHT_Friend *const fr = &dht->friends_list[i];
 2762|       |
 2763|  81.3k|        for (uint32_t j = 0; j < MAX_FRIEND_CLIENTS; ++j) {
  ------------------
  |  |   43|  81.3k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  |  Branch (2763:30): [True: 72.3k, False: 9.04k]
  ------------------
 2764|  72.3k|            numv4 += fr->client_list[j].assoc4.timestamp != 0;
 2765|  72.3k|            numv6 += fr->client_list[j].assoc6.timestamp != 0;
 2766|  72.3k|        }
 2767|  9.04k|    }
 2768|       |
 2769|  4.52k|    const uint32_t size32 = sizeof(uint32_t);
 2770|  4.52k|    const uint32_t sizesubhead = size32 * 2;
 2771|       |
 2772|  4.52k|    return size32 + sizesubhead + packed_node_size(net_family_ipv4()) * numv4 + packed_node_size(net_family_ipv6()) * numv6;
 2773|  4.52k|}
dht_save:
 2777|  1.50k|{
 2778|  1.50k|    host_to_lendian_bytes32(data, DHT_STATE_COOKIE_GLOBAL);
  ------------------
  |  | 2737|  1.50k|#define DHT_STATE_COOKIE_GLOBAL 0x159000d
  ------------------
 2779|  1.50k|    data += sizeof(uint32_t);
 2780|       |
 2781|  1.50k|    uint8_t *const old_data = data;
 2782|       |
 2783|       |    /* get right offset. we write the actual header later. */
 2784|  1.50k|    data = state_write_section_header(data, DHT_STATE_COOKIE_TYPE, 0, 0);
  ------------------
  |  | 2739|  1.50k|#define DHT_STATE_COOKIE_TYPE      0x11ce
  ------------------
 2785|       |
 2786|  1.50k|    Node_format *clients = (Node_format *)mem_valloc(dht->mem, MAX_SAVED_DHT_NODES, sizeof(Node_format));
  ------------------
  |  | 2742|  1.50k|#define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   75|  1.50k|#define DHT_FAKE_FRIEND_NUMBER 2
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   43|  1.50k|#define MAX_FRIEND_CLIENTS 8
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   49|  1.50k|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   46|  1.50k|#define LCLIENT_LENGTH 128
  |  |  |  |  ------------------
  |  |  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   45|  1.50k|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   43|  1.50k|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2787|       |
 2788|  1.50k|    if (clients == nullptr) {
  ------------------
  |  |   66|  1.50k|#define nullptr NULL
  ------------------
  |  Branch (2788:9): [True: 0, False: 1.50k]
  ------------------
 2789|      0|        LOGGER_ERROR(dht->log, "could not allocate %u nodes", MAX_SAVED_DHT_NODES);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2790|      0|        return;
 2791|      0|    }
 2792|       |
 2793|  1.50k|    uint32_t num = 0;
 2794|       |
 2795|  1.50k|    if (dht->loaded_num_nodes > 0) {
  ------------------
  |  Branch (2795:9): [True: 44, False: 1.46k]
  ------------------
 2796|     44|        memcpy(clients, dht->loaded_nodes_list, sizeof(Node_format) * dht->loaded_num_nodes);
 2797|     44|        num += dht->loaded_num_nodes;
 2798|     44|    }
 2799|       |
 2800|  1.54M|    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
  ------------------
  |  |   49|  1.54M|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   46|  1.54M|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   45|  1.54M|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|  1.54M|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2800:26): [True: 1.54M, False: 1.50k]
  ------------------
 2801|  1.54M|        if (dht->close_clientlist[i].assoc4.timestamp != 0) {
  ------------------
  |  Branch (2801:13): [True: 0, False: 1.54M]
  ------------------
 2802|      0|            memcpy(clients[num].public_key, dht->close_clientlist[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2803|      0|            clients[num].ip_port = dht->close_clientlist[i].assoc4.ip_port;
 2804|      0|            ++num;
 2805|      0|        }
 2806|       |
 2807|  1.54M|        if (dht->close_clientlist[i].assoc6.timestamp != 0) {
  ------------------
  |  Branch (2807:13): [True: 0, False: 1.54M]
  ------------------
 2808|      0|            memcpy(clients[num].public_key, dht->close_clientlist[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2809|      0|            clients[num].ip_port = dht->close_clientlist[i].assoc6.ip_port;
 2810|      0|            ++num;
 2811|      0|        }
 2812|  1.54M|    }
 2813|       |
 2814|  4.52k|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER && i < dht->num_friends; ++i) {
  ------------------
  |  |   75|  9.04k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2814:26): [True: 3.01k, False: 1.50k]
  |  Branch (2814:56): [True: 3.01k, False: 0]
  ------------------
 2815|  3.01k|        const DHT_Friend *const fr = &dht->friends_list[i];
 2816|       |
 2817|  27.1k|        for (uint32_t j = 0; j < MAX_FRIEND_CLIENTS; ++j) {
  ------------------
  |  |   43|  27.1k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  |  Branch (2817:30): [True: 24.1k, False: 3.01k]
  ------------------
 2818|  24.1k|            if (fr->client_list[j].assoc4.timestamp != 0) {
  ------------------
  |  Branch (2818:17): [True: 0, False: 24.1k]
  ------------------
 2819|      0|                memcpy(clients[num].public_key, fr->client_list[j].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2820|      0|                clients[num].ip_port = fr->client_list[j].assoc4.ip_port;
 2821|      0|                ++num;
 2822|      0|            }
 2823|       |
 2824|  24.1k|            if (fr->client_list[j].assoc6.timestamp != 0) {
  ------------------
  |  Branch (2824:17): [True: 0, False: 24.1k]
  ------------------
 2825|      0|                memcpy(clients[num].public_key, fr->client_list[j].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2826|      0|                clients[num].ip_port = fr->client_list[j].assoc6.ip_port;
 2827|      0|                ++num;
 2828|      0|            }
 2829|  24.1k|        }
 2830|  3.01k|    }
 2831|       |
 2832|  1.50k|    state_write_section_header(old_data, DHT_STATE_COOKIE_TYPE, pack_nodes(dht->log, data, sizeof(Node_format) * num,
  ------------------
  |  | 2739|  1.50k|#define DHT_STATE_COOKIE_TYPE      0x11ce
  ------------------
 2833|  1.50k|                               clients, num), DHT_STATE_TYPE_NODES);
  ------------------
  |  | 2740|  1.50k|#define DHT_STATE_TYPE_NODES       4
  ------------------
 2834|       |
 2835|  1.50k|    mem_delete(dht->mem, clients);
 2836|  1.50k|}
dht_load:
 2911|    675|{
 2912|    675|    const uint32_t cookie_len = sizeof(uint32_t);
 2913|       |
 2914|    675|    if (length > cookie_len) {
  ------------------
  |  Branch (2914:9): [True: 609, False: 66]
  ------------------
 2915|    609|        uint32_t data32;
 2916|    609|        lendian_bytes_to_host32(&data32, data);
 2917|       |
 2918|    609|        if (data32 == DHT_STATE_COOKIE_GLOBAL) {
  ------------------
  |  | 2737|    609|#define DHT_STATE_COOKIE_GLOBAL 0x159000d
  ------------------
  |  Branch (2918:13): [True: 591, False: 18]
  ------------------
 2919|    591|            return state_load(dht->log, dht_load_state_callback, dht, data + cookie_len,
 2920|    591|                              length - cookie_len, DHT_STATE_COOKIE_TYPE);
  ------------------
  |  | 2739|    591|#define DHT_STATE_COOKIE_TYPE      0x11ce
  ------------------
 2921|    591|        }
 2922|    609|    }
 2923|       |
 2924|     84|    return -1;
 2925|    675|}
DHT.c:get_somewhat_close_nodes:
  832|  4.28k|{
  833|  4.28k|    uint32_t num_nodes = 0;
  834|  4.28k|    get_close_nodes_inner(dht->cur_time, public_key, nodes_list, sa_family,
  835|  4.28k|                          dht->close_clientlist, LCLIENT_LIST, &num_nodes, is_lan, want_announce);
  ------------------
  |  |   49|  4.28k|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   46|  4.28k|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   45|  4.28k|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|  4.28k|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  836|       |
  837|  10.7k|    for (uint32_t i = 0; i < dht->num_friends; ++i) {
  ------------------
  |  Branch (837:26): [True: 6.42k, False: 4.28k]
  ------------------
  838|  6.42k|        get_close_nodes_inner(dht->cur_time, public_key, nodes_list, sa_family,
  839|  6.42k|                              dht->friends_list[i].client_list, MAX_FRIEND_CLIENTS,
  ------------------
  |  |   43|  6.42k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  840|  6.42k|                              &num_nodes, is_lan, want_announce);
  841|  6.42k|    }
  842|       |
  843|  4.28k|    return num_nodes;
  844|  4.28k|}
DHT.c:get_close_nodes_inner:
  764|  10.7k|{
  765|  10.7k|    if (!net_family_is_ipv4(sa_family) && !net_family_is_ipv6(sa_family) && !net_family_is_unspec(sa_family)) {
  ------------------
  |  Branch (765:9): [True: 10.7k, False: 0]
  |  Branch (765:43): [True: 10.7k, False: 0]
  |  Branch (765:77): [True: 0, False: 10.7k]
  ------------------
  766|      0|        return;
  767|      0|    }
  768|       |
  769|  10.7k|    uint32_t num_nodes = *num_nodes_ptr;
  770|       |
  771|  4.44M|    for (uint32_t i = 0; i < client_list_length; ++i) {
  ------------------
  |  Branch (771:26): [True: 4.43M, False: 10.7k]
  ------------------
  772|  4.43M|        const Client_data *const client = &client_list[i];
  773|       |
  774|       |        /* node already in list? */
  775|  4.43M|        if (index_of_node_pk(nodes_list, MAX_SENT_NODES, client->public_key) != UINT32_MAX) {
  ------------------
  |  |   54|  4.43M|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (775:13): [True: 4.43M, False: 0]
  ------------------
  776|  4.43M|            continue;
  777|  4.43M|        }
  778|       |
  779|      0|        const IPPTsPng *ipptp;
  780|       |
  781|      0|        if (net_family_is_ipv4(sa_family)) {
  ------------------
  |  Branch (781:13): [True: 0, False: 0]
  ------------------
  782|      0|            ipptp = &client->assoc4;
  783|      0|        } else if (net_family_is_ipv6(sa_family)) {
  ------------------
  |  Branch (783:20): [True: 0, False: 0]
  ------------------
  784|      0|            ipptp = &client->assoc6;
  785|      0|        } else if (client->assoc4.timestamp >= client->assoc6.timestamp) {
  ------------------
  |  Branch (785:20): [True: 0, False: 0]
  ------------------
  786|      0|            ipptp = &client->assoc4;
  787|      0|        } else {
  788|      0|            ipptp = &client->assoc6;
  789|      0|        }
  790|       |
  791|       |        /* node not in a good condition? */
  792|      0|        if (assoc_timeout(cur_time, ipptp)) {
  ------------------
  |  Branch (792:13): [True: 0, False: 0]
  ------------------
  793|      0|            continue;
  794|      0|        }
  795|       |
  796|       |        /* don't send LAN ips to non LAN peers */
  797|      0|        if (ip_is_lan(&ipptp->ip_port.ip) && !is_lan) {
  ------------------
  |  Branch (797:13): [True: 0, False: 0]
  |  Branch (797:46): [True: 0, False: 0]
  ------------------
  798|      0|            continue;
  799|      0|        }
  800|       |
  801|      0|#ifdef CHECK_ANNOUNCE_NODE
  802|       |
  803|      0|        if (want_announce && !client->announce_node) {
  ------------------
  |  Branch (803:13): [True: 0, False: 0]
  |  Branch (803:30): [True: 0, False: 0]
  ------------------
  804|      0|            continue;
  805|      0|        }
  806|       |
  807|      0|#endif
  808|       |
  809|      0|        if (num_nodes < MAX_SENT_NODES) {
  ------------------
  |  |   54|      0|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (809:13): [True: 0, False: 0]
  ------------------
  810|      0|            memcpy(nodes_list[num_nodes].public_key, client->public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  811|      0|            nodes_list[num_nodes].ip_port = ipptp->ip_port;
  812|      0|            ++num_nodes;
  813|      0|        } else {
  814|       |            // TODO(zugz): this could be made significantly more efficient by
  815|       |            // using a version of add_to_list which works with a sorted list.
  816|      0|            add_to_list(nodes_list, MAX_SENT_NODES, client->public_key, &ipptp->ip_port, public_key);
  ------------------
  |  |   54|      0|#define MAX_SENT_NODES 4
  ------------------
  817|      0|        }
  818|      0|    }
  819|       |
  820|  10.7k|    *num_nodes_ptr = num_nodes;
  821|  10.7k|}
DHT.c:index_of_node_pk:
  613|  4.43M|{
  614|  4.43M|    assert(size == 0 || array != nullptr);
  615|       |
  616|  4.43M|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (616:26): [True: 4.43M, False: 0]
  ------------------
  617|  4.43M|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (617:13): [True: 4.43M, False: 0]
  ------------------
  618|  4.43M|            return i;
  619|  4.43M|        }
  620|  4.43M|    }
  621|       |
  622|      0|    return UINT32_MAX;
  623|  4.43M|}
DHT.c:index_of_friend_pk:
  599|  4.28k|{
  600|  4.28k|    assert(size == 0 || array != nullptr);
  601|       |
  602|  6.42k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (602:26): [True: 2.14k, False: 4.28k]
  ------------------
  603|  2.14k|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (603:13): [True: 0, False: 2.14k]
  ------------------
  604|      0|            return i;
  605|      0|        }
  606|  2.14k|    }
  607|       |
  608|  4.28k|    return UINT32_MAX;
  609|  4.28k|}
DHT.c:dht_friend_lock:
 1618|  4.28k|{
 1619|       |    // find first free slot
 1620|  4.28k|    uint8_t lock_num;
 1621|  4.28k|    uint32_t lock_token = 0;
 1622|  4.28k|    for (lock_num = 0; lock_num < DHT_FRIEND_MAX_LOCKS; ++lock_num) {
  ------------------
  |  |   48|  4.28k|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1622:24): [True: 4.28k, False: 0]
  ------------------
 1623|  4.28k|        lock_token = UINT32_C(1) << lock_num;
 1624|  4.28k|        if ((dht_friend->lock_flags & lock_token) == 0) {
  ------------------
  |  Branch (1624:13): [True: 4.28k, False: 0]
  ------------------
 1625|  4.28k|            break;
 1626|  4.28k|        }
 1627|  4.28k|    }
 1628|       |
 1629|       |    // One of the conditions would be enough, but static analyzers don't get that
 1630|  4.28k|    if (lock_token == 0 || lock_num == DHT_FRIEND_MAX_LOCKS) {
  ------------------
  |  |   48|  4.28k|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1630:9): [True: 0, False: 4.28k]
  |  Branch (1630:28): [True: 0, False: 4.28k]
  ------------------
 1631|      0|        return 0;
 1632|      0|    }
 1633|       |
 1634|       |    // Claim that slot
 1635|  4.28k|    dht_friend->lock_flags |= lock_token;
 1636|       |
 1637|  4.28k|    dht_friend->callbacks[lock_num].ip_callback = ip_callback;
 1638|  4.28k|    dht_friend->callbacks[lock_num].data = data;
 1639|  4.28k|    dht_friend->callbacks[lock_num].number = number;
 1640|       |
 1641|  4.28k|    return lock_token;
 1642|  4.28k|}
DHT.c:dht_load_state_callback:
 2870|    565|{
 2871|    565|    DHT *dht = (DHT *)outer;
 2872|       |
 2873|    565|    switch (type) {
 2874|    499|        case DHT_STATE_TYPE_NODES: {
  ------------------
  |  | 2740|    499|#define DHT_STATE_TYPE_NODES       4
  ------------------
  |  Branch (2874:9): [True: 499, False: 66]
  ------------------
 2875|    499|            if (length == 0) {
  ------------------
  |  Branch (2875:17): [True: 10, False: 489]
  ------------------
 2876|     10|                break;
 2877|     10|            }
 2878|       |
 2879|    489|            mem_delete(dht->mem, dht->loaded_nodes_list);
 2880|       |            // Copy to loaded_clients_list
 2881|    489|            dht->loaded_nodes_list = (Node_format *)mem_valloc(dht->mem, MAX_SAVED_DHT_NODES, sizeof(Node_format));
  ------------------
  |  | 2742|    489|#define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   75|    489|#define DHT_FAKE_FRIEND_NUMBER 2
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   43|    489|#define MAX_FRIEND_CLIENTS 8
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   49|    489|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   46|    489|#define LCLIENT_LENGTH 128
  |  |  |  |  ------------------
  |  |  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   45|    489|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   43|    489|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2882|       |
 2883|    489|            if (dht->loaded_nodes_list == nullptr) {
  ------------------
  |  |   66|    489|#define nullptr NULL
  ------------------
  |  Branch (2883:17): [True: 0, False: 489]
  ------------------
 2884|      0|                LOGGER_ERROR(dht->log, "could not allocate %u nodes", MAX_SAVED_DHT_NODES);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2885|      0|                dht->loaded_num_nodes = 0;
 2886|      0|                break;
 2887|      0|            }
 2888|       |
 2889|    489|            const int num = unpack_nodes(dht->loaded_nodes_list, MAX_SAVED_DHT_NODES, nullptr, data, length, false);
  ------------------
  |  | 2742|    489|#define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   75|    489|#define DHT_FAKE_FRIEND_NUMBER 2
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   43|    489|#define MAX_FRIEND_CLIENTS 8
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   49|    489|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   46|    489|#define LCLIENT_LENGTH 128
  |  |  |  |  ------------------
  |  |  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   45|    489|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   43|    489|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                          const int num = unpack_nodes(dht->loaded_nodes_list, MAX_SAVED_DHT_NODES, nullptr, data, length, false);
  ------------------
  |  |   66|    489|#define nullptr NULL
  ------------------
 2890|       |
 2891|    489|            if (num > 0) {
  ------------------
  |  Branch (2891:17): [True: 88, False: 401]
  ------------------
 2892|     88|                dht->loaded_num_nodes = num;
 2893|    401|            } else {
 2894|    401|                dht->loaded_num_nodes = 0;
 2895|    401|            }
 2896|       |
 2897|    489|            break;
 2898|    489|        }
 2899|       |
 2900|     66|        default: {
  ------------------
  |  Branch (2900:9): [True: 66, False: 499]
  ------------------
 2901|     66|            LOGGER_ERROR(dht->log, "Load state (DHT): contains unrecognized part (len %u, type %u)",
  ------------------
  |  |   83|     66|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     66|    do {                                                                         \
  |  |  |  |   73|     66|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    132|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     66|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     66|        }                                                                        \
  |  |  |  |   76|     66|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2902|     66|                         length, type);
 2903|     66|            break;
 2904|    489|        }
 2905|    565|    }
 2906|       |
 2907|    565|    return STATE_LOAD_STATUS_CONTINUE;
 2908|    565|}

lan_discovery_init:
  380|  2.14k|{
  381|  2.14k|    return fetch_broadcast_info(ns);
  382|  2.14k|}
lan_discovery_kill:
  385|  2.14k|{
  386|  2.14k|    free(broadcast);
  387|  2.14k|}
LAN_discovery.c:fetch_broadcast_info:
  200|  2.14k|{
  201|  2.14k|    return (Broadcast_Info *)calloc(1, sizeof(Broadcast_Info));
  202|  2.14k|}

getfriend_id:
   69|  2.61k|{
   70|  3.36k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (70:26): [True: 881, False: 2.48k]
  ------------------
   71|    881|        if (m->friendlist[i].status > 0 && pk_equal(real_pk, m->friendlist[i].real_pk)) {
  ------------------
  |  Branch (71:13): [True: 881, False: 0]
  |  Branch (71:44): [True: 127, False: 754]
  ------------------
   72|    127|            return i;
   73|    127|        }
   74|    881|    }
   75|       |
   76|  2.48k|    return -1;
   77|  2.61k|}
m_addfriend:
  232|    130|{
  233|    130|    if (length > MAX_FRIEND_REQUEST_DATA_SIZE) {
  ------------------
  |  |   14|    130|#define MAX_FRIEND_REQUEST_DATA_SIZE (ONION_CLIENT_MAX_DATA_SIZE - (1 + sizeof(uint32_t)))
  |  |  ------------------
  |  |  |  |  179|    130|#define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   36|    130|#define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   48|    130|#define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   37|    130|#define ONION_MAX_PACKET_SIZE 1400
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   46|    130|#define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   66|    130|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   43|    130|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   40|    130|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  228|    130|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  226|    130|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|    130|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  227|    130|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   61|    130|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   35|    130|#define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   40|    130|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|    130|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   40|    130|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|    130|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  178|    130|#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|    130|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|    130|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (233:9): [True: 12, False: 118]
  ------------------
  234|     12|        return FAERR_TOOLONG;
  235|     12|    }
  236|       |
  237|    118|    uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
  238|    118|    pk_copy(real_pk, address);
  239|       |
  240|    118|    if (!public_key_valid(real_pk)) {
  ------------------
  |  Branch (240:9): [True: 11, False: 107]
  ------------------
  241|     11|        return FAERR_BADCHECKSUM;
  242|     11|    }
  243|       |
  244|    107|    uint16_t check;
  245|    107|    const uint16_t checksum = data_checksum(address, FRIEND_ADDRESS_SIZE - sizeof(checksum));
  ------------------
  |  |   33|    107|#define FRIEND_ADDRESS_SIZE (CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t) + sizeof(uint16_t))
  |  |  ------------------
  |  |  |  |   40|    107|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  246|    107|    memcpy(&check, address + CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t), sizeof(check));
  ------------------
  |  |   40|    107|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  247|       |
  248|    107|    if (check != checksum) {
  ------------------
  |  Branch (248:9): [True: 0, False: 107]
  ------------------
  249|      0|        return FAERR_BADCHECKSUM;
  250|      0|    }
  251|       |
  252|    107|    if (length < 1) {
  ------------------
  |  Branch (252:9): [True: 17, False: 90]
  ------------------
  253|     17|        return FAERR_NOMESSAGE;
  254|     17|    }
  255|       |
  256|     90|    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (256:9): [True: 10, False: 80]
  ------------------
  257|     10|        return FAERR_OWNKEY;
  258|     10|    }
  259|       |
  260|     80|    const int32_t friend_id = getfriend_id(m, real_pk);
  261|       |
  262|     80|    if (friend_id != -1) {
  ------------------
  |  Branch (262:9): [True: 45, False: 35]
  ------------------
  263|     45|        if (m->friendlist[friend_id].status >= FRIEND_CONFIRMED) {
  ------------------
  |  Branch (263:13): [True: 10, False: 35]
  ------------------
  264|     10|            return FAERR_ALREADYSENT;
  265|     10|        }
  266|       |
  267|     35|        uint32_t nospam;
  268|     35|        memcpy(&nospam, address + CRYPTO_PUBLIC_KEY_SIZE, sizeof(nospam));
  ------------------
  |  |   40|     35|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  269|       |
  270|     35|        if (m->friendlist[friend_id].friendrequest_nospam == nospam) {
  ------------------
  |  Branch (270:13): [True: 18, False: 17]
  ------------------
  271|     18|            return FAERR_ALREADYSENT;
  272|     18|        }
  273|       |
  274|     17|        m->friendlist[friend_id].friendrequest_nospam = nospam;
  275|     17|        return FAERR_SETNEWNOSPAM;
  276|     35|    }
  277|       |
  278|     35|    const int32_t ret = init_new_friend(m, real_pk, FRIEND_ADDED);
  279|       |
  280|     35|    if (ret < 0) {
  ------------------
  |  Branch (280:9): [True: 0, False: 35]
  ------------------
  281|      0|        return ret;
  282|      0|    }
  283|       |
  284|     35|    m->friendlist[ret].friendrequest_timeout = FRIENDREQUEST_TIMEOUT;
  ------------------
  |  |  113|     35|#define FRIENDREQUEST_TIMEOUT 5
  ------------------
  285|     35|    memcpy(m->friendlist[ret].info, data, length);
  286|     35|    m->friendlist[ret].info_size = length;
  287|     35|    memcpy(&m->friendlist[ret].friendrequest_nospam, address + CRYPTO_PUBLIC_KEY_SIZE, sizeof(uint32_t));
  ------------------
  |  |   40|     35|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  288|       |
  289|     35|    return ret;
  290|     35|}
m_addfriend_norequest:
  293|    305|{
  294|    305|    if (!public_key_valid(real_pk)) {
  ------------------
  |  Branch (294:9): [True: 27, False: 278]
  ------------------
  295|     27|        return FAERR_BADCHECKSUM;
  296|     27|    }
  297|       |
  298|    278|    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (298:9): [True: 10, False: 268]
  ------------------
  299|     10|        return FAERR_OWNKEY;
  300|     10|    }
  301|       |
  302|    268|    return m_add_friend_contact_norequest(m, real_pk);
  303|    278|}
m_create_group_connection:
  367|     18|{
  368|     18|    random_bytes(m->rng, chat->m_group_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|     18|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  369|     18|    const int friendcon_id = new_friend_connection(m->fr_c, chat->m_group_public_key);
  370|       |
  371|     18|    if (friendcon_id == -1) {
  ------------------
  |  Branch (371:9): [True: 0, False: 18]
  ------------------
  372|      0|        return false;
  373|      0|    }
  374|       |
  375|     18|    const Friend_Conn *connection = get_conn(m->fr_c, friendcon_id);
  376|       |
  377|     18|    if (connection == nullptr) {
  ------------------
  |  |   66|     18|#define nullptr NULL
  ------------------
  |  Branch (377:9): [True: 0, False: 18]
  ------------------
  378|      0|        return false;
  379|      0|    }
  380|       |
  381|     18|    chat->friend_connection_id = friendcon_id;
  382|       |
  383|     18|    if (friend_con_connected(m->fr_c, friendcon_id) == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (383:9): [True: 0, False: 18]
  ------------------
  384|      0|        send_online_packet(m, friendcon_id);
  385|      0|    }
  386|       |
  387|     18|    const int onion_friend_number = friend_conn_get_onion_friendnum(connection);
  388|     18|    Onion_Friend *onion_friend = onion_get_friend(m->onion_c, (uint16_t)onion_friend_number);
  389|       |
  390|     18|    onion_friend_set_gc_public_key(onion_friend, get_chat_id(chat->chat_public_key));
  391|     18|    onion_friend_set_gc_data(onion_friend, nullptr, 0);
  ------------------
  |  |   66|     18|#define nullptr NULL
  ------------------
  392|       |
  393|     18|    return true;
  394|     18|}
m_kill_group_connection:
  400|     18|{
  401|     18|    remove_request_received(m->fr, chat->m_group_public_key);
  402|       |
  403|     18|    friend_connection_callbacks(m->fr_c, chat->friend_connection_id, MESSENGER_CALLBACK_INDEX, nullptr,
  ------------------
  |  |   18|     18|#define MESSENGER_CALLBACK_INDEX 0
  ------------------
                  friend_connection_callbacks(m->fr_c, chat->friend_connection_id, MESSENGER_CALLBACK_INDEX, nullptr,
  ------------------
  |  |   66|     18|#define nullptr NULL
  ------------------
  404|     18|                                nullptr, nullptr, nullptr, 0);
  ------------------
  |  |   66|     18|#define nullptr NULL
  ------------------
                                              nullptr, nullptr, nullptr, 0);
  ------------------
  |  |   66|     18|#define nullptr NULL
  ------------------
                                              nullptr, nullptr, nullptr, 0);
  ------------------
  |  |   66|     18|#define nullptr NULL
  ------------------
  405|       |
  406|     18|    if (friend_con_connected(m->fr_c, chat->friend_connection_id) == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (406:9): [True: 0, False: 18]
  ------------------
  407|      0|        send_offline_packet(m, chat->friend_connection_id);
  408|      0|    }
  409|       |
  410|     18|    kill_friend_connection(m->fr_c, chat->friend_connection_id);
  411|     18|}
m_friend_exists:
  533|    803|{
  534|    803|    return (unsigned int)friendnumber < m->numfriends && m->friendlist[friendnumber].status != 0;
  ------------------
  |  Branch (534:12): [True: 803, False: 0]
  |  Branch (534:58): [True: 803, False: 0]
  ------------------
  535|    803|}
setfriendname:
  640|    256|{
  641|    256|    if (!m_friend_exists(m, friendnumber)) {
  ------------------
  |  Branch (641:9): [True: 0, False: 256]
  ------------------
  642|      0|        return -1;
  643|      0|    }
  644|       |
  645|    256|    if (length > MAX_NAME_LENGTH || length == 0) {
  ------------------
  |  |   24|    512|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (645:9): [True: 92, False: 164]
  |  Branch (645:37): [True: 91, False: 73]
  ------------------
  646|    183|        return -1;
  647|    183|    }
  648|       |
  649|     73|    m->friendlist[friendnumber].name_length = length;
  650|     73|    memcpy(m->friendlist[friendnumber].name, name, length);
  651|     73|    return 0;
  652|    256|}
setname:
  664|    295|{
  665|    295|    if (length > MAX_NAME_LENGTH) {
  ------------------
  |  |   24|    295|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (665:9): [True: 0, False: 295]
  ------------------
  666|      0|        return -1;
  667|      0|    }
  668|       |
  669|    295|    if (m->name_length == length && (length == 0 || memcmp(name, m->name, length) == 0)) {
  ------------------
  |  Branch (669:9): [True: 234, False: 61]
  |  Branch (669:38): [True: 0, False: 234]
  |  Branch (669:53): [True: 69, False: 165]
  ------------------
  670|     69|        return 0;
  671|     69|    }
  672|       |
  673|    226|    if (length > 0) {
  ------------------
  |  Branch (673:9): [True: 226, False: 0]
  ------------------
  674|    226|        memcpy(m->name, name, length);
  675|    226|    }
  676|       |
  677|    226|    m->name_length = length;
  678|       |
  679|    538|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (679:26): [True: 312, False: 226]
  ------------------
  680|    312|        m->friendlist[i].name_sent = false;
  681|    312|    }
  682|       |
  683|    226|    return 0;
  684|    295|}
m_set_statusmessage:
  738|    646|{
  739|    646|    if (length > MAX_STATUSMESSAGE_LENGTH) {
  ------------------
  |  |   26|    646|#define MAX_STATUSMESSAGE_LENGTH 1007
  ------------------
  |  Branch (739:9): [True: 0, False: 646]
  ------------------
  740|      0|        return -1;
  741|      0|    }
  742|       |
  743|    646|    if (m->statusmessage_length == length && (length == 0 || memcmp(m->statusmessage, status, length) == 0)) {
  ------------------
  |  Branch (743:9): [True: 410, False: 236]
  |  Branch (743:47): [True: 0, False: 410]
  |  Branch (743:62): [True: 148, False: 262]
  ------------------
  744|    148|        return 0;
  745|    148|    }
  746|       |
  747|    498|    if (length > 0) {
  ------------------
  |  Branch (747:9): [True: 498, False: 0]
  ------------------
  748|    498|        memcpy(m->statusmessage, status, length);
  749|    498|    }
  750|       |
  751|    498|    m->statusmessage_length = length;
  752|       |
  753|    819|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (753:26): [True: 321, False: 498]
  ------------------
  754|    321|        m->friendlist[i].statusmessage_sent = false;
  755|    321|    }
  756|       |
  757|    498|    return 0;
  758|    646|}
m_set_userstatus:
  761|    551|{
  762|    551|    if (status >= USERSTATUS_INVALID) {
  ------------------
  |  Branch (762:9): [True: 265, False: 286]
  ------------------
  763|    265|        return -1;
  764|    265|    }
  765|       |
  766|    286|    if (m->userstatus == status) {
  ------------------
  |  Branch (766:9): [True: 134, False: 152]
  ------------------
  767|    134|        return 0;
  768|    134|    }
  769|       |
  770|    152|    m->userstatus = (Userstatus)status;
  771|       |
  772|    307|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (772:26): [True: 155, False: 152]
  ------------------
  773|    155|        m->friendlist[i].userstatus_sent = false;
  774|    155|    }
  775|       |
  776|    152|    return 0;
  777|    286|}
m_callback_friendrequest:
  937|  1.50k|{
  938|  1.50k|    m->friend_request = function;
  939|  1.50k|}
m_callback_friendmessage:
  943|  1.50k|{
  944|  1.50k|    m->friend_message = function;
  945|  1.50k|}
m_callback_namechange:
  948|  1.50k|{
  949|  1.50k|    m->friend_namechange = function;
  950|  1.50k|}
m_callback_statusmessage:
  953|  1.50k|{
  954|  1.50k|    m->friend_statusmessagechange = function;
  955|  1.50k|}
m_callback_userstatus:
  958|  1.50k|{
  959|  1.50k|    m->friend_userstatuschange = function;
  960|  1.50k|}
m_callback_typingchange:
  963|  1.50k|{
  964|  1.50k|    m->friend_typingchange = function;
  965|  1.50k|}
m_callback_read_receipt:
  968|  1.50k|{
  969|  1.50k|    m->read_receipt = function;
  970|  1.50k|}
m_callback_connectionstatus:
  973|  1.50k|{
  974|  1.50k|    m->friend_connectionstatuschange = function;
  975|  1.50k|}
m_callback_core_connection:
  978|  1.50k|{
  979|  1.50k|    m->core_connection_change = function;
  980|  1.50k|}
m_callback_conference_invite:
 1056|  4.28k|{
 1057|  4.28k|    m->conference_invite = function;
 1058|  4.28k|}
m_callback_group_invite:
 1062|  1.50k|{
 1063|  1.50k|    m->group_invite = function;
 1064|  1.50k|}
callback_file_sendrequest:
 1092|  1.50k|{
 1093|  1.50k|    m->file_sendrequest = function;
 1094|  1.50k|}
callback_file_control:
 1098|  1.50k|{
 1099|  1.50k|    m->file_filecontrol = function;
 1100|  1.50k|}
callback_file_data:
 1104|  1.50k|{
 1105|  1.50k|    m->file_filedata = function;
 1106|  1.50k|}
callback_file_reqchunk:
 1110|  1.50k|{
 1111|  1.50k|    m->file_reqchunk = function;
 1112|  1.50k|}
custom_lossy_packet_registerhandler:
 1857|  1.50k|{
 1858|  1.50k|    m->lossy_packethandler = lossy_packethandler;
 1859|  1.50k|}
custom_lossless_packet_registerhandler:
 1943|  1.50k|{
 1944|  1.50k|    m->lossless_packethandler = lossless_packethandler;
 1945|  1.50k|}
m_register_state_plugin:
 2917|  19.2k|{
 2918|  19.2k|    const uint32_t new_length = m->options.state_plugins_length + 1;
 2919|  19.2k|    Messenger_State_Plugin *temp = (Messenger_State_Plugin *)mem_vrealloc(
 2920|  19.2k|            m->mem, m->options.state_plugins, new_length, sizeof(Messenger_State_Plugin));
 2921|       |
 2922|  19.2k|    if (temp == nullptr) {
  ------------------
  |  |   66|  19.2k|#define nullptr NULL
  ------------------
  |  Branch (2922:9): [True: 0, False: 19.2k]
  ------------------
 2923|      0|        return false;
 2924|      0|    }
 2925|       |
 2926|  19.2k|    m->options.state_plugins = temp;
 2927|  19.2k|    m->options.state_plugins_length = new_length;
 2928|       |
 2929|  19.2k|    const uint8_t index = m->options.state_plugins_length - 1;
 2930|  19.2k|    m->options.state_plugins[index].type = type;
 2931|  19.2k|    m->options.state_plugins[index].size = size_callback;
 2932|  19.2k|    m->options.state_plugins[index].load = load_callback;
 2933|  19.2k|    m->options.state_plugins[index].save = save_callback;
 2934|       |
 2935|  19.2k|    return true;
 2936|  19.2k|}
messenger_size:
 2956|  3.01k|{
 2957|  3.01k|    return m_state_plugins_size(m);
 2958|  3.01k|}
messenger_save:
 2962|  1.50k|{
 2963|  15.0k|    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
  ------------------
  |  Branch (2963:25): [True: 13.5k, False: 1.50k]
  ------------------
 2964|  13.5k|        const Messenger_State_Plugin plugin = m->options.state_plugins[i];
 2965|  13.5k|        data = plugin.save(m, data);
 2966|  13.5k|    }
 2967|       |
 2968|  1.50k|    return data;
 2969|  1.50k|}
messenger_load_state_section:
 3431|  32.3k|{
 3432|   219k|    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
  ------------------
  |  Branch (3432:25): [True: 218k, False: 803]
  ------------------
 3433|   218k|        const Messenger_State_Plugin *const plugin = &m->options.state_plugins[i];
 3434|       |
 3435|   218k|        if (plugin->type == type) {
  ------------------
  |  Branch (3435:13): [True: 31.5k, False: 186k]
  ------------------
 3436|  31.5k|            *status = plugin->load(m, data, length);
 3437|  31.5k|            return true;
 3438|  31.5k|        }
 3439|   218k|    }
 3440|       |
 3441|    803|    return false;
 3442|  32.3k|}
count_friendlist:
 3450|  4.52k|{
 3451|  4.52k|    uint32_t ret = 0;
 3452|       |
 3453|  4.90k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (3453:26): [True: 384, False: 4.52k]
  ------------------
 3454|    384|        if (m->friendlist[i].status > 0) {
  ------------------
  |  Branch (3454:13): [True: 384, False: 0]
  ------------------
 3455|    384|            ++ret;
 3456|    384|        }
 3457|    384|    }
 3458|       |
 3459|  4.52k|    return ret;
 3460|  4.52k|}
new_messenger:
 3513|  2.14k|{
 3514|  2.14k|    if (options == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3514:9): [True: 0, False: 2.14k]
  ------------------
 3515|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3516|      0|    }
 3517|       |
 3518|  2.14k|    if (error != nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3518:9): [True: 2.14k, False: 0]
  ------------------
 3519|  2.14k|        *error = MESSENGER_ERROR_OTHER;
 3520|  2.14k|    }
 3521|       |
 3522|  2.14k|    Messenger *m = (Messenger *)mem_alloc(mem, sizeof(Messenger));
 3523|       |
 3524|  2.14k|    if (m == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3524:9): [True: 0, False: 2.14k]
  ------------------
 3525|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3526|      0|    }
 3527|       |
 3528|  2.14k|    m->mono_time = mono_time;
 3529|  2.14k|    m->mem = mem;
 3530|  2.14k|    m->rng = rng;
 3531|  2.14k|    m->ns = ns;
 3532|       |
 3533|  2.14k|    m->fr = friendreq_new();
 3534|       |
 3535|  2.14k|    if (m->fr == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3535:9): [True: 0, False: 2.14k]
  ------------------
 3536|      0|        mem_delete(mem, m);
 3537|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3538|      0|    }
 3539|       |
 3540|  2.14k|    m->log = logger_new();
 3541|       |
 3542|  2.14k|    if (m->log == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3542:9): [True: 0, False: 2.14k]
  ------------------
 3543|      0|        friendreq_kill(m->fr);
 3544|      0|        mem_delete(mem, m);
 3545|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3546|      0|    }
 3547|       |
 3548|  2.14k|    logger_callback_log(m->log, options->log_callback, options->log_context, options->log_user_data);
 3549|       |
 3550|  2.14k|    unsigned int net_err = 0;
 3551|       |
 3552|  2.14k|    if (!options->udp_disabled && options->proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (3552:9): [True: 2.14k, False: 0]
  |  Branch (3552:35): [True: 0, False: 2.14k]
  ------------------
 3553|       |        // We don't currently support UDP over proxy.
 3554|      0|        LOGGER_INFO(m->log, "UDP enabled and proxy set: disabling UDP");
  ------------------
  |  |   81|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3555|      0|        options->udp_disabled = true;
 3556|      0|    }
 3557|       |
 3558|  2.14k|    if (options->udp_disabled) {
  ------------------
  |  Branch (3558:9): [True: 0, False: 2.14k]
  ------------------
 3559|      0|        m->net = new_networking_no_udp(m->log, m->mem, m->ns);
 3560|  2.14k|    } else {
 3561|  2.14k|        IP ip;
 3562|  2.14k|        ip_init(&ip, options->ipv6enabled);
 3563|  2.14k|        m->net = new_networking_ex(m->log, m->mem, m->ns, &ip, options->port_range[0], options->port_range[1], &net_err);
 3564|  2.14k|    }
 3565|       |
 3566|  2.14k|    if (m->net == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3566:9): [True: 0, False: 2.14k]
  ------------------
 3567|      0|        friendreq_kill(m->fr);
 3568|      0|        logger_kill(m->log);
 3569|      0|        mem_delete(mem, m);
 3570|       |
 3571|      0|        if (error != nullptr && net_err == 1) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (3571:13): [True: 0, False: 0]
  |  Branch (3571:33): [True: 0, False: 0]
  ------------------
 3572|      0|            *error = MESSENGER_ERROR_PORT;
 3573|      0|        }
 3574|       |
 3575|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3576|      0|    }
 3577|       |
 3578|  2.14k|    m->dht = new_dht(m->log, m->mem, m->rng, m->ns, m->mono_time, m->net, options->hole_punching_enabled, options->local_discovery_enabled);
 3579|       |
 3580|  2.14k|    if (m->dht == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3580:9): [True: 0, False: 2.14k]
  ------------------
 3581|      0|        kill_networking(m->net);
 3582|      0|        friendreq_kill(m->fr);
 3583|      0|        logger_kill(m->log);
 3584|      0|        mem_delete(mem, m);
 3585|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3586|      0|    }
 3587|       |
 3588|  2.14k|    m->net_crypto = new_net_crypto(m->log, m->mem, m->rng, m->ns, m->mono_time, m->dht, &options->proxy_info);
 3589|       |
 3590|  2.14k|    if (m->net_crypto == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3590:9): [True: 0, False: 2.14k]
  ------------------
 3591|      0|        kill_dht(m->dht);
 3592|      0|        kill_networking(m->net);
 3593|      0|        friendreq_kill(m->fr);
 3594|      0|        logger_kill(m->log);
 3595|      0|        mem_delete(mem, m);
 3596|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3597|      0|    }
 3598|       |
 3599|  2.14k|#ifndef VANILLA_NACL
 3600|  2.14k|    m->group_announce = new_gca_list();
 3601|       |
 3602|  2.14k|    if (m->group_announce == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3602:9): [True: 0, False: 2.14k]
  ------------------
 3603|      0|        kill_net_crypto(m->net_crypto);
 3604|      0|        kill_dht(m->dht);
 3605|      0|        kill_networking(m->net);
 3606|      0|        friendreq_kill(m->fr);
 3607|      0|        logger_kill(m->log);
 3608|      0|        mem_delete(mem, m);
 3609|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3610|      0|    }
 3611|       |
 3612|  2.14k|#endif /* VANILLA_NACL */
 3613|       |
 3614|  2.14k|    if (options->dht_announcements_enabled) {
  ------------------
  |  Branch (3614:9): [True: 2.14k, False: 0]
  ------------------
 3615|  2.14k|        m->forwarding = new_forwarding(m->log, m->rng, m->mono_time, m->dht);
 3616|  2.14k|        m->announce = new_announcements(m->log, m->mem, m->rng, m->mono_time, m->forwarding);
 3617|  2.14k|    } else {
 3618|      0|        m->forwarding = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3619|      0|        m->announce = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3620|      0|    }
 3621|       |
 3622|  2.14k|    m->onion = new_onion(m->log, m->mem, m->mono_time, m->rng, m->dht);
 3623|  2.14k|    m->onion_a = new_onion_announce(m->log, m->mem, m->rng, m->mono_time, m->dht);
 3624|  2.14k|    m->onion_c = new_onion_client(m->log, m->mem, m->rng, m->mono_time, m->net_crypto);
 3625|  2.14k|    m->fr_c = new_friend_connections(m->log, m->mono_time, m->ns, m->onion_c, options->local_discovery_enabled);
 3626|       |
 3627|  2.14k|    if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                  if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3627:10): [True: 2.14k, False: 0]
  |  Branch (3627:49): [True: 0, False: 2.14k]
  |  Branch (3627:77): [True: 0, False: 2.14k]
  ------------------
 3628|  2.14k|            m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3628:13): [True: 0, False: 2.14k]
  |  Branch (3628:36): [True: 0, False: 2.14k]
  |  Branch (3628:61): [True: 0, False: 2.14k]
  |  Branch (3628:86): [True: 0, False: 2.14k]
  ------------------
 3629|      0|        kill_onion(m->onion);
 3630|      0|        kill_onion_announce(m->onion_a);
 3631|      0|        kill_onion_client(m->onion_c);
 3632|      0|#ifndef VANILLA_NACL
 3633|      0|        kill_gca(m->group_announce);
 3634|      0|#endif /* VANILLA_NACL */
 3635|      0|        kill_friend_connections(m->fr_c);
 3636|      0|        kill_announcements(m->announce);
 3637|      0|        kill_forwarding(m->forwarding);
 3638|      0|        kill_net_crypto(m->net_crypto);
 3639|      0|        kill_dht(m->dht);
 3640|      0|        kill_networking(m->net);
 3641|      0|        friendreq_kill(m->fr);
 3642|      0|        logger_kill(m->log);
 3643|      0|        mem_delete(mem, m);
 3644|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3645|      0|    }
 3646|       |
 3647|  2.14k|#ifndef VANILLA_NACL
 3648|  2.14k|    gca_onion_init(m->group_announce, m->onion_a);
 3649|       |
 3650|  2.14k|    m->group_handler = new_dht_groupchats(m);
 3651|       |
 3652|  2.14k|    if (m->group_handler == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3652:9): [True: 0, False: 2.14k]
  ------------------
 3653|      0|        kill_onion(m->onion);
 3654|      0|        kill_onion_announce(m->onion_a);
 3655|      0|        kill_onion_client(m->onion_c);
 3656|      0|        kill_gca(m->group_announce);
 3657|      0|        kill_friend_connections(m->fr_c);
 3658|      0|        kill_announcements(m->announce);
 3659|      0|        kill_forwarding(m->forwarding);
 3660|      0|        kill_net_crypto(m->net_crypto);
 3661|      0|        kill_dht(m->dht);
 3662|      0|        kill_networking(m->net);
 3663|      0|        friendreq_kill(m->fr);
 3664|      0|        logger_kill(m->log);
 3665|      0|        mem_delete(mem, m);
 3666|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3667|      0|    }
 3668|       |
 3669|  2.14k|#endif /* VANILLA_NACL */
 3670|       |
 3671|  2.14k|    if (options->tcp_server_port != 0) {
  ------------------
  |  Branch (3671:9): [True: 0, False: 2.14k]
  ------------------
 3672|      0|        m->tcp_server = new_tcp_server(m->log, m->mem, m->rng, m->ns, options->ipv6enabled, 1,
 3673|      0|                                       &options->tcp_server_port, dht_get_self_secret_key(m->dht),
 3674|      0|                                       m->onion, m->forwarding);
 3675|       |
 3676|      0|        if (m->tcp_server == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (3676:13): [True: 0, False: 0]
  ------------------
 3677|      0|            kill_onion(m->onion);
 3678|      0|            kill_onion_announce(m->onion_a);
 3679|      0|#ifndef VANILLA_NACL
 3680|      0|            kill_dht_groupchats(m->group_handler);
 3681|      0|#endif
 3682|      0|            kill_friend_connections(m->fr_c);
 3683|      0|            kill_onion_client(m->onion_c);
 3684|      0|#ifndef VANILLA_NACL
 3685|      0|            kill_gca(m->group_announce);
 3686|      0|#endif
 3687|      0|            kill_announcements(m->announce);
 3688|      0|            kill_forwarding(m->forwarding);
 3689|      0|            kill_net_crypto(m->net_crypto);
 3690|      0|            kill_dht(m->dht);
 3691|      0|            kill_networking(m->net);
 3692|      0|            friendreq_kill(m->fr);
 3693|      0|            logger_kill(m->log);
 3694|      0|            mem_delete(mem, m);
 3695|       |
 3696|      0|            if (error != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (3696:17): [True: 0, False: 0]
  ------------------
 3697|      0|                *error = MESSENGER_ERROR_TCP_SERVER;
 3698|      0|            }
 3699|       |
 3700|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3701|      0|        }
 3702|      0|    }
 3703|       |
 3704|  2.14k|    m->options = *options;
 3705|  2.14k|    friendreq_init(m->fr, m->fr_c);
 3706|  2.14k|    set_nospam(m->fr, random_u32(m->rng));
 3707|  2.14k|    set_filter_function(m->fr, &friend_already_added, m);
 3708|       |
 3709|  2.14k|    m->lastdump = 0;
 3710|  2.14k|    m->is_receiving_file = 0;
 3711|       |
 3712|  2.14k|    m_register_default_plugins(m);
 3713|  2.14k|    callback_friendrequest(m->fr, m_handle_friend_request, m);
 3714|       |
 3715|  2.14k|    if (error != nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3715:9): [True: 2.14k, False: 0]
  ------------------
 3716|  2.14k|        *error = MESSENGER_ERROR_NONE;
 3717|  2.14k|    }
 3718|       |
 3719|  2.14k|    return m;
 3720|  2.14k|}
kill_messenger:
 3727|  2.14k|{
 3728|  2.14k|    if (m == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3728:9): [True: 0, False: 2.14k]
  ------------------
 3729|      0|        return;
 3730|      0|    }
 3731|       |
 3732|  2.14k|    if (m->tcp_server != nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3732:9): [True: 0, False: 2.14k]
  ------------------
 3733|      0|        kill_tcp_server(m->tcp_server);
 3734|      0|    }
 3735|       |
 3736|  2.14k|    kill_onion(m->onion);
 3737|  2.14k|    kill_onion_announce(m->onion_a);
 3738|  2.14k|#ifndef VANILLA_NACL
 3739|  2.14k|    kill_dht_groupchats(m->group_handler);
 3740|  2.14k|#endif
 3741|  2.14k|    kill_friend_connections(m->fr_c);
 3742|  2.14k|    kill_onion_client(m->onion_c);
 3743|  2.14k|#ifndef VANILLA_NACL
 3744|  2.14k|    kill_gca(m->group_announce);
 3745|  2.14k|#endif
 3746|  2.14k|    kill_announcements(m->announce);
 3747|  2.14k|    kill_forwarding(m->forwarding);
 3748|  2.14k|    kill_net_crypto(m->net_crypto);
 3749|  2.14k|    kill_dht(m->dht);
 3750|  2.14k|    kill_networking(m->net);
 3751|       |
 3752|  2.43k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (3752:26): [True: 291, False: 2.14k]
  ------------------
 3753|    291|        clear_receipts(m, i);
 3754|    291|    }
 3755|       |
 3756|  2.14k|    logger_kill(m->log);
 3757|  2.14k|    mem_delete(m->mem, m->friendlist);
 3758|  2.14k|    friendreq_kill(m->fr);
 3759|       |
 3760|  2.14k|    mem_delete(m->mem, m->options.state_plugins);
 3761|  2.14k|    mem_delete(m->mem, m);
 3762|  2.14k|}
Messenger.c:init_new_friend:
  148|    291|{
  149|    291|    if (m->numfriends == UINT32_MAX) {
  ------------------
  |  Branch (149:9): [True: 0, False: 291]
  ------------------
  150|      0|        LOGGER_ERROR(m->log, "Friend list full: we have more than 4 billion friends");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  151|       |        /* This is technically incorrect, but close enough. */
  152|      0|        return FAERR_NOMEM;
  153|      0|    }
  154|       |
  155|       |    /* Resize the friend list if necessary. */
  156|    291|    if (realloc_friendlist(m, m->numfriends + 1) != 0) {
  ------------------
  |  Branch (156:9): [True: 0, False: 291]
  ------------------
  157|      0|        return FAERR_NOMEM;
  158|      0|    }
  159|       |
  160|    291|    m->friendlist[m->numfriends] = empty_friend;
  161|       |
  162|    291|    const int friendcon_id = new_friend_connection(m->fr_c, real_pk);
  163|       |
  164|    291|    if (friendcon_id == -1) {
  ------------------
  |  Branch (164:9): [True: 0, False: 291]
  ------------------
  165|      0|        return FAERR_NOMEM;
  166|      0|    }
  167|       |
  168|    715|    for (uint32_t i = 0; i <= m->numfriends; ++i) {
  ------------------
  |  Branch (168:26): [True: 715, False: 0]
  ------------------
  169|    715|        if (m->friendlist[i].status == NOFRIEND) {
  ------------------
  |  Branch (169:13): [True: 291, False: 424]
  ------------------
  170|    291|            m->friendlist[i].status = status;
  171|    291|            m->friendlist[i].friendcon_id = friendcon_id;
  172|    291|            m->friendlist[i].friendrequest_lastsent = 0;
  173|    291|            pk_copy(m->friendlist[i].real_pk, real_pk);
  174|    291|            m->friendlist[i].statusmessage_length = 0;
  175|    291|            m->friendlist[i].userstatus = USERSTATUS_NONE;
  176|    291|            m->friendlist[i].is_typing = false;
  177|    291|            m->friendlist[i].message_id = 0;
  178|    291|            friend_connection_callbacks(m->fr_c, friendcon_id, MESSENGER_CALLBACK_INDEX, &m_handle_status, &m_handle_packet,
  ------------------
  |  |   18|    291|#define MESSENGER_CALLBACK_INDEX 0
  ------------------
  179|    291|                                        &m_handle_lossy_packet, m, i);
  180|       |
  181|    291|            if (m->numfriends == i) {
  ------------------
  |  Branch (181:17): [True: 291, False: 0]
  ------------------
  182|    291|                ++m->numfriends;
  183|    291|            }
  184|       |
  185|    291|            if (friend_con_connected(m->fr_c, friendcon_id) == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (185:17): [True: 0, False: 291]
  ------------------
  186|      0|                send_online_packet(m, friendcon_id);
  187|      0|            }
  188|       |
  189|    291|            return i;
  190|    291|        }
  191|    715|    }
  192|       |
  193|      0|    return FAERR_NOMEM;
  194|    291|}
Messenger.c:set_friend_statusmessage:
  906|    256|{
  907|    256|    if (!m_friend_exists(m, friendnumber)) {
  ------------------
  |  Branch (907:9): [True: 0, False: 256]
  ------------------
  908|      0|        return -1;
  909|      0|    }
  910|       |
  911|    256|    if (length > MAX_STATUSMESSAGE_LENGTH) {
  ------------------
  |  |   26|    256|#define MAX_STATUSMESSAGE_LENGTH 1007
  ------------------
  |  Branch (911:9): [True: 122, False: 134]
  ------------------
  912|    122|        return -1;
  913|    122|    }
  914|       |
  915|    134|    if (length > 0) {
  ------------------
  |  Branch (915:9): [True: 70, False: 64]
  ------------------
  916|     70|        memcpy(m->friendlist[friendnumber].statusmessage, status, length);
  917|     70|    }
  918|       |
  919|    134|    m->friendlist[friendnumber].statusmessage_length = length;
  920|    134|    return 0;
  921|    256|}
Messenger.c:set_friend_userstatus:
  925|    256|{
  926|    256|    m->friendlist[friendnumber].userstatus = (Userstatus)status;
  927|    256|}
Messenger.c:m_add_friend_contact_norequest:
  198|    268|{
  199|    268|    if (getfriend_id(m, real_pk) != -1) {
  ------------------
  |  Branch (199:9): [True: 12, False: 256]
  ------------------
  200|     12|        return FAERR_ALREADYSENT;
  201|     12|    }
  202|       |
  203|    256|    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (203:9): [True: 0, False: 256]
  ------------------
  204|      0|        return FAERR_OWNKEY;
  205|      0|    }
  206|       |
  207|    256|    return init_new_friend(m, real_pk, FRIEND_CONFIRMED);
  208|    256|}
Messenger.c:clear_receipts:
  307|    291|{
  308|    291|    if (!m_friend_exists(m, friendnumber)) {
  ------------------
  |  Branch (308:9): [True: 0, False: 291]
  ------------------
  309|      0|        return -1;
  310|      0|    }
  311|       |
  312|    291|    struct Receipts *receipts = m->friendlist[friendnumber].receipts_start;
  313|       |
  314|    291|    while (receipts != nullptr) {
  ------------------
  |  |   66|    291|#define nullptr NULL
  ------------------
  |  Branch (314:12): [True: 0, False: 291]
  ------------------
  315|      0|        struct Receipts *temp_r = receipts->next;
  316|      0|        mem_delete(m->mem, receipts);
  317|      0|        receipts = temp_r;
  318|      0|    }
  319|       |
  320|    291|    m->friendlist[friendnumber].receipts_start = nullptr;
  ------------------
  |  |   66|    291|#define nullptr NULL
  ------------------
  321|    291|    m->friendlist[friendnumber].receipts_end = nullptr;
  ------------------
  |  |   66|    291|#define nullptr NULL
  ------------------
  322|    291|    return 0;
  323|    291|}
Messenger.c:realloc_friendlist:
   48|    291|{
   49|    291|    if (num == 0) {
  ------------------
  |  Branch (49:9): [True: 0, False: 291]
  ------------------
   50|      0|        mem_delete(m->mem, m->friendlist);
   51|      0|        m->friendlist = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   52|      0|        return 0;
   53|      0|    }
   54|       |
   55|    291|    Friend *newfriendlist = (Friend *)mem_vrealloc(m->mem, m->friendlist, num, sizeof(Friend));
   56|       |
   57|    291|    if (newfriendlist == nullptr) {
  ------------------
  |  |   66|    291|#define nullptr NULL
  ------------------
  |  Branch (57:9): [True: 0, False: 291]
  ------------------
   58|      0|        return -1;
   59|      0|    }
   60|       |
   61|    291|    m->friendlist = newfriendlist;
   62|    291|    return 0;
   63|    291|}
Messenger.c:m_state_plugins_size:
 2894|  3.01k|{
 2895|  3.01k|    const uint32_t size32 = sizeof(uint32_t);
 2896|  3.01k|    const uint32_t sizesubhead = size32 * 2;
 2897|       |
 2898|  3.01k|    uint32_t size = 0;
 2899|       |
 2900|  3.01k|    for (const Messenger_State_Plugin *plugin = m->options.state_plugins;
 2901|  30.1k|            plugin != m->options.state_plugins + m->options.state_plugins_length;
  ------------------
  |  Branch (2901:13): [True: 27.1k, False: 3.01k]
  ------------------
 2902|  27.1k|            ++plugin) {
 2903|  27.1k|        size += sizesubhead + plugin->size(m);
 2904|  27.1k|    }
 2905|       |
 2906|  3.01k|    return size;
 2907|  3.01k|}
Messenger.c:m_register_default_plugins:
 3414|  2.14k|{
 3415|  2.14k|    m_register_state_plugin(m, STATE_TYPE_NOSPAMKEYS, nospam_keys_size, load_nospam_keys, save_nospam_keys);
 3416|  2.14k|    m_register_state_plugin(m, STATE_TYPE_DHT, m_dht_size, m_dht_load, save_dht);
 3417|  2.14k|    m_register_state_plugin(m, STATE_TYPE_FRIENDS, saved_friendslist_size, friends_list_load, friends_list_save);
 3418|  2.14k|    m_register_state_plugin(m, STATE_TYPE_NAME, name_size, load_name, save_name);
 3419|  2.14k|    m_register_state_plugin(m, STATE_TYPE_STATUSMESSAGE, status_message_size, load_status_message,
 3420|  2.14k|                            save_status_message);
 3421|  2.14k|    m_register_state_plugin(m, STATE_TYPE_STATUS, status_size, load_status, save_status);
 3422|  2.14k|#ifndef VANILLA_NACL
 3423|  2.14k|    m_register_state_plugin(m, STATE_TYPE_GROUPS, saved_groups_size, groups_load, groups_save);
 3424|  2.14k|#endif
 3425|  2.14k|    m_register_state_plugin(m, STATE_TYPE_TCP_RELAY, tcp_relay_size, load_tcp_relays, save_tcp_relays);
 3426|  2.14k|    m_register_state_plugin(m, STATE_TYPE_PATH_NODE, path_node_size, load_path_nodes, save_path_nodes);
 3427|  2.14k|}
Messenger.c:nospam_keys_size:
 2974|  5.05k|{
 2975|  5.05k|    return sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SECRET_KEY_SIZE;
  ------------------
  |  |   40|  5.05k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  return sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SECRET_KEY_SIZE;
  ------------------
  |  |   45|  5.05k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 2976|  5.05k|}
Messenger.c:load_nospam_keys:
 2980|    533|{
 2981|    533|    if (length != m_plugin_size(m, STATE_TYPE_NOSPAMKEYS)) {
  ------------------
  |  Branch (2981:9): [True: 1, False: 532]
  ------------------
 2982|      1|        return STATE_LOAD_STATUS_ERROR;
 2983|      1|    }
 2984|       |
 2985|    532|    uint32_t nospam;
 2986|    532|    lendian_bytes_to_host32(&nospam, data);
 2987|    532|    set_nospam(m->fr, nospam);
 2988|    532|    load_secret_key(m->net_crypto, data + sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    532|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2989|       |
 2990|    532|    if (!pk_equal(data + sizeof(uint32_t), nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (2990:9): [True: 3, False: 529]
  ------------------
 2991|      3|        LOGGER_ERROR(m->log, "public key stored in savedata does not match its secret key");
  ------------------
  |  |   83|      3|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      3|    do {                                                                         \
  |  |  |  |   73|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      3|        }                                                                        \
  |  |  |  |   76|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2992|      3|        return STATE_LOAD_STATUS_ERROR;
 2993|      3|    }
 2994|       |
 2995|    529|    return STATE_LOAD_STATUS_CONTINUE;
 2996|    532|}
Messenger.c:m_plugin_size:
 2940|  9.86k|{
 2941|  34.2k|    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
  ------------------
  |  Branch (2941:25): [True: 34.2k, False: 0]
  ------------------
 2942|  34.2k|        const Messenger_State_Plugin plugin = m->options.state_plugins[i];
 2943|       |
 2944|  34.2k|        if (plugin.type == type) {
  ------------------
  |  Branch (2944:13): [True: 9.86k, False: 24.3k]
  ------------------
 2945|  9.86k|            return plugin.size(m);
 2946|  9.86k|        }
 2947|  34.2k|    }
 2948|       |
 2949|      0|    LOGGER_ERROR(m->log, "Unknown type encountered: %u", type);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2950|       |
 2951|      0|    return UINT32_MAX;
 2952|  9.86k|}
Messenger.c:save_nospam_keys:
 3000|  1.50k|{
 3001|  1.50k|    const uint32_t len = m_plugin_size(m, STATE_TYPE_NOSPAMKEYS);
 3002|  1.50k|    static_assert(sizeof(get_nospam(m->fr)) == sizeof(uint32_t), "nospam doesn't fit in a 32 bit int");
  ------------------
  |  |   70|  1.50k|#define static_assert _Static_assert
  ------------------
 3003|  1.50k|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_NOSPAMKEYS);
  ------------------
  |  |   28|  1.50k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3004|  1.50k|    const uint32_t nospam = get_nospam(m->fr);
 3005|  1.50k|    host_to_lendian_bytes32(data, nospam);
 3006|  1.50k|    save_keys(m->net_crypto, data + sizeof(uint32_t));
 3007|  1.50k|    data += len;
 3008|  1.50k|    return data;
 3009|  1.50k|}
Messenger.c:m_dht_size:
 3014|  4.52k|{
 3015|  4.52k|    return dht_size(m->dht);
 3016|  4.52k|}
Messenger.c:m_dht_load:
 3030|    675|{
 3031|    675|    dht_load(m->dht, data, length); // TODO(endoffile78): Should we throw an error if dht_load fails?
 3032|    675|    return STATE_LOAD_STATUS_CONTINUE;
 3033|    675|}
Messenger.c:save_dht:
 3020|  1.50k|{
 3021|  1.50k|    const uint32_t len = m_plugin_size(m, STATE_TYPE_DHT);
 3022|  1.50k|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_DHT);
  ------------------
  |  |   28|  1.50k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3023|  1.50k|    dht_save(m->dht, data);
 3024|  1.50k|    data += len;
 3025|  1.50k|    return data;
 3026|  1.50k|}
Messenger.c:saved_friendslist_size:
 3038|  4.52k|{
 3039|  4.52k|    return count_friendlist(m) * friend_size();
 3040|  4.52k|}
Messenger.c:friend_size:
 2781|  6.54k|{
 2782|  6.54k|    uint32_t data = 0;
 2783|  6.54k|    const struct Saved_Friend *const temp = nullptr;
  ------------------
  |  |   66|  6.54k|#define nullptr NULL
  ------------------
 2784|       |
 2785|  6.54k|#define VALUE_MEMBER(data, name) \
 2786|  6.54k|    do {                         \
 2787|  6.54k|        data += sizeof(name);    \
 2788|  6.54k|    } while (0)
 2789|  6.54k|#define ARRAY_MEMBER(data, name) \
 2790|  6.54k|    do {                         \
 2791|  6.54k|        data += sizeof(name);    \
 2792|  6.54k|    } while (0)
 2793|       |
 2794|       |    // Exactly the same in friend_load, friend_save, and friend_size
 2795|  6.54k|    VALUE_MEMBER(data, temp->status);
  ------------------
  |  | 2786|  6.54k|    do {                         \
  |  | 2787|  6.54k|        data += sizeof(name);    \
  |  | 2788|  6.54k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2788:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2796|  6.54k|    ARRAY_MEMBER(data, temp->real_pk);
  ------------------
  |  | 2790|  6.54k|    do {                         \
  |  | 2791|  6.54k|        data += sizeof(name);    \
  |  | 2792|  6.54k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2792:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2797|  6.54k|    ARRAY_MEMBER(data, temp->info);
  ------------------
  |  | 2790|  6.54k|    do {                         \
  |  | 2791|  6.54k|        data += sizeof(name);    \
  |  | 2792|  6.54k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2792:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2798|  6.54k|    ++data; // padding
 2799|  6.54k|    VALUE_MEMBER(data, temp->info_size);
  ------------------
  |  | 2786|  6.54k|    do {                         \
  |  | 2787|  6.54k|        data += sizeof(name);    \
  |  | 2788|  6.54k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2788:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2800|  6.54k|    ARRAY_MEMBER(data, temp->name);
  ------------------
  |  | 2790|  6.54k|    do {                         \
  |  | 2791|  6.54k|        data += sizeof(name);    \
  |  | 2792|  6.54k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2792:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2801|  6.54k|    VALUE_MEMBER(data, temp->name_length);
  ------------------
  |  | 2786|  6.54k|    do {                         \
  |  | 2787|  6.54k|        data += sizeof(name);    \
  |  | 2788|  6.54k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2788:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2802|  6.54k|    ARRAY_MEMBER(data, temp->statusmessage);
  ------------------
  |  | 2790|  6.54k|    do {                         \
  |  | 2791|  6.54k|        data += sizeof(name);    \
  |  | 2792|  6.54k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2792:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2803|  6.54k|    ++data; // padding
 2804|  6.54k|    VALUE_MEMBER(data, temp->statusmessage_length);
  ------------------
  |  | 2786|  6.54k|    do {                         \
  |  | 2787|  6.54k|        data += sizeof(name);    \
  |  | 2788|  6.54k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2788:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2805|  6.54k|    VALUE_MEMBER(data, temp->userstatus);
  ------------------
  |  | 2786|  6.54k|    do {                         \
  |  | 2787|  6.54k|        data += sizeof(name);    \
  |  | 2788|  6.54k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2788:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2806|  6.54k|    data += 3; // padding
 2807|  6.54k|    VALUE_MEMBER(data, temp->friendrequest_nospam);
  ------------------
  |  | 2786|  6.54k|    do {                         \
  |  | 2787|  6.54k|        data += sizeof(name);    \
  |  | 2788|  6.54k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2788:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2808|  6.54k|    ARRAY_MEMBER(data, temp->last_seen_time);
  ------------------
  |  | 2790|  6.54k|    do {                         \
  |  | 2791|  6.54k|        data += sizeof(name);    \
  |  | 2792|  6.54k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2792:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2809|       |
 2810|  6.54k|#undef VALUE_MEMBER
 2811|  6.54k|#undef ARRAY_MEMBER
 2812|       |
 2813|  6.54k|    return data;
 2814|  6.54k|}
Messenger.c:friends_list_load:
 3095|    265|{
 3096|    265|    const uint32_t l_friend_size = friend_size();
 3097|       |
 3098|    265|    if (length % l_friend_size != 0) {
  ------------------
  |  Branch (3098:9): [True: 1, False: 264]
  ------------------
 3099|      1|        return STATE_LOAD_STATUS_ERROR; // TODO(endoffile78): error or continue?
 3100|      1|    }
 3101|       |
 3102|    264|    const uint32_t num = length / l_friend_size;
 3103|    264|    const uint8_t *cur_data = data;
 3104|       |
 3105|    781|    for (uint32_t i = 0; i < num; ++i) {
  ------------------
  |  Branch (3105:26): [True: 517, False: 264]
  ------------------
 3106|    517|        struct Saved_Friend temp = { 0 };
 3107|    517|        const uint8_t *next_data = friend_load(&temp, cur_data);
 3108|    517|        assert(next_data - cur_data == l_friend_size);
 3109|       |
 3110|      0|        cur_data = next_data;
 3111|       |
 3112|    517|        if (temp.status >= 3) {
  ------------------
  |  Branch (3112:13): [True: 305, False: 212]
  ------------------
 3113|    305|            const int fnum = m_addfriend_norequest(m, temp.real_pk);
 3114|       |
 3115|    305|            if (fnum < 0) {
  ------------------
  |  Branch (3115:17): [True: 49, False: 256]
  ------------------
 3116|     49|                continue;
 3117|     49|            }
 3118|       |
 3119|    256|            setfriendname(m, fnum, temp.name, net_ntohs(temp.name_length));
 3120|    256|            set_friend_statusmessage(m, fnum, temp.statusmessage, net_ntohs(temp.statusmessage_length));
 3121|    256|            set_friend_userstatus(m, fnum, temp.userstatus);
 3122|    256|            net_unpack_u64(temp.last_seen_time, &m->friendlist[fnum].last_seen_time);
 3123|    256|        } else if (temp.status != 0) {
  ------------------
  |  Branch (3123:20): [True: 130, False: 82]
  ------------------
 3124|       |            /* TODO(irungentoo): This is not a good way to do this. */
 3125|    130|            uint8_t address[FRIEND_ADDRESS_SIZE];
 3126|    130|            pk_copy(address, temp.real_pk);
 3127|    130|            memcpy(address + CRYPTO_PUBLIC_KEY_SIZE, &temp.friendrequest_nospam, sizeof(uint32_t));
  ------------------
  |  |   40|    130|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3128|    130|            uint16_t checksum = data_checksum(address, FRIEND_ADDRESS_SIZE - sizeof(checksum));
  ------------------
  |  |   33|    130|#define FRIEND_ADDRESS_SIZE (CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t) + sizeof(uint16_t))
  |  |  ------------------
  |  |  |  |   40|    130|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 3129|    130|            memcpy(address + CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t), &checksum, sizeof(checksum));
  ------------------
  |  |   40|    130|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3130|    130|            m_addfriend(m, address, temp.info, net_ntohs(temp.info_size));
 3131|    130|        }
 3132|    517|    }
 3133|       |
 3134|    264|    return STATE_LOAD_STATUS_CONTINUE;
 3135|    265|}
Messenger.c:friend_load:
 2856|    517|{
 2857|    517|#define VALUE_MEMBER(data, name)           \
 2858|    517|    do {                                   \
 2859|    517|        memcpy(&name, data, sizeof(name)); \
 2860|    517|        data += sizeof(name);              \
 2861|    517|    } while (0)
 2862|       |
 2863|    517|#define ARRAY_MEMBER(data, name)          \
 2864|    517|    do {                                  \
 2865|    517|        memcpy(name, data, sizeof(name)); \
 2866|    517|        data += sizeof(name);             \
 2867|    517|    } while (0)
 2868|       |
 2869|       |    // Exactly the same in friend_load, friend_save, and friend_size
 2870|    517|    VALUE_MEMBER(data, temp->status);
  ------------------
  |  | 2858|    517|    do {                                   \
  |  | 2859|    517|        memcpy(&name, data, sizeof(name)); \
  |  | 2860|    517|        data += sizeof(name);              \
  |  | 2861|    517|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2861:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2871|    517|    ARRAY_MEMBER(data, temp->real_pk);
  ------------------
  |  | 2864|    517|    do {                                  \
  |  | 2865|    517|        memcpy(name, data, sizeof(name)); \
  |  | 2866|    517|        data += sizeof(name);             \
  |  | 2867|    517|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2867:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2872|    517|    ARRAY_MEMBER(data, temp->info);
  ------------------
  |  | 2864|    517|    do {                                  \
  |  | 2865|    517|        memcpy(name, data, sizeof(name)); \
  |  | 2866|    517|        data += sizeof(name);             \
  |  | 2867|    517|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2867:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2873|    517|    ++data; // padding
 2874|    517|    VALUE_MEMBER(data, temp->info_size);
  ------------------
  |  | 2858|    517|    do {                                   \
  |  | 2859|    517|        memcpy(&name, data, sizeof(name)); \
  |  | 2860|    517|        data += sizeof(name);              \
  |  | 2861|    517|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2861:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2875|    517|    ARRAY_MEMBER(data, temp->name);
  ------------------
  |  | 2864|    517|    do {                                  \
  |  | 2865|    517|        memcpy(name, data, sizeof(name)); \
  |  | 2866|    517|        data += sizeof(name);             \
  |  | 2867|    517|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2867:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2876|    517|    VALUE_MEMBER(data, temp->name_length);
  ------------------
  |  | 2858|    517|    do {                                   \
  |  | 2859|    517|        memcpy(&name, data, sizeof(name)); \
  |  | 2860|    517|        data += sizeof(name);              \
  |  | 2861|    517|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2861:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2877|    517|    ARRAY_MEMBER(data, temp->statusmessage);
  ------------------
  |  | 2864|    517|    do {                                  \
  |  | 2865|    517|        memcpy(name, data, sizeof(name)); \
  |  | 2866|    517|        data += sizeof(name);             \
  |  | 2867|    517|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2867:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2878|    517|    ++data; // padding
 2879|    517|    VALUE_MEMBER(data, temp->statusmessage_length);
  ------------------
  |  | 2858|    517|    do {                                   \
  |  | 2859|    517|        memcpy(&name, data, sizeof(name)); \
  |  | 2860|    517|        data += sizeof(name);              \
  |  | 2861|    517|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2861:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2880|    517|    VALUE_MEMBER(data, temp->userstatus);
  ------------------
  |  | 2858|    517|    do {                                   \
  |  | 2859|    517|        memcpy(&name, data, sizeof(name)); \
  |  | 2860|    517|        data += sizeof(name);              \
  |  | 2861|    517|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2861:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2881|    517|    data += 3; // padding
 2882|    517|    VALUE_MEMBER(data, temp->friendrequest_nospam);
  ------------------
  |  | 2858|    517|    do {                                   \
  |  | 2859|    517|        memcpy(&name, data, sizeof(name)); \
  |  | 2860|    517|        data += sizeof(name);              \
  |  | 2861|    517|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2861:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2883|    517|    ARRAY_MEMBER(data, temp->last_seen_time);
  ------------------
  |  | 2864|    517|    do {                                  \
  |  | 2865|    517|        memcpy(name, data, sizeof(name)); \
  |  | 2866|    517|        data += sizeof(name);             \
  |  | 2867|    517|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2867:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2884|       |
 2885|    517|#undef VALUE_MEMBER
 2886|    517|#undef ARRAY_MEMBER
 2887|       |
 2888|    517|    return data;
 2889|    517|}
Messenger.c:friends_list_save:
 3044|  1.50k|{
 3045|  1.50k|    const uint32_t len = m_plugin_size(m, STATE_TYPE_FRIENDS);
 3046|  1.50k|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_FRIENDS);
  ------------------
  |  |   28|  1.50k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3047|       |
 3048|  1.50k|    uint32_t num = 0;
 3049|  1.50k|    uint8_t *cur_data = data;
 3050|       |
 3051|  1.63k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (3051:26): [True: 128, False: 1.50k]
  ------------------
 3052|    128|        if (m->friendlist[i].status > 0) {
  ------------------
  |  Branch (3052:13): [True: 128, False: 0]
  ------------------
 3053|    128|            struct Saved_Friend temp = { 0 };
 3054|    128|            temp.status = m->friendlist[i].status;
 3055|    128|            memcpy(temp.real_pk, m->friendlist[i].real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    128|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3056|       |
 3057|    128|            if (temp.status < 3) {
  ------------------
  |  Branch (3057:17): [True: 25, False: 103]
  ------------------
 3058|       |                // TODO(iphydf): Use uint16_t and min_u16 here.
 3059|     25|                const size_t friendrequest_length =
 3060|     25|                    min_u32(m->friendlist[i].info_size,
 3061|     25|                            min_u32(SAVED_FRIEND_REQUEST_SIZE, MAX_FRIEND_REQUEST_DATA_SIZE));
  ------------------
  |  | 2763|     25|#define SAVED_FRIEND_REQUEST_SIZE 1024
  ------------------
                                          min_u32(SAVED_FRIEND_REQUEST_SIZE, MAX_FRIEND_REQUEST_DATA_SIZE));
  ------------------
  |  |   14|     25|#define MAX_FRIEND_REQUEST_DATA_SIZE (ONION_CLIENT_MAX_DATA_SIZE - (1 + sizeof(uint32_t)))
  |  |  ------------------
  |  |  |  |  179|     25|#define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   36|     25|#define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   48|     25|#define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   37|     25|#define ONION_MAX_PACKET_SIZE 1400
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   46|     25|#define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   66|     25|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   43|     25|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   40|     25|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  228|     25|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  226|     25|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  225|     25|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  227|     25|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   61|     25|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   35|     25|#define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   40|     25|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   66|     25|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   40|     25|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   61|     25|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  178|     25|#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   40|     25|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|     25|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3062|     25|                memcpy(temp.info, m->friendlist[i].info, friendrequest_length);
 3063|       |
 3064|     25|                temp.info_size = net_htons(m->friendlist[i].info_size);
 3065|     25|                temp.friendrequest_nospam = m->friendlist[i].friendrequest_nospam;
 3066|    103|            } else {
 3067|    103|                temp.status = 3;
 3068|    103|                memcpy(temp.name, m->friendlist[i].name, m->friendlist[i].name_length);
 3069|    103|                temp.name_length = net_htons(m->friendlist[i].name_length);
 3070|    103|                memcpy(temp.statusmessage, m->friendlist[i].statusmessage, m->friendlist[i].statusmessage_length);
 3071|    103|                temp.statusmessage_length = net_htons(m->friendlist[i].statusmessage_length);
 3072|    103|                temp.userstatus = m->friendlist[i].userstatus;
 3073|       |
 3074|    103|                net_pack_u64(temp.last_seen_time, m->friendlist[i].last_seen_time);
 3075|    103|            }
 3076|       |
 3077|    128|            uint8_t *next_data = friend_save(&temp, cur_data);
 3078|    128|            assert(next_data - cur_data == friend_size());
 3079|      0|#ifdef __LP64__
 3080|      0|            assert(memcmp(cur_data, &temp, friend_size()) == 0);
 3081|      0|#endif
 3082|      0|            cur_data = next_data;
 3083|    128|            ++num;
 3084|    128|        }
 3085|    128|    }
 3086|       |
 3087|  1.50k|    assert(cur_data - data == num * friend_size());
 3088|      0|    data += len;
 3089|       |
 3090|  1.50k|    return data;
 3091|  1.50k|}
Messenger.c:friend_save:
 2818|    128|{
 2819|    128|#define VALUE_MEMBER(data, name)           \
 2820|    128|    do {                                   \
 2821|    128|        memcpy(data, &name, sizeof(name)); \
 2822|    128|        data += sizeof(name);              \
 2823|    128|    } while (0)
 2824|       |
 2825|    128|#define ARRAY_MEMBER(data, name)          \
 2826|    128|    do {                                  \
 2827|    128|        memcpy(data, name, sizeof(name)); \
 2828|    128|        data += sizeof(name);             \
 2829|    128|    } while (0)
 2830|       |
 2831|       |    // Exactly the same in friend_load, friend_save, and friend_size
 2832|    128|    VALUE_MEMBER(data, temp->status);
  ------------------
  |  | 2820|    128|    do {                                   \
  |  | 2821|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2822|    128|        data += sizeof(name);              \
  |  | 2823|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2823:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2833|    128|    ARRAY_MEMBER(data, temp->real_pk);
  ------------------
  |  | 2826|    128|    do {                                  \
  |  | 2827|    128|        memcpy(data, name, sizeof(name)); \
  |  | 2828|    128|        data += sizeof(name);             \
  |  | 2829|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2829:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2834|    128|    ARRAY_MEMBER(data, temp->info);
  ------------------
  |  | 2826|    128|    do {                                  \
  |  | 2827|    128|        memcpy(data, name, sizeof(name)); \
  |  | 2828|    128|        data += sizeof(name);             \
  |  | 2829|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2829:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2835|    128|    ++data; // padding
 2836|    128|    VALUE_MEMBER(data, temp->info_size);
  ------------------
  |  | 2820|    128|    do {                                   \
  |  | 2821|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2822|    128|        data += sizeof(name);              \
  |  | 2823|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2823:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2837|    128|    ARRAY_MEMBER(data, temp->name);
  ------------------
  |  | 2826|    128|    do {                                  \
  |  | 2827|    128|        memcpy(data, name, sizeof(name)); \
  |  | 2828|    128|        data += sizeof(name);             \
  |  | 2829|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2829:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2838|    128|    VALUE_MEMBER(data, temp->name_length);
  ------------------
  |  | 2820|    128|    do {                                   \
  |  | 2821|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2822|    128|        data += sizeof(name);              \
  |  | 2823|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2823:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2839|    128|    ARRAY_MEMBER(data, temp->statusmessage);
  ------------------
  |  | 2826|    128|    do {                                  \
  |  | 2827|    128|        memcpy(data, name, sizeof(name)); \
  |  | 2828|    128|        data += sizeof(name);             \
  |  | 2829|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2829:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2840|    128|    ++data; // padding
 2841|    128|    VALUE_MEMBER(data, temp->statusmessage_length);
  ------------------
  |  | 2820|    128|    do {                                   \
  |  | 2821|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2822|    128|        data += sizeof(name);              \
  |  | 2823|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2823:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2842|    128|    VALUE_MEMBER(data, temp->userstatus);
  ------------------
  |  | 2820|    128|    do {                                   \
  |  | 2821|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2822|    128|        data += sizeof(name);              \
  |  | 2823|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2823:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2843|    128|    data += 3; // padding
 2844|    128|    VALUE_MEMBER(data, temp->friendrequest_nospam);
  ------------------
  |  | 2820|    128|    do {                                   \
  |  | 2821|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2822|    128|        data += sizeof(name);              \
  |  | 2823|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2823:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2845|    128|    ARRAY_MEMBER(data, temp->last_seen_time);
  ------------------
  |  | 2826|    128|    do {                                  \
  |  | 2827|    128|        memcpy(data, name, sizeof(name)); \
  |  | 2828|    128|        data += sizeof(name);             \
  |  | 2829|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2829:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2846|       |
 2847|    128|#undef VALUE_MEMBER
 2848|    128|#undef ARRAY_MEMBER
 2849|       |
 2850|    128|    return data;
 2851|    128|}
Messenger.c:name_size:
 3239|  4.52k|{
 3240|  4.52k|    return m->name_length;
 3241|  4.52k|}
Messenger.c:load_name:
 3255|    427|{
 3256|    427|    if (length > 0 && length <= MAX_NAME_LENGTH) {
  ------------------
  |  |   24|    361|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (3256:9): [True: 361, False: 66]
  |  Branch (3256:23): [True: 295, False: 66]
  ------------------
 3257|    295|        setname(m, data, length);
 3258|    295|    }
 3259|       |
 3260|    427|    return STATE_LOAD_STATUS_CONTINUE;
 3261|    427|}
Messenger.c:save_name:
 3245|  1.50k|{
 3246|  1.50k|    const uint32_t len = m_plugin_size(m, STATE_TYPE_NAME);
 3247|  1.50k|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_NAME);
  ------------------
  |  |   28|  1.50k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3248|  1.50k|    memcpy(data, m->name, len);
 3249|  1.50k|    data += len;
 3250|  1.50k|    return data;
 3251|  1.50k|}
Messenger.c:status_message_size:
 3266|  4.52k|{
 3267|  4.52k|    return m->statusmessage_length;
 3268|  4.52k|}
Messenger.c:load_status_message:
 3282|    722|{
 3283|    722|    if (length > 0 && length <= MAX_STATUSMESSAGE_LENGTH) {
  ------------------
  |  |   26|    656|#define MAX_STATUSMESSAGE_LENGTH 1007
  ------------------
  |  Branch (3283:9): [True: 656, False: 66]
  |  Branch (3283:23): [True: 646, False: 10]
  ------------------
 3284|    646|        m_set_statusmessage(m, data, length);
 3285|    646|    }
 3286|       |
 3287|    722|    return STATE_LOAD_STATUS_CONTINUE;
 3288|    722|}
Messenger.c:save_status_message:
 3272|  1.50k|{
 3273|  1.50k|    const uint32_t len = m_plugin_size(m, STATE_TYPE_STATUSMESSAGE);
 3274|  1.50k|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_STATUSMESSAGE);
  ------------------
  |  |   28|  1.50k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3275|  1.50k|    memcpy(data, m->statusmessage, len);
 3276|  1.50k|    data += len;
 3277|  1.50k|    return data;
 3278|  1.50k|}
Messenger.c:status_size:
 3293|  4.52k|{
 3294|  4.52k|    return 1;
 3295|  4.52k|}
Messenger.c:load_status:
 3309|    594|{
 3310|    594|    if (length == 1) {
  ------------------
  |  Branch (3310:9): [True: 551, False: 43]
  ------------------
 3311|    551|        m_set_userstatus(m, *data);
 3312|    551|    }
 3313|       |
 3314|    594|    return STATE_LOAD_STATUS_CONTINUE;
 3315|    594|}
Messenger.c:save_status:
 3299|  1.50k|{
 3300|  1.50k|    const uint32_t len = m_plugin_size(m, STATE_TYPE_STATUS);
 3301|  1.50k|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_STATUS);
  ------------------
  |  |   28|  1.50k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3302|  1.50k|    *data = m->userstatus;
 3303|  1.50k|    data += len;
 3304|  1.50k|    return data;
 3305|  1.50k|}
Messenger.c:saved_groups_size:
 3164|  3.30k|{
 3165|  3.30k|    GC_Session *c = m->group_handler;
 3166|  3.30k|    return bin_pack_obj_size(pack_groupchats_handler, c);
 3167|  3.30k|}
Messenger.c:pack_groupchats_handler:
 3157|  3.59k|{
 3158|  3.59k|    pack_groupchats((const GC_Session *)obj, bp);
 3159|  3.59k|    return true;  // TODO(iphydf): Return bool from pack functions.
 3160|  3.59k|}
Messenger.c:pack_groupchats:
 3140|  3.59k|{
 3141|  3.59k|    assert(bp != nullptr && c != nullptr);
 3142|      0|    bin_pack_array(bp, gc_count_groups(c));
 3143|       |
 3144|  10.0k|    for (uint32_t i = 0; i < c->chats_index; ++i) { // this loop must match the one in gc_count_groups()
  ------------------
  |  Branch (3144:26): [True: 6.44k, False: 3.59k]
  ------------------
 3145|  6.44k|        const GC_Chat *chat = &c->chats[i];
 3146|       |
 3147|  6.44k|        if (!gc_group_is_valid(chat)) {
  ------------------
  |  Branch (3147:13): [True: 2.61k, False: 3.83k]
  ------------------
 3148|  2.61k|            continue;
 3149|  2.61k|        }
 3150|       |
 3151|  3.83k|        gc_group_save(chat, bp);
 3152|  3.83k|    }
 3153|  3.59k|}
Messenger.c:groups_load:
 3202|  27.3k|{
 3203|  27.3k|    Bin_Unpack *bu = bin_unpack_new(data, length);
 3204|  27.3k|    if (bu == nullptr) {
  ------------------
  |  |   66|  27.3k|#define nullptr NULL
  ------------------
  |  Branch (3204:9): [True: 0, False: 27.3k]
  ------------------
 3205|      0|        LOGGER_ERROR(m->log, "failed to allocate binary unpacker");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3206|      0|        return STATE_LOAD_STATUS_ERROR;
 3207|      0|    }
 3208|       |
 3209|  27.3k|    uint32_t num_groups;
 3210|  27.3k|    if (!bin_unpack_array(bu, &num_groups)) {
  ------------------
  |  Branch (3210:9): [True: 57, False: 27.2k]
  ------------------
 3211|     57|        LOGGER_ERROR(m->log, "msgpack failed to unpack groupchats array: expected array");
  ------------------
  |  |   83|     57|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     57|    do {                                                                         \
  |  |  |  |   73|     57|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    114|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     57|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     57|        }                                                                        \
  |  |  |  |   76|     57|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3212|     57|        bin_unpack_free(bu);
 3213|     57|        return STATE_LOAD_STATUS_ERROR;
 3214|     57|    }
 3215|       |
 3216|  27.2k|    LOGGER_DEBUG(m->log, "Loading %u groups (length %u)", num_groups, length);
  ------------------
  |  |   80|  27.2k|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  27.2k|    do {                                                                         \
  |  |  |  |   73|  27.2k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  54.4k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  27.2k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3217|       |
 3218|  27.4k|    for (uint32_t i = 0; i < num_groups; ++i) {
  ------------------
  |  Branch (3218:26): [True: 27.4k, False: 77]
  ------------------
 3219|  27.4k|        const int group_number = gc_group_load(m->group_handler, bu);
 3220|       |
 3221|  27.4k|        if (group_number < 0) {
  ------------------
  |  Branch (3221:13): [True: 27.1k, False: 238]
  ------------------
 3222|  27.1k|            LOGGER_WARNING(m->log, "Failed to load group %u", i);
  ------------------
  |  |   82|  27.1k|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  27.1k|    do {                                                                         \
  |  |  |  |   73|  27.1k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  54.3k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|  27.1k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|  27.1k|        }                                                                        \
  |  |  |  |   76|  27.1k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3223|       |            // Can't recover trivially. We may need to skip over some data here.
 3224|  27.1k|            break;
 3225|  27.1k|        }
 3226|  27.4k|    }
 3227|       |
 3228|  27.2k|    LOGGER_DEBUG(m->log, "Successfully loaded %u groups", gc_count_groups(m->group_handler));
  ------------------
  |  |   80|  27.2k|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  27.2k|    do {                                                                         \
  |  |  |  |   73|  27.2k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  54.4k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  27.2k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3229|       |
 3230|  27.2k|    bin_unpack_free(bu);
 3231|       |
 3232|  27.2k|    return STATE_LOAD_STATUS_CONTINUE;
 3233|  27.3k|}
Messenger.c:groups_save:
 3171|  1.50k|{
 3172|  1.50k|    const GC_Session *c = m->group_handler;
 3173|       |
 3174|  1.50k|    const uint32_t num_groups = gc_count_groups(c);
 3175|       |
 3176|  1.50k|    if (num_groups == 0) {
  ------------------
  |  Branch (3176:9): [True: 1.21k, False: 292]
  ------------------
 3177|  1.21k|        return data;
 3178|  1.21k|    }
 3179|       |
 3180|    292|    const uint32_t len = m_plugin_size(m, STATE_TYPE_GROUPS);
 3181|       |
 3182|    292|    if (len == 0) {
  ------------------
  |  Branch (3182:9): [True: 0, False: 292]
  ------------------
 3183|      0|        return data;
 3184|      0|    }
 3185|       |
 3186|    292|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_GROUPS);
  ------------------
  |  |   28|    292|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3187|       |
 3188|    292|    if (!bin_pack_obj(pack_groupchats_handler, c, data, len)) {
  ------------------
  |  Branch (3188:9): [True: 0, False: 292]
  ------------------
 3189|      0|        LOGGER_FATAL(m->log, "failed to pack group chats into buffer of length %u", len);
  ------------------
  |  |   86|      0|    do {                                \
  |  |   87|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   88|      0|        abort();                        \
  |  |   89|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (89:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3190|      0|        return data;
 3191|      0|    }
 3192|       |
 3193|    292|    data += len;
 3194|       |
 3195|    292|    LOGGER_DEBUG(m->log, "Saved %u groups (length %u)", num_groups, len);
  ------------------
  |  |   80|    292|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    292|    do {                                                                         \
  |  |  |  |   73|    292|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    584|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|    292|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3196|       |
 3197|    292|    return data;
 3198|    292|}
Messenger.c:tcp_relay_size:
 3320|  3.01k|{
 3321|  3.01k|    return NUM_SAVED_TCP_RELAYS * packed_node_size(net_family_tcp_ipv6());
  ------------------
  |  |   28|  3.01k|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
 3322|  3.01k|}
Messenger.c:load_tcp_relays:
 3351|    657|{
 3352|    657|    if (length > 0) {
  ------------------
  |  Branch (3352:9): [True: 591, False: 66]
  ------------------
 3353|    591|        const int num = unpack_nodes(m->loaded_relays, NUM_SAVED_TCP_RELAYS, nullptr, data, length, true);
  ------------------
  |  |   28|    591|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
                      const int num = unpack_nodes(m->loaded_relays, NUM_SAVED_TCP_RELAYS, nullptr, data, length, true);
  ------------------
  |  |   66|    591|#define nullptr NULL
  ------------------
 3354|       |
 3355|    591|        if (num == -1) {
  ------------------
  |  Branch (3355:13): [True: 216, False: 375]
  ------------------
 3356|    216|            m->num_loaded_relays = 0;
 3357|    216|            return STATE_LOAD_STATUS_CONTINUE;
 3358|    216|        }
 3359|       |
 3360|    375|        m->num_loaded_relays = num;
 3361|    375|        m->has_added_relays = false;
 3362|    375|    }
 3363|       |
 3364|    441|    return STATE_LOAD_STATUS_CONTINUE;
 3365|    657|}
Messenger.c:save_tcp_relays:
 3326|  1.50k|{
 3327|  1.50k|    Node_format relays[NUM_SAVED_TCP_RELAYS] = {{{0}}};
 3328|  1.50k|    uint8_t *temp_data = data;
 3329|  1.50k|    data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, 0, STATE_TYPE_TCP_RELAY);
  ------------------
  |  |   28|  1.50k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3330|       |
 3331|  1.50k|    if (m->num_loaded_relays > 0) {
  ------------------
  |  Branch (3331:9): [True: 26, False: 1.48k]
  ------------------
 3332|     26|        memcpy(relays, m->loaded_relays, sizeof(Node_format) * m->num_loaded_relays);
 3333|     26|    }
 3334|       |
 3335|  1.50k|    uint32_t num = m->num_loaded_relays;
 3336|  1.50k|    num += copy_connected_tcp_relays(m->net_crypto, relays + num, NUM_SAVED_TCP_RELAYS - num);
  ------------------
  |  |   28|  1.50k|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
 3337|       |
 3338|  1.50k|    const int l = pack_nodes(m->log, data, NUM_SAVED_TCP_RELAYS * packed_node_size(net_family_tcp_ipv6()), relays, num);
  ------------------
  |  |   28|  1.50k|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
 3339|       |
 3340|  1.50k|    if (l > 0) {
  ------------------
  |  Branch (3340:9): [True: 26, False: 1.48k]
  ------------------
 3341|     26|        const uint32_t len = l;
 3342|     26|        data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, len, STATE_TYPE_TCP_RELAY);
  ------------------
  |  |   28|     26|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3343|     26|        data += len;
 3344|     26|    }
 3345|       |
 3346|  1.50k|    return data;
 3347|  1.50k|}
Messenger.c:path_node_size:
 3370|  3.01k|{
 3371|  3.01k|    return NUM_SAVED_PATH_NODES * packed_node_size(net_family_tcp_ipv6());
  ------------------
  |  | 2764|  3.01k|#define NUM_SAVED_PATH_NODES 8
  ------------------
 3372|  3.01k|}
Messenger.c:load_path_nodes:
 3395|    351|{
 3396|    351|    if (length > 0) {
  ------------------
  |  Branch (3396:9): [True: 283, False: 68]
  ------------------
 3397|    283|        Node_format nodes[NUM_SAVED_PATH_NODES];
 3398|    283|        const int num = unpack_nodes(nodes, NUM_SAVED_PATH_NODES, nullptr, data, length, false);
  ------------------
  |  | 2764|    283|#define NUM_SAVED_PATH_NODES 8
  ------------------
                      const int num = unpack_nodes(nodes, NUM_SAVED_PATH_NODES, nullptr, data, length, false);
  ------------------
  |  |   66|    283|#define nullptr NULL
  ------------------
 3399|       |
 3400|    283|        if (num == -1) {
  ------------------
  |  Branch (3400:13): [True: 102, False: 181]
  ------------------
 3401|    102|            return STATE_LOAD_STATUS_CONTINUE;
 3402|    102|        }
 3403|       |
 3404|  1.57k|        for (int i = 0; i < num; ++i) {
  ------------------
  |  Branch (3404:25): [True: 1.38k, False: 181]
  ------------------
 3405|  1.38k|            onion_add_bs_path_node(m->onion_c, &nodes[i].ip_port, nodes[i].public_key);
 3406|  1.38k|        }
 3407|    181|    }
 3408|       |
 3409|    249|    return STATE_LOAD_STATUS_CONTINUE;
 3410|    351|}
Messenger.c:save_path_nodes:
 3376|  1.50k|{
 3377|  1.50k|    Node_format nodes[NUM_SAVED_PATH_NODES];
 3378|  1.50k|    uint8_t *temp_data = data;
 3379|  1.50k|    data = state_write_section_header(data, STATE_COOKIE_TYPE, 0, STATE_TYPE_PATH_NODE);
  ------------------
  |  |   28|  1.50k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3380|  1.50k|    memset(nodes, 0, sizeof(nodes));
 3381|  1.50k|    const unsigned int num = onion_backup_nodes(m->onion_c, nodes, NUM_SAVED_PATH_NODES);
  ------------------
  |  | 2764|  1.50k|#define NUM_SAVED_PATH_NODES 8
  ------------------
 3382|  1.50k|    const int l = pack_nodes(m->log, data, NUM_SAVED_PATH_NODES * packed_node_size(net_family_tcp_ipv6()), nodes, num);
  ------------------
  |  | 2764|  1.50k|#define NUM_SAVED_PATH_NODES 8
  ------------------
 3383|       |
 3384|  1.50k|    if (l > 0) {
  ------------------
  |  Branch (3384:9): [True: 31, False: 1.47k]
  ------------------
 3385|     31|        const uint32_t len = l;
 3386|     31|        data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, len, STATE_TYPE_PATH_NODE);
  ------------------
  |  |   28|     31|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3387|     31|        data += len;
 3388|     31|    }
 3389|       |
 3390|  1.50k|    return data;
 3391|  1.50k|}

tcp_connections_count:
   67|    238|{
   68|    238|    return tcp_c->tcp_connections_length;
   69|    238|}
set_packet_tcp_connection_callback:
  544|  2.37k|{
  545|  2.37k|    tcp_c->tcp_data_callback = tcp_data_callback;
  546|  2.37k|    tcp_c->tcp_data_callback_object = object;
  547|  2.37k|}
set_oob_packet_tcp_connection_callback:
  551|  2.37k|{
  552|  2.37k|    tcp_c->tcp_oob_callback = tcp_oob_callback;
  553|  2.37k|    tcp_c->tcp_oob_callback_object = object;
  554|  2.37k|}
set_onion_packet_tcp_connection_callback:
  558|  4.28k|{
  559|  4.28k|    tcp_c->tcp_onion_callback = tcp_onion_callback;
  560|  4.28k|    tcp_c->tcp_onion_callback_object = object;
  561|  4.28k|}
tcp_copy_connected_relays:
 1479|  1.50k|{
 1480|  1.50k|    const uint32_t r = random_u32(tcp_c->rng);
 1481|  1.50k|    uint32_t copied = 0;
 1482|       |
 1483|  1.50k|    for (uint32_t i = 0; (i < tcp_c->tcp_connections_length) && (copied < max_num); ++i) {
  ------------------
  |  Branch (1483:26): [True: 0, False: 1.50k]
  |  Branch (1483:65): [True: 0, False: 0]
  ------------------
 1484|      0|        const uint16_t idx = (i + r) % tcp_c->tcp_connections_length;
 1485|       |
 1486|      0|        if (copy_tcp_relay_conn(tcp_c, &tcp_relays[copied], idx)) {
  ------------------
  |  Branch (1486:13): [True: 0, False: 0]
  ------------------
 1487|      0|            ++copied;
 1488|      0|        }
 1489|      0|    }
 1490|       |
 1491|  1.50k|    return copied;
 1492|  1.50k|}
new_tcp_connections:
 1590|  2.37k|{
 1591|  2.37k|    assert(logger != nullptr);
 1592|      0|    assert(mem != nullptr);
 1593|      0|    assert(rng != nullptr);
 1594|      0|    assert(ns != nullptr);
 1595|      0|    assert(mono_time != nullptr);
 1596|       |
 1597|  2.37k|    if (secret_key == nullptr) {
  ------------------
  |  |   66|  2.37k|#define nullptr NULL
  ------------------
  |  Branch (1597:9): [True: 0, False: 2.37k]
  ------------------
 1598|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1599|      0|    }
 1600|       |
 1601|  2.37k|    TCP_Connections *temp = (TCP_Connections *)mem_alloc(mem, sizeof(TCP_Connections));
 1602|       |
 1603|  2.37k|    if (temp == nullptr) {
  ------------------
  |  |   66|  2.37k|#define nullptr NULL
  ------------------
  |  Branch (1603:9): [True: 0, False: 2.37k]
  ------------------
 1604|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1605|      0|    }
 1606|       |
 1607|  2.37k|    temp->logger = logger;
 1608|  2.37k|    temp->mem = mem;
 1609|  2.37k|    temp->rng = rng;
 1610|  2.37k|    temp->mono_time = mono_time;
 1611|  2.37k|    temp->ns = ns;
 1612|       |
 1613|  2.37k|    memcpy(temp->self_secret_key, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   45|  2.37k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 1614|  2.37k|    crypto_derive_public_key(temp->self_public_key, temp->self_secret_key);
 1615|  2.37k|    temp->proxy_info = *proxy_info;
 1616|       |
 1617|  2.37k|    return temp;
 1618|  2.37k|}
kill_tcp_connections:
 1710|  2.37k|{
 1711|  2.37k|    if (tcp_c == nullptr) {
  ------------------
  |  |   66|  2.37k|#define nullptr NULL
  ------------------
  |  Branch (1711:9): [True: 0, False: 2.37k]
  ------------------
 1712|      0|        return;
 1713|      0|    }
 1714|       |
 1715|  2.37k|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1715:26): [True: 0, False: 2.37k]
  ------------------
 1716|      0|        kill_tcp_connection(tcp_c->tcp_connections[i].connection);
 1717|      0|    }
 1718|       |
 1719|  2.37k|    crypto_memzero(tcp_c->self_secret_key, sizeof(tcp_c->self_secret_key));
 1720|       |
 1721|  2.37k|    mem_delete(tcp_c->mem, tcp_c->tcp_connections);
 1722|  2.37k|    mem_delete(tcp_c->mem, tcp_c->connections);
 1723|  2.37k|    mem_delete(tcp_c->mem, tcp_c);
 1724|  2.37k|}

new_announcements:
  642|  2.14k|{
  643|  2.14k|    if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (643:9): [True: 0, False: 2.14k]
  |  Branch (643:27): [True: 0, False: 2.14k]
  |  Branch (643:51): [True: 0, False: 2.14k]
  ------------------
  644|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  645|      0|    }
  646|       |
  647|  2.14k|    Announcements *announce = (Announcements *)calloc(1, sizeof(Announcements));
  648|       |
  649|  2.14k|    if (announce == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (649:9): [True: 0, False: 2.14k]
  ------------------
  650|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  651|      0|    }
  652|       |
  653|  2.14k|    announce->log = log;
  654|  2.14k|    announce->mem = mem;
  655|  2.14k|    announce->rng = rng;
  656|  2.14k|    announce->forwarding = forwarding;
  657|  2.14k|    announce->mono_time = mono_time;
  658|  2.14k|    announce->dht = forwarding_get_dht(forwarding);
  659|  2.14k|    announce->net = dht_get_net(announce->dht);
  660|  2.14k|    announce->public_key = dht_get_self_public_key(announce->dht);
  661|  2.14k|    announce->secret_key = dht_get_self_secret_key(announce->dht);
  662|  2.14k|    new_hmac_key(announce->rng, announce->hmac_key);
  663|  2.14k|    announce->shared_keys = shared_key_cache_new(mono_time, mem, announce->secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   23|  2.14k|#define KEYS_TIMEOUT 600
  ------------------
                  announce->shared_keys = shared_key_cache_new(mono_time, mem, announce->secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   22|  2.14k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  664|  2.14k|    if (announce->shared_keys == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (664:9): [True: 0, False: 2.14k]
  ------------------
  665|      0|        free(announce);
  666|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  667|      0|    }
  668|       |
  669|  2.14k|    announce->start_time = mono_time_get(announce->mono_time);
  670|       |
  671|  2.14k|    set_callback_forwarded_request(forwarding, forwarded_request_callback, announce);
  672|       |
  673|  2.14k|    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, handle_dht_announce_request, announce);
  674|  2.14k|    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, handle_dht_announce_request, announce);
  675|  2.14k|    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, handle_dht_announce_request, announce);
  676|       |
  677|  2.14k|    return announce;
  678|  2.14k|}
kill_announcements:
  681|  2.14k|{
  682|  2.14k|    if (announce == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (682:9): [True: 0, False: 2.14k]
  ------------------
  683|      0|        return;
  684|      0|    }
  685|       |
  686|  2.14k|    set_callback_forwarded_request(announce->forwarding, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  set_callback_forwarded_request(announce->forwarding, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  687|       |
  688|  2.14k|    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  689|  2.14k|    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  690|  2.14k|    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  691|       |
  692|  2.14k|    crypto_memzero(announce->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  136|  2.14k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  693|  2.14k|    shared_key_cache_free(announce->shared_keys);
  694|       |
  695|   550k|    for (uint32_t i = 0; i < ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   66|   550k|#define ANNOUNCE_BUCKETS 32 // ANNOUNCE_BUCKETS = 2 ** ANNOUNCE_BUCKET_PREFIX_LENGTH
  ------------------
                  for (uint32_t i = 0; i < ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   64|   550k|#define ANNOUNCE_BUCKET_SIZE 8
  ------------------
  |  Branch (695:26): [True: 548k, False: 2.14k]
  ------------------
  696|   548k|        if (announce->entries[i].data != nullptr) {
  ------------------
  |  |   66|   548k|#define nullptr NULL
  ------------------
  |  Branch (696:13): [True: 0, False: 548k]
  ------------------
  697|      0|            free(announce->entries[i].data);
  698|      0|        }
  699|   548k|    }
  700|       |
  701|  2.14k|    free(announce);
  702|  2.14k|}

bin_pack_obj:
   66|    292|{
   67|    292|    Bin_Pack bp;
   68|    292|    bin_pack_init(&bp, buf, buf_size);
   69|    292|    return callback(&bp, obj);
   70|    292|}
bin_pack_obj_size:
   73|  3.30k|{
   74|  3.30k|    Bin_Pack bp;
   75|  3.30k|    bin_pack_init(&bp, nullptr, 0);
  ------------------
  |  |   66|  3.30k|#define nullptr NULL
  ------------------
   76|  3.30k|    callback(&bp, obj);
   77|  3.30k|    return bp.bytes_pos;
   78|  3.30k|}
bin_pack_array:
   96|  6.95k|{
   97|  6.95k|    return cmp_write_array(&bp->ctx, size);
   98|  6.95k|}
bin_pack_bool:
  101|    420|{
  102|    420|    return cmp_write_bool(&bp->ctx, val);
  103|    420|}
bin_pack_u08:
  106|  1.68k|{
  107|  1.68k|    return cmp_write_uinteger(&bp->ctx, val);
  108|  1.68k|}
bin_pack_u16:
  111|  3.36k|{
  112|  3.36k|    return cmp_write_uinteger(&bp->ctx, val);
  113|  3.36k|}
bin_pack_u32:
  116|  1.26k|{
  117|  1.26k|    return cmp_write_uinteger(&bp->ctx, val);
  118|  1.26k|}
bin_pack_bin:
  126|  6.18k|{
  127|  6.18k|    return cmp_write_bin(&bp->ctx, data, length);
  128|  6.18k|}
bin_pack_nil:
  131|    120|{
  132|    120|    return cmp_write_nil(&bp->ctx);
  133|    120|}
bin_pack.c:bin_pack_init:
   58|  3.59k|{
   59|  3.59k|    bp->bytes = buf;
   60|  3.59k|    bp->bytes_size = buf_size;
   61|  3.59k|    bp->bytes_pos = 0;
   62|  3.59k|    cmp_init(&bp->ctx, bp, null_reader, null_skipper, buf_writer);
   63|  3.59k|}
bin_pack.c:buf_writer:
   37|  32.5k|{
   38|  32.5k|    Bin_Pack *bp = (Bin_Pack *)ctx->buf;
   39|  32.5k|    assert(bp != nullptr);
   40|      0|    const uint32_t new_pos = bp->bytes_pos + count;
   41|  32.5k|    if (new_pos < bp->bytes_pos) {
  ------------------
  |  Branch (41:9): [True: 0, False: 32.5k]
  ------------------
   42|       |        // 32 bit overflow.
   43|      0|        return 0;
   44|      0|    }
   45|  32.5k|    if (bp->bytes != nullptr) {
  ------------------
  |  |   66|  32.5k|#define nullptr NULL
  ------------------
  |  Branch (45:9): [True: 7.52k, False: 25.0k]
  ------------------
   46|  7.52k|        if (new_pos > bp->bytes_size) {
  ------------------
  |  Branch (46:13): [True: 0, False: 7.52k]
  ------------------
   47|       |            // Buffer too small.
   48|      0|            return 0;
   49|      0|        }
   50|  7.52k|        memcpy(bp->bytes + bp->bytes_pos, data, count);
   51|  7.52k|    }
   52|  32.5k|    bp->bytes_pos += count;
   53|  32.5k|    return count;
   54|  32.5k|}

bin_unpack_new:
   55|  27.3k|{
   56|  27.3k|    Bin_Unpack *bu = (Bin_Unpack *)calloc(1, sizeof(Bin_Unpack));
   57|  27.3k|    if (bu == nullptr) {
  ------------------
  |  |   66|  27.3k|#define nullptr NULL
  ------------------
  |  Branch (57:9): [True: 0, False: 27.3k]
  ------------------
   58|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   59|      0|    }
   60|  27.3k|    bu->bytes = buf;
   61|  27.3k|    bu->bytes_size = buf_size;
   62|  27.3k|    cmp_init(&bu->ctx, bu, buf_reader, buf_skipper, null_writer);
   63|  27.3k|    return bu;
   64|  27.3k|}
bin_unpack_free:
   67|  27.3k|{
   68|  27.3k|    free(bu);
   69|  27.3k|}
bin_unpack_array:
   72|  27.3k|{
   73|  27.3k|    return cmp_read_array(&bu->ctx, size) && *size <= bu->bytes_size;
  ------------------
  |  Branch (73:12): [True: 27.2k, False: 56]
  |  Branch (73:46): [True: 27.2k, False: 1]
  ------------------
   74|  27.3k|}
bin_unpack_array_fixed:
   77|  56.7k|{
   78|  56.7k|    uint32_t size = 0;
   79|  56.7k|    const bool success = cmp_read_array(&bu->ctx, &size) && size == required_size;
  ------------------
  |  Branch (79:26): [True: 51.1k, False: 5.64k]
  |  Branch (79:61): [True: 50.9k, False: 114]
  ------------------
   80|  56.7k|    if (actual_size != nullptr) {
  ------------------
  |  |   66|  56.7k|#define nullptr NULL
  ------------------
  |  Branch (80:9): [True: 28.0k, False: 28.7k]
  ------------------
   81|  28.0k|        *actual_size = size;
   82|  28.0k|    }
   83|  56.7k|    return success;
   84|  56.7k|}
bin_unpack_bool:
   87|  22.6k|{
   88|  22.6k|    return cmp_read_bool(&bu->ctx, val);
   89|  22.6k|}
bin_unpack_u08:
   92|  30.1k|{
   93|  30.1k|    return cmp_read_uchar(&bu->ctx, val);
   94|  30.1k|}
bin_unpack_u16:
   97|  57.0k|{
   98|  57.0k|    return cmp_read_ushort(&bu->ctx, val);
   99|  57.0k|}
bin_unpack_u32:
  102|  30.7k|{
  103|  30.7k|    return cmp_read_uint(&bu->ctx, val);
  104|  30.7k|}
bin_unpack_nil:
  112|    195|{
  113|    195|    return cmp_read_nil(&bu->ctx);
  114|    195|}
bin_unpack_bin_max:
  136|  2.29k|{
  137|  2.29k|    uint32_t bin_size;
  138|  2.29k|    if (!bin_unpack_bin_size(bu, &bin_size) || bin_size > max_data_length) {
  ------------------
  |  Branch (138:9): [True: 147, False: 2.14k]
  |  Branch (138:48): [True: 3, False: 2.14k]
  ------------------
  139|    150|        return false;
  140|    150|    }
  141|       |
  142|  2.14k|    *data_length_ptr = bin_size;
  143|       |
  144|  2.14k|    return bin_unpack_bin_b(bu, data, bin_size);
  145|  2.29k|}
bin_unpack_bin_fixed:
  148|  8.45k|{
  149|  8.45k|    uint32_t bin_size;
  150|  8.45k|    if (!bin_unpack_bin_size(bu, &bin_size) || bin_size != data_length) {
  ------------------
  |  Branch (150:9): [True: 2.58k, False: 5.86k]
  |  Branch (150:48): [True: 35, False: 5.83k]
  ------------------
  151|  2.62k|        return false;
  152|  2.62k|    }
  153|       |
  154|  5.83k|    return bin_unpack_bin_b(bu, data, bin_size);
  155|  8.45k|}
bin_unpack_bin_size:
  158|  10.7k|{
  159|  10.7k|    return cmp_read_bin_size(&bu->ctx, size);
  160|  10.7k|}
bin_unpack_bin_b:
  204|  7.97k|{
  205|  7.97k|    return bu->ctx.read(&bu->ctx, data, length);
  206|  7.97k|}
bin_unpack.c:buf_reader:
   22|   281k|{
   23|   281k|    Bin_Unpack *reader = (Bin_Unpack *)ctx->buf;
   24|   281k|    assert(reader != nullptr && reader->bytes != nullptr);
   25|   281k|    if (limit > reader->bytes_size) {
  ------------------
  |  Branch (25:9): [True: 9.79k, False: 271k]
  ------------------
   26|  9.79k|        return false;
   27|  9.79k|    }
   28|   271k|    memcpy(data, reader->bytes, limit);
   29|   271k|    reader->bytes += limit;
   30|   271k|    reader->bytes_size -= limit;
   31|   271k|    return true;
   32|   281k|}

get_enc_key:
   94|    566|{
   95|    566|    return key;
   96|    566|}
get_sig_pk:
   99|    714|{
  100|    714|    return key + ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |   39|    714|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|    714|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  101|    714|}
get_chat_id:
  114|    301|{
  115|    301|    return key + ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |   39|    301|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|    301|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  116|    301|}
crypto_memzero:
  143|  34.8k|{
  144|  34.8k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) || defined(VANILLA_NACL)
  145|  34.8k|    memset(data, 0, length);
  146|       |#else
  147|       |    sodium_memzero(data, length);
  148|       |#endif
  149|  34.8k|}
crypto_memlock:
  152|  15.2k|{
  153|  15.2k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) || defined(VANILLA_NACL)
  154|  15.2k|    return false;
  155|       |#else
  156|       |
  157|       |    if (sodium_mlock(data, length) != 0) {
  158|       |        return false;
  159|       |    }
  160|       |
  161|       |    return true;
  162|       |#endif
  163|  15.2k|}
crypto_memunlock:
  166|  27.9k|{
  167|  27.9k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) || defined(VANILLA_NACL)
  168|  27.9k|    return false;
  169|       |#else
  170|       |
  171|       |    if (sodium_munlock(data, length) != 0) {
  172|       |        return false;
  173|       |    }
  174|       |
  175|       |    return true;
  176|       |#endif
  177|  27.9k|}
pk_equal:
  180|  4.48M|{
  181|  4.48M|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  182|       |    // Hope that this is better for the fuzzer
  183|  4.48M|    return memcmp(pk1, pk2, CRYPTO_PUBLIC_KEY_SIZE) == 0;
  ------------------
  |  |   40|  4.48M|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  184|       |#else
  185|       |    return crypto_verify_32(pk1, pk2) == 0;
  186|       |#endif
  187|  4.48M|}
pk_copy:
  190|  7.01k|{
  191|  7.01k|    memcpy(dest, src, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|  7.01k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  192|  7.01k|}
random_u32:
  233|  3.64k|{
  234|  3.64k|    uint32_t randnum;
  235|  3.64k|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  236|  3.64k|    return randnum;
  237|  3.64k|}
random_u64:
  240|  4.28k|{
  241|  4.28k|    uint64_t randnum;
  242|  4.28k|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  243|  4.28k|    return randnum;
  244|  4.28k|}
public_key_valid:
  272|    423|{
  273|       |    /* Last bit of key is always zero. */
  274|    423|    return public_key[31] < 128;
  275|    423|}
new_symmetric_key:
  466|  6.42k|{
  467|  6.42k|    random_bytes(rng, key, CRYPTO_SYMMETRIC_KEY_SIZE);
  ------------------
  |  |   55|  6.42k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  ------------------
  |  |  |  |   50|  6.42k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  ------------------
  ------------------
  468|  6.42k|}
crypto_new_keypair:
  471|  11.2k|{
  472|  11.2k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  473|  11.2k|    random_bytes(rng, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   45|  11.2k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
  474|  11.2k|    memset(public_key, 0, CRYPTO_PUBLIC_KEY_SIZE);  // Make MSAN happy
  ------------------
  |  |   40|  11.2k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  475|  11.2k|    crypto_derive_public_key(public_key, secret_key);
  476|  11.2k|    return 0;
  477|       |#else
  478|       |    return crypto_box_keypair(public_key, secret_key);
  479|       |#endif
  480|  11.2k|}
crypto_derive_public_key:
  483|  14.2k|{
  484|  14.2k|    crypto_scalarmult_curve25519_base(public_key, secret_key);
  485|  14.2k|}
new_hmac_key:
  488|  6.42k|{
  489|  6.42k|    random_bytes(rng, key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  136|  6.42k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  490|  6.42k|}
system_random:
  563|  2.14k|{
  564|  2.14k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  565|  2.14k|    if ((true)) {
  ------------------
  |  Branch (565:9): [Folded - Ignored]
  ------------------
  566|  2.14k|        return nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  567|  2.14k|    }
  568|      0|#endif
  569|      0|#ifndef VANILLA_NACL
  570|       |    // It is safe to call this function more than once and from different
  571|       |    // threads -- subsequent calls won't have any effects.
  572|      0|    if (sodium_init() == -1) {
  ------------------
  |  Branch (572:9): [True: 0, False: 0]
  ------------------
  573|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  574|      0|    }
  575|      0|#endif
  576|      0|    return &system_random_obj;
  577|      0|}
random_bytes:
  580|  32.0k|{
  581|  32.0k|    rng->funcs->random_bytes(rng->obj, bytes, length);
  582|  32.0k|}

forwarding_get_dht:
   35|  2.14k|{
   36|  2.14k|    return forwarding->dht;
   37|  2.14k|}
set_callback_forwarded_request:
  338|  4.28k|{
  339|  4.28k|    forwarding->forwarded_request_callback = function;
  340|  4.28k|    forwarding->forwarded_request_callback_object = object;
  341|  4.28k|}
new_forwarding:
  356|  2.14k|{
  357|  2.14k|    if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (357:9): [True: 0, False: 2.14k]
  |  Branch (357:27): [True: 0, False: 2.14k]
  |  Branch (357:51): [True: 0, False: 2.14k]
  ------------------
  358|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  359|      0|    }
  360|       |
  361|  2.14k|    Forwarding *forwarding = (Forwarding *)calloc(1, sizeof(Forwarding));
  362|       |
  363|  2.14k|    if (forwarding == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (363:9): [True: 0, False: 2.14k]
  ------------------
  364|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  365|      0|    }
  366|       |
  367|  2.14k|    forwarding->log = log;
  368|  2.14k|    forwarding->rng = rng;
  369|  2.14k|    forwarding->mono_time = mono_time;
  370|  2.14k|    forwarding->dht = dht;
  371|  2.14k|    forwarding->net = dht_get_net(dht);
  372|       |
  373|  2.14k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, &handle_forward_request, forwarding);
  374|  2.14k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, &handle_forward_reply, forwarding);
  375|  2.14k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, &handle_forwarding, forwarding);
  376|       |
  377|  2.14k|    new_hmac_key(forwarding->rng, forwarding->hmac_key);
  378|       |
  379|  2.14k|    return forwarding;
  380|  2.14k|}
kill_forwarding:
  383|  2.14k|{
  384|  2.14k|    if (forwarding == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (384:9): [True: 0, False: 2.14k]
  ------------------
  385|      0|        return;
  386|      0|    }
  387|       |
  388|  2.14k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  389|  2.14k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  390|  2.14k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  391|       |
  392|  2.14k|    crypto_memzero(forwarding->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  136|  2.14k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  393|       |
  394|  2.14k|    free(forwarding);
  395|  2.14k|}

friend_conn_get_onion_friendnum:
   84|     18|{
   85|     18|    return fc->onion_friendnum;
   86|     18|}
get_conn:
  192|  1.47k|{
  193|  1.47k|    if (!friendconn_id_valid(fr_c, friendcon_id)) {
  ------------------
  |  Branch (193:9): [True: 1, False: 1.47k]
  ------------------
  194|      1|        return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  195|      1|    }
  196|       |
  197|  1.47k|    return &fr_c->conns[friendcon_id];
  198|  1.47k|}
getfriend_conn_id_pk:
  205|    309|{
  206|    815|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (206:26): [True: 509, False: 306]
  ------------------
  207|    509|        const Friend_Conn *friend_con = get_conn(fr_c, i);
  208|       |
  209|    509|        if (friend_con != nullptr) {
  ------------------
  |  |   66|    509|#define nullptr NULL
  ------------------
  |  Branch (209:13): [True: 509, False: 0]
  ------------------
  210|    509|            if (pk_equal(friend_con->real_public_key, real_pk)) {
  ------------------
  |  Branch (210:17): [True: 3, False: 506]
  ------------------
  211|      3|                return i;
  212|      3|            }
  213|    509|        }
  214|    509|    }
  215|       |
  216|    306|    return -1;
  217|    309|}
friend_con_connected:
  673|    327|{
  674|    327|    const Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  675|       |
  676|    327|    if (friend_con == nullptr) {
  ------------------
  |  |   66|    327|#define nullptr NULL
  ------------------
  |  Branch (676:9): [True: 0, False: 327]
  ------------------
  677|      0|        return 0;
  678|      0|    }
  679|       |
  680|    327|    return friend_con->status;
  681|    327|}
friend_connection_callbacks:
  725|    309|{
  726|    309|    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  727|       |
  728|    309|    if (friend_con == nullptr) {
  ------------------
  |  |   66|    309|#define nullptr NULL
  ------------------
  |  Branch (728:9): [True: 0, False: 309]
  ------------------
  729|      0|        return -1;
  730|      0|    }
  731|       |
  732|    309|    if (index >= MAX_FRIEND_CONNECTION_CALLBACKS) {
  ------------------
  |  |   17|    309|#define MAX_FRIEND_CONNECTION_CALLBACKS 2
  ------------------
  |  Branch (732:9): [True: 0, False: 309]
  ------------------
  733|      0|        return -1;
  734|      0|    }
  735|       |
  736|    309|    if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   66|    618|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   66|    582|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   66|    582|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   66|    291|#define nullptr NULL
  ------------------
  |  Branch (736:9): [True: 291, False: 18]
  |  Branch (736:31): [True: 0, False: 291]
  |  Branch (736:61): [True: 0, False: 291]
  |  Branch (736:89): [True: 0, False: 291]
  ------------------
  737|      0|        LOGGER_ERROR(fr_c->logger, "non-null user data object but null callbacks");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  738|      0|        return -1;
  739|      0|    }
  740|       |
  741|    309|    friend_con->callbacks[index].status_callback = status_callback;
  742|    309|    friend_con->callbacks[index].data_callback = data_callback;
  743|    309|    friend_con->callbacks[index].lossy_data_callback = lossy_data_callback;
  744|       |
  745|    309|    friend_con->callbacks[index].callback_object = object;
  746|    309|    friend_con->callbacks[index].callback_id = number;
  747|       |
  748|    309|    return 0;
  749|    309|}
set_global_status_callback:
  753|  4.28k|{
  754|  4.28k|    if (object != nullptr && global_status_callback == nullptr) {
  ------------------
  |  |   66|  8.56k|#define nullptr NULL
  ------------------
                  if (object != nullptr && global_status_callback == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (754:9): [True: 2.14k, False: 2.14k]
  |  Branch (754:30): [True: 0, False: 2.14k]
  ------------------
  755|      0|        LOGGER_ERROR(fr_c->logger, "non-null user data object but null callback");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  756|      0|        object = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  757|      0|    }
  758|       |
  759|  4.28k|    fr_c->global_status_callback = global_status_callback;
  760|  4.28k|    fr_c->global_status_callback_object = object;
  761|  4.28k|}
new_friend_connection:
  786|    309|{
  787|    309|    int friendcon_id = getfriend_conn_id_pk(fr_c, real_public_key);
  788|       |
  789|    309|    if (friendcon_id != -1) {
  ------------------
  |  Branch (789:9): [True: 3, False: 306]
  ------------------
  790|      3|        ++fr_c->conns[friendcon_id].lock_count;
  791|      3|        return friendcon_id;
  792|      3|    }
  793|       |
  794|    306|    friendcon_id = create_friend_conn(fr_c);
  795|       |
  796|    306|    if (friendcon_id == -1) {
  ------------------
  |  Branch (796:9): [True: 0, False: 306]
  ------------------
  797|      0|        return -1;
  798|      0|    }
  799|       |
  800|    306|    const int32_t onion_friendnum = onion_addfriend(fr_c->onion_c, real_public_key);
  801|       |
  802|    306|    if (onion_friendnum == -1) {
  ------------------
  |  Branch (802:9): [True: 0, False: 306]
  ------------------
  803|      0|        return -1;
  804|      0|    }
  805|       |
  806|    306|    Friend_Conn *const friend_con = &fr_c->conns[friendcon_id];
  807|       |
  808|    306|    friend_con->crypt_connection_id = -1;
  809|    306|    friend_con->status = FRIENDCONN_STATUS_CONNECTING;
  810|    306|    memcpy(friend_con->real_public_key, real_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    306|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  811|    306|    friend_con->onion_friendnum = onion_friendnum;
  812|       |
  813|    306|    recv_tcp_relay_handler(fr_c->onion_c, onion_friendnum, &tcp_relay_node_callback, fr_c, friendcon_id);
  814|    306|    onion_dht_pk_callback(fr_c->onion_c, onion_friendnum, &dht_pk_callback, fr_c, friendcon_id);
  815|       |
  816|    306|    return friendcon_id;
  817|    306|}
kill_friend_connection:
  825|    310|{
  826|    310|    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  827|       |
  828|    310|    if (friend_con == nullptr) {
  ------------------
  |  |   66|    310|#define nullptr NULL
  ------------------
  |  Branch (828:9): [True: 1, False: 309]
  ------------------
  829|      1|        return -1;
  830|      1|    }
  831|       |
  832|    309|    if (friend_con->lock_count > 0) {
  ------------------
  |  Branch (832:9): [True: 3, False: 306]
  ------------------
  833|      3|        --friend_con->lock_count;
  834|      3|        return 0;
  835|      3|    }
  836|       |
  837|    306|    onion_delfriend(fr_c->onion_c, friend_con->onion_friendnum);
  838|    306|    crypto_kill(fr_c->net_crypto, friend_con->crypt_connection_id);
  839|       |
  840|    306|    if (friend_con->dht_lock_token > 0) {
  ------------------
  |  Branch (840:9): [True: 0, False: 306]
  ------------------
  841|      0|        dht_delfriend(fr_c->dht, friend_con->dht_temp_pk, friend_con->dht_lock_token);
  842|      0|        friend_con->dht_lock_token = 0;
  843|      0|    }
  844|       |
  845|    306|    return wipe_friend_conn(fr_c, friendcon_id);
  846|    309|}
set_friend_request_callback:
  854|  2.14k|{
  855|  2.14k|    fr_c->fr_request_callback = fr_request_callback;
  856|  2.14k|    fr_c->fr_request_object = object;
  857|  2.14k|    oniondata_registerhandler(fr_c->onion_c, CRYPTO_PACKET_FRIEND_REQ, fr_request_callback, object);
  ------------------
  |  |   80|  2.14k|#define CRYPTO_PACKET_FRIEND_REQ    32  // Friend request crypto packet ID.
  ------------------
  858|  2.14k|}
new_friend_connections:
  903|  2.14k|{
  904|  2.14k|    if (onion_c == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (904:9): [True: 0, False: 2.14k]
  ------------------
  905|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  906|      0|    }
  907|       |
  908|  2.14k|    Friend_Connections *const temp = (Friend_Connections *)calloc(1, sizeof(Friend_Connections));
  909|       |
  910|  2.14k|    if (temp == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (910:9): [True: 0, False: 2.14k]
  ------------------
  911|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  912|      0|    }
  913|       |
  914|  2.14k|    temp->mono_time = mono_time;
  915|  2.14k|    temp->logger = logger;
  916|  2.14k|    temp->dht = onion_get_dht(onion_c);
  917|  2.14k|    temp->net_crypto = onion_get_net_crypto(onion_c);
  918|  2.14k|    temp->onion_c = onion_c;
  919|  2.14k|    temp->local_discovery_enabled = local_discovery_enabled;
  920|       |    // Don't include default port in port range
  921|  2.14k|    temp->next_lan_port = TOX_PORTRANGE_FROM + 1;
  ------------------
  |  |  201|  2.14k|#define TOX_PORTRANGE_FROM 33445
  ------------------
  922|       |
  923|  2.14k|    new_connection_handler(temp->net_crypto, &handle_new_connections, temp);
  924|       |
  925|  2.14k|    if (temp->local_discovery_enabled) {
  ------------------
  |  Branch (925:9): [True: 2.14k, False: 0]
  ------------------
  926|  2.14k|        temp->broadcast = lan_discovery_init(ns);
  927|       |
  928|  2.14k|        if (temp->broadcast == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (928:13): [True: 0, False: 2.14k]
  ------------------
  929|      0|            LOGGER_ERROR(logger, "could not initialise LAN discovery");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  930|      0|        }
  931|  2.14k|    }
  932|       |
  933|  2.14k|    return temp;
  934|  2.14k|}
kill_friend_connections:
 1014|  2.14k|{
 1015|  2.14k|    if (fr_c == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (1015:9): [True: 0, False: 2.14k]
  ------------------
 1016|      0|        return;
 1017|      0|    }
 1018|       |
 1019|  2.43k|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (1019:26): [True: 292, False: 2.14k]
  ------------------
 1020|    292|        kill_friend_connection(fr_c, i);
 1021|    292|    }
 1022|       |
 1023|  2.14k|    lan_discovery_kill(fr_c->broadcast);
 1024|  2.14k|    free(fr_c);
 1025|  2.14k|}
friend_connection.c:friendconn_id_valid:
  105|  1.77k|{
  106|  1.77k|    return (unsigned int)friendcon_id < fr_c->num_cons &&
  ------------------
  |  Branch (106:12): [True: 1.77k, False: 0]
  ------------------
  107|  1.77k|           fr_c->conns != nullptr &&
  ------------------
  |  |   66|  3.55k|#define nullptr NULL
  ------------------
  |  Branch (107:12): [True: 1.77k, False: 0]
  ------------------
  108|  1.77k|           fr_c->conns[friendcon_id].status != FRIENDCONN_STATUS_NONE;
  ------------------
  |  Branch (108:12): [True: 1.77k, False: 1]
  ------------------
  109|  1.77k|}
friend_connection.c:create_friend_conn:
  143|    306|{
  144|    810|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (144:26): [True: 504, False: 306]
  ------------------
  145|    504|        if (fr_c->conns[i].status == FRIENDCONN_STATUS_NONE) {
  ------------------
  |  Branch (145:13): [True: 0, False: 504]
  ------------------
  146|      0|            return i;
  147|      0|        }
  148|    504|    }
  149|       |
  150|    306|    if (!realloc_friendconns(fr_c, fr_c->num_cons + 1)) {
  ------------------
  |  Branch (150:9): [True: 0, False: 306]
  ------------------
  151|      0|        return -1;
  152|      0|    }
  153|       |
  154|    306|    const int id = fr_c->num_cons;
  155|    306|    ++fr_c->num_cons;
  156|    306|    fr_c->conns[id] = empty_friend_conn;
  157|       |
  158|    306|    return id;
  159|    306|}
friend_connection.c:realloc_friendconns:
  119|    425|{
  120|    425|    if (num == 0) {
  ------------------
  |  Branch (120:9): [True: 113, False: 312]
  ------------------
  121|    113|        free(fr_c->conns);
  122|    113|        fr_c->conns = nullptr;
  ------------------
  |  |   66|    113|#define nullptr NULL
  ------------------
  123|    113|        return true;
  124|    113|    }
  125|       |
  126|    312|    Friend_Conn *newgroup_cons = (Friend_Conn *)realloc(fr_c->conns, num * sizeof(Friend_Conn));
  127|       |
  128|    312|    if (newgroup_cons == nullptr) {
  ------------------
  |  |   66|    312|#define nullptr NULL
  ------------------
  |  Branch (128:9): [True: 0, False: 312]
  ------------------
  129|      0|        return false;
  130|      0|    }
  131|       |
  132|    312|    fr_c->conns = newgroup_cons;
  133|    312|    return true;
  134|    312|}
friend_connection.c:wipe_friend_conn:
  168|    306|{
  169|    306|    if (!friendconn_id_valid(fr_c, friendcon_id)) {
  ------------------
  |  Branch (169:9): [True: 0, False: 306]
  ------------------
  170|      0|        return -1;
  171|      0|    }
  172|       |
  173|    306|    fr_c->conns[friendcon_id] = empty_friend_conn;
  174|       |
  175|    306|    uint32_t i;
  176|       |
  177|    612|    for (i = fr_c->num_cons; i != 0; --i) {
  ------------------
  |  Branch (177:30): [True: 499, False: 113]
  ------------------
  178|    499|        if (fr_c->conns[i - 1].status != FRIENDCONN_STATUS_NONE) {
  ------------------
  |  Branch (178:13): [True: 193, False: 306]
  ------------------
  179|    193|            break;
  180|    193|        }
  181|    499|    }
  182|       |
  183|    306|    if (fr_c->num_cons != i) {
  ------------------
  |  Branch (183:9): [True: 119, False: 187]
  ------------------
  184|    119|        fr_c->num_cons = i;
  185|    119|        realloc_friendconns(fr_c, fr_c->num_cons);
  186|    119|    }
  187|       |
  188|    306|    return 0;
  189|    306|}

set_nospam:
   42|  2.67k|{
   43|  2.67k|    fr->nospam = num;
   44|  2.67k|}
get_nospam:
   47|  1.50k|{
   48|  1.50k|    return fr->nospam;
   49|  1.50k|}
callback_friendrequest:
   54|  2.14k|{
   55|  2.14k|    fr->handle_friendrequest = function;
   56|  2.14k|    fr->handle_friendrequest_isset = 1;
   57|  2.14k|    fr->handle_friendrequest_object = object;
   58|  2.14k|}
set_filter_function:
   64|  2.14k|{
   65|  2.14k|    fr->filter_function = function;
   66|  2.14k|    fr->filter_function_userdata = userdata;
   67|  2.14k|}
remove_request_received:
  104|     18|{
  105|    594|    for (uint32_t i = 0; i < MAX_RECEIVED_STORED; ++i) {
  ------------------
  |  |   21|    594|#define MAX_RECEIVED_STORED 32
  ------------------
  |  Branch (105:26): [True: 576, False: 18]
  ------------------
  106|    576|        if (pk_equal(fr->received.requests[i], real_pk)) {
  ------------------
  |  Branch (106:13): [True: 0, False: 576]
  ------------------
  107|      0|            crypto_memzero(fr->received.requests[i], CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  108|      0|            return 0;
  109|      0|        }
  110|    576|    }
  111|       |
  112|     18|    return -1;
  113|     18|}
friendreq_init:
  159|  2.14k|{
  160|  2.14k|    set_friend_request_callback(fr_c, &friendreq_handlepacket, fr);
  161|  2.14k|}
friendreq_new:
  164|  2.14k|{
  165|  2.14k|    return (Friend_Requests *)calloc(1, sizeof(Friend_Requests));
  166|  2.14k|}
friendreq_kill:
  169|  2.14k|{
  170|  2.14k|    free(fr);
  171|  2.14k|}

del_groupchat:
 1356|  1.36k|{
 1357|  1.36k|    Group_c *g = get_group_c(g_c, groupnumber);
 1358|       |
 1359|  1.36k|    if (g == nullptr) {
  ------------------
  |  |   66|  1.36k|#define nullptr NULL
  ------------------
  |  Branch (1359:9): [True: 0, False: 1.36k]
  ------------------
 1360|      0|        return false;
 1361|      0|    }
 1362|       |
 1363|  1.36k|    group_leave(g_c, groupnumber, leave_permanently);
 1364|       |
 1365|  23.2k|    for (uint32_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
  ------------------
  |  |   46|  23.2k|#define MAX_GROUP_CONNECTIONS 16
  ------------------
  |  Branch (1365:26): [True: 21.8k, False: 1.36k]
  ------------------
 1366|  21.8k|        if (g->connections[i].type == GROUPCHAT_CONNECTION_NONE) {
  ------------------
  |  Branch (1366:13): [True: 21.8k, False: 0]
  ------------------
 1367|  21.8k|            continue;
 1368|  21.8k|        }
 1369|       |
 1370|      0|        g->connections[i].type = GROUPCHAT_CONNECTION_NONE;
 1371|      0|        kill_friend_connection(g_c->fr_c, g->connections[i].number);
 1372|      0|    }
 1373|       |
 1374|  2.73k|    for (uint32_t i = 0; i < g->numpeers; ++i) {
  ------------------
  |  Branch (1374:26): [True: 1.36k, False: 1.36k]
  ------------------
 1375|  1.36k|        if (g->peer_on_leave != nullptr) {
  ------------------
  |  |   66|  1.36k|#define nullptr NULL
  ------------------
  |  Branch (1375:13): [True: 0, False: 1.36k]
  ------------------
 1376|      0|            g->peer_on_leave(g->object, groupnumber, g->group[i].object);
 1377|      0|        }
 1378|  1.36k|    }
 1379|       |
 1380|  1.36k|    if (g->group_on_delete != nullptr) {
  ------------------
  |  |   66|  1.36k|#define nullptr NULL
  ------------------
  |  Branch (1380:9): [True: 0, False: 1.36k]
  ------------------
 1381|      0|        g->group_on_delete(g->object, groupnumber);
 1382|      0|    }
 1383|       |
 1384|  1.36k|    return wipe_group_chat(g_c, groupnumber);
 1385|  1.36k|}
g_callback_group_invite:
 1828|  1.50k|{
 1829|  1.50k|    g_c->invite_callback = function;
 1830|  1.50k|}
g_callback_group_connected:
 1834|  1.50k|{
 1835|  1.50k|    g_c->connected_callback = function;
 1836|  1.50k|}
g_callback_group_message:
 1840|  1.50k|{
 1841|  1.50k|    g_c->message_callback = function;
 1842|  1.50k|}
g_callback_peer_name:
 1849|  1.50k|{
 1850|  1.50k|    g_c->peer_name_callback = function;
 1851|  1.50k|}
g_callback_peer_list_changed:
 1858|  1.50k|{
 1859|  1.50k|    g_c->peer_list_changed_callback = function;
 1860|  1.50k|}
g_callback_group_title:
 1864|  1.50k|{
 1865|  1.50k|    g_c->title_callback = function;
 1866|  1.50k|}
conferences_size:
 3532|  3.01k|{
 3533|  3.01k|    return 2 * sizeof(uint32_t) + conferences_section_size(g_c);
 3534|  3.01k|}
conferences_save:
 3537|  1.50k|{
 3538|  1.50k|    const uint32_t len = conferences_section_size(g_c);
 3539|  1.50k|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_CONFERENCES);
  ------------------
  |  |   28|  1.50k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3540|       |
 3541|  2.58k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3541:26): [True: 1.08k, False: 1.50k]
  ------------------
 3542|  1.08k|        const Group_c *g = get_group_c(g_c, i);
 3543|       |
 3544|  1.08k|        if (g == nullptr || g->status != GROUPCHAT_STATUS_CONNECTED) {
  ------------------
  |  |   66|  2.16k|#define nullptr NULL
  ------------------
  |  Branch (3544:13): [True: 0, False: 1.08k]
  |  Branch (3544:29): [True: 0, False: 1.08k]
  ------------------
 3545|      0|            continue;
 3546|      0|        }
 3547|       |
 3548|  1.08k|        data = save_conf(g, data);
 3549|  1.08k|    }
 3550|       |
 3551|  1.50k|    return data;
 3552|  1.50k|}
conferences_load_state_section:
 3744|    803|{
 3745|    803|    if (type != STATE_TYPE_CONFERENCES) {
  ------------------
  |  Branch (3745:9): [True: 516, False: 287]
  ------------------
 3746|    516|        return false;
 3747|    516|    }
 3748|       |
 3749|    287|    *status = load_conferences(g_c, data, length);
 3750|    287|    return true;
 3751|    803|}
new_groupchats:
 3756|  2.14k|{
 3757|  2.14k|    if (m == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3757:9): [True: 0, False: 2.14k]
  ------------------
 3758|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3759|      0|    }
 3760|       |
 3761|  2.14k|    Group_Chats *temp = (Group_Chats *)calloc(1, sizeof(Group_Chats));
 3762|       |
 3763|  2.14k|    if (temp == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3763:9): [True: 0, False: 2.14k]
  ------------------
 3764|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3765|      0|    }
 3766|       |
 3767|  2.14k|    temp->mono_time = mono_time;
 3768|  2.14k|    temp->m = m;
 3769|  2.14k|    temp->fr_c = m->fr_c;
 3770|  2.14k|    m->conferences_object = temp;
 3771|  2.14k|    m_callback_conference_invite(m, &handle_friend_invite_packet);
 3772|       |
 3773|  2.14k|    set_global_status_callback(m->fr_c, &g_handle_any_status, temp);
 3774|       |
 3775|  2.14k|    return temp;
 3776|  2.14k|}
kill_groupchats:
 3806|  2.14k|{
 3807|  2.14k|    if (g_c == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3807:9): [True: 0, False: 2.14k]
  ------------------
 3808|      0|        return;
 3809|      0|    }
 3810|       |
 3811|  3.50k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3811:26): [True: 1.36k, False: 2.14k]
  ------------------
 3812|  1.36k|        del_groupchat(g_c, i, false);
 3813|  1.36k|    }
 3814|       |
 3815|  2.14k|    m_callback_conference_invite(g_c->m, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 3816|  2.14k|    set_global_status_callback(g_c->m->fr_c, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  set_global_status_callback(g_c->m->fr_c, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 3817|  2.14k|    g_c->m->conferences_object = nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 3818|  2.14k|    free(g_c);
 3819|  2.14k|}
group.c:create_group_chat:
  277|  1.91k|{
  278|  79.0k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (278:26): [True: 77.1k, False: 1.91k]
  ------------------
  279|  77.1k|        if (g_c->chats[i].status == GROUPCHAT_STATUS_NONE) {
  ------------------
  |  Branch (279:13): [True: 0, False: 77.1k]
  ------------------
  280|      0|            return i;
  281|      0|        }
  282|  77.1k|    }
  283|       |
  284|  1.91k|    if (realloc_conferences(g_c, g_c->num_chats + 1)) {
  ------------------
  |  Branch (284:9): [True: 1.91k, False: 0]
  ------------------
  285|  1.91k|        const uint16_t id = g_c->num_chats;
  286|  1.91k|        ++g_c->num_chats;
  287|  1.91k|        setup_conference(&g_c->chats[id]);
  288|  1.91k|        return id;
  289|  1.91k|    }
  290|       |
  291|      0|    return -1;
  292|  1.91k|}
group.c:realloc_conferences:
  246|  2.03k|{
  247|  2.03k|    if (num == 0) {
  ------------------
  |  Branch (247:9): [True: 95, False: 1.94k]
  ------------------
  248|     95|        free(g_c->chats);
  249|     95|        g_c->chats = nullptr;
  ------------------
  |  |   66|     95|#define nullptr NULL
  ------------------
  250|     95|        return true;
  251|     95|    }
  252|       |
  253|  1.94k|    Group_c *newgroup_chats = (Group_c *)realloc(g_c->chats, num * sizeof(Group_c));
  254|       |
  255|  1.94k|    if (newgroup_chats == nullptr) {
  ------------------
  |  |   66|  1.94k|#define nullptr NULL
  ------------------
  |  Branch (255:9): [True: 0, False: 1.94k]
  ------------------
  256|      0|        return false;
  257|      0|    }
  258|       |
  259|  1.94k|    g_c->chats = newgroup_chats;
  260|  1.94k|    return true;
  261|  1.94k|}
group.c:setup_conference:
  265|  3.83k|{
  266|  3.83k|    *g = empty_group_c;
  267|  3.83k|    g->maxfrozen = MAX_FROZEN_DEFAULT;
  ------------------
  |  |   51|  3.83k|#define MAX_FROZEN_DEFAULT 128
  ------------------
  268|  3.83k|}
group.c:addpeer:
  792|  1.87k|{
  793|  1.87k|    Group_c *g = get_group_c(g_c, groupnumber);
  794|       |
  795|  1.87k|    if (g == nullptr) {
  ------------------
  |  |   66|  1.87k|#define nullptr NULL
  ------------------
  |  Branch (795:9): [True: 0, False: 1.87k]
  ------------------
  796|      0|        return -1;
  797|      0|    }
  798|       |
  799|  1.87k|    const int peer_index = fresh ?
  ------------------
  |  Branch (799:28): [True: 1.87k, False: 0]
  ------------------
  800|  1.87k|                           note_peer_active(g_c, groupnumber, peer_number, userdata) :
  801|  1.87k|                           get_peer_index(g, peer_number);
  802|       |
  803|  1.87k|    if (peer_index != -1) {
  ------------------
  |  Branch (803:9): [True: 56, False: 1.82k]
  ------------------
  804|     56|        if (!pk_equal(g->group[peer_index].real_pk, real_pk)) {
  ------------------
  |  Branch (804:13): [True: 6, False: 50]
  ------------------
  805|      6|            LOGGER_ERROR(g_c->m->log, "peer public key is incorrect for peer %d", peer_number);
  ------------------
  |  |   83|      6|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      6|    do {                                                                         \
  |  |  |  |   73|      6|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     12|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      6|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      6|        }                                                                        \
  |  |  |  |   76|      6|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  806|      6|            return -1;
  807|      6|        }
  808|       |
  809|     50|        if (fresh || !g->group[peer_index].temp_pk_updated) {
  ------------------
  |  Branch (809:13): [True: 50, False: 0]
  |  Branch (809:22): [True: 0, False: 0]
  ------------------
  810|     50|            pk_copy(g->group[peer_index].temp_pk, temp_pk);
  811|     50|            g->group[peer_index].temp_pk_updated = true;
  812|     50|        }
  813|       |
  814|     50|        return peer_index;
  815|     56|    }
  816|       |
  817|  1.82k|    if (!fresh) {
  ------------------
  |  Branch (817:9): [True: 0, False: 1.82k]
  ------------------
  818|      0|        const int frozen_index = get_frozen_index(g, peer_number);
  819|       |
  820|      0|        if (frozen_index != -1) {
  ------------------
  |  Branch (820:13): [True: 0, False: 0]
  ------------------
  821|      0|            if (!pk_equal(g->frozen[frozen_index].real_pk, real_pk)) {
  ------------------
  |  Branch (821:17): [True: 0, False: 0]
  ------------------
  822|      0|                return -1;
  823|      0|            }
  824|       |
  825|      0|            pk_copy(g->frozen[frozen_index].temp_pk, temp_pk);
  826|       |
  827|      0|            return -1;
  828|      0|        }
  829|      0|    }
  830|       |
  831|  1.82k|    delete_any_peer_with_pk(g_c, groupnumber, real_pk, userdata);
  832|       |
  833|  1.82k|    Group_Peer *temp = (Group_Peer *)realloc(g->group, sizeof(Group_Peer) * (g->numpeers + 1));
  834|       |
  835|  1.82k|    if (temp == nullptr) {
  ------------------
  |  |   66|  1.82k|#define nullptr NULL
  ------------------
  |  Branch (835:9): [True: 0, False: 1.82k]
  ------------------
  836|      0|        return -1;
  837|      0|    }
  838|       |
  839|  1.82k|    temp[g->numpeers] = empty_group_peer;
  840|  1.82k|    g->group = temp;
  841|       |
  842|  1.82k|    const uint32_t new_index = g->numpeers;
  843|       |
  844|  1.82k|    pk_copy(g->group[new_index].real_pk, real_pk);
  845|  1.82k|    pk_copy(g->group[new_index].temp_pk, temp_pk);
  846|  1.82k|    g->group[new_index].temp_pk_updated = true;
  847|  1.82k|    g->group[new_index].peer_number = peer_number;
  848|  1.82k|    g->group[new_index].last_active = mono_time_get(g_c->mono_time);
  849|  1.82k|    g->group[new_index].is_friend = getfriend_id(g_c->m, real_pk) != -1;
  850|  1.82k|    ++g->numpeers;
  851|       |
  852|  1.82k|    add_to_closest(g, real_pk, temp_pk);
  853|       |
  854|  1.82k|    if (do_gc_callback && g_c->peer_list_changed_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (854:9): [True: 0, False: 1.82k]
  |  Branch (854:27): [True: 0, False: 0]
  ------------------
  855|      0|        g_c->peer_list_changed_callback(g_c->m, groupnumber, userdata);
  856|      0|    }
  857|       |
  858|  1.82k|    if (g->peer_on_join != nullptr) {
  ------------------
  |  |   66|  1.82k|#define nullptr NULL
  ------------------
  |  Branch (858:9): [True: 0, False: 1.82k]
  ------------------
  859|      0|        g->peer_on_join(g->object, groupnumber, new_index);
  860|      0|    }
  861|       |
  862|  1.82k|    return new_index;
  863|  1.82k|}
group.c:note_peer_active:
  698|  1.87k|{
  699|  1.87k|    Group_c *g = get_group_c(g_c, groupnumber);
  700|       |
  701|  1.87k|    if (g == nullptr) {
  ------------------
  |  |   66|  1.87k|#define nullptr NULL
  ------------------
  |  Branch (701:9): [True: 0, False: 1.87k]
  ------------------
  702|      0|        return -1;
  703|      0|    }
  704|       |
  705|  1.87k|    const int peer_index = get_peer_index(g, peer_number);
  706|       |
  707|  1.87k|    if (peer_index != -1) {
  ------------------
  |  Branch (707:9): [True: 0, False: 1.87k]
  ------------------
  708|      0|        g->group[peer_index].last_active = mono_time_get(g_c->mono_time);
  709|      0|        return peer_index;
  710|      0|    }
  711|       |
  712|  1.87k|    const int frozen_index = get_frozen_index(g, peer_number);
  713|       |
  714|  1.87k|    if (frozen_index == -1) {
  ------------------
  |  Branch (714:9): [True: 1.82k, False: 56]
  ------------------
  715|  1.82k|        return -1;
  716|  1.82k|    }
  717|       |
  718|       |    /* Now thaw the peer */
  719|       |
  720|     56|    Group_Peer *temp = (Group_Peer *)realloc(g->group, sizeof(Group_Peer) * (g->numpeers + 1));
  721|       |
  722|     56|    if (temp == nullptr) {
  ------------------
  |  |   66|     56|#define nullptr NULL
  ------------------
  |  Branch (722:9): [True: 0, False: 56]
  ------------------
  723|      0|        return -1;
  724|      0|    }
  725|       |
  726|     56|    const uint32_t thawed_index = g->numpeers;
  727|       |
  728|     56|    g->group = temp;
  729|     56|    g->group[thawed_index] = g->frozen[frozen_index];
  730|     56|    g->group[thawed_index].temp_pk_updated = false;
  731|     56|    g->group[thawed_index].last_active = mono_time_get(g_c->mono_time);
  732|       |
  733|     56|    add_to_closest(g, g->group[thawed_index].real_pk, g->group[thawed_index].temp_pk);
  734|       |
  735|     56|    ++g->numpeers;
  736|       |
  737|     56|    delete_frozen(g, frozen_index);
  738|       |
  739|     56|    if (g_c->peer_list_changed_callback != nullptr) {
  ------------------
  |  |   66|     56|#define nullptr NULL
  ------------------
  |  Branch (739:9): [True: 0, False: 56]
  ------------------
  740|      0|        g_c->peer_list_changed_callback(g_c->m, groupnumber, userdata);
  741|      0|    }
  742|       |
  743|     56|    if (g->peer_on_join != nullptr) {
  ------------------
  |  |   66|     56|#define nullptr NULL
  ------------------
  |  Branch (743:9): [True: 0, False: 56]
  ------------------
  744|      0|        g->peer_on_join(g->object, groupnumber, thawed_index);
  745|      0|    }
  746|       |
  747|     56|    g->need_send_name = true;
  748|       |
  749|     56|    return thawed_index;
  750|     56|}
group.c:delete_frozen:
  664|     91|{
  665|     91|    if (frozen_index >= g->numfrozen) {
  ------------------
  |  Branch (665:9): [True: 0, False: 91]
  ------------------
  666|      0|        return false;
  667|      0|    }
  668|       |
  669|     91|    --g->numfrozen;
  670|       |
  671|     91|    if (g->numfrozen == 0) {
  ------------------
  |  Branch (671:9): [True: 72, False: 19]
  ------------------
  672|     72|        free(g->frozen);
  673|     72|        g->frozen = nullptr;
  ------------------
  |  |   66|     72|#define nullptr NULL
  ------------------
  674|     72|    } else {
  675|     19|        if (g->numfrozen != frozen_index) {
  ------------------
  |  Branch (675:13): [True: 16, False: 3]
  ------------------
  676|     16|            g->frozen[frozen_index] = g->frozen[g->numfrozen];
  677|     16|        }
  678|       |
  679|     19|        Group_Peer *const frozen_temp = (Group_Peer *)realloc(g->frozen, sizeof(Group_Peer) * g->numfrozen);
  680|       |
  681|     19|        if (frozen_temp == nullptr) {
  ------------------
  |  |   66|     19|#define nullptr NULL
  ------------------
  |  Branch (681:13): [True: 0, False: 19]
  ------------------
  682|      0|            return false;
  683|      0|        }
  684|       |
  685|     19|        g->frozen = frozen_temp;
  686|     19|    }
  687|       |
  688|     91|    return true;
  689|     91|}
group.c:get_peer_index:
  414|  1.87k|{
  415|  1.87k|    for (uint32_t i = 0; i < g->numpeers; ++i) {
  ------------------
  |  Branch (415:26): [True: 0, False: 1.87k]
  ------------------
  416|      0|        if (g->group[i].peer_number == peer_number) {
  ------------------
  |  Branch (416:13): [True: 0, False: 0]
  ------------------
  417|      0|            return i;
  418|      0|        }
  419|      0|    }
  420|       |
  421|  1.87k|    return -1;
  422|  1.87k|}
group.c:get_frozen_index:
  652|  1.87k|{
  653|  2.20k|    for (uint32_t i = 0; i < g->numfrozen; ++i) {
  ------------------
  |  Branch (653:26): [True: 384, False: 1.82k]
  ------------------
  654|    384|        if (g->frozen[i].peer_number == peer_number) {
  ------------------
  |  Branch (654:13): [True: 56, False: 328]
  ------------------
  655|     56|            return i;
  656|     56|        }
  657|    384|    }
  658|       |
  659|  1.82k|    return -1;
  660|  1.87k|}
group.c:delete_any_peer_with_pk:
  757|  1.82k|{
  758|  1.82k|    Group_c *g = get_group_c(g_c, groupnumber);
  759|       |
  760|  1.82k|    if (g == nullptr) {
  ------------------
  |  |   66|  1.82k|#define nullptr NULL
  ------------------
  |  Branch (760:9): [True: 0, False: 1.82k]
  ------------------
  761|      0|        return;
  762|      0|    }
  763|       |
  764|  1.82k|    const int peer_index = peer_in_group(g, real_pk);
  765|       |
  766|  1.82k|    if (peer_index >= 0) {
  ------------------
  |  Branch (766:9): [True: 0, False: 1.82k]
  ------------------
  767|      0|        delpeer(g_c, groupnumber, peer_index, userdata);
  768|      0|    }
  769|       |
  770|  1.82k|    const int frozen_index = frozen_in_group(g, real_pk);
  771|       |
  772|  1.82k|    if (frozen_index >= 0) {
  ------------------
  |  Branch (772:9): [True: 35, False: 1.78k]
  ------------------
  773|     35|        delete_frozen(g, frozen_index);
  774|     35|    }
  775|  1.82k|}
group.c:peer_in_group:
  351|  1.82k|{
  352|  1.82k|    for (uint32_t i = 0; i < g->numpeers; ++i) {
  ------------------
  |  Branch (352:26): [True: 0, False: 1.82k]
  ------------------
  353|      0|        if (pk_equal(g->group[i].real_pk, real_pk)) {
  ------------------
  |  Branch (353:13): [True: 0, False: 0]
  ------------------
  354|      0|            return i;
  355|      0|        }
  356|      0|    }
  357|       |
  358|  1.82k|    return -1;
  359|  1.82k|}
group.c:frozen_in_group:
  363|  1.82k|{
  364|  1.96k|    for (uint32_t i = 0; i < g->numfrozen; ++i) {
  ------------------
  |  Branch (364:26): [True: 182, False: 1.78k]
  ------------------
  365|    182|        if (pk_equal(g->frozen[i].real_pk, real_pk)) {
  ------------------
  |  Branch (365:13): [True: 35, False: 147]
  ------------------
  366|     35|            return i;
  367|     35|        }
  368|    182|    }
  369|       |
  370|  1.78k|    return -1;
  371|  1.82k|}
group.c:add_to_closest:
  447|  1.87k|{
  448|  1.87k|    if (pk_equal(g->real_pk, real_pk)) {
  ------------------
  |  Branch (448:9): [True: 1.87k, False: 6]
  ------------------
  449|  1.87k|        return false;
  450|  1.87k|    }
  451|       |
  452|      6|    unsigned int index = DESIRED_CLOSEST;
  ------------------
  |  |   45|      6|#define DESIRED_CLOSEST 4
  ------------------
  453|       |
  454|     30|    for (unsigned int i = 0; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   45|     30|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (454:30): [True: 24, False: 6]
  ------------------
  455|     24|        if (g->closest_peers[i].active && pk_equal(real_pk, g->closest_peers[i].real_pk)) {
  ------------------
  |  Branch (455:13): [True: 0, False: 24]
  |  Branch (455:43): [True: 0, False: 0]
  ------------------
  456|      0|            return true;
  457|      0|        }
  458|     24|    }
  459|       |
  460|      6|    for (unsigned int i = 0; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   45|      6|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (460:30): [True: 6, False: 0]
  ------------------
  461|      6|        if (!g->closest_peers[i].active) {
  ------------------
  |  Branch (461:13): [True: 6, False: 0]
  ------------------
  462|      6|            index = i;
  463|      6|            break;
  464|      6|        }
  465|      6|    }
  466|       |
  467|      6|    if (index == DESIRED_CLOSEST) {
  ------------------
  |  |   45|      6|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (467:9): [True: 0, False: 6]
  ------------------
  468|      0|        uint64_t comp_val = calculate_comp_value(g->real_pk, real_pk);
  469|      0|        uint64_t comp_d = 0;
  470|       |
  471|      0|        for (unsigned int i = 0; i < (DESIRED_CLOSEST / 2); ++i) {
  ------------------
  |  |   45|      0|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (471:34): [True: 0, False: 0]
  ------------------
  472|      0|            const uint64_t comp = calculate_comp_value(g->real_pk, g->closest_peers[i].real_pk);
  473|       |
  474|      0|            if (comp > comp_val && comp > comp_d) {
  ------------------
  |  Branch (474:17): [True: 0, False: 0]
  |  Branch (474:36): [True: 0, False: 0]
  ------------------
  475|      0|                index = i;
  476|      0|                comp_d = comp;
  477|      0|            }
  478|      0|        }
  479|       |
  480|      0|        comp_val = calculate_comp_value(real_pk, g->real_pk);
  481|       |
  482|      0|        for (unsigned int i = DESIRED_CLOSEST / 2; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   45|      0|#define DESIRED_CLOSEST 4
  ------------------
                      for (unsigned int i = DESIRED_CLOSEST / 2; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   45|      0|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (482:52): [True: 0, False: 0]
  ------------------
  483|      0|            uint64_t comp = calculate_comp_value(g->closest_peers[i].real_pk, g->real_pk);
  484|       |
  485|      0|            if (comp > comp_val && comp > comp_d) {
  ------------------
  |  Branch (485:17): [True: 0, False: 0]
  |  Branch (485:36): [True: 0, False: 0]
  ------------------
  486|      0|                index = i;
  487|      0|                comp_d = comp;
  488|      0|            }
  489|      0|        }
  490|      0|    }
  491|       |
  492|      6|    if (index == DESIRED_CLOSEST) {
  ------------------
  |  |   45|      6|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (492:9): [True: 0, False: 6]
  ------------------
  493|      0|        return false;
  494|      0|    }
  495|       |
  496|      6|    uint8_t old_real_pk[CRYPTO_PUBLIC_KEY_SIZE];
  497|      6|    uint8_t old_temp_pk[CRYPTO_PUBLIC_KEY_SIZE];
  498|      6|    bool old = false;
  499|       |
  500|      6|    if (g->closest_peers[index].active) {
  ------------------
  |  Branch (500:9): [True: 0, False: 6]
  ------------------
  501|      0|        memcpy(old_real_pk, g->closest_peers[index].real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  502|      0|        memcpy(old_temp_pk, g->closest_peers[index].temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  503|      0|        old = true;
  504|      0|    }
  505|       |
  506|      6|    g->closest_peers[index].active = true;
  507|      6|    memcpy(g->closest_peers[index].real_pk, real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  508|      6|    memcpy(g->closest_peers[index].temp_pk, temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|      6|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  509|       |
  510|      6|    if (old) {
  ------------------
  |  Branch (510:9): [True: 0, False: 6]
  ------------------
  511|      0|        add_to_closest(g, old_real_pk, old_temp_pk);
  512|      0|    }
  513|       |
  514|      6|    if (g->changed == GROUPCHAT_CLOSEST_CHANGE_NONE) {
  ------------------
  |  Branch (514:9): [True: 6, False: 0]
  ------------------
  515|      6|        g->changed = GROUPCHAT_CLOSEST_CHANGE_ADDED;
  516|      6|    }
  517|       |
  518|      6|    return true;
  519|      6|}
group.c:setnick:
 1050|  1.87k|{
 1051|  1.87k|    if (nick_len > MAX_NAME_LENGTH) {
  ------------------
  |  |   24|  1.87k|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (1051:9): [True: 0, False: 1.87k]
  ------------------
 1052|      0|        return false;
 1053|      0|    }
 1054|       |
 1055|  1.87k|    Group_c *g = get_group_c(g_c, groupnumber);
 1056|       |
 1057|  1.87k|    if (g == nullptr) {
  ------------------
  |  |   66|  1.87k|#define nullptr NULL
  ------------------
  |  Branch (1057:9): [True: 0, False: 1.87k]
  ------------------
 1058|      0|        return false;
 1059|      0|    }
 1060|       |
 1061|  1.87k|    g->group[peer_index].nick_updated = true;
 1062|       |
 1063|  1.87k|    if (g_peer_nick_eq(&g->group[peer_index], nick, nick_len)) {
  ------------------
  |  Branch (1063:9): [True: 1.60k, False: 269]
  ------------------
 1064|       |        /* same name as already stored */
 1065|  1.60k|        return true;
 1066|  1.60k|    }
 1067|       |
 1068|    269|    if (nick_len > 0) {
  ------------------
  |  Branch (1068:9): [True: 220, False: 49]
  ------------------
 1069|    220|        memcpy(g->group[peer_index].nick, nick, nick_len);
 1070|    220|    }
 1071|       |
 1072|    269|    g->group[peer_index].nick_len = nick_len;
 1073|       |
 1074|    269|    if (do_gc_callback && g_c->peer_name_callback != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1074:9): [True: 0, False: 269]
  |  Branch (1074:27): [True: 0, False: 0]
  ------------------
 1075|      0|        g_c->peer_name_callback(g_c->m, groupnumber, peer_index, nick, nick_len, userdata);
 1076|      0|    }
 1077|       |
 1078|    269|    return true;
 1079|  1.87k|}
group.c:g_peer_nick_eq:
  222|  1.87k|{
  223|  1.87k|    return memeq(peer->nick, peer->nick_len, nick, nick_len);
  224|  1.87k|}
group.c:get_group_c:
  333|  15.8k|{
  334|  15.8k|    if (!is_groupnumber_valid(g_c, groupnumber)) {
  ------------------
  |  Branch (334:9): [True: 0, False: 15.8k]
  ------------------
  335|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  336|      0|    }
  337|       |
  338|  15.8k|    return &g_c->chats[groupnumber];
  339|  15.8k|}
group.c:is_groupnumber_valid:
  232|  15.8k|{
  233|  15.8k|    return groupnumber < g_c->num_chats
  ------------------
  |  Branch (233:12): [True: 15.8k, False: 0]
  ------------------
  234|  15.8k|           && g_c->chats != nullptr
  ------------------
  |  |   66|  31.7k|#define nullptr NULL
  ------------------
  |  Branch (234:15): [True: 15.8k, False: 0]
  ------------------
  235|  15.8k|           && g_c->chats[groupnumber].status != GROUPCHAT_STATUS_NONE;
  ------------------
  |  Branch (235:15): [True: 15.8k, False: 0]
  ------------------
  236|  15.8k|}
group.c:wipe_group_chat:
  308|  1.91k|{
  309|  1.91k|    if (groupnumber >= g_c->num_chats || g_c->chats == nullptr) {
  ------------------
  |  |   66|  1.91k|#define nullptr NULL
  ------------------
  |  Branch (309:9): [True: 0, False: 1.91k]
  |  Branch (309:42): [True: 0, False: 1.91k]
  ------------------
  310|      0|        return false;
  311|      0|    }
  312|       |
  313|  1.91k|    wipe_group_c(&g_c->chats[groupnumber]);
  314|       |
  315|  1.91k|    uint16_t i;
  316|       |
  317|  3.83k|    for (i = g_c->num_chats; i != 0; --i) {
  ------------------
  |  Branch (317:30): [True: 3.73k, False: 95]
  ------------------
  318|  3.73k|        if (g_c->chats[i - 1].status != GROUPCHAT_STATUS_NONE) {
  ------------------
  |  Branch (318:13): [True: 1.82k, False: 1.91k]
  ------------------
  319|  1.82k|            break;
  320|  1.82k|        }
  321|  3.73k|    }
  322|       |
  323|  1.91k|    if (g_c->num_chats != i) {
  ------------------
  |  Branch (323:9): [True: 119, False: 1.79k]
  ------------------
  324|    119|        g_c->num_chats = i;
  325|    119|        realloc_conferences(g_c, g_c->num_chats);
  326|    119|    }
  327|       |
  328|  1.91k|    return true;
  329|  1.91k|}
group.c:wipe_group_c:
  296|  1.91k|{
  297|  1.91k|    free(g->frozen);
  298|  1.91k|    free(g->group);
  299|  1.91k|    crypto_memzero(g, sizeof(Group_c));
  300|  1.91k|}
group.c:count_connected:
 2256|  1.36k|{
 2257|  1.36k|    unsigned int count = 0;
 2258|       |
 2259|  23.2k|    for (unsigned int i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
  ------------------
  |  |   46|  23.2k|#define MAX_GROUP_CONNECTIONS 16
  ------------------
  |  Branch (2259:30): [True: 21.8k, False: 1.36k]
  ------------------
 2260|  21.8k|        if (g->connections[i].type == GROUPCHAT_CONNECTION_ONLINE) {
  ------------------
  |  Branch (2260:13): [True: 0, False: 21.8k]
  ------------------
 2261|      0|            ++count;
 2262|      0|        }
 2263|  21.8k|    }
 2264|       |
 2265|  1.36k|    return count;
 2266|  1.36k|}
group.c:group_leave:
 1994|  1.36k|{
 1995|  1.36k|    const Group_c *g = get_group_c(g_c, groupnumber);
 1996|       |
 1997|  1.36k|    if (g == nullptr) {
  ------------------
  |  |   66|  1.36k|#define nullptr NULL
  ------------------
  |  Branch (1997:9): [True: 0, False: 1.36k]
  ------------------
 1998|      0|        return false;
 1999|      0|    }
 2000|       |
 2001|  1.36k|    if (permanent) {
  ------------------
  |  Branch (2001:9): [True: 0, False: 1.36k]
  ------------------
 2002|      0|        return group_kill_peer_send(g_c, groupnumber, g->peer_number);
 2003|  1.36k|    } else {
 2004|  1.36k|        return group_freeze_peer_send(g_c, groupnumber, g->peer_number);
 2005|  1.36k|    }
 2006|  1.36k|}
group.c:group_freeze_peer_send:
 1968|  1.36k|{
 1969|  1.36k|    uint8_t packet[GROUP_MESSAGE_KILL_PEER_LENGTH];
 1970|       |
 1971|  1.36k|    peer_num = net_htons(peer_num);
 1972|  1.36k|    memcpy(packet, &peer_num, sizeof(uint16_t));
 1973|       |
 1974|  1.36k|    return send_message_group(g_c, groupnumber, GROUP_MESSAGE_FREEZE_PEER_ID, packet, sizeof(packet)) > 0;
 1975|  1.36k|}
group.c:send_message_group:
 2675|  1.36k|{
 2676|  1.36k|    assert(len == 0 || data != nullptr);
 2677|      0|    Group_c *g = get_group_c(g_c, groupnumber);
 2678|       |
 2679|  1.36k|    if (g == nullptr) {
  ------------------
  |  |   66|  1.36k|#define nullptr NULL
  ------------------
  |  Branch (2679:9): [True: 0, False: 1.36k]
  ------------------
 2680|      0|        return -1;
 2681|      0|    }
 2682|       |
 2683|  1.36k|    if (len > MAX_GROUP_MESSAGE_DATA_LEN) {
  ------------------
  |  |  177|  1.36k|#define MAX_GROUP_MESSAGE_DATA_LEN (MAX_CRYPTO_DATA_SIZE - (1 + MIN_MESSAGE_PACKET_LEN))
  |  |  ------------------
  |  |  |  |   85|  1.36k|#define MAX_CRYPTO_DATA_SIZE (uint16_t)(MAX_CRYPTO_PACKET_SIZE - CRYPTO_DATA_PACKET_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   80|  1.36k|#define MAX_CRYPTO_PACKET_SIZE (uint16_t)1400
  |  |  |  |  ------------------
  |  |  |  |               #define MAX_CRYPTO_DATA_SIZE (uint16_t)(MAX_CRYPTO_PACKET_SIZE - CRYPTO_DATA_PACKET_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   82|  1.36k|#define CRYPTO_DATA_PACKET_MIN_SIZE (uint16_t)(1 + sizeof(uint16_t) + (sizeof(uint32_t) + sizeof(uint32_t)) + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   61|  1.36k|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define MAX_GROUP_MESSAGE_DATA_LEN (MAX_CRYPTO_DATA_SIZE - (1 + MIN_MESSAGE_PACKET_LEN))
  |  |  ------------------
  |  |  |  |  198|  1.36k|#define MIN_MESSAGE_PACKET_LEN (sizeof(uint16_t) * 2 + sizeof(uint32_t) + 1)
  |  |  ------------------
  ------------------
  |  Branch (2683:9): [True: 0, False: 1.36k]
  ------------------
 2684|      0|        return -2;
 2685|      0|    }
 2686|       |
 2687|  1.36k|    if (g->status != GROUPCHAT_STATUS_CONNECTED || count_connected(g) == 0) {
  ------------------
  |  Branch (2687:9): [True: 0, False: 1.36k]
  |  Branch (2687:52): [True: 1.36k, False: 0]
  ------------------
 2688|  1.36k|        return -3;
 2689|  1.36k|    }
 2690|       |
 2691|      0|    VLA(uint8_t, packet, sizeof(uint16_t) + sizeof(uint32_t) + 1 + len);
  ------------------
  |  |   62|      0|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      0|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 2692|      0|    const uint16_t peer_num = net_htons(g->peer_number);
 2693|      0|    memcpy(packet, &peer_num, sizeof(peer_num));
 2694|       |
 2695|      0|    ++g->message_number;
 2696|       |
 2697|      0|    if (g->message_number == 0) {
  ------------------
  |  Branch (2697:9): [True: 0, False: 0]
  ------------------
 2698|      0|        ++g->message_number;
 2699|      0|    }
 2700|       |
 2701|      0|    const uint32_t message_num = net_htonl(g->message_number);
 2702|      0|    memcpy(packet + sizeof(uint16_t), &message_num, sizeof(message_num));
 2703|       |
 2704|      0|    packet[sizeof(uint16_t) + sizeof(uint32_t)] = message_id;
 2705|       |
 2706|      0|    if (len != 0) {
  ------------------
  |  Branch (2706:9): [True: 0, False: 0]
  ------------------
 2707|      0|        memcpy(packet + sizeof(uint16_t) + sizeof(uint32_t) + 1, data, len);
 2708|      0|    }
 2709|       |
 2710|      0|    const unsigned int ret = send_message_all_connections(g_c, g, packet, SIZEOF_VLA(packet), -1);
  ------------------
  |  |   29|      0|#define SIZEOF_VLA sizeof
  ------------------
 2711|       |
 2712|      0|    if (ret == 0) {
  ------------------
  |  Branch (2712:9): [True: 0, False: 0]
  ------------------
 2713|      0|        return -4;
 2714|      0|    }
 2715|       |
 2716|      0|    return ret;
 2717|      0|}
group.c:conferences_section_size:
 3515|  4.52k|{
 3516|  4.52k|    uint32_t len = 0;
 3517|       |
 3518|  7.76k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3518:26): [True: 3.24k, False: 4.52k]
  ------------------
 3519|  3.24k|        const Group_c *g = get_group_c(g_c, i);
 3520|       |
 3521|  3.24k|        if (g == nullptr || g->status != GROUPCHAT_STATUS_CONNECTED) {
  ------------------
  |  |   66|  6.48k|#define nullptr NULL
  ------------------
  |  Branch (3521:13): [True: 0, False: 3.24k]
  |  Branch (3521:29): [True: 0, False: 3.24k]
  ------------------
 3522|      0|            continue;
 3523|      0|        }
 3524|       |
 3525|  3.24k|        len += saved_conf_size(g);
 3526|  3.24k|    }
 3527|       |
 3528|  4.52k|    return len;
 3529|  4.52k|}
group.c:saved_conf_size:
 3445|  3.24k|{
 3446|  3.24k|    uint32_t len = SAVED_CONF_SIZE_CONSTANT + g->title_len;
  ------------------
  |  | 3440|  3.24k|#define SAVED_CONF_SIZE_CONSTANT (1 + GROUP_ID_LENGTH + sizeof(uint32_t) \
  |  |  ------------------
  |  |  |  |   43|  3.24k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   55|  3.24k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   50|  3.24k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 3441|  3.24k|      + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t) + 1)
  ------------------
 3447|       |
 3448|  7.28k|    for (uint32_t j = 0; j < g->numpeers + g->numfrozen; ++j) {
  ------------------
  |  Branch (3448:26): [True: 4.04k, False: 3.24k]
  ------------------
 3449|  4.04k|        const Group_Peer *peer = (j < g->numpeers) ? &g->group[j] : &g->frozen[j - g->numpeers];
  ------------------
  |  Branch (3449:34): [True: 3.24k, False: 798]
  ------------------
 3450|       |
 3451|  4.04k|        if (pk_equal(peer->real_pk, g->real_pk)) {
  ------------------
  |  Branch (3451:13): [True: 3.24k, False: 798]
  ------------------
 3452|  3.24k|            continue;
 3453|  3.24k|        }
 3454|       |
 3455|    798|        len += saved_peer_size(peer);
 3456|    798|    }
 3457|       |
 3458|  3.24k|    return len;
 3459|  3.24k|}
group.c:saved_peer_size:
 3411|    798|{
 3412|    798|    return SAVED_PEER_SIZE_CONSTANT + peer->nick_len;
  ------------------
  |  | 3407|    798|#define SAVED_PEER_SIZE_CONSTANT (2 * CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint16_t) + sizeof(uint64_t) + 1)
  |  |  ------------------
  |  |  |  |   40|    798|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 3413|    798|}
group.c:save_conf:
 3470|  1.08k|{
 3471|  1.08k|    *data = g->type;
 3472|  1.08k|    ++data;
 3473|       |
 3474|  1.08k|    memcpy(data, g->id, GROUP_ID_LENGTH);
  ------------------
  |  |   43|  1.08k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   55|  1.08k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   50|  1.08k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3475|  1.08k|    data += GROUP_ID_LENGTH;
  ------------------
  |  |   43|  1.08k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   55|  1.08k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   50|  1.08k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3476|       |
 3477|  1.08k|    host_to_lendian_bytes32(data, g->message_number + SAVE_OFFSET_MESSAGE_NUMBER);
  ------------------
  |  | 3465|  1.08k|#define SAVE_OFFSET_MESSAGE_NUMBER (1 << 16)
  ------------------
 3478|  1.08k|    data += sizeof(uint32_t);
 3479|       |
 3480|  1.08k|    host_to_lendian_bytes16(data, g->lossy_message_number + SAVE_OFFSET_LOSSY_MESSAGE_NUMBER);
  ------------------
  |  | 3466|  1.08k|#define SAVE_OFFSET_LOSSY_MESSAGE_NUMBER (1 << 13)
  ------------------
 3481|  1.08k|    data += sizeof(uint16_t);
 3482|       |
 3483|  1.08k|    host_to_lendian_bytes16(data, g->peer_number);
 3484|  1.08k|    data += sizeof(uint16_t);
 3485|       |
 3486|  1.08k|    uint8_t *const numsaved_location = data;
 3487|  1.08k|    data += sizeof(uint32_t);
 3488|       |
 3489|  1.08k|    *data = g->title_len;
 3490|  1.08k|    ++data;
 3491|       |
 3492|  1.08k|    memcpy(data, g->title, g->title_len);
 3493|  1.08k|    data += g->title_len;
 3494|       |
 3495|  1.08k|    uint32_t numsaved = 0;
 3496|       |
 3497|  2.42k|    for (uint32_t j = 0; j < g->numpeers + g->numfrozen; ++j) {
  ------------------
  |  Branch (3497:26): [True: 1.34k, False: 1.08k]
  ------------------
 3498|  1.34k|        const Group_Peer *peer = (j < g->numpeers) ? &g->group[j] : &g->frozen[j - g->numpeers];
  ------------------
  |  Branch (3498:34): [True: 1.08k, False: 266]
  ------------------
 3499|       |
 3500|  1.34k|        if (pk_equal(peer->real_pk, g->real_pk)) {
  ------------------
  |  Branch (3500:13): [True: 1.08k, False: 266]
  ------------------
 3501|  1.08k|            continue;
 3502|  1.08k|        }
 3503|       |
 3504|    266|        data = save_peer(peer, data);
 3505|    266|        ++numsaved;
 3506|    266|    }
 3507|       |
 3508|  1.08k|    host_to_lendian_bytes32(numsaved_location, numsaved);
 3509|       |
 3510|  1.08k|    return data;
 3511|  1.08k|}
group.c:save_peer:
 3417|    266|{
 3418|    266|    memcpy(data, peer->real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    266|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3419|    266|    data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|    266|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3420|       |
 3421|    266|    memcpy(data, peer->temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    266|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3422|    266|    data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|    266|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3423|       |
 3424|    266|    host_to_lendian_bytes16(data, peer->peer_number);
 3425|    266|    data += sizeof(uint16_t);
 3426|       |
 3427|    266|    host_to_lendian_bytes64(data, peer->last_active);
 3428|    266|    data += sizeof(uint64_t);
 3429|       |
 3430|       |    // TODO(iphydf): This looks broken: nick_len can be > 255.
 3431|    266|    *data = peer->nick_len;
 3432|    266|    ++data;
 3433|       |
 3434|    266|    memcpy(data, peer->nick, peer->nick_len);
 3435|    266|    data += peer->nick_len;
 3436|       |
 3437|    266|    return data;
 3438|    266|}
group.c:load_conferences:
 3723|    287|{
 3724|    287|    const State_Load_Status res = load_conferences_helper(g_c, data, length);
 3725|       |
 3726|    287|    if (res == STATE_LOAD_STATUS_CONTINUE) {
  ------------------
  |  Branch (3726:9): [True: 243, False: 44]
  ------------------
 3727|    243|        return res;
 3728|    243|    }
 3729|       |
 3730|       |    // Loading failed, cleanup all Group_c
 3731|       |
 3732|       |    // save locally, because wipe_group_chat(...) modifies it
 3733|     44|    const uint16_t num_groups = g_c->num_chats;
 3734|       |
 3735|    557|    for (uint16_t i = 0; i < num_groups; ++i) {
  ------------------
  |  Branch (3735:26): [True: 513, False: 44]
  ------------------
 3736|    513|        wipe_group_chat(g_c, i);
 3737|    513|    }
 3738|       |
 3739|     44|    return res;
 3740|    287|}
group.c:load_conferences_helper:
 3672|    287|{
 3673|    287|    const uint8_t *init_data = data;
 3674|       |
 3675|  2.15k|    while (length >= (uint32_t)(data - init_data) + SAVED_CONF_SIZE_CONSTANT) {
  ------------------
  |  | 3440|  2.15k|#define SAVED_CONF_SIZE_CONSTANT (1 + GROUP_ID_LENGTH + sizeof(uint32_t) \
  |  |  ------------------
  |  |  |  |   43|  2.15k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   55|  2.15k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   50|  2.15k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 3441|  2.15k|      + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t) + 1)
  ------------------
  |  Branch (3675:12): [True: 1.91k, False: 243]
  ------------------
 3676|  1.91k|        const int groupnumber = create_group_chat(g_c);
 3677|       |
 3678|       |        // Helpful for testing
 3679|  1.91k|        assert(groupnumber != -1);
 3680|       |
 3681|  1.91k|        if (groupnumber == -1) {
  ------------------
  |  Branch (3681:13): [True: 0, False: 1.91k]
  ------------------
 3682|       |            // If this fails there's a serious problem, don't bother with cleanup
 3683|      0|            LOGGER_ERROR(g_c->m->log, "conference creation failed");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3684|      0|            return STATE_LOAD_STATUS_ERROR;
 3685|      0|        }
 3686|       |
 3687|  1.91k|        Group_c *g = &g_c->chats[groupnumber];
 3688|       |
 3689|  1.91k|        const uint32_t consumed = load_group(g, g_c, data, length - (uint32_t)(data - init_data));
 3690|       |
 3691|  1.91k|        if (consumed == 0) {
  ------------------
  |  Branch (3691:13): [True: 38, False: 1.87k]
  ------------------
 3692|       |            // remove partially loaded stuff, wipe_group_chat must be able to wipe a partially loaded group
 3693|     38|            const bool ret = wipe_group_chat(g_c, groupnumber);
 3694|       |
 3695|       |            // HACK: suppress unused variable warning
 3696|     38|            if (!ret) {
  ------------------
  |  Branch (3696:17): [True: 0, False: 38]
  ------------------
 3697|       |                // wipe_group_chat(...) must be able to wipe partially allocated groups
 3698|      0|                assert(ret);
 3699|      0|            }
 3700|       |
 3701|     38|            LOGGER_ERROR(g_c->m->log, "conference loading failed");
  ------------------
  |  |   83|     38|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     38|    do {                                                                         \
  |  |  |  |   73|     38|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     76|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     38|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     38|        }                                                                        \
  |  |  |  |   76|     38|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3702|     38|            return STATE_LOAD_STATUS_ERROR;
 3703|     38|        }
 3704|       |
 3705|  1.87k|        data += consumed;
 3706|       |
 3707|  1.87k|        const int peer_index = addpeer(g_c, groupnumber, g->real_pk, dht_get_self_public_key(g_c->m->dht), g->peer_number,
 3708|  1.87k|                                       nullptr, true, false);
  ------------------
  |  |   66|  1.87k|#define nullptr NULL
  ------------------
 3709|       |
 3710|  1.87k|        if (peer_index == -1) {
  ------------------
  |  Branch (3710:13): [True: 6, False: 1.87k]
  ------------------
 3711|      6|            LOGGER_ERROR(g_c->m->log, "adding peer %d failed", g->peer_number);
  ------------------
  |  |   83|      6|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      6|    do {                                                                         \
  |  |  |  |   73|      6|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     12|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      6|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      6|        }                                                                        \
  |  |  |  |   76|      6|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3712|      6|            return STATE_LOAD_STATUS_ERROR;
 3713|      6|        }
 3714|       |
 3715|  1.87k|        setnick(g_c, groupnumber, peer_index, g_c->m->name, g_c->m->name_length, nullptr, false);
  ------------------
  |  |   66|  1.87k|#define nullptr NULL
  ------------------
 3716|  1.87k|    }
 3717|       |
 3718|    243|    return STATE_LOAD_STATUS_CONTINUE;
 3719|    287|}
group.c:load_group:
 3564|  1.91k|{
 3565|  1.91k|    const uint8_t *init_data = data;
 3566|       |
 3567|       |    // Initialize to default values so we can unconditionally free in case of an error
 3568|  1.91k|    setup_conference(g);
 3569|       |
 3570|  1.91k|    g->type = *data;
 3571|  1.91k|    ++data;
 3572|       |
 3573|  1.91k|    memcpy(g->id, data, GROUP_ID_LENGTH);
  ------------------
  |  |   43|  1.91k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   55|  1.91k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   50|  1.91k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3574|  1.91k|    data += GROUP_ID_LENGTH;
  ------------------
  |  |   43|  1.91k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   55|  1.91k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   50|  1.91k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3575|       |
 3576|  1.91k|    lendian_bytes_to_host32(&g->message_number, data);
 3577|  1.91k|    data += sizeof(uint32_t);
 3578|       |
 3579|  1.91k|    lendian_bytes_to_host16(&g->lossy_message_number, data);
 3580|  1.91k|    data += sizeof(uint16_t);
 3581|       |
 3582|  1.91k|    lendian_bytes_to_host16(&g->peer_number, data);
 3583|  1.91k|    data += sizeof(uint16_t);
 3584|       |
 3585|  1.91k|    lendian_bytes_to_host32(&g->numfrozen, data);
 3586|  1.91k|    data += sizeof(uint32_t);
 3587|       |
 3588|  1.91k|    g->title_len = *data;
 3589|       |
 3590|  1.91k|    if (g->title_len > MAX_NAME_LENGTH) {
  ------------------
  |  |   24|  1.91k|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (3590:9): [True: 6, False: 1.91k]
  ------------------
 3591|      6|        return 0;
 3592|      6|    }
 3593|       |
 3594|  1.91k|    ++data;
 3595|       |
 3596|  1.91k|    assert((data - init_data) < UINT32_MAX);
 3597|       |
 3598|  1.91k|    if (length < (uint32_t)(data - init_data) + g->title_len) {
  ------------------
  |  Branch (3598:9): [True: 2, False: 1.90k]
  ------------------
 3599|      2|        return 0;
 3600|      2|    }
 3601|       |
 3602|  1.90k|    memcpy(g->title, data, g->title_len);
 3603|  1.90k|    data += g->title_len;
 3604|       |
 3605|  2.35k|    for (uint32_t j = 0; j < g->numfrozen; ++j) {
  ------------------
  |  Branch (3605:26): [True: 473, False: 1.87k]
  ------------------
 3606|       |
 3607|    473|        assert((data - init_data) < UINT32_MAX);
 3608|       |
 3609|    473|        if (length < (uint32_t)(data - init_data) + SAVED_PEER_SIZE_CONSTANT) {
  ------------------
  |  | 3407|    473|#define SAVED_PEER_SIZE_CONSTANT (2 * CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint16_t) + sizeof(uint64_t) + 1)
  |  |  ------------------
  |  |  |  |   40|    473|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (3609:13): [True: 23, False: 450]
  ------------------
 3610|     23|            return 0;
 3611|     23|        }
 3612|       |
 3613|       |        // This is inefficient, but allows us to check data consistency before allocating memory
 3614|    450|        Group_Peer *tmp_frozen = (Group_Peer *)realloc(g->frozen, (j + 1) * sizeof(Group_Peer));
 3615|       |
 3616|    450|        if (tmp_frozen == nullptr) {
  ------------------
  |  |   66|    450|#define nullptr NULL
  ------------------
  |  Branch (3616:13): [True: 0, False: 450]
  ------------------
 3617|       |            // Memory allocation failure
 3618|      0|            return 0;
 3619|      0|        }
 3620|       |
 3621|    450|        g->frozen = tmp_frozen;
 3622|       |
 3623|    450|        Group_Peer *peer = &g->frozen[j];
 3624|    450|        *peer = empty_group_peer;
 3625|       |
 3626|    450|        pk_copy(peer->real_pk, data);
 3627|    450|        data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|    450|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3628|    450|        pk_copy(peer->temp_pk, data);
 3629|    450|        data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   40|    450|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3630|       |
 3631|    450|        lendian_bytes_to_host16(&peer->peer_number, data);
 3632|    450|        data += sizeof(uint16_t);
 3633|       |
 3634|    450|        lendian_bytes_to_host64(&peer->last_active, data);
 3635|    450|        data += sizeof(uint64_t);
 3636|       |
 3637|    450|        peer->nick_len = *data;
 3638|       |
 3639|    450|        if (peer->nick_len > MAX_NAME_LENGTH) {
  ------------------
  |  |   24|    450|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (3639:13): [True: 3, False: 447]
  ------------------
 3640|      3|            return 0;
 3641|      3|        }
 3642|       |
 3643|    447|        ++data;
 3644|    447|        assert((data - init_data) < UINT32_MAX);
 3645|       |
 3646|    447|        if (length < (uint32_t)(data - init_data) + peer->nick_len) {
  ------------------
  |  Branch (3646:13): [True: 4, False: 443]
  ------------------
 3647|      4|            return 0;
 3648|      4|        }
 3649|       |
 3650|    443|        memcpy(peer->nick, data, peer->nick_len);
 3651|    443|        data += peer->nick_len;
 3652|       |
 3653|       |        // NOTE: this relies on friends being loaded before conferences.
 3654|    443|        peer->is_friend = getfriend_id(g_c->m, peer->real_pk) != -1;
 3655|    443|    }
 3656|       |
 3657|  1.87k|    if (g->numfrozen > g->maxfrozen) {
  ------------------
  |  Branch (3657:9): [True: 0, False: 1.87k]
  ------------------
 3658|      0|        g->maxfrozen = g->numfrozen;
 3659|      0|    }
 3660|       |
 3661|  1.87k|    g->status = GROUPCHAT_STATUS_CONNECTED;
 3662|       |
 3663|  1.87k|    pk_copy(g->real_pk, nc_get_self_public_key(g_c->m->net_crypto));
 3664|       |
 3665|  1.87k|    assert((data - init_data) < UINT32_MAX);
 3666|       |
 3667|      0|    return (uint32_t)(data - init_data);
 3668|  1.90k|}

new_gca_list:
  397|  2.14k|{
  398|  2.14k|    GC_Announces_List *announces_list = (GC_Announces_List *)calloc(1, sizeof(GC_Announces_List));
  399|  2.14k|    return announces_list;
  400|  2.14k|}
kill_gca:
  403|  2.14k|{
  404|  2.14k|    if (announces_list == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (404:9): [True: 0, False: 2.14k]
  ------------------
  405|      0|        return;
  406|      0|    }
  407|       |
  408|  2.14k|    GC_Announces *root = announces_list->root_announces;
  409|       |
  410|  2.14k|    while (root != nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (410:12): [True: 0, False: 2.14k]
  ------------------
  411|      0|        GC_Announces *next = root->next_announce;
  412|      0|        free(root);
  413|      0|        root = next;
  414|      0|    }
  415|       |
  416|  2.14k|    free(announces_list);
  417|  2.14k|}

gc_peer_number_is_valid:
  204|    283|{
  205|    283|    return peer_number >= 0 && peer_number < (int)chat->numpeers;
  ------------------
  |  Branch (205:12): [True: 283, False: 0]
  |  Branch (205:32): [True: 283, False: 0]
  ------------------
  206|    283|}
get_gc_connection:
  219|    283|{
  220|    283|    GC_Peer *peer = get_gc_peer(chat, peer_number);
  221|       |
  222|    283|    if (peer == nullptr) {
  ------------------
  |  |   66|    283|#define nullptr NULL
  ------------------
  |  Branch (222:9): [True: 0, False: 283]
  ------------------
  223|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  224|      0|    }
  225|       |
  226|    283|    return &peer->gconn;
  227|    283|}
pack_gc_saved_peers:
  387|    420|{
  388|    420|    uint16_t packed_len = 0;
  389|    420|    uint16_t count = 0;
  390|       |
  391|  42.4k|    for (uint32_t i = 0; i < GC_MAX_SAVED_PEERS; ++i) {
  ------------------
  |  |   42|  42.4k|#define GC_MAX_SAVED_PEERS 100
  ------------------
  |  Branch (391:26): [True: 42.0k, False: 420]
  ------------------
  392|  42.0k|        const GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];
  393|       |
  394|  42.0k|        if (!saved_peer_is_valid(saved_peer)) {
  ------------------
  |  Branch (394:13): [True: 41.2k, False: 704]
  ------------------
  395|  41.2k|            continue;
  396|  41.2k|        }
  397|       |
  398|    704|        int packed_ipp_len = 0;
  399|    704|        int packed_tcp_len = 0;
  400|       |
  401|    704|        if (ipport_isset(&saved_peer->ip_port)) {
  ------------------
  |  Branch (401:13): [True: 512, False: 192]
  ------------------
  402|    512|            if (packed_len > length) {
  ------------------
  |  Branch (402:17): [True: 0, False: 512]
  ------------------
  403|      0|                return -1;
  404|      0|            }
  405|       |
  406|    512|            packed_ipp_len = pack_ip_port(chat->log, data + packed_len, length - packed_len, &saved_peer->ip_port);
  407|       |
  408|    512|            if (packed_ipp_len > 0) {
  ------------------
  |  Branch (408:17): [True: 512, False: 0]
  ------------------
  409|    512|                packed_len += packed_ipp_len;
  410|    512|            }
  411|    512|        }
  412|       |
  413|    704|        if (ipport_isset(&saved_peer->tcp_relay.ip_port)) {
  ------------------
  |  Branch (413:13): [True: 216, False: 488]
  ------------------
  414|    216|            if (packed_len > length) {
  ------------------
  |  Branch (414:17): [True: 0, False: 216]
  ------------------
  415|      0|                return -1;
  416|      0|            }
  417|       |
  418|    216|            packed_tcp_len = pack_nodes(chat->log, data + packed_len, length - packed_len, &saved_peer->tcp_relay, 1);
  419|       |
  420|    216|            if (packed_tcp_len > 0) {
  ------------------
  |  Branch (420:17): [True: 216, False: 0]
  ------------------
  421|    216|                packed_len += packed_tcp_len;
  422|    216|            }
  423|    216|        }
  424|       |
  425|    704|        if (packed_len + ENC_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |   27|    704|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|    704|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (425:13): [True: 0, False: 704]
  ------------------
  426|      0|            return -1;
  427|      0|        }
  428|       |
  429|    704|        if (packed_tcp_len > 0 || packed_ipp_len > 0) {
  ------------------
  |  Branch (429:13): [True: 216, False: 488]
  |  Branch (429:35): [True: 488, False: 0]
  ------------------
  430|    704|            memcpy(data + packed_len, chat->saved_peers[i].public_key, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |   27|    704|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|    704|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  431|    704|            packed_len += ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |   27|    704|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|    704|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  432|    704|            ++count;
  433|    704|        } else {
  434|      0|            LOGGER_WARNING(chat->log, "Failed to pack saved peer");
  ------------------
  |  |   82|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  435|      0|        }
  436|    704|    }
  437|       |
  438|    420|    if (processed != nullptr) {
  ------------------
  |  |   66|    420|#define nullptr NULL
  ------------------
  |  Branch (438:9): [True: 420, False: 0]
  ------------------
  439|    420|        *processed = packed_len;
  440|    420|    }
  441|       |
  442|    420|    return count;
  443|    420|}
unpack_gc_saved_peers:
  446|    222|{
  447|    222|    uint16_t count = 0;
  448|    222|    uint16_t unpacked_len = 0;
  449|       |
  450|    643|    for (size_t i = 0; unpacked_len < length; ++i) {
  ------------------
  |  Branch (450:24): [True: 631, False: 12]
  ------------------
  451|    631|        GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];
  452|       |
  453|    631|        const int ipp_len = unpack_ip_port(&saved_peer->ip_port, data + unpacked_len, length - unpacked_len, false);
  454|       |
  455|    631|        if (ipp_len > 0) {
  ------------------
  |  Branch (455:13): [True: 381, False: 250]
  ------------------
  456|    381|            unpacked_len += ipp_len;
  457|    381|        }
  458|       |
  459|    631|        if (unpacked_len > length) {
  ------------------
  |  Branch (459:13): [True: 0, False: 631]
  ------------------
  460|      0|            return -1;
  461|      0|        }
  462|       |
  463|    631|        uint16_t tcp_len_processed = 0;
  464|    631|        const int tcp_len = unpack_nodes(&saved_peer->tcp_relay, 1, &tcp_len_processed, data + unpacked_len,
  465|    631|                                         length - unpacked_len, true);
  466|       |
  467|    631|        if (tcp_len == 1 && tcp_len_processed > 0) {
  ------------------
  |  Branch (467:13): [True: 61, False: 570]
  |  Branch (467:29): [True: 61, False: 0]
  ------------------
  468|     61|            unpacked_len += tcp_len_processed;
  469|    570|        } else if (ipp_len <= 0) {
  ------------------
  |  Branch (469:20): [True: 206, False: 364]
  ------------------
  470|    206|            LOGGER_WARNING(chat->log, "Failed to unpack saved peer: Invalid connection info.");
  ------------------
  |  |   82|    206|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    206|    do {                                                                         \
  |  |  |  |   73|    206|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    412|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    206|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    206|        }                                                                        \
  |  |  |  |   76|    206|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  471|    206|            return -1;
  472|    206|        }
  473|       |
  474|    425|        if (unpacked_len + ENC_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |   27|    425|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|    425|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (474:13): [True: 4, False: 421]
  ------------------
  475|      4|            return -1;
  476|      4|        }
  477|       |
  478|    421|        if (tcp_len > 0 || ipp_len > 0) {
  ------------------
  |  Branch (478:13): [True: 59, False: 362]
  |  Branch (478:28): [True: 362, False: 0]
  ------------------
  479|    421|            memcpy(saved_peer->public_key, data + unpacked_len, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |   27|    421|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|    421|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  480|    421|            unpacked_len += ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |   27|    421|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|    421|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  481|    421|            ++count;
  482|    421|        } else {
  483|      0|            LOGGER_ERROR(chat->log, "Unpacked peer with bad connection info");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  484|      0|            return -1;
  485|      0|        }
  486|    421|    }
  487|       |
  488|     12|    return count;
  489|    222|}
gc_get_pk_jenkins_hash:
  552|    283|{
  553|    283|    return jenkins_one_at_a_time_hash(public_key, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |   27|    283|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|    283|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  554|    283|}
get_peer_number_of_enc_pk:
  586|    283|{
  587|    283|    for (uint32_t i = 0; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (587:26): [True: 0, False: 283]
  ------------------
  588|      0|        const GC_Connection *gconn = get_gc_connection(chat, i);
  589|       |
  590|      0|        assert(gconn != nullptr);
  591|       |
  592|      0|        if (gconn->pending_delete) {
  ------------------
  |  Branch (592:13): [True: 0, False: 0]
  ------------------
  593|      0|            continue;
  594|      0|        }
  595|       |
  596|      0|        if (confirmed && !gconn->confirmed) {
  ------------------
  |  Branch (596:13): [True: 0, False: 0]
  |  Branch (596:26): [True: 0, False: 0]
  ------------------
  597|      0|            continue;
  598|      0|        }
  599|       |
  600|      0|        if (memcmp(gconn->addr.public_key, public_enc_key, ENC_PUBLIC_KEY_SIZE) == 0) {
  ------------------
  |  |   27|      0|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (600:13): [True: 0, False: 0]
  ------------------
  601|      0|            return i;
  602|      0|        }
  603|      0|    }
  604|       |
  605|    283|    return -1;
  606|    283|}
gc_callback_message:
 6474|  1.50k|{
 6475|  1.50k|    GC_Session *c = m->group_handler;
 6476|  1.50k|    c->message = function;
 6477|  1.50k|}
gc_callback_private_message:
 6480|  1.50k|{
 6481|  1.50k|    GC_Session *c = m->group_handler;
 6482|  1.50k|    c->private_message = function;
 6483|  1.50k|}
gc_callback_custom_packet:
 6486|  1.50k|{
 6487|  1.50k|    GC_Session *c = m->group_handler;
 6488|  1.50k|    c->custom_packet = function;
 6489|  1.50k|}
gc_callback_custom_private_packet:
 6492|  1.50k|{
 6493|  1.50k|    GC_Session *c = m->group_handler;
 6494|  1.50k|    c->custom_private_packet = function;
 6495|  1.50k|}
gc_callback_moderation:
 6498|  1.50k|{
 6499|  1.50k|    GC_Session *c = m->group_handler;
 6500|  1.50k|    c->moderation = function;
 6501|  1.50k|}
gc_callback_nick_change:
 6504|  1.50k|{
 6505|  1.50k|    GC_Session *c = m->group_handler;
 6506|  1.50k|    c->nick_change = function;
 6507|  1.50k|}
gc_callback_status_change:
 6510|  1.50k|{
 6511|  1.50k|    GC_Session *c = m->group_handler;
 6512|  1.50k|    c->status_change = function;
 6513|  1.50k|}
gc_callback_topic_change:
 6516|  1.50k|{
 6517|  1.50k|    GC_Session *c = m->group_handler;
 6518|  1.50k|    c->topic_change = function;
 6519|  1.50k|}
gc_callback_topic_lock:
 6522|  1.50k|{
 6523|  1.50k|    GC_Session *c = m->group_handler;
 6524|  1.50k|    c->topic_lock = function;
 6525|  1.50k|}
gc_callback_voice_state:
 6528|  1.50k|{
 6529|  1.50k|    GC_Session *c = m->group_handler;
 6530|  1.50k|    c->voice_state = function;
 6531|  1.50k|}
gc_callback_peer_limit:
 6534|  1.50k|{
 6535|  1.50k|    GC_Session *c = m->group_handler;
 6536|  1.50k|    c->peer_limit = function;
 6537|  1.50k|}
gc_callback_privacy_state:
 6540|  1.50k|{
 6541|  1.50k|    GC_Session *c = m->group_handler;
 6542|  1.50k|    c->privacy_state = function;
 6543|  1.50k|}
gc_callback_password:
 6546|  1.50k|{
 6547|  1.50k|    GC_Session *c = m->group_handler;
 6548|  1.50k|    c->password = function;
 6549|  1.50k|}
gc_callback_peer_join:
 6552|  1.50k|{
 6553|  1.50k|    GC_Session *c = m->group_handler;
 6554|  1.50k|    c->peer_join = function;
 6555|  1.50k|}
gc_callback_peer_exit:
 6558|  1.50k|{
 6559|  1.50k|    GC_Session *c = m->group_handler;
 6560|  1.50k|    c->peer_exit = function;
 6561|  1.50k|}
gc_callback_self_join:
 6564|  1.50k|{
 6565|  1.50k|    GC_Session *c = m->group_handler;
 6566|  1.50k|    c->self_join = function;
 6567|  1.50k|}
gc_callback_rejected:
 6570|  1.50k|{
 6571|  1.50k|    GC_Session *c = m->group_handler;
 6572|  1.50k|    c->rejected = function;
 6573|  1.50k|}
peer_add:
 6665|    283|{
 6666|    283|    if (get_peer_number_of_enc_pk(chat, public_key, false) != -1) {
  ------------------
  |  Branch (6666:9): [True: 0, False: 283]
  ------------------
 6667|      0|        return -2;
 6668|      0|    }
 6669|       |
 6670|    283|    const uint32_t peer_id = get_new_peer_id(chat);
 6671|       |
 6672|    283|    if (peer_id == UINT32_MAX) {
  ------------------
  |  Branch (6672:9): [True: 0, False: 283]
  ------------------
 6673|      0|        LOGGER_WARNING(chat->log, "Failed to add peer: all peer ID's are taken?");
  ------------------
  |  |   82|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6674|      0|        return -1;
 6675|      0|    }
 6676|       |
 6677|    283|    const int peer_number = chat->numpeers;
 6678|    283|    int tcp_connection_num = -1;
 6679|       |
 6680|    283|    if (peer_number > 0) {  // we don't need a connection to ourself
  ------------------
  |  Branch (6680:9): [True: 0, False: 283]
  ------------------
 6681|      0|        tcp_connection_num = new_tcp_connection_to(chat->tcp_conn, public_key, 0);
 6682|       |
 6683|      0|        if (tcp_connection_num == -1) {
  ------------------
  |  Branch (6683:13): [True: 0, False: 0]
  ------------------
 6684|      0|            LOGGER_WARNING(chat->log, "Failed to init tcp connection for peer %d", peer_number);
  ------------------
  |  |   82|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6685|      0|        }
 6686|      0|    }
 6687|       |
 6688|    283|    GC_Message_Array_Entry *send = (GC_Message_Array_Entry *)calloc(GCC_BUFFER_SIZE, sizeof(GC_Message_Array_Entry));
  ------------------
  |  |   49|    283|#define GCC_BUFFER_SIZE 8192
  ------------------
 6689|    283|    GC_Message_Array_Entry *recv = (GC_Message_Array_Entry *)calloc(GCC_BUFFER_SIZE, sizeof(GC_Message_Array_Entry));
  ------------------
  |  |   49|    283|#define GCC_BUFFER_SIZE 8192
  ------------------
 6690|       |
 6691|    283|    if (send == nullptr || recv == nullptr) {
  ------------------
  |  |   66|    566|#define nullptr NULL
  ------------------
                  if (send == nullptr || recv == nullptr) {
  ------------------
  |  |   66|    283|#define nullptr NULL
  ------------------
  |  Branch (6691:9): [True: 0, False: 283]
  |  Branch (6691:28): [True: 0, False: 283]
  ------------------
 6692|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for gconn buffers");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6693|       |
 6694|      0|        if (tcp_connection_num != -1) {
  ------------------
  |  Branch (6694:13): [True: 0, False: 0]
  ------------------
 6695|      0|            kill_tcp_connection_to(chat->tcp_conn, tcp_connection_num);
 6696|      0|        }
 6697|       |
 6698|      0|        free(send);
 6699|      0|        free(recv);
 6700|      0|        return -1;
 6701|      0|    }
 6702|       |
 6703|    283|    GC_Peer *tmp_group = (GC_Peer *)realloc(chat->group, (chat->numpeers + 1) * sizeof(GC_Peer));
 6704|       |
 6705|    283|    if (tmp_group == nullptr) {
  ------------------
  |  |   66|    283|#define nullptr NULL
  ------------------
  |  Branch (6705:9): [True: 0, False: 283]
  ------------------
 6706|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for group realloc");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6707|       |
 6708|      0|        if (tcp_connection_num != -1) {
  ------------------
  |  Branch (6708:13): [True: 0, False: 0]
  ------------------
 6709|      0|            kill_tcp_connection_to(chat->tcp_conn, tcp_connection_num);
 6710|      0|        }
 6711|       |
 6712|      0|        free(send);
 6713|      0|        free(recv);
 6714|      0|        return -1;
 6715|      0|    }
 6716|       |
 6717|    283|    ++chat->numpeers;
 6718|    283|    chat->group = tmp_group;
 6719|       |
 6720|    283|    chat->group[peer_number] = (GC_Peer) {
 6721|    283|        0
 6722|    283|    };
 6723|       |
 6724|    283|    GC_Connection *gconn = &chat->group[peer_number].gconn;
 6725|       |
 6726|    283|    gconn->send_array = send;
 6727|    283|    gconn->recv_array = recv;
 6728|       |
 6729|    283|    gcc_set_ip_port(gconn, ipp);
 6730|    283|    chat->group[peer_number].role = GR_USER;
 6731|    283|    chat->group[peer_number].peer_id = peer_id;
 6732|    283|    chat->group[peer_number].ignore = false;
 6733|       |
 6734|    283|    crypto_memlock(gconn->session_secret_key, sizeof(gconn->session_secret_key));
 6735|       |
 6736|    283|    create_gc_session_keypair(chat->log, chat->rng, gconn->session_public_key, gconn->session_secret_key);
 6737|       |
 6738|    283|    if (peer_number > 0) {
  ------------------
  |  Branch (6738:9): [True: 0, False: 283]
  ------------------
 6739|      0|        memcpy(gconn->addr.public_key, public_key, ENC_PUBLIC_KEY_SIZE);  // we get the sig key in the handshake
  ------------------
  |  |   27|      0|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 6740|    283|    } else {
 6741|    283|        memcpy(gconn->addr.public_key, chat->self_public_key, EXT_PUBLIC_KEY_SIZE);
  ------------------
  |  |   37|    283|#define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   27|    283|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    283|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   29|    283|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    283|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6742|    283|    }
 6743|       |
 6744|    283|    const uint64_t tm = mono_time_get(chat->mono_time);
 6745|       |
 6746|    283|    gcc_set_send_message_id(gconn, 1);
 6747|    283|    gconn->public_key_hash = gc_get_pk_jenkins_hash(public_key);
 6748|    283|    gconn->last_received_packet_time = tm;
 6749|    283|    gconn->last_key_rotation = tm;
 6750|    283|    gconn->tcp_connection_num = tcp_connection_num;
 6751|    283|    gconn->last_sent_ip_time = tm;
 6752|    283|    gconn->last_sent_ping_time = tm - (GC_PING_TIMEOUT / 2) + (peer_number % (GC_PING_TIMEOUT / 2));
  ------------------
  |  |   24|    283|#define GC_PING_TIMEOUT 12
  ------------------
                  gconn->last_sent_ping_time = tm - (GC_PING_TIMEOUT / 2) + (peer_number % (GC_PING_TIMEOUT / 2));
  ------------------
  |  |   24|    283|#define GC_PING_TIMEOUT 12
  ------------------
 6753|    283|    gconn->self_is_closer = id_closest(get_chat_id(chat->chat_public_key),
 6754|    283|                                       get_enc_key(chat->self_public_key),
 6755|    283|                                       get_enc_key(gconn->addr.public_key)) == 1;
 6756|    283|    return peer_number;
 6757|    283|}
gc_group_save:
 7471|  3.83k|{
 7472|  3.83k|    gc_save_pack_group(chat, bp);
 7473|  3.83k|}
gc_group_load:
 7476|  27.4k|{
 7477|  27.4k|    const int group_number = get_new_group_index(c);
 7478|       |
 7479|  27.4k|    if (group_number < 0) {
  ------------------
  |  Branch (7479:9): [True: 0, False: 27.4k]
  ------------------
 7480|      0|        return -1;
 7481|      0|    }
 7482|       |
 7483|  27.4k|    const uint64_t tm = mono_time_get(c->messenger->mono_time);
 7484|       |
 7485|  27.4k|    Messenger *m = c->messenger;
 7486|  27.4k|    GC_Chat *chat = &c->chats[group_number];
 7487|       |
 7488|  27.4k|    chat->group_number = group_number;
 7489|  27.4k|    chat->numpeers = 0;
 7490|  27.4k|    chat->net = m->net;
 7491|  27.4k|    chat->mono_time = m->mono_time;
 7492|  27.4k|    chat->log = m->log;
 7493|  27.4k|    chat->mem = m->mem;
 7494|  27.4k|    chat->rng = m->rng;
 7495|  27.4k|    chat->last_ping_interval = tm;
 7496|  27.4k|    chat->friend_connection_id = -1;
 7497|       |
 7498|       |    // Initialise these first, because we may need to log/dealloc things on cleanup.
 7499|  27.4k|    chat->moderation.log = m->log;
 7500|  27.4k|    chat->moderation.mem = m->mem;
 7501|       |
 7502|  27.4k|    if (!gc_load_unpack_group(chat, bu)) {
  ------------------
  |  Branch (7502:9): [True: 27.1k, False: 238]
  ------------------
 7503|  27.1k|        LOGGER_ERROR(chat->log, "Failed to unpack group");
  ------------------
  |  |   83|  27.1k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  27.1k|    do {                                                                         \
  |  |  |  |   73|  27.1k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  54.3k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|  27.1k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|  27.1k|        }                                                                        \
  |  |  |  |   76|  27.1k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 7504|  27.1k|        return -1;
 7505|  27.1k|    }
 7506|       |
 7507|    238|    init_gc_moderation(chat);
 7508|       |
 7509|    238|    if (!init_gc_tcp_connection(c, chat)) {
  ------------------
  |  Branch (7509:9): [True: 0, False: 238]
  ------------------
 7510|      0|        LOGGER_ERROR(chat->log, "Failed to init tcp connection");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 7511|      0|        return -1;
 7512|      0|    }
 7513|       |
 7514|    238|    if (chat->connection_state == CS_DISCONNECTED) {
  ------------------
  |  Branch (7514:9): [True: 2, False: 236]
  ------------------
 7515|      2|        return group_number;
 7516|      2|    }
 7517|       |
 7518|    236|    if (is_public_chat(chat)) {
  ------------------
  |  Branch (7518:9): [True: 18, False: 218]
  ------------------
 7519|     18|        if (!m_create_group_connection(m, chat)) {
  ------------------
  |  Branch (7519:13): [True: 0, False: 18]
  ------------------
 7520|      0|            LOGGER_ERROR(chat->log, "Failed to initialize group friend connection");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 7521|      0|        }
 7522|     18|    }
 7523|       |
 7524|    236|    return group_number;
 7525|    238|}
new_dht_groupchats:
 8093|  2.14k|{
 8094|  2.14k|    if (m == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (8094:9): [True: 0, False: 2.14k]
  ------------------
 8095|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 8096|      0|    }
 8097|       |
 8098|  2.14k|    GC_Session *c = (GC_Session *)calloc(1, sizeof(GC_Session));
 8099|       |
 8100|  2.14k|    if (c == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (8100:9): [True: 0, False: 2.14k]
  ------------------
 8101|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 8102|      0|    }
 8103|       |
 8104|  2.14k|    c->messenger = m;
 8105|  2.14k|    c->announces_list = m->group_announce;
 8106|       |
 8107|  2.14k|    networking_registerhandler(m->net, NET_PACKET_GC_LOSSLESS, &handle_gc_udp_packet, m);
 8108|  2.14k|    networking_registerhandler(m->net, NET_PACKET_GC_LOSSY, &handle_gc_udp_packet, m);
 8109|  2.14k|    networking_registerhandler(m->net, NET_PACKET_GC_HANDSHAKE, &handle_gc_udp_packet, m);
 8110|  2.14k|    onion_group_announce_register(m->onion_c, gc_handle_announce_response_callback, c);
 8111|       |
 8112|  2.14k|    return c;
 8113|  2.14k|}
kill_dht_groupchats:
 8178|  2.14k|{
 8179|  2.14k|    if (c == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (8179:9): [True: 0, False: 2.14k]
  ------------------
 8180|      0|        return;
 8181|      0|    }
 8182|       |
 8183|  7.48k|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (8183:26): [True: 5.34k, False: 2.14k]
  ------------------
 8184|  5.34k|        GC_Chat *chat = &c->chats[i];
 8185|       |
 8186|  5.34k|        if (chat->connection_state == CS_NONE) {
  ------------------
  |  Branch (8186:13): [True: 1.19k, False: 4.14k]
  ------------------
 8187|  1.19k|            continue;
 8188|  1.19k|        }
 8189|       |
 8190|  4.14k|        if (group_can_handle_packets(chat)) {
  ------------------
  |  Branch (8190:13): [True: 1.55k, False: 2.58k]
  ------------------
 8191|  1.55k|            send_gc_self_exit(chat, nullptr, 0);
  ------------------
  |  |   66|  1.55k|#define nullptr NULL
  ------------------
 8192|  1.55k|        }
 8193|       |
 8194|  4.14k|        group_cleanup(c, chat);
 8195|  4.14k|    }
 8196|       |
 8197|  2.14k|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSY, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSY, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 8198|  2.14k|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSLESS, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSLESS, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 8199|  2.14k|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_HANDSHAKE, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_HANDSHAKE, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 8200|  2.14k|    onion_group_announce_register(c->messenger->onion_c, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  onion_group_announce_register(c->messenger->onion_c, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 8201|       |
 8202|  2.14k|    free(c->chats);
 8203|  2.14k|    free(c);
 8204|  2.14k|}
gc_group_is_valid:
 8207|  14.9k|{
 8208|  14.9k|    return chat->connection_state != CS_NONE && chat->shared_state.version > 0;
  ------------------
  |  Branch (8208:12): [True: 10.2k, False: 4.66k]
  |  Branch (8208:49): [True: 8.62k, False: 1.67k]
  ------------------
 8209|  14.9k|}
gc_count_groups:
 8226|  5.10k|{
 8227|  5.10k|    uint32_t count = 0;
 8228|       |
 8229|  13.6k|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (8229:26): [True: 8.51k, False: 5.10k]
  ------------------
 8230|  8.51k|        const GC_Chat *chat = &c->chats[i];
 8231|       |
 8232|  8.51k|        if (gc_group_is_valid(chat)) {
  ------------------
  |  Branch (8232:13): [True: 4.79k, False: 3.72k]
  ------------------
 8233|  4.79k|            ++count;
 8234|  4.79k|        }
 8235|  8.51k|    }
 8236|       |
 8237|  5.10k|    return count;
 8238|  5.10k|}
group_chats.c:get_gc_peer:
  210|    283|{
  211|    283|    if (!gc_peer_number_is_valid(chat, peer_number)) {
  ------------------
  |  Branch (211:9): [True: 0, False: 283]
  ------------------
  212|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  213|      0|    }
  214|       |
  215|    283|    return &chat->group[peer_number];
  216|    283|}
group_chats.c:saved_peer_is_valid:
  774|  42.0k|{
  775|  42.0k|    return ipport_isset(&saved_peer->ip_port) || ipport_isset(&saved_peer->tcp_relay.ip_port);
  ------------------
  |  Branch (775:12): [True: 512, False: 41.4k]
  |  Branch (775:50): [True: 192, False: 41.2k]
  ------------------
  776|  42.0k|}
group_chats.c:send_gc_broadcast_message:
 2302|  1.55k|{
 2303|  1.55k|    if (length + GC_BROADCAST_ENC_HEADER_SIZE > MAX_GC_PACKET_SIZE) {
  ------------------
  |  |   53|  1.55k|#define GC_BROADCAST_ENC_HEADER_SIZE 1
  ------------------
                  if (length + GC_BROADCAST_ENC_HEADER_SIZE > MAX_GC_PACKET_SIZE) {
  ------------------
  |  |   46|  1.55k|#define MAX_GC_PACKET_SIZE (MAX_GC_PACKET_CHUNK_SIZE * 100)
  |  |  ------------------
  |  |  |  |   30|  1.55k|#define MAX_GC_PACKET_CHUNK_SIZE 500
  |  |  ------------------
  ------------------
  |  Branch (2303:9): [True: 0, False: 1.55k]
  ------------------
 2304|      0|        LOGGER_ERROR(chat->log, "Failed to broadcast message: invalid length %u", length);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2305|      0|        return false;
 2306|      0|    }
 2307|       |
 2308|  1.55k|    uint8_t *packet = (uint8_t *)malloc(length + GC_BROADCAST_ENC_HEADER_SIZE);
  ------------------
  |  |   53|  1.55k|#define GC_BROADCAST_ENC_HEADER_SIZE 1
  ------------------
 2309|       |
 2310|  1.55k|    if (packet == nullptr) {
  ------------------
  |  |   66|  1.55k|#define nullptr NULL
  ------------------
  |  Branch (2310:9): [True: 0, False: 1.55k]
  ------------------
 2311|      0|        return false;
 2312|      0|    }
 2313|       |
 2314|  1.55k|    const uint16_t packet_len = make_gc_broadcast_header(data, length, packet, bc_type);
 2315|       |
 2316|  1.55k|    send_gc_lossless_packet_all_peers(chat, packet, packet_len, GP_BROADCAST);
 2317|       |
 2318|  1.55k|    free(packet);
 2319|       |
 2320|  1.55k|    return true;
 2321|  1.55k|}
group_chats.c:get_peer_number_of_peer_id:
  678|    283|{
  679|    283|    for (uint32_t i = 0; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (679:26): [True: 0, False: 283]
  ------------------
  680|      0|        if (chat->group[i].peer_id == peer_id) {
  ------------------
  |  Branch (680:13): [True: 0, False: 0]
  ------------------
  681|      0|            return i;
  682|      0|        }
  683|      0|    }
  684|       |
  685|    283|    return -1;
  686|    283|}
group_chats.c:kill_group_friend_connection:
  177|  4.14k|{
  178|  4.14k|    if (chat->friend_connection_id != -1) {
  ------------------
  |  Branch (178:9): [True: 18, False: 4.12k]
  ------------------
  179|     18|        m_kill_group_connection(c->messenger, chat);
  180|     18|    }
  181|  4.14k|}
group_chats.c:make_gc_broadcast_header:
 2285|  1.55k|{
 2286|  1.55k|    packet[0] = bc_type;
 2287|  1.55k|    const uint16_t header_len = sizeof(uint8_t);
 2288|       |
 2289|  1.55k|    if (data != nullptr && length > 0) {
  ------------------
  |  |   66|  3.11k|#define nullptr NULL
  ------------------
  |  Branch (2289:9): [True: 0, False: 1.55k]
  |  Branch (2289:28): [True: 0, False: 0]
  ------------------
 2290|      0|        memcpy(packet + header_len, data, length);
 2291|      0|    }
 2292|       |
 2293|  1.55k|    return length + header_len;
 2294|  1.55k|}
group_chats.c:send_gc_lossless_packet_all_peers:
 2252|  1.55k|{
 2253|  1.55k|    for (uint32_t i = 1; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (2253:26): [True: 0, False: 1.55k]
  ------------------
 2254|      0|        GC_Connection *gconn = get_gc_connection(chat, i);
 2255|       |
 2256|      0|        assert(gconn != nullptr);
 2257|       |
 2258|      0|        if (gconn->confirmed) {
  ------------------
  |  Branch (2258:13): [True: 0, False: 0]
  ------------------
 2259|      0|            send_lossless_group_packet(chat, gconn, data, length, type);
 2260|      0|        }
 2261|      0|    }
 2262|  1.55k|}
group_chats.c:get_new_peer_id:
  696|    283|{
  697|    283|    for (uint32_t i = 0; i < UINT32_MAX - 1; ++i) {
  ------------------
  |  Branch (697:26): [True: 283, False: 0]
  ------------------
  698|    283|        if (get_peer_number_of_peer_id(chat, i) == -1) {
  ------------------
  |  Branch (698:13): [True: 283, False: 0]
  ------------------
  699|    283|            return i;
  700|    283|        }
  701|    283|    }
  702|       |
  703|      0|    return UINT32_MAX;
  704|    283|}
group_chats.c:add_tcp_relays_to_chat:
 7236|    238|{
 7237|    238|    const Messenger *m = c->messenger;
 7238|       |
 7239|    238|    const uint32_t num_relays = tcp_connections_count(nc_get_tcp_c(m->net_crypto));
 7240|       |
 7241|    238|    if (num_relays == 0) {
  ------------------
  |  Branch (7241:9): [True: 238, False: 0]
  ------------------
 7242|    238|        return;
 7243|    238|    }
 7244|       |
 7245|      0|    Node_format *tcp_relays = (Node_format *)calloc(num_relays, sizeof(Node_format));
 7246|       |
 7247|      0|    if (tcp_relays == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (7247:9): [True: 0, False: 0]
  ------------------
 7248|      0|        return;
 7249|      0|    }
 7250|       |
 7251|      0|    const uint32_t num_copied = tcp_copy_connected_relays(nc_get_tcp_c(m->net_crypto), tcp_relays, (uint16_t)num_relays);
 7252|       |
 7253|      0|    for (uint32_t i = 0; i < num_copied; ++i) {
  ------------------
  |  Branch (7253:26): [True: 0, False: 0]
  ------------------
 7254|      0|        add_tcp_relay_global(chat->tcp_conn, &tcp_relays[i].ip_port, tcp_relays[i].public_key);
 7255|      0|    }
 7256|       |
 7257|      0|    free(tcp_relays);
 7258|      0|}
group_chats.c:get_new_group_index:
 7208|  27.4k|{
 7209|  27.4k|    if (c == nullptr) {
  ------------------
  |  |   66|  27.4k|#define nullptr NULL
  ------------------
  |  Branch (7209:9): [True: 0, False: 27.4k]
  ------------------
 7210|      0|        return -1;
 7211|      0|    }
 7212|       |
 7213|   361k|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (7213:26): [True: 355k, False: 5.34k]
  ------------------
 7214|   355k|        if (c->chats[i].connection_state == CS_NONE) {
  ------------------
  |  Branch (7214:13): [True: 22.0k, False: 333k]
  ------------------
 7215|  22.0k|            return i;
 7216|  22.0k|        }
 7217|   355k|    }
 7218|       |
 7219|  5.34k|    if (!realloc_groupchats(c, c->chats_index + 1)) {
  ------------------
  |  Branch (7219:9): [True: 0, False: 5.34k]
  ------------------
 7220|      0|        return -1;
 7221|      0|    }
 7222|       |
 7223|  5.34k|    const int new_index = c->chats_index;
 7224|       |
 7225|  5.34k|    c->chats[new_index] = empty_gc_chat;
 7226|       |
 7227|  5.34k|    memset(&c->chats[new_index].saved_invites, -1, sizeof(c->chats[new_index].saved_invites));
 7228|       |
 7229|  5.34k|    ++c->chats_index;
 7230|       |
 7231|  5.34k|    return new_index;
 7232|  5.34k|}
group_chats.c:realloc_groupchats:
 7189|  5.34k|{
 7190|  5.34k|    if (n == 0) {
  ------------------
  |  Branch (7190:9): [True: 0, False: 5.34k]
  ------------------
 7191|      0|        free(c->chats);
 7192|      0|        c->chats = nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 7193|      0|        return true;
 7194|      0|    }
 7195|       |
 7196|  5.34k|    GC_Chat *temp = (GC_Chat *)realloc(c->chats, n * sizeof(GC_Chat));
 7197|       |
 7198|  5.34k|    if (temp == nullptr) {
  ------------------
  |  |   66|  5.34k|#define nullptr NULL
  ------------------
  |  Branch (7198:9): [True: 0, False: 5.34k]
  ------------------
 7199|      0|        return false;
 7200|      0|    }
 7201|       |
 7202|  5.34k|    c->chats = temp;
 7203|  5.34k|    return true;
 7204|  5.34k|}
group_chats.c:init_gc_moderation:
 7313|    238|{
 7314|    238|    memcpy(chat->moderation.founder_public_sig_key,
 7315|    238|           get_sig_pk(chat->shared_state.founder_public_key), SIG_PUBLIC_KEY_SIZE);
  ------------------
  |  |   29|    238|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   30|    238|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
 7316|    238|    memcpy(chat->moderation.self_public_sig_key, get_sig_pk(chat->self_public_key), SIG_PUBLIC_KEY_SIZE);
  ------------------
  |  |   29|    238|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   30|    238|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
 7317|    238|    memcpy(chat->moderation.self_secret_sig_key, get_sig_pk(chat->self_secret_key), SIG_SECRET_KEY_SIZE);
  ------------------
  |  |   30|    238|#define SIG_SECRET_KEY_SIZE CRYPTO_SIGN_SECRET_KEY_SIZE
  |  |  ------------------
  |  |  |  |   35|    238|#define CRYPTO_SIGN_SECRET_KEY_SIZE    64
  |  |  ------------------
  ------------------
 7318|    238|    chat->moderation.shared_state_version = chat->shared_state.version;
 7319|    238|    chat->moderation.log = chat->log;
 7320|    238|    chat->moderation.mem = chat->mem;
 7321|    238|}
group_chats.c:init_gc_tcp_connection:
 7262|    238|{
 7263|    238|    const Messenger *m = c->messenger;
 7264|       |
 7265|    238|    chat->tcp_conn = new_tcp_connections(chat->log, chat->mem, chat->rng, m->ns, chat->mono_time, chat->self_secret_key,
 7266|    238|                                         &m->options.proxy_info);
 7267|       |
 7268|    238|    if (chat->tcp_conn == nullptr) {
  ------------------
  |  |   66|    238|#define nullptr NULL
  ------------------
  |  Branch (7268:9): [True: 0, False: 238]
  ------------------
 7269|      0|        return false;
 7270|      0|    }
 7271|       |
 7272|    238|    add_tcp_relays_to_chat(c, chat);
 7273|       |
 7274|    238|    set_packet_tcp_connection_callback(chat->tcp_conn, &handle_gc_tcp_packet, c->messenger);
 7275|    238|    set_oob_packet_tcp_connection_callback(chat->tcp_conn, &handle_gc_tcp_oob_packet, c->messenger);
 7276|       |
 7277|    238|    return true;
 7278|    238|}
group_chats.c:is_public_chat:
  494|    236|{
  495|    236|    return chat->shared_state.privacy_state == GI_PUBLIC;
  496|    236|}
group_chats.c:group_can_handle_packets:
 6248|  4.14k|{
 6249|  4.14k|    const GC_Conn_State state = chat->connection_state;
 6250|  4.14k|    return state == CS_CONNECTING || state == CS_CONNECTED;
  ------------------
  |  Branch (6250:12): [True: 1.55k, False: 2.58k]
  |  Branch (6250:38): [True: 0, False: 2.58k]
  ------------------
 6251|  4.14k|}
group_chats.c:send_gc_self_exit:
 3358|  1.55k|{
 3359|  1.55k|    if (length > MAX_GC_PART_MESSAGE_SIZE) {
  ------------------
  |  |   19|  1.55k|#define MAX_GC_PART_MESSAGE_SIZE 128
  ------------------
  |  Branch (3359:9): [True: 0, False: 1.55k]
  ------------------
 3360|      0|        return -1;
 3361|      0|    }
 3362|       |
 3363|  1.55k|    if (!send_gc_broadcast_message(chat, partmessage, length, GM_PEER_EXIT)) {
  ------------------
  |  Branch (3363:9): [True: 0, False: 1.55k]
  ------------------
 3364|      0|        return -2;
 3365|      0|    }
 3366|       |
 3367|  1.55k|    return 0;
 3368|  1.55k|}
group_chats.c:group_cleanup:
 8116|  4.14k|{
 8117|  4.14k|    kill_group_friend_connection(c, chat);
 8118|       |
 8119|  4.14k|    mod_list_cleanup(&chat->moderation);
 8120|  4.14k|    sanctions_list_cleanup(&chat->moderation);
 8121|       |
 8122|  4.14k|    if (chat->tcp_conn != nullptr) {
  ------------------
  |  |   66|  4.14k|#define nullptr NULL
  ------------------
  |  Branch (8122:9): [True: 238, False: 3.90k]
  ------------------
 8123|    238|        kill_tcp_connections(chat->tcp_conn);
 8124|    238|    }
 8125|       |
 8126|  4.14k|    gcc_cleanup(chat);
 8127|       |
 8128|  4.14k|    if (chat->group != nullptr) {
  ------------------
  |  |   66|  4.14k|#define nullptr NULL
  ------------------
  |  Branch (8128:9): [True: 283, False: 3.86k]
  ------------------
 8129|    283|        free(chat->group);
 8130|    283|        chat->group = nullptr;
  ------------------
  |  |   66|    283|#define nullptr NULL
  ------------------
 8131|    283|    }
 8132|       |
 8133|  4.14k|    crypto_memunlock(chat->self_secret_key, sizeof(chat->self_secret_key));
 8134|  4.14k|    crypto_memunlock(chat->chat_secret_key, sizeof(chat->chat_secret_key));
 8135|  4.14k|    crypto_memunlock(chat->shared_state.password, sizeof(chat->shared_state.password));
 8136|  4.14k|}
group_chats.c:create_gc_session_keypair:
 8286|    283|{
 8287|    283|    if (crypto_new_keypair(rng, public_key, secret_key) != 0) {
  ------------------
  |  Branch (8287:9): [True: 0, False: 283]
  ------------------
 8288|      0|        LOGGER_FATAL(log, "Failed to create group session keypair");
  ------------------
  |  |   86|      0|    do {                                \
  |  |   87|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   88|      0|        abort();                        \
  |  |   89|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (89:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 8289|      0|    }
 8290|    283|}

gcc_set_send_message_id:
   76|    283|{
   77|    283|    gconn->send_message_id = id;
   78|    283|    gconn->send_array_start = id % GCC_BUFFER_SIZE;
  ------------------
  |  |   49|    283|#define GCC_BUFFER_SIZE 8192
  ------------------
   79|    283|}
gcc_set_ip_port:
  265|    283|{
  266|    283|    if (ipp != nullptr && ipport_isset(ipp)) {
  ------------------
  |  |   66|    566|#define nullptr NULL
  ------------------
  |  Branch (266:9): [True: 0, False: 283]
  |  Branch (266:27): [True: 0, False: 0]
  ------------------
  267|      0|        gconn->addr.ip_port = *ipp;
  268|      0|    }
  269|    283|}
gcc_peer_cleanup:
  683|    283|{
  684|  2.31M|    for (size_t i = 0; i < GCC_BUFFER_SIZE; ++i) {
  ------------------
  |  |   49|  2.31M|#define GCC_BUFFER_SIZE 8192
  ------------------
  |  Branch (684:24): [True: 2.31M, False: 283]
  ------------------
  685|  2.31M|        free(gconn->send_array[i].data);
  686|  2.31M|        free(gconn->recv_array[i].data);
  687|  2.31M|    }
  688|       |
  689|    283|    free(gconn->recv_array);
  690|    283|    free(gconn->send_array);
  691|       |
  692|    283|    crypto_memunlock(gconn->session_secret_key, sizeof(gconn->session_secret_key));
  693|    283|    crypto_memunlock(gconn->session_shared_key, sizeof(gconn->session_shared_key));
  694|    283|    crypto_memzero(gconn, sizeof(GC_Connection));
  695|    283|}
gcc_cleanup:
  698|  4.14k|{
  699|  4.42k|    for (uint32_t i = 0; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (699:26): [True: 283, False: 4.14k]
  ------------------
  700|    283|        GC_Connection *gconn = get_gc_connection(chat, i);
  701|    283|        assert(gconn != nullptr);
  702|       |
  703|      0|        gcc_peer_cleanup(gconn);
  704|    283|    }
  705|  4.14k|}

mod_list_unpack:
   41|    311|{
   42|    311|    if (length < num_mods * MOD_LIST_ENTRY_SIZE) {
  ------------------
  |  |   24|    311|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|    311|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    311|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (42:9): [True: 0, False: 311]
  ------------------
   43|      0|        return -1;
   44|      0|    }
   45|       |
   46|    311|    mod_list_cleanup(moderation);
   47|       |
   48|    311|    if (num_mods == 0) {
  ------------------
  |  Branch (48:9): [True: 0, False: 311]
  ------------------
   49|      0|        return 0;
   50|      0|    }
   51|       |
   52|    311|    uint8_t **tmp_list = (uint8_t **)calloc(num_mods, sizeof(uint8_t *));
   53|       |
   54|    311|    if (tmp_list == nullptr) {
  ------------------
  |  |   66|    311|#define nullptr NULL
  ------------------
  |  Branch (54:9): [True: 0, False: 311]
  ------------------
   55|      0|        return -1;
   56|      0|    }
   57|       |
   58|    311|    uint16_t unpacked_len = 0;
   59|       |
   60|    627|    for (uint16_t i = 0; i < num_mods; ++i) {
  ------------------
  |  Branch (60:26): [True: 316, False: 311]
  ------------------
   61|    316|        tmp_list[i] = (uint8_t *)malloc(sizeof(uint8_t) * MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   24|    316|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|    316|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    316|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   62|       |
   63|    316|        if (tmp_list[i] == nullptr) {
  ------------------
  |  |   66|    316|#define nullptr NULL
  ------------------
  |  Branch (63:13): [True: 0, False: 316]
  ------------------
   64|      0|            free_uint8_t_pointer_array(moderation->mem, tmp_list, i);
   65|      0|            return -1;
   66|      0|        }
   67|       |
   68|    316|        memcpy(tmp_list[i], &data[i * MOD_LIST_ENTRY_SIZE], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   24|    316|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|    316|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    316|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      memcpy(tmp_list[i], &data[i * MOD_LIST_ENTRY_SIZE], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   24|    316|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|    316|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    316|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   69|    316|        unpacked_len += MOD_LIST_ENTRY_SIZE;
  ------------------
  |  |   24|    316|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|    316|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    316|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   70|    316|    }
   71|       |
   72|    311|    moderation->mod_list = tmp_list;
   73|    311|    moderation->num_mods = num_mods;
   74|       |
   75|    311|    return unpacked_len;
   76|    311|}
mod_list_pack:
   79|    416|{
   80|    836|    for (uint16_t i = 0; i < moderation->num_mods; ++i) {
  ------------------
  |  Branch (80:26): [True: 420, False: 416]
  ------------------
   81|    420|        memcpy(&data[i * MOD_LIST_ENTRY_SIZE], moderation->mod_list[i], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   24|    420|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|    420|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    420|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      memcpy(&data[i * MOD_LIST_ENTRY_SIZE], moderation->mod_list[i], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   24|    420|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|    420|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    420|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   82|    420|    }
   83|    416|}
mod_list_cleanup:
  223|  4.45k|{
  224|  4.45k|    free_uint8_t_pointer_array(moderation->mem, moderation->mod_list, moderation->num_mods);
  225|  4.45k|    moderation->num_mods = 0;
  226|  4.45k|    moderation->mod_list = nullptr;
  ------------------
  |  |   66|  4.45k|#define nullptr NULL
  ------------------
  227|  4.45k|}
sanctions_list_cleanup:
  861|  4.14k|{
  862|  4.14k|    if (moderation->sanctions != nullptr) {
  ------------------
  |  |   66|  4.14k|#define nullptr NULL
  ------------------
  |  Branch (862:9): [True: 0, False: 4.14k]
  ------------------
  863|      0|        free(moderation->sanctions);
  864|      0|    }
  865|       |
  866|  4.14k|    moderation->sanctions = nullptr;
  ------------------
  |  |   66|  4.14k|#define nullptr NULL
  ------------------
  867|  4.14k|    moderation->num_sanctions = 0;
  868|  4.14k|}

gca_onion_init:
   64|  2.14k|{
   65|  2.14k|    onion_announce_extra_data_callback(onion_a, GCA_MAX_SENT_ANNOUNCES * sizeof(GC_Announce), pack_group_announces,
  ------------------
  |  |   27|  2.14k|#define GCA_MAX_SENT_ANNOUNCES 4
  ------------------
   66|  2.14k|                                       group_announce);
   67|  2.14k|}

gc_load_unpack_group:
  267|  27.4k|{
  268|  27.4k|    uint32_t actual_size;
  269|  27.4k|    if (!bin_unpack_array_fixed(bu, 7, &actual_size)) {
  ------------------
  |  Branch (269:9): [True: 4.59k, False: 22.8k]
  ------------------
  270|  4.59k|        LOGGER_ERROR(chat->log, "Group info array malformed: %d != 7", actual_size);
  ------------------
  |  |   83|  4.59k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  4.59k|    do {                                                                         \
  |  |  |  |   73|  4.59k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  9.19k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|  4.59k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|  4.59k|        }                                                                        \
  |  |  |  |   76|  4.59k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  271|  4.59k|        return false;
  272|  4.59k|    }
  273|       |
  274|  22.8k|    return load_unpack_state_values(chat, bu)
  ------------------
  |  Branch (274:12): [True: 4.14k, False: 18.6k]
  ------------------
  275|  22.8k|           && load_unpack_state_bin(chat, bu)
  ------------------
  |  Branch (275:15): [True: 696, False: 3.44k]
  ------------------
  276|  22.8k|           && load_unpack_topic_info(chat, bu)
  ------------------
  |  Branch (276:15): [True: 600, False: 96]
  ------------------
  277|  22.8k|           && load_unpack_mod_list(chat, bu)
  ------------------
  |  Branch (277:15): [True: 490, False: 110]
  ------------------
  278|  22.8k|           && load_unpack_keys(chat, bu)
  ------------------
  |  Branch (278:15): [True: 314, False: 176]
  ------------------
  279|  22.8k|           && load_unpack_self_info(chat, bu)
  ------------------
  |  Branch (279:15): [True: 283, False: 31]
  ------------------
  280|  22.8k|           && load_unpack_saved_peers(chat, bu);
  ------------------
  |  Branch (280:15): [True: 238, False: 45]
  ------------------
  281|  27.4k|}
gc_save_pack_group:
  418|  3.83k|{
  419|  3.83k|    if (chat->numpeers == 0) {
  ------------------
  |  Branch (419:9): [True: 3.41k, False: 420]
  ------------------
  420|  3.41k|        LOGGER_ERROR(chat->log, "Failed to pack group: numpeers is 0");
  ------------------
  |  |   83|  3.41k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  3.41k|    do {                                                                         \
  |  |  |  |   73|  3.41k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  6.82k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|  3.41k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|  3.41k|        }                                                                        \
  |  |  |  |   76|  3.41k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  421|  3.41k|        return;
  422|  3.41k|    }
  423|       |
  424|    420|    bin_pack_array(bp, 7);
  425|       |
  426|    420|    save_pack_state_values(chat, bp); // 1
  427|    420|    save_pack_state_bin(chat, bp); // 2
  428|    420|    save_pack_topic_info(chat, bp); // 3
  429|    420|    save_pack_mod_list(chat, bp); // 4
  430|    420|    save_pack_keys(chat, bp); // 5
  431|    420|    save_pack_self_info(chat, bp); // 6
  432|    420|    save_pack_saved_peers(chat, bp); // 7
  433|    420|}
group_pack.c:load_unpack_state_values:
   24|  22.8k|{
   25|  22.8k|    if (!bin_unpack_array_fixed(bu, 8, nullptr)) {
  ------------------
  |  |   66|  22.8k|#define nullptr NULL
  ------------------
  |  Branch (25:9): [True: 160, False: 22.6k]
  ------------------
   26|    160|        LOGGER_ERROR(chat->log, "Group state values array malformed");
  ------------------
  |  |   83|    160|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    160|    do {                                                                         \
  |  |  |  |   73|    160|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    320|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    160|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    160|        }                                                                        \
  |  |  |  |   76|    160|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   27|    160|        return false;
   28|    160|    }
   29|       |
   30|  22.6k|    bool manually_disconnected = false;
   31|  22.6k|    uint8_t privacy_state = 0;
   32|  22.6k|    uint8_t voice_state = 0;
   33|       |
   34|  22.6k|    if (!(bin_unpack_bool(bu, &manually_disconnected)
  ------------------
  |  Branch (34:11): [True: 20.3k, False: 2.28k]
  ------------------
   35|  22.6k|            && bin_unpack_u16(bu, &chat->shared_state.group_name_len)
  ------------------
  |  Branch (35:16): [True: 19.3k, False: 1.03k]
  ------------------
   36|  22.6k|            && bin_unpack_u08(bu, &privacy_state)
  ------------------
  |  Branch (36:16): [True: 18.2k, False: 1.10k]
  ------------------
   37|  22.6k|            && bin_unpack_u16(bu, &chat->shared_state.maxpeers)
  ------------------
  |  Branch (37:16): [True: 15.9k, False: 2.22k]
  ------------------
   38|  22.6k|            && bin_unpack_u16(bu, &chat->shared_state.password_length)
  ------------------
  |  Branch (38:16): [True: 15.5k, False: 407]
  ------------------
   39|  22.6k|            && bin_unpack_u32(bu, &chat->shared_state.version)
  ------------------
  |  Branch (39:16): [True: 14.4k, False: 1.09k]
  ------------------
   40|  22.6k|            && bin_unpack_u32(bu, &chat->shared_state.topic_lock)
  ------------------
  |  Branch (40:16): [True: 10.2k, False: 4.28k]
  ------------------
   41|  22.6k|            && bin_unpack_u08(bu, &voice_state))) {
  ------------------
  |  Branch (41:16): [True: 4.14k, False: 6.07k]
  ------------------
   42|  18.5k|        LOGGER_ERROR(chat->log, "Failed to unpack state value");
  ------------------
  |  |   83|  18.5k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  18.5k|    do {                                                                         \
  |  |  |  |   73|  18.5k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  37.0k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|  18.5k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|  18.5k|        }                                                                        \
  |  |  |  |   76|  18.5k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   43|  18.5k|        return false;
   44|  18.5k|    }
   45|       |
   46|  4.14k|    chat->connection_state = manually_disconnected ? CS_DISCONNECTED : CS_CONNECTING;
  ------------------
  |  Branch (46:30): [True: 2.58k, False: 1.55k]
  ------------------
   47|  4.14k|    chat->shared_state.privacy_state = (Group_Privacy_State)privacy_state;
   48|  4.14k|    chat->shared_state.voice_state = (Group_Voice_State)voice_state;
   49|       |
   50|       |    // we always load saved groups as private in case the group became private while we were offline.
   51|       |    // this will have no detrimental effect if the group is public, as the correct privacy
   52|       |    // state will be set via sync.
   53|  4.14k|    chat->join_type = HJ_PRIVATE;
   54|       |
   55|  4.14k|    return true;
   56|  22.6k|}
group_pack.c:load_unpack_state_bin:
   60|  4.14k|{
   61|  4.14k|    if (!bin_unpack_array_fixed(bu, 5, nullptr)) {
  ------------------
  |  |   66|  4.14k|#define nullptr NULL
  ------------------
  |  Branch (61:9): [True: 834, False: 3.30k]
  ------------------
   62|    834|        LOGGER_ERROR(chat->log, "Group state binary array malformed");
  ------------------
  |  |   83|    834|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    834|    do {                                                                         \
  |  |  |  |   73|    834|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  1.66k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    834|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    834|        }                                                                        \
  |  |  |  |   76|    834|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   63|    834|        return false;
   64|    834|    }
   65|       |
   66|  3.30k|    if (!bin_unpack_bin_fixed(bu, chat->shared_state_sig, SIGNATURE_SIZE)) {
  ------------------
  |  |   41|  3.30k|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   25|  3.30k|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  |  Branch (66:9): [True: 2.41k, False: 896]
  ------------------
   67|  2.41k|        LOGGER_ERROR(chat->log, "Failed to unpack shared state signature");
  ------------------
  |  |   83|  2.41k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  2.41k|    do {                                                                         \
  |  |  |  |   73|  2.41k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  4.82k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|  2.41k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|  2.41k|        }                                                                        \
  |  |  |  |   76|  2.41k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   68|  2.41k|        return false;
   69|  2.41k|    }
   70|       |
   71|    896|    if (!bin_unpack_bin_fixed(bu, chat->shared_state.founder_public_key, EXT_PUBLIC_KEY_SIZE)) {
  ------------------
  |  |   37|    896|#define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   27|    896|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    896|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   29|    896|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    896|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (71:9): [True: 54, False: 842]
  ------------------
   72|     54|        LOGGER_ERROR(chat->log, "Failed to unpack founder public key");
  ------------------
  |  |   83|     54|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     54|    do {                                                                         \
  |  |  |  |   73|     54|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    108|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     54|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     54|        }                                                                        \
  |  |  |  |   76|     54|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   73|     54|        return false;
   74|     54|    }
   75|       |
   76|    842|    if (!(bin_unpack_bin_max(bu, chat->shared_state.group_name, &chat->shared_state.group_name_len, sizeof(chat->shared_state.group_name))
  ------------------
  |  Branch (76:11): [True: 806, False: 36]
  ------------------
   77|    842|            && bin_unpack_bin_max(bu, chat->shared_state.password, &chat->shared_state.password_length, sizeof(chat->shared_state.password))
  ------------------
  |  Branch (77:16): [True: 711, False: 95]
  ------------------
   78|    842|            && bin_unpack_bin_fixed(bu, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE))) {
  ------------------
  |  |   23|    711|#define MOD_MODERATION_HASH_SIZE CRYPTO_SHA256_SIZE
  |  |  ------------------
  |  |  |  |   71|    711|#define CRYPTO_SHA256_SIZE             32
  |  |  ------------------
  ------------------
  |  Branch (78:16): [True: 696, False: 15]
  ------------------
   79|    146|        LOGGER_ERROR(chat->log, "Failed to unpack state binary data");
  ------------------
  |  |   83|    146|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    146|    do {                                                                         \
  |  |  |  |   73|    146|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    292|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    146|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    146|        }                                                                        \
  |  |  |  |   76|    146|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   80|    146|        return false;
   81|    146|    }
   82|       |
   83|    696|    return true;
   84|    842|}
group_pack.c:load_unpack_topic_info:
   88|    696|{
   89|    696|    if (!bin_unpack_array_fixed(bu, 6, nullptr)) {
  ------------------
  |  |   66|    696|#define nullptr NULL
  ------------------
  |  Branch (89:9): [True: 18, False: 678]
  ------------------
   90|     18|        LOGGER_ERROR(chat->log, "Group topic array malformed");
  ------------------
  |  |   83|     18|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     18|    do {                                                                         \
  |  |  |  |   73|     18|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     36|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     18|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     18|        }                                                                        \
  |  |  |  |   76|     18|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   91|     18|        return false;
   92|     18|    }
   93|       |
   94|    678|    if (!(bin_unpack_u32(bu, &chat->topic_info.version)
  ------------------
  |  Branch (94:11): [True: 665, False: 13]
  ------------------
   95|    678|            && bin_unpack_u16(bu, &chat->topic_info.length)
  ------------------
  |  Branch (95:16): [True: 655, False: 10]
  ------------------
   96|    678|            && bin_unpack_u16(bu, &chat->topic_info.checksum)
  ------------------
  |  Branch (96:16): [True: 645, False: 10]
  ------------------
   97|    678|            && bin_unpack_bin_max(bu, chat->topic_info.topic, &chat->topic_info.length, sizeof(chat->topic_info.topic))
  ------------------
  |  Branch (97:16): [True: 626, False: 19]
  ------------------
   98|    678|            && bin_unpack_bin_fixed(bu, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE)
  ------------------
  |  |   29|    626|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   30|    626|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
  |  Branch (98:16): [True: 616, False: 10]
  ------------------
   99|    678|            && bin_unpack_bin_fixed(bu, chat->topic_sig, SIGNATURE_SIZE))) {
  ------------------
  |  |   41|    616|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   25|    616|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  |  Branch (99:16): [True: 600, False: 16]
  ------------------
  100|     78|        LOGGER_ERROR(chat->log, "Failed to unpack topic info");
  ------------------
  |  |   83|     78|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     78|    do {                                                                         \
  |  |  |  |   73|     78|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    156|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     78|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     78|        }                                                                        \
  |  |  |  |   76|     78|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  101|     78|        return false;
  102|     78|    }
  103|       |
  104|    600|    return true;
  105|    678|}
group_pack.c:load_unpack_mod_list:
  109|    600|{
  110|    600|    uint32_t actual_size = 0;
  111|    600|    if (!bin_unpack_array_fixed(bu, 2, &actual_size)) {
  ------------------
  |  Branch (111:9): [True: 12, False: 588]
  ------------------
  112|     12|        LOGGER_ERROR(chat->log, "Group mod list array malformed: %d != 2", actual_size);
  ------------------
  |  |   83|     12|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     12|    do {                                                                         \
  |  |  |  |   73|     12|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     24|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     12|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     12|        }                                                                        \
  |  |  |  |   76|     12|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  113|     12|        return false;
  114|     12|    }
  115|       |
  116|    588|    if (!bin_unpack_u16(bu, &chat->moderation.num_mods)) {
  ------------------
  |  Branch (116:9): [True: 70, False: 518]
  ------------------
  117|     70|        LOGGER_ERROR(chat->log, "Failed to unpack mod list value");
  ------------------
  |  |   83|     70|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     70|    do {                                                                         \
  |  |  |  |   73|     70|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    140|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     70|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     70|        }                                                                        \
  |  |  |  |   76|     70|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  118|     70|        return false;
  119|     70|    }
  120|       |
  121|    518|    if (chat->moderation.num_mods == 0) {
  ------------------
  |  Branch (121:9): [True: 179, False: 339]
  ------------------
  122|    179|        bin_unpack_nil(bu);
  123|    179|        return true;
  124|    179|    }
  125|       |
  126|    339|    if (chat->moderation.num_mods > MOD_MAX_NUM_MODERATORS) {
  ------------------
  |  |   43|    339|#define MOD_MAX_NUM_MODERATORS       ((MOD_MAX_NUM_MODERATORS_LIMIT / 16) + 3)
  |  |  ------------------
  |  |  |  |   40|    339|#define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   37|    339|#define MAX_PACKET_SIZE_NO_HEADERS 49900
  |  |  |  |  ------------------
  |  |  |  |               #define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   24|    339|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   29|    339|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   30|    339|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (126:9): [True: 18, False: 321]
  ------------------
  127|     18|        LOGGER_ERROR(chat->log, "moderation count %u exceeds maximum %u", chat->moderation.num_mods, MOD_MAX_NUM_MODERATORS);
  ------------------
  |  |   83|     18|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     18|    do {                                                                         \
  |  |  |  |   73|     18|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     36|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     18|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     18|        }                                                                        \
  |  |  |  |   76|     18|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  128|     18|        return false;
  129|     18|    }
  130|       |
  131|    321|    uint8_t *packed_mod_list = (uint8_t *)malloc(chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   24|    321|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|    321|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    321|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  132|       |
  133|    321|    if (packed_mod_list == nullptr) {
  ------------------
  |  |   66|    321|#define nullptr NULL
  ------------------
  |  Branch (133:9): [True: 0, False: 321]
  ------------------
  134|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for packed mod list");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  135|      0|        return false;
  136|      0|    }
  137|       |
  138|    321|    const size_t packed_size = chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE;
  ------------------
  |  |   24|    321|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|    321|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    321|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  139|       |
  140|    321|    if (!bin_unpack_bin_fixed(bu, packed_mod_list, packed_size)) {
  ------------------
  |  Branch (140:9): [True: 10, False: 311]
  ------------------
  141|     10|        LOGGER_ERROR(chat->log, "Failed to unpack mod list binary data");
  ------------------
  |  |   83|     10|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     10|    do {                                                                         \
  |  |  |  |   73|     10|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     20|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     10|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     10|        }                                                                        \
  |  |  |  |   76|     10|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  142|     10|        free(packed_mod_list);
  143|     10|        return false;
  144|     10|    }
  145|       |
  146|    311|    if (mod_list_unpack(&chat->moderation, packed_mod_list, packed_size, chat->moderation.num_mods) == -1) {
  ------------------
  |  Branch (146:9): [True: 0, False: 311]
  ------------------
  147|      0|        LOGGER_ERROR(chat->log, "Failed to unpack mod list info");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  148|      0|        free(packed_mod_list);
  149|      0|        return false;
  150|      0|    }
  151|       |
  152|    311|    free(packed_mod_list);
  153|       |
  154|    311|    return true;
  155|    311|}
group_pack.c:load_unpack_keys:
  159|    490|{
  160|    490|    if (!bin_unpack_array_fixed(bu, 4, nullptr)) {
  ------------------
  |  |   66|    490|#define nullptr NULL
  ------------------
  |  Branch (160:9): [True: 95, False: 395]
  ------------------
  161|     95|        LOGGER_ERROR(chat->log, "Group keys array malformed");
  ------------------
  |  |   83|     95|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     95|    do {                                                                         \
  |  |  |  |   73|     95|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    190|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     95|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     95|        }                                                                        \
  |  |  |  |   76|     95|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  162|     95|        return false;
  163|     95|    }
  164|       |
  165|    395|    if (!(bin_unpack_bin_fixed(bu, chat->chat_public_key, EXT_PUBLIC_KEY_SIZE)
  ------------------
  |  |   37|    395|#define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   27|    395|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    395|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   29|    395|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    395|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (165:11): [True: 377, False: 18]
  ------------------
  166|    395|            && bin_unpack_bin_fixed(bu, chat->chat_secret_key, EXT_SECRET_KEY_SIZE)
  ------------------
  |  |   36|    377|#define EXT_SECRET_KEY_SIZE (ENC_SECRET_KEY_SIZE + SIG_SECRET_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   28|    377|#define ENC_SECRET_KEY_SIZE CRYPTO_SECRET_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   45|    377|#define CRYPTO_SECRET_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_SECRET_KEY_SIZE (ENC_SECRET_KEY_SIZE + SIG_SECRET_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   30|    377|#define SIG_SECRET_KEY_SIZE CRYPTO_SIGN_SECRET_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   35|    377|#define CRYPTO_SIGN_SECRET_KEY_SIZE    64
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (166:16): [True: 343, False: 34]
  ------------------
  167|    395|            && bin_unpack_bin_fixed(bu, chat->self_public_key, EXT_PUBLIC_KEY_SIZE)
  ------------------
  |  |   37|    343|#define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   27|    343|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    343|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   29|    343|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    343|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (167:16): [True: 332, False: 11]
  ------------------
  168|    395|            && bin_unpack_bin_fixed(bu, chat->self_secret_key, EXT_SECRET_KEY_SIZE))) {
  ------------------
  |  |   36|    332|#define EXT_SECRET_KEY_SIZE (ENC_SECRET_KEY_SIZE + SIG_SECRET_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   28|    332|#define ENC_SECRET_KEY_SIZE CRYPTO_SECRET_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   45|    332|#define CRYPTO_SECRET_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_SECRET_KEY_SIZE (ENC_SECRET_KEY_SIZE + SIG_SECRET_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   30|    332|#define SIG_SECRET_KEY_SIZE CRYPTO_SIGN_SECRET_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   35|    332|#define CRYPTO_SIGN_SECRET_KEY_SIZE    64
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (168:16): [True: 314, False: 18]
  ------------------
  169|     81|        LOGGER_ERROR(chat->log, "Failed to unpack keys");
  ------------------
  |  |   83|     81|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     81|    do {                                                                         \
  |  |  |  |   73|     81|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    162|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     81|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     81|        }                                                                        \
  |  |  |  |   76|     81|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  170|     81|        return false;
  171|     81|    }
  172|       |
  173|    314|    return true;
  174|    395|}
group_pack.c:load_unpack_self_info:
  178|    314|{
  179|    314|    if (!bin_unpack_array_fixed(bu, 4, nullptr)) {
  ------------------
  |  |   66|    314|#define nullptr NULL
  ------------------
  |  Branch (179:9): [True: 16, False: 298]
  ------------------
  180|     16|        LOGGER_ERROR(chat->log, "Group self info array malformed");
  ------------------
  |  |   83|     16|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     16|    do {                                                                         \
  |  |  |  |   73|     16|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     32|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     16|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     16|        }                                                                        \
  |  |  |  |   76|     16|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  181|     16|        return false;
  182|     16|    }
  183|       |
  184|    298|    uint8_t self_nick[MAX_GC_NICK_SIZE];
  185|    298|    uint16_t self_nick_len = 0;
  186|    298|    uint8_t self_role = GR_USER;
  187|    298|    uint8_t self_status = GS_NONE;
  188|       |
  189|    298|    if (!(bin_unpack_u16(bu, &self_nick_len)
  ------------------
  |  Branch (189:11): [True: 288, False: 10]
  ------------------
  190|    298|            && bin_unpack_u08(bu, &self_role)
  ------------------
  |  Branch (190:16): [True: 287, False: 1]
  ------------------
  191|    298|            && bin_unpack_u08(bu, &self_status))) {
  ------------------
  |  Branch (191:16): [True: 286, False: 1]
  ------------------
  192|     12|        LOGGER_ERROR(chat->log, "Failed to unpack self values");
  ------------------
  |  |   83|     12|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     12|    do {                                                                         \
  |  |  |  |   73|     12|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     24|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     12|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     12|        }                                                                        \
  |  |  |  |   76|     12|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  193|     12|        return false;
  194|     12|    }
  195|       |
  196|    286|    assert(self_nick_len <= MAX_GC_NICK_SIZE);
  197|       |
  198|    286|    if (!bin_unpack_bin_fixed(bu, self_nick, self_nick_len)) {
  ------------------
  |  Branch (198:9): [True: 3, False: 283]
  ------------------
  199|      3|        LOGGER_ERROR(chat->log, "Failed to unpack self nick bytes");
  ------------------
  |  |   83|      3|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      3|    do {                                                                         \
  |  |  |  |   73|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      3|        }                                                                        \
  |  |  |  |   76|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  200|      3|        return false;
  201|      3|    }
  202|       |
  203|       |    // we have to add ourself before setting self info
  204|    283|    if (peer_add(chat, nullptr, chat->self_public_key) != 0) {
  ------------------
  |  |   66|    283|#define nullptr NULL
  ------------------
  |  Branch (204:9): [True: 0, False: 283]
  ------------------
  205|      0|        LOGGER_ERROR(chat->log, "Failed to add self to peer list");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  206|      0|        return false;
  207|      0|    }
  208|       |
  209|    283|    assert(chat->numpeers > 0);
  210|       |
  211|      0|    GC_Peer *self = &chat->group[0];
  212|       |
  213|    283|    memcpy(self->gconn.addr.public_key, chat->self_public_key, EXT_PUBLIC_KEY_SIZE);
  ------------------
  |  |   37|    283|#define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   27|    283|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    283|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   29|    283|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    283|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  214|    283|    memcpy(self->nick, self_nick, self_nick_len);
  215|    283|    self->nick_length = self_nick_len;
  216|    283|    self->role = (Group_Role)self_role;
  217|    283|    self->status = (Group_Peer_Status)self_status;
  218|    283|    self->gconn.confirmed = true;
  219|       |
  220|    283|    return true;
  221|    283|}
group_pack.c:load_unpack_saved_peers:
  225|    283|{
  226|    283|    if (!bin_unpack_array_fixed(bu, 2, nullptr)) {
  ------------------
  |  |   66|    283|#define nullptr NULL
  ------------------
  |  Branch (226:9): [True: 25, False: 258]
  ------------------
  227|     25|        LOGGER_ERROR(chat->log, "Group saved peers array malformed");
  ------------------
  |  |   83|     25|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     25|    do {                                                                         \
  |  |  |  |   73|     25|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     50|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     25|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     25|        }                                                                        \
  |  |  |  |   76|     25|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  228|     25|        return false;
  229|     25|    }
  230|       |
  231|       |    // Saved peers
  232|    258|    uint16_t saved_peers_size = 0;
  233|       |
  234|    258|    if (!bin_unpack_u16(bu, &saved_peers_size)) {
  ------------------
  |  Branch (234:9): [True: 1, False: 257]
  ------------------
  235|      1|        LOGGER_ERROR(chat->log, "Failed to unpack saved peers value");
  ------------------
  |  |   83|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      1|    do {                                                                         \
  |  |  |  |   73|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      1|        }                                                                        \
  |  |  |  |   76|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  236|      1|        return false;
  237|      1|    }
  238|       |
  239|    257|    if (saved_peers_size == 0) {
  ------------------
  |  Branch (239:9): [True: 16, False: 241]
  ------------------
  240|     16|        bin_unpack_nil(bu);
  241|     16|        return true;
  242|     16|    }
  243|       |
  244|    241|    uint8_t *saved_peers = (uint8_t *)malloc(saved_peers_size * GC_SAVED_PEER_SIZE);
  ------------------
  |  |   43|    241|#define GC_SAVED_PEER_SIZE (ENC_PUBLIC_KEY_SIZE + sizeof(Node_format) + sizeof(IP_Port))
  |  |  ------------------
  |  |  |  |   27|    241|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    241|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  245|       |
  246|    241|    if (saved_peers == nullptr) {
  ------------------
  |  |   66|    241|#define nullptr NULL
  ------------------
  |  Branch (246:9): [True: 0, False: 241]
  ------------------
  247|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for saved peer list");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  248|      0|        return false;
  249|      0|    }
  250|       |
  251|    241|    if (!bin_unpack_bin_fixed(bu, saved_peers, saved_peers_size)) {
  ------------------
  |  Branch (251:9): [True: 19, False: 222]
  ------------------
  252|     19|        LOGGER_ERROR(chat->log, "Failed to unpack saved peers binary data");
  ------------------
  |  |   83|     19|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     19|    do {                                                                         \
  |  |  |  |   73|     19|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     38|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     19|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     19|        }                                                                        \
  |  |  |  |   76|     19|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  253|     19|        free(saved_peers);
  254|     19|        return false;
  255|     19|    }
  256|       |
  257|    222|    if (unpack_gc_saved_peers(chat, saved_peers, saved_peers_size) == -1) {
  ------------------
  |  Branch (257:9): [True: 210, False: 12]
  ------------------
  258|    210|        LOGGER_ERROR(chat->log, "Failed to unpack saved peers");  // recoverable error
  ------------------
  |  |   83|    210|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    210|    do {                                                                         \
  |  |  |  |   73|    210|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    420|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    210|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    210|        }                                                                        \
  |  |  |  |   76|    210|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  259|    210|    }
  260|       |
  261|    222|    free(saved_peers);
  262|       |
  263|    222|    return true;
  264|    241|}
group_pack.c:save_pack_state_values:
  285|    420|{
  286|    420|    bin_pack_array(bp, 8);
  287|    420|    bin_pack_bool(bp, chat->connection_state == CS_DISCONNECTED); // 1
  288|    420|    bin_pack_u16(bp, chat->shared_state.group_name_len); // 2
  289|    420|    bin_pack_u08(bp, chat->shared_state.privacy_state); // 3
  290|    420|    bin_pack_u16(bp, chat->shared_state.maxpeers); // 4
  291|    420|    bin_pack_u16(bp, chat->shared_state.password_length); // 5
  292|    420|    bin_pack_u32(bp, chat->shared_state.version); // 6
  293|    420|    bin_pack_u32(bp, chat->shared_state.topic_lock); // 7
  294|    420|    bin_pack_u08(bp, chat->shared_state.voice_state); // 8
  295|    420|}
group_pack.c:save_pack_state_bin:
  299|    420|{
  300|    420|    bin_pack_array(bp, 5);
  301|       |
  302|    420|    bin_pack_bin(bp, chat->shared_state_sig, SIGNATURE_SIZE); // 1
  ------------------
  |  |   41|    420|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   25|    420|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  303|    420|    bin_pack_bin(bp, chat->shared_state.founder_public_key, EXT_PUBLIC_KEY_SIZE); // 2
  ------------------
  |  |   37|    420|#define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   27|    420|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    420|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   29|    420|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    420|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  304|    420|    bin_pack_bin(bp, chat->shared_state.group_name, chat->shared_state.group_name_len); // 3
  305|    420|    bin_pack_bin(bp, chat->shared_state.password, chat->shared_state.password_length); // 4
  306|    420|    bin_pack_bin(bp, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE); // 5
  ------------------
  |  |   23|    420|#define MOD_MODERATION_HASH_SIZE CRYPTO_SHA256_SIZE
  |  |  ------------------
  |  |  |  |   71|    420|#define CRYPTO_SHA256_SIZE             32
  |  |  ------------------
  ------------------
  307|    420|}
group_pack.c:save_pack_topic_info:
  311|    420|{
  312|    420|    bin_pack_array(bp, 6);
  313|       |
  314|    420|    bin_pack_u32(bp, chat->topic_info.version); // 1
  315|    420|    bin_pack_u16(bp, chat->topic_info.length); // 2
  316|    420|    bin_pack_u16(bp, chat->topic_info.checksum); // 3
  317|    420|    bin_pack_bin(bp, chat->topic_info.topic, chat->topic_info.length); // 4
  318|    420|    bin_pack_bin(bp, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE); // 5
  ------------------
  |  |   29|    420|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   30|    420|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
  319|    420|    bin_pack_bin(bp, chat->topic_sig, SIGNATURE_SIZE); // 6
  ------------------
  |  |   41|    420|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   25|    420|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  320|    420|}
group_pack.c:save_pack_mod_list:
  324|    420|{
  325|    420|    bin_pack_array(bp, 2);
  326|       |
  327|    420|    const uint16_t num_mods = min_u16(chat->moderation.num_mods, MOD_MAX_NUM_MODERATORS);
  ------------------
  |  |   43|    420|#define MOD_MAX_NUM_MODERATORS       ((MOD_MAX_NUM_MODERATORS_LIMIT / 16) + 3)
  |  |  ------------------
  |  |  |  |   40|    420|#define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   37|    420|#define MAX_PACKET_SIZE_NO_HEADERS 49900
  |  |  |  |  ------------------
  |  |  |  |               #define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   24|    420|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   29|    420|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   30|    420|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  328|       |
  329|    420|    if (num_mods == 0) {
  ------------------
  |  Branch (329:9): [True: 4, False: 416]
  ------------------
  330|      4|        bin_pack_u16(bp, num_mods); // 1
  331|      4|        bin_pack_nil(bp); // 2
  332|      4|        return;
  333|      4|    }
  334|       |
  335|    416|    uint8_t *packed_mod_list = (uint8_t *)malloc(num_mods * MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   24|    416|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|    416|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    416|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  336|       |
  337|       |    // we can still recover without the mod list
  338|    416|    if (packed_mod_list == nullptr) {
  ------------------
  |  |   66|    416|#define nullptr NULL
  ------------------
  |  Branch (338:9): [True: 0, False: 416]
  ------------------
  339|      0|        bin_pack_u16(bp, 0); // 1
  340|      0|        bin_pack_nil(bp); // 2
  341|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for moderation list");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  342|      0|        return;
  343|      0|    }
  344|       |
  345|    416|    bin_pack_u16(bp, num_mods); // 1
  346|       |
  347|    416|    mod_list_pack(&chat->moderation, packed_mod_list);
  348|       |
  349|    416|    const size_t packed_size = num_mods * MOD_LIST_ENTRY_SIZE;
  ------------------
  |  |   24|    416|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   29|    416|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    416|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  350|       |
  351|    416|    bin_pack_bin(bp, packed_mod_list, packed_size); // 2
  352|       |
  353|    416|    free(packed_mod_list);
  354|    416|}
group_pack.c:save_pack_keys:
  358|    420|{
  359|    420|    bin_pack_array(bp, 4);
  360|       |
  361|    420|    bin_pack_bin(bp, chat->chat_public_key, EXT_PUBLIC_KEY_SIZE); // 1
  ------------------
  |  |   37|    420|#define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   27|    420|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    420|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   29|    420|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    420|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  362|    420|    bin_pack_bin(bp, chat->chat_secret_key, EXT_SECRET_KEY_SIZE); // 2
  ------------------
  |  |   36|    420|#define EXT_SECRET_KEY_SIZE (ENC_SECRET_KEY_SIZE + SIG_SECRET_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   28|    420|#define ENC_SECRET_KEY_SIZE CRYPTO_SECRET_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   45|    420|#define CRYPTO_SECRET_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_SECRET_KEY_SIZE (ENC_SECRET_KEY_SIZE + SIG_SECRET_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   30|    420|#define SIG_SECRET_KEY_SIZE CRYPTO_SIGN_SECRET_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   35|    420|#define CRYPTO_SIGN_SECRET_KEY_SIZE    64
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  363|    420|    bin_pack_bin(bp, chat->self_public_key, EXT_PUBLIC_KEY_SIZE); // 3
  ------------------
  |  |   37|    420|#define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   27|    420|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    420|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   29|    420|#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|    420|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  364|    420|    bin_pack_bin(bp, chat->self_secret_key, EXT_SECRET_KEY_SIZE); // 4
  ------------------
  |  |   36|    420|#define EXT_SECRET_KEY_SIZE (ENC_SECRET_KEY_SIZE + SIG_SECRET_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   28|    420|#define ENC_SECRET_KEY_SIZE CRYPTO_SECRET_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   45|    420|#define CRYPTO_SECRET_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define EXT_SECRET_KEY_SIZE (ENC_SECRET_KEY_SIZE + SIG_SECRET_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   30|    420|#define SIG_SECRET_KEY_SIZE CRYPTO_SIGN_SECRET_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   35|    420|#define CRYPTO_SIGN_SECRET_KEY_SIZE    64
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  365|    420|}
group_pack.c:save_pack_self_info:
  369|    420|{
  370|    420|    bin_pack_array(bp, 4);
  371|       |
  372|    420|    const GC_Peer *self = &chat->group[0];
  373|       |
  374|    420|    assert(self->nick_length <= MAX_GC_NICK_SIZE);
  375|       |
  376|      0|    bin_pack_u16(bp, self->nick_length); // 1
  377|    420|    bin_pack_u08(bp, (uint8_t)self->role); // 2
  378|    420|    bin_pack_u08(bp, (uint8_t)self->status); // 3
  379|    420|    bin_pack_bin(bp, self->nick, self->nick_length); // 4
  380|    420|}
group_pack.c:save_pack_saved_peers:
  384|    420|{
  385|    420|    bin_pack_array(bp, 2);
  386|       |
  387|    420|    uint8_t *saved_peers = (uint8_t *)malloc(GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE);
  ------------------
  |  |   42|    420|#define GC_MAX_SAVED_PEERS 100
  ------------------
                  uint8_t *saved_peers = (uint8_t *)malloc(GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE);
  ------------------
  |  |   43|    420|#define GC_SAVED_PEER_SIZE (ENC_PUBLIC_KEY_SIZE + sizeof(Node_format) + sizeof(IP_Port))
  |  |  ------------------
  |  |  |  |   27|    420|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    420|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  388|       |
  389|       |    // we can still recover without the saved peers list
  390|    420|    if (saved_peers == nullptr) {
  ------------------
  |  |   66|    420|#define nullptr NULL
  ------------------
  |  Branch (390:9): [True: 0, False: 420]
  ------------------
  391|      0|        bin_pack_u16(bp, 0); // 1
  392|      0|        bin_pack_nil(bp); // 2
  393|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for saved peers list");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  394|      0|        return;
  395|      0|    }
  396|       |
  397|    420|    uint16_t packed_size = 0;
  398|    420|    const int count = pack_gc_saved_peers(chat, saved_peers, GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE, &packed_size);
  ------------------
  |  |   42|    420|#define GC_MAX_SAVED_PEERS 100
  ------------------
                  const int count = pack_gc_saved_peers(chat, saved_peers, GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE, &packed_size);
  ------------------
  |  |   43|    420|#define GC_SAVED_PEER_SIZE (ENC_PUBLIC_KEY_SIZE + sizeof(Node_format) + sizeof(IP_Port))
  |  |  ------------------
  |  |  |  |   27|    420|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    420|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  399|       |
  400|    420|    if (count < 0) {
  ------------------
  |  Branch (400:9): [True: 0, False: 420]
  ------------------
  401|      0|        LOGGER_ERROR(chat->log, "Failed to pack saved peers");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  402|      0|    }
  403|       |
  404|    420|    bin_pack_u16(bp, packed_size); // 1
  405|       |
  406|    420|    if (packed_size == 0) {
  ------------------
  |  Branch (406:9): [True: 116, False: 304]
  ------------------
  407|    116|        bin_pack_nil(bp); // 2
  408|    116|        free(saved_peers);
  409|    116|        return;
  410|    116|    }
  411|       |
  412|    304|    bin_pack_bin(bp, saved_peers, packed_size); // 2
  413|       |
  414|    304|    free(saved_peers);
  415|    304|}

bs_list_init:
  138|  2.14k|{
  139|       |    // set initial values
  140|  2.14k|    list->n = 0;
  141|  2.14k|    list->element_size = element_size;
  142|  2.14k|    list->capacity = 0;
  143|  2.14k|    list->data = nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  144|  2.14k|    list->ids = nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  145|       |
  146|  2.14k|    if (initial_capacity != 0) {
  ------------------
  |  Branch (146:9): [True: 2.14k, False: 0]
  ------------------
  147|  2.14k|        if (!resize(list, initial_capacity)) {
  ------------------
  |  Branch (147:13): [True: 0, False: 2.14k]
  ------------------
  148|      0|            return 0;
  149|      0|        }
  150|  2.14k|    }
  151|       |
  152|  2.14k|    list->capacity = initial_capacity;
  153|       |
  154|  2.14k|    return 1;
  155|  2.14k|}
bs_list_free:
  158|  2.14k|{
  159|  2.14k|    if (list == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (159:9): [True: 0, False: 2.14k]
  ------------------
  160|      0|        return;
  161|      0|    }
  162|       |
  163|       |    // free both arrays
  164|  2.14k|    free(list->data);
  165|  2.14k|    list->data = nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  166|       |
  167|  2.14k|    free(list->ids);
  168|  2.14k|    list->ids = nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  169|  2.14k|}
list.c:resize:
  111|  2.14k|{
  112|  2.14k|    if (new_size == 0) {
  ------------------
  |  Branch (112:9): [True: 0, False: 2.14k]
  ------------------
  113|      0|        bs_list_free(list);
  114|      0|        return true;
  115|      0|    }
  116|       |
  117|  2.14k|    uint8_t *data = (uint8_t *)realloc(list->data, list->element_size * new_size);
  118|       |
  119|  2.14k|    if (data == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (119:9): [True: 0, False: 2.14k]
  ------------------
  120|      0|        return false;
  121|      0|    }
  122|       |
  123|  2.14k|    list->data = data;
  124|       |
  125|  2.14k|    int *ids = (int *)realloc(list->ids, sizeof(int) * new_size);
  126|       |
  127|  2.14k|    if (ids == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (127:9): [True: 0, False: 2.14k]
  ------------------
  128|      0|        return false;
  129|      0|    }
  130|       |
  131|  2.14k|    list->ids = ids;
  132|       |
  133|  2.14k|    return true;
  134|  2.14k|}

logger_new:
   72|  2.14k|{
   73|  2.14k|    return (Logger *)calloc(1, sizeof(Logger));
   74|  2.14k|}
logger_kill:
   77|  2.14k|{
   78|  2.14k|    free(log);
   79|  2.14k|}
logger_callback_log:
   82|  2.14k|{
   83|  2.14k|    log->callback = function;
   84|  2.14k|    log->context  = context;
   85|  2.14k|    log->userdata = userdata;
   86|  2.14k|}
logger_write:
   90|  86.9k|{
   91|  86.9k|    if (log == nullptr) {
  ------------------
  |  |   66|  86.9k|#define nullptr NULL
  ------------------
  |  Branch (91:9): [True: 0, False: 86.9k]
  ------------------
   92|      0|        log = &logger_stderr;
   93|      0|    }
   94|       |
   95|  86.9k|    if (log->callback == nullptr) {
  ------------------
  |  |   66|  86.9k|#define nullptr NULL
  ------------------
  |  Branch (95:9): [True: 0, False: 86.9k]
  ------------------
   96|      0|        return;
   97|      0|    }
   98|       |
   99|       |    // Only pass the file name, not the entire file path, for privacy reasons.
  100|       |    // The full path may contain PII of the person compiling toxcore (their
  101|       |    // username and directory layout).
  102|  86.9k|    const char *filename = strrchr(file, '/');
  103|  86.9k|    file = filename != nullptr ? filename + 1 : file;
  ------------------
  |  |   66|  86.9k|#define nullptr NULL
  ------------------
  |  Branch (103:12): [True: 86.9k, False: 0]
  ------------------
  104|       |#if defined(_WIN32) || defined(__CYGWIN__)
  105|       |    // On Windows, the path separator *may* be a backslash, so we look for that
  106|       |    // one too.
  107|       |    const char *windows_filename = strrchr(file, '\\');
  108|       |    file = windows_filename != nullptr ? windows_filename + 1 : file;
  109|       |#endif
  110|       |
  111|       |    // Format message
  112|  86.9k|    char msg[1024];
  113|  86.9k|    va_list args;
  114|  86.9k|    va_start(args, format);
  115|  86.9k|    vsnprintf(msg, sizeof(msg), format, args);
  116|  86.9k|    va_end(args);
  117|       |
  118|  86.9k|    log->callback(log->context, level, file, line, func, msg, log->userdata);
  119|  86.9k|}

system_memory:
   45|  2.14k|{
   46|  2.14k|    return &system_memory_obj;
   47|  2.14k|}
mem_alloc:
   56|  47.3k|{
   57|  47.3k|    void *const ptr = mem->funcs->calloc(mem->obj, 1, size);
   58|  47.3k|    return ptr;
   59|  47.3k|}
mem_valloc:
   62|  23.4k|{
   63|  23.4k|    const uint32_t bytes = nmemb * size;
   64|       |
   65|  23.4k|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (65:9): [True: 23.4k, False: 0]
  |  Branch (65:22): [True: 0, False: 23.4k]
  ------------------
   66|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   67|      0|    }
   68|       |
   69|  23.4k|    void *const ptr = mem->funcs->calloc(mem->obj, nmemb, size);
   70|  23.4k|    return ptr;
   71|  23.4k|}
mem_vrealloc:
   74|  24.1k|{
   75|  24.1k|    const uint32_t bytes = nmemb * size;
   76|       |
   77|  24.1k|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (77:9): [True: 24.1k, False: 0]
  |  Branch (77:22): [True: 0, False: 24.1k]
  ------------------
   78|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   79|      0|    }
   80|       |
   81|  24.1k|    void *const new_ptr = mem->funcs->realloc(mem->obj, ptr, bytes);
   82|  24.1k|    return new_ptr;
   83|  24.1k|}
mem_delete:
   86|  87.5k|{
   87|  87.5k|    mem->funcs->free(mem->obj, ptr);
   88|  87.5k|}

mono_time_new:
  126|  2.14k|{
  127|  2.14k|    Mono_Time *mono_time = (Mono_Time *)mem_alloc(mem, sizeof(Mono_Time));
  128|       |
  129|  2.14k|    if (mono_time == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (129:9): [True: 0, False: 2.14k]
  ------------------
  130|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  131|      0|    }
  132|       |
  133|  2.14k|#ifndef ESP_PLATFORM
  134|  2.14k|    mono_time->time_update_lock = (pthread_rwlock_t *)mem_alloc(mem, sizeof(pthread_rwlock_t));
  135|       |
  136|  2.14k|    if (mono_time->time_update_lock == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (136:9): [True: 0, False: 2.14k]
  ------------------
  137|      0|        mem_delete(mem, mono_time);
  138|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  139|      0|    }
  140|       |
  141|  2.14k|    if (pthread_rwlock_init(mono_time->time_update_lock, nullptr) != 0) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (141:9): [True: 0, False: 2.14k]
  ------------------
  142|      0|        mem_delete(mem, mono_time->time_update_lock);
  143|      0|        mem_delete(mem, mono_time);
  144|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  145|      0|    }
  146|  2.14k|#endif
  147|       |
  148|  2.14k|    mono_time_set_current_time_callback(mono_time, current_time_callback, user_data);
  149|       |
  150|       |#ifdef OS_WIN32
  151|       |
  152|       |    mono_time->last_clock_mono = 0;
  153|       |    mono_time->last_clock_update = false;
  154|       |
  155|       |    if (pthread_mutex_init(&mono_time->last_clock_lock, nullptr) < 0) {
  156|       |        mem_delete(mem, mono_time->time_update_lock);
  157|       |        mem_delete(mem, mono_time);
  158|       |        return nullptr;
  159|       |    }
  160|       |
  161|       |#endif
  162|       |
  163|  2.14k|    mono_time->cur_time = 0;
  164|  2.14k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  165|       |    // Maximum reproducibility. Never return time = 0.
  166|  2.14k|    mono_time->base_time = 1;
  167|       |#else
  168|       |    mono_time->base_time = (uint64_t)time(nullptr) * 1000ULL - current_time_monotonic(mono_time);
  169|       |#endif
  170|       |
  171|  2.14k|    mono_time_update(mono_time);
  172|       |
  173|  2.14k|    return mono_time;
  174|  2.14k|}
mono_time_free:
  177|  2.14k|{
  178|  2.14k|    if (mono_time == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (178:9): [True: 0, False: 2.14k]
  ------------------
  179|      0|        return;
  180|      0|    }
  181|       |#ifdef OS_WIN32
  182|       |    pthread_mutex_destroy(&mono_time->last_clock_lock);
  183|       |#endif
  184|  2.14k|#ifndef ESP_PLATFORM
  185|  2.14k|    pthread_rwlock_destroy(mono_time->time_update_lock);
  186|  2.14k|    mem_delete(mem, mono_time->time_update_lock);
  187|  2.14k|#endif
  188|  2.14k|    mem_delete(mem, mono_time);
  189|  2.14k|}
mono_time_update:
  192|  2.14k|{
  193|       |#ifdef OS_WIN32
  194|       |    /* we actually want to update the overflow state of mono_time here */
  195|       |    pthread_mutex_lock(&mono_time->last_clock_lock);
  196|       |    mono_time->last_clock_update = true;
  197|       |#endif
  198|  2.14k|    const uint64_t cur_time =
  199|  2.14k|        mono_time->base_time + mono_time->current_time_callback(mono_time->user_data);
  200|       |#ifdef OS_WIN32
  201|       |    pthread_mutex_unlock(&mono_time->last_clock_lock);
  202|       |#endif
  203|       |
  204|  2.14k|#ifndef ESP_PLATFORM
  205|  2.14k|    pthread_rwlock_wrlock(mono_time->time_update_lock);
  206|  2.14k|#endif
  207|  2.14k|    mono_time->cur_time = cur_time;
  208|  2.14k|#ifndef ESP_PLATFORM
  209|  2.14k|    pthread_rwlock_unlock(mono_time->time_update_lock);
  210|  2.14k|#endif
  211|  2.14k|}
mono_time_get_ms:
  214|  50.9k|{
  215|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  216|       |    // Fuzzing is only single thread for now, no locking needed */
  217|       |    pthread_rwlock_rdlock(mono_time->time_update_lock);
  218|       |#endif
  219|  50.9k|    const uint64_t cur_time = mono_time->cur_time;
  220|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  221|       |    pthread_rwlock_unlock(mono_time->time_update_lock);
  222|       |#endif
  223|  50.9k|    return cur_time;
  224|  50.9k|}
mono_time_get:
  227|  50.9k|{
  228|  50.9k|    return mono_time_get_ms(mono_time) / 1000ULL;
  229|  50.9k|}
mono_time_set_current_time_callback:
  238|  2.14k|{
  239|  2.14k|    if (current_time_callback == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (239:9): [True: 0, False: 2.14k]
  ------------------
  240|      0|        mono_time->current_time_callback = current_time_monotonic_default;
  241|      0|        mono_time->user_data = mono_time;
  242|  2.14k|    } else {
  243|  2.14k|        mono_time->current_time_callback = current_time_callback;
  244|  2.14k|        mono_time->user_data = user_data;
  245|  2.14k|    }
  246|  2.14k|}

nc_get_self_public_key:
  163|  3.03k|{
  164|  3.03k|    return c->self_public_key;
  165|  3.03k|}
nc_get_tcp_c:
  173|  4.52k|{
  174|  4.52k|    return c->tcp_c;
  175|  4.52k|}
nc_get_dht:
  178|  2.14k|{
  179|  2.14k|    return c->dht;
  180|  2.14k|}
new_connection_handler:
 2005|  2.14k|{
 2006|  2.14k|    c->new_connection_callback = new_connection_callback;
 2007|  2.14k|    c->new_connection_callback_object = object;
 2008|  2.14k|}
copy_connected_tcp_relays:
 2390|  1.50k|{
 2391|  1.50k|    if (num == 0) {
  ------------------
  |  Branch (2391:9): [True: 7, False: 1.50k]
  ------------------
 2392|      7|        return 0;
 2393|      7|    }
 2394|       |
 2395|  1.50k|    pthread_mutex_lock(&c->tcp_mutex);
 2396|  1.50k|    const unsigned int ret = tcp_copy_connected_relays(c->tcp_c, tcp_relays, num);
 2397|  1.50k|    pthread_mutex_unlock(&c->tcp_mutex);
 2398|       |
 2399|  1.50k|    return ret;
 2400|  1.50k|}
crypto_kill:
 3030|    306|{
 3031|    306|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 3032|       |
 3033|    306|    int ret = -1;
 3034|       |
 3035|    306|    if (conn != nullptr) {
  ------------------
  |  |   66|    306|#define nullptr NULL
  ------------------
  |  Branch (3035:9): [True: 0, False: 306]
  ------------------
 3036|      0|        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
  ------------------
  |  Branch (3036:13): [True: 0, False: 0]
  ------------------
 3037|      0|            send_kill_packet(c, crypt_connection_id);
 3038|      0|        }
 3039|       |
 3040|      0|        pthread_mutex_lock(&c->tcp_mutex);
 3041|      0|        kill_tcp_connection_to(c->tcp_c, conn->connection_number_tcp);
 3042|      0|        pthread_mutex_unlock(&c->tcp_mutex);
 3043|       |
 3044|      0|        bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv4, crypt_connection_id);
 3045|      0|        bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv6, crypt_connection_id);
 3046|      0|        clear_temp_packet(c, crypt_connection_id);
 3047|      0|        clear_buffer(c->mem, &conn->send_array);
 3048|      0|        clear_buffer(c->mem, &conn->recv_array);
 3049|      0|        ret = wipe_crypto_connection(c, crypt_connection_id);
 3050|      0|    }
 3051|       |
 3052|    306|    return ret;
 3053|    306|}
new_keys:
 3083|  2.14k|{
 3084|  2.14k|    crypto_new_keypair(c->rng, c->self_public_key, c->self_secret_key);
 3085|  2.14k|}
save_keys:
 3093|  1.50k|{
 3094|  1.50k|    memcpy(keys, c->self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|  1.50k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3095|  1.50k|    memcpy(keys + CRYPTO_PUBLIC_KEY_SIZE, c->self_secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   40|  1.50k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(keys + CRYPTO_PUBLIC_KEY_SIZE, c->self_secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   45|  1.50k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 3096|  1.50k|}
load_secret_key:
 3102|    532|{
 3103|    532|    memcpy(c->self_secret_key, sk, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   45|    532|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 3104|    532|    crypto_derive_public_key(c->self_public_key, c->self_secret_key);
 3105|    532|}
new_net_crypto:
 3112|  2.14k|{
 3113|  2.14k|    if (dht == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3113:9): [True: 0, False: 2.14k]
  ------------------
 3114|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3115|      0|    }
 3116|       |
 3117|  2.14k|    Net_Crypto *temp = (Net_Crypto *)mem_alloc(mem, sizeof(Net_Crypto));
 3118|       |
 3119|  2.14k|    if (temp == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3119:9): [True: 0, False: 2.14k]
  ------------------
 3120|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3121|      0|    }
 3122|       |
 3123|  2.14k|    temp->log = log;
 3124|  2.14k|    temp->mem = mem;
 3125|  2.14k|    temp->rng = rng;
 3126|  2.14k|    temp->mono_time = mono_time;
 3127|  2.14k|    temp->ns = ns;
 3128|       |
 3129|  2.14k|    temp->tcp_c = new_tcp_connections(log, mem, rng, ns, mono_time, dht_get_self_secret_key(dht), proxy_info);
 3130|       |
 3131|  2.14k|    if (temp->tcp_c == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3131:9): [True: 0, False: 2.14k]
  ------------------
 3132|      0|        mem_delete(mem, temp);
 3133|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3134|      0|    }
 3135|       |
 3136|  2.14k|    set_packet_tcp_connection_callback(temp->tcp_c, &tcp_data_callback, temp);
 3137|  2.14k|    set_oob_packet_tcp_connection_callback(temp->tcp_c, &tcp_oob_callback, temp);
 3138|       |
 3139|  2.14k|    if (create_recursive_mutex(&temp->tcp_mutex) != 0 ||
  ------------------
  |  Branch (3139:9): [True: 0, False: 2.14k]
  ------------------
 3140|  2.14k|            pthread_mutex_init(&temp->connections_mutex, nullptr) != 0) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3140:13): [True: 0, False: 2.14k]
  ------------------
 3141|      0|        kill_tcp_connections(temp->tcp_c);
 3142|      0|        mem_delete(mem, temp);
 3143|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 3144|      0|    }
 3145|       |
 3146|  2.14k|    temp->dht = dht;
 3147|       |
 3148|  2.14k|    new_keys(temp);
 3149|  2.14k|    new_symmetric_key(rng, temp->secret_symmetric_key);
 3150|       |
 3151|  2.14k|    temp->current_sleep_time = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |   88|  2.14k|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 3152|       |
 3153|  2.14k|    networking_registerhandler(dht_get_net(dht), NET_PACKET_COOKIE_REQUEST, &udp_handle_cookie_request, temp);
 3154|  2.14k|    networking_registerhandler(dht_get_net(dht), NET_PACKET_COOKIE_RESPONSE, &udp_handle_packet, temp);
 3155|  2.14k|    networking_registerhandler(dht_get_net(dht), NET_PACKET_CRYPTO_HS, &udp_handle_packet, temp);
 3156|  2.14k|    networking_registerhandler(dht_get_net(dht), NET_PACKET_CRYPTO_DATA, &udp_handle_packet, temp);
 3157|       |
 3158|  2.14k|    bs_list_init(&temp->ip_port_list, sizeof(IP_Port), 8);
 3159|       |
 3160|  2.14k|    return temp;
 3161|  2.14k|}
kill_net_crypto:
 3208|  2.14k|{
 3209|  2.14k|    if (c == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (3209:9): [True: 0, False: 2.14k]
  ------------------
 3210|      0|        return;
 3211|      0|    }
 3212|       |
 3213|  2.14k|    const Memory *mem = c->mem;
 3214|       |
 3215|  2.14k|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (3215:26): [True: 0, False: 2.14k]
  ------------------
 3216|      0|        crypto_kill(c, i);
 3217|      0|    }
 3218|       |
 3219|  2.14k|    pthread_mutex_destroy(&c->tcp_mutex);
 3220|  2.14k|    pthread_mutex_destroy(&c->connections_mutex);
 3221|       |
 3222|  2.14k|    kill_tcp_connections(c->tcp_c);
 3223|  2.14k|    bs_list_free(&c->ip_port_list);
 3224|  2.14k|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 3225|  2.14k|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 3226|  2.14k|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 3227|  2.14k|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 3228|  2.14k|    crypto_memzero(c, sizeof(Net_Crypto));
 3229|  2.14k|    mem_delete(mem, c);
 3230|  2.14k|}
net_crypto.c:crypt_connection_id_is_valid:
  184|    306|{
  185|    306|    if ((uint32_t)crypt_connection_id >= c->crypto_connections_length) {
  ------------------
  |  Branch (185:9): [True: 306, False: 0]
  ------------------
  186|    306|        return false;
  187|    306|    }
  188|       |
  189|      0|    if (c->crypto_connections == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (189:9): [True: 0, False: 0]
  ------------------
  190|      0|        return false;
  191|      0|    }
  192|       |
  193|      0|    const Crypto_Conn_State status = c->crypto_connections[crypt_connection_id].status;
  194|       |
  195|      0|    return status != CRYPTO_CONN_NO_CONNECTION && status != CRYPTO_CONN_FREE;
  ------------------
  |  Branch (195:12): [True: 0, False: 0]
  |  Branch (195:51): [True: 0, False: 0]
  ------------------
  196|      0|}
net_crypto.c:get_crypto_connection:
  568|    306|{
  569|    306|    if (!crypt_connection_id_is_valid(c, crypt_connection_id)) {
  ------------------
  |  Branch (569:9): [True: 306, False: 0]
  ------------------
  570|    306|        return nullptr;
  ------------------
  |  |   66|    306|#define nullptr NULL
  ------------------
  571|    306|    }
  572|       |
  573|      0|    return &c->crypto_connections[crypt_connection_id];
  574|    306|}

net_family_unspec:
  381|  4.28k|{
  382|  4.28k|    return family_unspec;
  383|  4.28k|}
net_family_ipv4:
  386|  11.7k|{
  387|  11.7k|    return family_ipv4;
  388|  11.7k|}
net_family_ipv6:
  391|  7.54k|{
  392|  7.54k|    return family_ipv6;
  393|  7.54k|}
net_family_tcp_ipv4:
  406|    423|{
  407|    423|    return family_tcp_ipv4;
  408|    423|}
net_family_tcp_ipv6:
  411|  9.19k|{
  412|  9.19k|    return family_tcp_ipv6;
  413|  9.19k|}
net_family_is_unspec:
  426|  14.2k|{
  427|  14.2k|    return family.value == family_unspec.value;
  428|  14.2k|}
net_family_is_ipv4:
  431|  41.6k|{
  432|  41.6k|    return family.value == family_ipv4.value;
  433|  41.6k|}
net_family_is_ipv6:
  436|  36.0k|{
  437|  36.0k|    return family.value == family_ipv6.value;
  438|  36.0k|}
net_family_is_tcp_ipv4:
  451|  14.2k|{
  452|  14.2k|    return family.value == family_tcp_ipv4.value;
  453|  14.2k|}
net_family_is_tcp_ipv6:
  456|  9.21k|{
  457|  9.21k|    return family.value == family_tcp_ipv6.value;
  458|  9.21k|}
sock_valid:
  471|  2.14k|{
  472|  2.14k|    return sock.sock != net_invalid_socket.sock;
  473|  2.14k|}
system_network:
  597|  2.14k|{
  598|  2.14k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  599|  2.14k|    if ((true)) {
  ------------------
  |  Branch (599:9): [Folded - Ignored]
  ------------------
  600|  2.14k|        return nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  601|  2.14k|    }
  602|      0|#endif
  603|       |#ifdef OS_WIN32
  604|       |    WSADATA wsaData;
  605|       |
  606|       |    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != NO_ERROR) {
  607|       |        return nullptr;
  608|       |    }
  609|       |#endif
  610|      0|    return &system_network_obj;
  611|  2.14k|}
kill_sock:
  854|  2.14k|{
  855|  2.14k|    ns->funcs->close(ns->obj, sock.sock);
  856|  2.14k|}
set_socket_nonblock:
  859|  2.14k|{
  860|  2.14k|    return ns->funcs->socket_nonblock(ns->obj, sock.sock, true) == 0;
  861|  2.14k|}
set_socket_nosigpipe:
  864|  2.14k|{
  865|       |#if defined(__APPLE__)
  866|       |    int set = 1;
  867|       |    return net_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
  868|       |#else
  869|  2.14k|    return true;
  870|  2.14k|#endif
  871|  2.14k|}
set_socket_dualstack:
  880|  2.14k|{
  881|  2.14k|    int ipv6only = 0;
  882|  2.14k|    size_t optsize = sizeof(ipv6only);
  883|  2.14k|    const int res = net_getsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, &optsize);
  884|       |
  885|  2.14k|    if ((res == 0) && (ipv6only == 0)) {
  ------------------
  |  Branch (885:9): [True: 2.14k, False: 0]
  |  Branch (885:23): [True: 2.14k, False: 0]
  ------------------
  886|  2.14k|        return true;
  887|  2.14k|    }
  888|       |
  889|      0|    ipv6only = 0;
  890|      0|    return net_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only)) == 0;
  891|  2.14k|}
networking_registerhandler:
 1076|   134k|{
 1077|   134k|    net->packethandlers[byte].function = cb;
 1078|   134k|    net->packethandlers[byte].object = object;
 1079|   134k|}
new_networking_ex:
 1123|  2.14k|{
 1124|       |    /* If both from and to are 0, use default port range
 1125|       |     * If one is 0 and the other is non-0, use the non-0 value as only port
 1126|       |     * If from > to, swap
 1127|       |     */
 1128|  2.14k|    if (port_from == 0 && port_to == 0) {
  ------------------
  |  Branch (1128:9): [True: 2.14k, False: 0]
  |  Branch (1128:27): [True: 2.14k, False: 0]
  ------------------
 1129|  2.14k|        port_from = TOX_PORTRANGE_FROM;
  ------------------
  |  |  201|  2.14k|#define TOX_PORTRANGE_FROM 33445
  ------------------
 1130|  2.14k|        port_to = TOX_PORTRANGE_TO;
  ------------------
  |  |  202|  2.14k|#define TOX_PORTRANGE_TO   33545
  ------------------
 1131|  2.14k|    } else if (port_from == 0 && port_to != 0) {
  ------------------
  |  Branch (1131:16): [True: 0, False: 0]
  |  Branch (1131:34): [True: 0, False: 0]
  ------------------
 1132|      0|        port_from = port_to;
 1133|      0|    } else if (port_from != 0 && port_to == 0) {
  ------------------
  |  Branch (1133:16): [True: 0, False: 0]
  |  Branch (1133:34): [True: 0, False: 0]
  ------------------
 1134|      0|        port_to = port_from;
 1135|      0|    } else if (port_from > port_to) {
  ------------------
  |  Branch (1135:16): [True: 0, False: 0]
  ------------------
 1136|      0|        const uint16_t temp_port = port_from;
 1137|      0|        port_from = port_to;
 1138|      0|        port_to = temp_port;
 1139|      0|    }
 1140|       |
 1141|  2.14k|    if (error != nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (1141:9): [True: 2.14k, False: 0]
  ------------------
 1142|  2.14k|        *error = 2;
 1143|  2.14k|    }
 1144|       |
 1145|       |    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
 1146|  2.14k|    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1146:9): [True: 2.14k, False: 0]
  |  Branch (1146:44): [True: 0, False: 2.14k]
  ------------------
 1147|      0|        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1148|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1149|      0|    }
 1150|       |
 1151|  2.14k|    Networking_Core *temp = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
 1152|       |
 1153|  2.14k|    if (temp == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (1153:9): [True: 0, False: 2.14k]
  ------------------
 1154|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1155|      0|    }
 1156|       |
 1157|  2.14k|    temp->ns = ns;
 1158|  2.14k|    temp->log = log;
 1159|  2.14k|    temp->mem = mem;
 1160|  2.14k|    temp->family = ip->family;
 1161|  2.14k|    temp->port = 0;
 1162|       |
 1163|       |    /* Initialize our socket. */
 1164|       |    /* add log message what we're creating */
 1165|  2.14k|    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  213|  2.14k|#define TOX_SOCK_DGRAM 2
  ------------------
                  temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  216|  2.14k|#define TOX_PROTO_UDP 2
  ------------------
 1166|       |
 1167|       |    /* Check for socket error. */
 1168|  2.14k|    if (!sock_valid(temp->sock)) {
  ------------------
  |  Branch (1168:9): [True: 0, False: 2.14k]
  ------------------
 1169|      0|        const int neterror = net_error();
 1170|      0|        char *strerror = net_new_strerror(neterror);
 1171|      0|        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, strerror);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1172|      0|        net_kill_strerror(strerror);
 1173|      0|        mem_delete(mem, temp);
 1174|       |
 1175|      0|        if (error != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1175:13): [True: 0, False: 0]
  ------------------
 1176|      0|            *error = 1;
 1177|      0|        }
 1178|       |
 1179|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1180|      0|    }
 1181|       |
 1182|       |    /* Functions to increase the size of the send and receive UDP buffers.
 1183|       |     */
 1184|  2.14k|    int n = 1024 * 1024 * 2;
 1185|       |
 1186|  2.14k|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1186:9): [True: 0, False: 2.14k]
  ------------------
 1187|      0|        LOGGER_ERROR(log, "failed to set socket option %d", SO_RCVBUF);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1188|      0|    }
 1189|       |
 1190|  2.14k|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_SNDBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1190:9): [True: 0, False: 2.14k]
  ------------------
 1191|      0|        LOGGER_ERROR(log, "failed to set socket option %d", SO_SNDBUF);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1192|      0|    }
 1193|       |
 1194|       |    /* Enable broadcast on socket */
 1195|  2.14k|    int broadcast = 1;
 1196|       |
 1197|  2.14k|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) != 0) {
  ------------------
  |  Branch (1197:9): [True: 0, False: 2.14k]
  ------------------
 1198|      0|        LOGGER_ERROR(log, "failed to set socket option %d", SO_BROADCAST);
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1199|      0|    }
 1200|       |
 1201|       |    /* iOS UDP sockets are weird and apparently can SIGPIPE */
 1202|  2.14k|    if (!set_socket_nosigpipe(ns, temp->sock)) {
  ------------------
  |  Branch (1202:9): [True: 0, False: 2.14k]
  ------------------
 1203|      0|        kill_networking(temp);
 1204|       |
 1205|      0|        if (error != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1205:13): [True: 0, False: 0]
  ------------------
 1206|      0|            *error = 1;
 1207|      0|        }
 1208|       |
 1209|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1210|      0|    }
 1211|       |
 1212|       |    /* Set socket nonblocking. */
 1213|  2.14k|    if (!set_socket_nonblock(ns, temp->sock)) {
  ------------------
  |  Branch (1213:9): [True: 0, False: 2.14k]
  ------------------
 1214|      0|        kill_networking(temp);
 1215|       |
 1216|      0|        if (error != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1216:13): [True: 0, False: 0]
  ------------------
 1217|      0|            *error = 1;
 1218|      0|        }
 1219|       |
 1220|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1221|      0|    }
 1222|       |
 1223|       |    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
 1224|  2.14k|    uint16_t *portptr = nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 1225|  2.14k|    Network_Addr addr;
 1226|       |
 1227|  2.14k|    memset(&addr.addr, 0, sizeof(struct sockaddr_storage));
 1228|       |
 1229|  2.14k|    if (net_family_is_ipv4(temp->family)) {
  ------------------
  |  Branch (1229:9): [True: 0, False: 2.14k]
  ------------------
 1230|      0|        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr.addr;
 1231|       |
 1232|      0|        addr.size = sizeof(struct sockaddr_in);
 1233|      0|        addr4->sin_family = AF_INET;
 1234|      0|        addr4->sin_port = 0;
 1235|      0|        fill_addr4(&ip->ip.v4, &addr4->sin_addr);
 1236|       |
 1237|      0|        portptr = &addr4->sin_port;
 1238|  2.14k|    } else if (net_family_is_ipv6(temp->family)) {
  ------------------
  |  Branch (1238:16): [True: 2.14k, False: 0]
  ------------------
 1239|  2.14k|        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr.addr;
 1240|       |
 1241|  2.14k|        addr.size = sizeof(struct sockaddr_in6);
 1242|  2.14k|        addr6->sin6_family = AF_INET6;
 1243|  2.14k|        addr6->sin6_port = 0;
 1244|  2.14k|        fill_addr6(&ip->ip.v6, &addr6->sin6_addr);
 1245|       |
 1246|  2.14k|        addr6->sin6_flowinfo = 0;
 1247|  2.14k|        addr6->sin6_scope_id = 0;
 1248|       |
 1249|  2.14k|        portptr = &addr6->sin6_port;
 1250|  2.14k|    } else {
 1251|      0|        mem_delete(mem, temp);
 1252|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1253|      0|    }
 1254|       |
 1255|  2.14k|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1255:9): [True: 2.14k, False: 0]
  ------------------
 1256|  2.14k|        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);
 1257|       |
 1258|  2.14k|        if (is_dualstack) {
  ------------------
  |  Branch (1258:13): [True: 2.14k, False: 0]
  ------------------
 1259|  2.14k|            LOGGER_TRACE(log, "Dual-stack socket: enabled");
  ------------------
  |  |   79|  2.14k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  2.14k|    do {                                                                         \
  |  |  |  |   73|  2.14k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  4.28k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  2.14k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1260|  2.14k|        } else {
 1261|      0|            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1262|      0|        }
 1263|       |
 1264|  2.14k|#ifndef ESP_PLATFORM
 1265|       |        /* multicast local nodes */
 1266|  2.14k|        struct ipv6_mreq mreq;
 1267|  2.14k|        memset(&mreq, 0, sizeof(mreq));
 1268|  2.14k|        mreq.ipv6mr_multiaddr.s6_addr[ 0] = 0xFF;
 1269|  2.14k|        mreq.ipv6mr_multiaddr.s6_addr[ 1] = 0x02;
 1270|  2.14k|        mreq.ipv6mr_multiaddr.s6_addr[15] = 0x01;
 1271|  2.14k|        mreq.ipv6mr_interface = 0;
 1272|       |
 1273|  2.14k|        const int res = net_setsockopt(ns, temp->sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
 1274|       |
 1275|  2.14k|        int neterror = net_error();
 1276|  2.14k|        char *strerror = net_new_strerror(neterror);
 1277|       |
 1278|  2.14k|        if (res < 0) {
  ------------------
  |  Branch (1278:13): [True: 0, False: 2.14k]
  ------------------
 1279|      0|            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, strerror);
  ------------------
  |  |   81|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1280|  2.14k|        } else {
 1281|  2.14k|            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, strerror);
  ------------------
  |  |   79|  2.14k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  2.14k|    do {                                                                         \
  |  |  |  |   73|  2.14k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  4.28k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  2.14k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1282|  2.14k|        }
 1283|       |
 1284|  2.14k|        net_kill_strerror(strerror);
 1285|  2.14k|#endif
 1286|  2.14k|    }
 1287|       |
 1288|       |    /* A hanging program or a different user might block the standard port.
 1289|       |     * As long as it isn't a parameter coming from the commandline,
 1290|       |     * try a few ports after it, to see if we can find a "free" one.
 1291|       |     *
 1292|       |     * If we go on without binding, the first sendto() automatically binds to
 1293|       |     * a free port chosen by the system (i.e. anything from 1024 to 65535).
 1294|       |     *
 1295|       |     * Returning NULL after bind fails has both advantages and disadvantages:
 1296|       |     * advantage:
 1297|       |     *   we can rely on getting the port in the range 33445..33450, which
 1298|       |     *   enables us to tell joe user to open their firewall to a small range
 1299|       |     *
 1300|       |     * disadvantage:
 1301|       |     *   some clients might not test return of tox_new(), blindly assuming that
 1302|       |     *   it worked ok (which it did previously without a successful bind)
 1303|       |     */
 1304|  2.14k|    uint16_t port_to_try = port_from;
 1305|  2.14k|    *portptr = net_htons(port_to_try);
 1306|       |
 1307|  2.14k|    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
  ------------------
  |  Branch (1307:38): [True: 2.14k, False: 0]
  ------------------
 1308|  2.14k|        const int res = net_bind(ns, temp->sock, &addr);
 1309|       |
 1310|  2.14k|        if (res == 0) {
  ------------------
  |  Branch (1310:13): [True: 2.14k, False: 0]
  ------------------
 1311|  2.14k|            temp->port = *portptr;
 1312|       |
 1313|  2.14k|            Ip_Ntoa ip_str;
 1314|  2.14k|            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
  ------------------
  |  |   80|  2.14k|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|  2.14k|    do {                                                                         \
  |  |  |  |   73|  2.14k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  4.28k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|  2.14k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1315|  2.14k|                         net_ntohs(temp->port));
 1316|       |
 1317|       |            /* errno isn't reset on success, only set on failure, the failed
 1318|       |             * binds with parallel clients yield a -EPERM to the outside if
 1319|       |             * errno isn't cleared here */
 1320|  2.14k|            if (tries > 0) {
  ------------------
  |  Branch (1320:17): [True: 2.14k, False: 0]
  ------------------
 1321|  2.14k|                errno = 0;
 1322|  2.14k|            }
 1323|       |
 1324|  2.14k|            if (error != nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (1324:17): [True: 2.14k, False: 0]
  ------------------
 1325|  2.14k|                *error = 0;
 1326|  2.14k|            }
 1327|       |
 1328|  2.14k|            return temp;
 1329|  2.14k|        }
 1330|       |
 1331|      0|        ++port_to_try;
 1332|       |
 1333|      0|        if (port_to_try > port_to) {
  ------------------
  |  Branch (1333:13): [True: 0, False: 0]
  ------------------
 1334|      0|            port_to_try = port_from;
 1335|      0|        }
 1336|       |
 1337|      0|        *portptr = net_htons(port_to_try);
 1338|      0|    }
 1339|       |
 1340|      0|    Ip_Ntoa ip_str;
 1341|      0|    int neterror = net_error();
 1342|      0|    char *strerror = net_new_strerror(neterror);
 1343|      0|    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u", neterror, strerror,
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1344|      0|                 net_ip_ntoa(ip, &ip_str), port_from, port_to);
 1345|      0|    net_kill_strerror(strerror);
 1346|      0|    kill_networking(temp);
 1347|       |
 1348|      0|    if (error != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (1348:9): [True: 0, False: 0]
  ------------------
 1349|      0|        *error = 1;
 1350|      0|    }
 1351|       |
 1352|      0|    return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 1353|  2.14k|}
kill_networking:
 1373|  2.14k|{
 1374|  2.14k|    if (net == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (1374:9): [True: 0, False: 2.14k]
  ------------------
 1375|      0|        return;
 1376|      0|    }
 1377|       |
 1378|  2.14k|    if (!net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (1378:9): [True: 2.14k, False: 0]
  ------------------
 1379|       |        /* Socket is initialized, so we close it. */
 1380|  2.14k|        kill_sock(net->ns, net->sock);
 1381|  2.14k|    }
 1382|       |
 1383|  2.14k|    mem_delete(net->mem, net);
 1384|  2.14k|}
ip_init:
 1464|  2.14k|{
 1465|  2.14k|    if (ip == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (1465:9): [True: 0, False: 2.14k]
  ------------------
 1466|      0|        return;
 1467|      0|    }
 1468|       |
 1469|  2.14k|    *ip = empty_ip;
 1470|  2.14k|    ip->family = ipv6enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (1470:18): [True: 2.14k, False: 0]
  ------------------
 1471|  2.14k|}
ip_isset:
 1475|  1.43k|{
 1476|  1.43k|    if (ip == nullptr) {
  ------------------
  |  |   66|  1.43k|#define nullptr NULL
  ------------------
  |  Branch (1476:9): [True: 0, False: 1.43k]
  ------------------
 1477|      0|        return false;
 1478|      0|    }
 1479|       |
 1480|  1.43k|    return !net_family_is_unspec(ip->family);
 1481|  1.43k|}
ipport_isset:
 1485|  84.8k|{
 1486|  84.8k|    if (ipport == nullptr) {
  ------------------
  |  |   66|  84.8k|#define nullptr NULL
  ------------------
  |  Branch (1486:9): [True: 0, False: 84.8k]
  ------------------
 1487|      0|        return false;
 1488|      0|    }
 1489|       |
 1490|  84.8k|    if (ipport->port == 0) {
  ------------------
  |  Branch (1490:9): [True: 83.4k, False: 1.43k]
  ------------------
 1491|  83.4k|        return false;
 1492|  83.4k|    }
 1493|       |
 1494|  1.43k|    return ip_isset(&ipport->ip);
 1495|  84.8k|}
net_socket:
 1906|  2.14k|{
 1907|  2.14k|    const int platform_domain = make_family(domain);
 1908|  2.14k|    const int platform_type = make_socktype(type);
 1909|  2.14k|    const int platform_prot = make_proto(protocol);
 1910|  2.14k|    const Socket sock = {ns->funcs->socket(ns->obj, platform_domain, platform_type, platform_prot)};
 1911|  2.14k|    return sock;
 1912|  2.14k|}
net_htons:
 1926|  3.73k|{
 1927|  3.73k|    return htons(hostshort);
 1928|  3.73k|}
net_ntohs:
 1936|    642|{
 1937|    642|    return ntohs(hostshort);
 1938|    642|}
net_pack_u16:
 1947|    412|{
 1948|    412|    bytes[0] = (v >> 8) & 0xff;
 1949|    412|    bytes[1] = v & 0xff;
 1950|    412|    return sizeof(v);
 1951|    412|}
net_pack_u32:
 1954|    206|{
 1955|    206|    uint8_t *p = bytes;
 1956|    206|    p += net_pack_u16(p, (v >> 16) & 0xffff);
 1957|    206|    p += net_pack_u16(p, v & 0xffff);
 1958|    206|    return p - bytes;
 1959|    206|}
net_pack_u64:
 1962|    103|{
 1963|    103|    uint8_t *p = bytes;
 1964|    103|    p += net_pack_u32(p, (v >> 32) & 0xffffffff);
 1965|    103|    p += net_pack_u32(p, v & 0xffffffff);
 1966|    103|    return p - bytes;
 1967|    103|}
net_unpack_u16:
 1976|  1.02k|{
 1977|  1.02k|    const uint8_t hi = bytes[0];
 1978|  1.02k|    const uint8_t lo = bytes[1];
 1979|  1.02k|    *v = ((uint16_t)hi << 8) | lo;
 1980|  1.02k|    return sizeof(*v);
 1981|  1.02k|}
net_unpack_u32:
 1984|    512|{
 1985|    512|    const uint8_t *p = bytes;
 1986|    512|    uint16_t hi;
 1987|    512|    uint16_t lo;
 1988|    512|    p += net_unpack_u16(p, &hi);
 1989|    512|    p += net_unpack_u16(p, &lo);
 1990|    512|    *v = ((uint32_t)hi << 16) | lo;
 1991|    512|    return p - bytes;
 1992|    512|}
net_unpack_u64:
 1995|    256|{
 1996|    256|    const uint8_t *p = bytes;
 1997|    256|    uint32_t hi;
 1998|    256|    uint32_t lo;
 1999|    256|    p += net_unpack_u32(p, &hi);
 2000|    256|    p += net_unpack_u32(p, &lo);
 2001|    256|    *v = ((uint64_t)hi << 32) | lo;
 2002|    256|    return p - bytes;
 2003|    256|}
net_error:
 2011|  2.14k|{
 2012|       |#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
 2013|       |    return WSAGetLastError();
 2014|       |#else
 2015|  2.14k|    return errno;
 2016|  2.14k|#endif
 2017|  2.14k|}
net_new_strerror:
 2061|  2.14k|{
 2062|  2.14k|    char tmp[256];
 2063|       |
 2064|  2.14k|    errno = 0;
 2065|       |
 2066|  2.14k|    const char *retstr = net_strerror_r(error, tmp, sizeof(tmp));
 2067|  2.14k|    const size_t retstr_len = strlen(retstr);
 2068|       |
 2069|  2.14k|    char *str = (char *)malloc(retstr_len + 1);
 2070|       |
 2071|  2.14k|    if (str == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (2071:9): [True: 0, False: 2.14k]
  ------------------
 2072|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2073|      0|    }
 2074|       |
 2075|  2.14k|    memcpy(str, retstr, retstr_len + 1);
 2076|       |
 2077|  2.14k|    return str;
 2078|  2.14k|}
net_kill_strerror:
 2082|  2.14k|{
 2083|       |#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
 2084|       |    LocalFree((char *)strerror);
 2085|       |#else
 2086|  2.14k|    free(strerror);
 2087|  2.14k|#endif
 2088|  2.14k|}
network.c:net_setsockopt:
  625|  8.56k|{
  626|  8.56k|    return ns->funcs->setsockopt(ns->obj, sock.sock, level, optname, optval, optlen);
  627|  8.56k|}
network.c:net_getsockopt:
  631|  2.14k|{
  632|  2.14k|    return ns->funcs->getsockopt(ns->obj, sock.sock, level, optname, optval, optlen);
  633|  2.14k|}
network.c:fill_addr6:
  339|  2.14k|{
  340|  2.14k|    memcpy(addr->s6_addr, ip->uint8, sizeof(ip->uint8));
  341|  2.14k|}
network.c:net_bind:
  842|  2.14k|{
  843|  2.14k|    return ns->funcs->bind(ns->obj, sock.sock, addr);
  844|  2.14k|}
network.c:make_family:
  272|  2.14k|{
  273|  2.14k|    switch (tox_family.value) {
  274|      0|        case TOX_AF_INET:
  ------------------
  |  |  207|      0|#define TOX_AF_INET 2
  ------------------
  |  Branch (274:9): [True: 0, False: 2.14k]
  ------------------
  275|      0|            return AF_INET;
  276|       |
  277|  2.14k|        case TOX_AF_INET6:
  ------------------
  |  |  208|  2.14k|#define TOX_AF_INET6 10
  ------------------
  |  Branch (277:9): [True: 2.14k, False: 0]
  ------------------
  278|  2.14k|            return AF_INET6;
  279|       |
  280|      0|        case TOX_AF_UNSPEC:
  ------------------
  |  |  206|      0|#define TOX_AF_UNSPEC 0
  ------------------
  |  Branch (280:9): [True: 0, False: 2.14k]
  ------------------
  281|      0|            return AF_UNSPEC;
  282|       |
  283|      0|        default:
  ------------------
  |  Branch (283:9): [True: 0, False: 2.14k]
  ------------------
  284|      0|            return tox_family.value;
  285|  2.14k|    }
  286|  2.14k|}
network.c:make_socktype:
  258|  2.14k|{
  259|  2.14k|    switch (type) {
  260|      0|        case TOX_SOCK_STREAM:
  ------------------
  |  |  212|      0|#define TOX_SOCK_STREAM 1
  ------------------
  |  Branch (260:9): [True: 0, False: 2.14k]
  ------------------
  261|      0|            return SOCK_STREAM;
  262|       |
  263|  2.14k|        case TOX_SOCK_DGRAM:
  ------------------
  |  |  213|  2.14k|#define TOX_SOCK_DGRAM 2
  ------------------
  |  Branch (263:9): [True: 2.14k, False: 0]
  ------------------
  264|  2.14k|            return SOCK_DGRAM;
  265|       |
  266|      0|        default:
  ------------------
  |  Branch (266:9): [True: 0, False: 2.14k]
  ------------------
  267|      0|            return type;
  268|  2.14k|    }
  269|  2.14k|}
network.c:make_proto:
  244|  2.14k|{
  245|  2.14k|    switch (proto) {
  246|      0|        case TOX_PROTO_TCP:
  ------------------
  |  |  215|      0|#define TOX_PROTO_TCP 1
  ------------------
  |  Branch (246:9): [True: 0, False: 2.14k]
  ------------------
  247|      0|            return IPPROTO_TCP;
  248|       |
  249|  2.14k|        case TOX_PROTO_UDP:
  ------------------
  |  |  216|  2.14k|#define TOX_PROTO_UDP 2
  ------------------
  |  Branch (249:9): [True: 2.14k, False: 0]
  ------------------
  250|  2.14k|            return IPPROTO_UDP;
  251|       |
  252|      0|        default:
  ------------------
  |  Branch (252:9): [True: 0, False: 2.14k]
  ------------------
  253|      0|            return proto;
  254|  2.14k|    }
  255|  2.14k|}
network.c:net_strerror_r:
 2050|  2.14k|{
 2051|  2.14k|    const int fmt_error = strerror_r(error, tmp, tmp_size);
 2052|       |
 2053|  2.14k|    if (fmt_error != 0) {
  ------------------
  |  Branch (2053:9): [True: 0, False: 2.14k]
  ------------------
 2054|      0|        snprintf(tmp, tmp_size, "error %d (strerror_r failed with error %d, errno %d)", error, fmt_error, errno);
 2055|      0|    }
 2056|       |
 2057|  2.14k|    return tmp;
 2058|  2.14k|}

new_onion:
  672|  2.14k|{
  673|  2.14k|    if (dht == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (673:9): [True: 0, False: 2.14k]
  ------------------
  674|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  675|      0|    }
  676|       |
  677|  2.14k|    Onion *onion = (Onion *)mem_alloc(mem, sizeof(Onion));
  678|       |
  679|  2.14k|    if (onion == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (679:9): [True: 0, False: 2.14k]
  ------------------
  680|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  681|      0|    }
  682|       |
  683|  2.14k|    onion->log = log;
  684|  2.14k|    onion->dht = dht;
  685|  2.14k|    onion->net = dht_get_net(dht);
  686|  2.14k|    onion->mono_time = mono_time;
  687|  2.14k|    onion->rng = rng;
  688|  2.14k|    onion->mem = mem;
  689|  2.14k|    new_symmetric_key(rng, onion->secret_symmetric_key);
  690|  2.14k|    onion->timestamp = mono_time_get(onion->mono_time);
  691|       |
  692|  2.14k|    const uint8_t *secret_key = dht_get_self_secret_key(dht);
  693|  2.14k|    onion->shared_keys_1 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   33|  2.14k|#define KEYS_TIMEOUT 600
  ------------------
                  onion->shared_keys_1 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   32|  2.14k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  694|  2.14k|    onion->shared_keys_2 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   33|  2.14k|#define KEYS_TIMEOUT 600
  ------------------
                  onion->shared_keys_2 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   32|  2.14k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  695|  2.14k|    onion->shared_keys_3 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   33|  2.14k|#define KEYS_TIMEOUT 600
  ------------------
                  onion->shared_keys_3 = shared_key_cache_new(mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   32|  2.14k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  696|       |
  697|  2.14k|    if (onion->shared_keys_1 == nullptr ||
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
  |  Branch (697:9): [True: 0, False: 2.14k]
  ------------------
  698|  2.14k|        onion->shared_keys_2 == nullptr ||
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
  |  Branch (698:9): [True: 0, False: 2.14k]
  ------------------
  699|  2.14k|        onion->shared_keys_3 == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (699:9): [True: 0, False: 2.14k]
  ------------------
  700|      0|        kill_onion(onion);
  701|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  702|      0|    }
  703|       |
  704|       |
  705|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, &handle_send_initial, onion);
  706|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, &handle_send_1, onion);
  707|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, &handle_send_2, onion);
  708|       |
  709|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, &handle_recv_3, onion);
  710|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, &handle_recv_2, onion);
  711|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, &handle_recv_1, onion);
  712|       |
  713|  2.14k|    return onion;
  714|  2.14k|}
kill_onion:
  717|  2.14k|{
  718|  2.14k|    if (onion == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (718:9): [True: 0, False: 2.14k]
  ------------------
  719|      0|        return;
  720|      0|    }
  721|       |
  722|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  723|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  724|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  725|       |
  726|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  727|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  728|  2.14k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  729|       |
  730|  2.14k|    crypto_memzero(onion->secret_symmetric_key, sizeof(onion->secret_symmetric_key));
  731|       |
  732|  2.14k|    shared_key_cache_free(onion->shared_keys_1);
  733|  2.14k|    shared_key_cache_free(onion->shared_keys_2);
  734|  2.14k|    shared_key_cache_free(onion->shared_keys_3);
  735|       |
  736|  2.14k|    mem_delete(onion->mem, onion);
  737|  2.14k|}

onion_announce_extra_data_callback:
   69|  2.14k|{
   70|  2.14k|    onion_a->extra_data_max_size = extra_data_max_size;
   71|  2.14k|    onion_a->extra_data_callback = extra_data_callback;
   72|  2.14k|    onion_a->extra_data_object = extra_data_object;
   73|  2.14k|}
new_onion_announce:
  646|  2.14k|{
  647|  2.14k|    if (dht == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (647:9): [True: 0, False: 2.14k]
  ------------------
  648|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  649|      0|    }
  650|       |
  651|  2.14k|    Onion_Announce *onion_a = (Onion_Announce *)mem_alloc(mem, sizeof(Onion_Announce));
  652|       |
  653|  2.14k|    if (onion_a == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (653:9): [True: 0, False: 2.14k]
  ------------------
  654|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  655|      0|    }
  656|       |
  657|  2.14k|    onion_a->log = log;
  658|  2.14k|    onion_a->rng = rng;
  659|  2.14k|    onion_a->mem = mem;
  660|  2.14k|    onion_a->mono_time = mono_time;
  661|  2.14k|    onion_a->dht = dht;
  662|  2.14k|    onion_a->net = dht_get_net(dht);
  663|  2.14k|    onion_a->extra_data_max_size = 0;
  664|  2.14k|    onion_a->extra_data_callback = nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  665|  2.14k|    onion_a->extra_data_object = nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  666|  2.14k|    new_hmac_key(rng, onion_a->hmac_key);
  667|       |
  668|  2.14k|    onion_a->shared_keys_recv = shared_key_cache_new(mono_time, mem, dht_get_self_secret_key(dht), KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   37|  2.14k|#define KEYS_TIMEOUT 600
  ------------------
                  onion_a->shared_keys_recv = shared_key_cache_new(mono_time, mem, dht_get_self_secret_key(dht), KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   36|  2.14k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  669|  2.14k|    if (onion_a->shared_keys_recv == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (669:9): [True: 0, False: 2.14k]
  ------------------
  670|      0|        kill_onion_announce(onion_a);
  671|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  672|      0|    }
  673|       |
  674|  2.14k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, &handle_announce_request, onion_a);
  675|  2.14k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, &handle_announce_request_old, onion_a);
  676|  2.14k|    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, &handle_data_request, onion_a);
  677|       |
  678|  2.14k|    return onion_a;
  679|  2.14k|}
kill_onion_announce:
  682|  2.14k|{
  683|  2.14k|    if (onion_a == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (683:9): [True: 0, False: 2.14k]
  ------------------
  684|      0|        return;
  685|      0|    }
  686|       |
  687|  2.14k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  688|  2.14k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  689|  2.14k|    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  690|       |
  691|  2.14k|    crypto_memzero(onion_a->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  136|  2.14k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  692|  2.14k|    shared_key_cache_free(onion_a->shared_keys_recv);
  693|       |
  694|  2.14k|    mem_delete(onion_a->mem, onion_a);
  695|  2.14k|}

onion_get_friend:
  159|     18|{
  160|     18|    return &onion_c->friends_list[friend_num];
  161|     18|}
onion_friend_set_gc_public_key:
  174|     18|{
  175|     18|    memcpy(onion_friend->gc_public_key, public_key, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |   27|     18|#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   40|     18|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  176|     18|}
onion_friend_set_gc_data:
  179|     18|{
  180|     18|    if (gc_data_length > 0 && gc_data != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (180:9): [True: 0, False: 18]
  |  Branch (180:31): [True: 0, False: 0]
  ------------------
  181|      0|        memcpy(onion_friend->gc_data, gc_data, gc_data_length);
  182|      0|    }
  183|       |
  184|     18|    onion_friend->gc_data_length = gc_data_length;
  185|     18|    onion_friend->is_groupchat = true;
  186|     18|}
onion_get_dht:
  194|  2.14k|{
  195|  2.14k|    return onion_c->dht;
  196|  2.14k|}
onion_get_net_crypto:
  199|  2.14k|{
  200|  2.14k|    return onion_c->c;
  201|  2.14k|}
onion_add_bs_path_node:
  217|  1.38k|{
  218|  1.38k|    if (!net_family_is_ipv4(ip_port->ip.family) && !net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (218:9): [True: 66, False: 1.32k]
  |  Branch (218:52): [True: 0, False: 66]
  ------------------
  219|      0|        return false;
  220|      0|    }
  221|       |
  222|  33.0k|    for (unsigned int i = 0; i < MAX_PATH_NODES; ++i) {
  ------------------
  |  |   44|  33.0k|#define MAX_PATH_NODES 32
  ------------------
  |  Branch (222:30): [True: 32.2k, False: 819]
  ------------------
  223|  32.2k|        if (pk_equal(public_key, onion_c->path_nodes_bs[i].public_key)) {
  ------------------
  |  Branch (223:13): [True: 570, False: 31.6k]
  ------------------
  224|    570|            return true;
  225|    570|        }
  226|  32.2k|    }
  227|       |
  228|    819|    onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].ip_port = *ip_port;
  ------------------
  |  |   44|    819|#define MAX_PATH_NODES 32
  ------------------
  229|    819|    memcpy(onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].public_key, public_key,
  ------------------
  |  |   44|    819|#define MAX_PATH_NODES 32
  ------------------
  230|    819|           CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    819|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  231|       |
  232|    819|    const uint16_t last = onion_c->path_nodes_index_bs;
  233|    819|    ++onion_c->path_nodes_index_bs;
  234|       |
  235|    819|    if (onion_c->path_nodes_index_bs < last) {
  ------------------
  |  Branch (235:9): [True: 0, False: 819]
  ------------------
  236|      0|        onion_c->path_nodes_index_bs = MAX_PATH_NODES + 1;
  ------------------
  |  |   44|      0|#define MAX_PATH_NODES 32
  ------------------
  237|      0|    }
  238|       |
  239|    819|    return true;
  240|  1.38k|}
onion_backup_nodes:
  279|  1.50k|{
  280|  1.50k|    if (max_num == 0) {
  ------------------
  |  Branch (280:9): [True: 0, False: 1.50k]
  ------------------
  281|      0|        return 0;
  282|      0|    }
  283|       |
  284|  1.50k|    const uint16_t num_nodes = min_u16(onion_c->path_nodes_index, MAX_PATH_NODES);
  ------------------
  |  |   44|  1.50k|#define MAX_PATH_NODES 32
  ------------------
  285|  1.50k|    uint16_t i = 0;
  286|       |
  287|  1.50k|    while (i < max_num && i < num_nodes) {
  ------------------
  |  Branch (287:12): [True: 1.50k, False: 0]
  |  Branch (287:27): [True: 0, False: 1.50k]
  ------------------
  288|      0|        nodes[i] = onion_c->path_nodes[(onion_c->path_nodes_index - (1 + i)) % num_nodes];
  289|      0|        ++i;
  290|      0|    }
  291|       |
  292|  1.71k|    for (uint16_t j = 0; i < max_num && j < MAX_PATH_NODES && j < onion_c->path_nodes_index_bs; ++j) {
  ------------------
  |  |   44|  3.41k|#define MAX_PATH_NODES 32
  ------------------
  |  Branch (292:26): [True: 1.69k, False: 20]
  |  Branch (292:41): [True: 1.69k, False: 0]
  |  Branch (292:63): [True: 212, False: 1.48k]
  ------------------
  293|    212|        bool already_saved = false;
  294|       |
  295|    212|        for (uint16_t k = 0; k < num_nodes; ++k) {
  ------------------
  |  Branch (295:30): [True: 0, False: 212]
  ------------------
  296|      0|            if (pk_equal(nodes[k].public_key, onion_c->path_nodes_bs[j].public_key)) {
  ------------------
  |  Branch (296:17): [True: 0, False: 0]
  ------------------
  297|      0|                already_saved = true;
  298|      0|                break;
  299|      0|            }
  300|      0|        }
  301|       |
  302|    212|        if (!already_saved) {
  ------------------
  |  Branch (302:13): [True: 212, False: 0]
  ------------------
  303|    212|            nodes[i] = onion_c->path_nodes_bs[j];
  304|    212|            ++i;
  305|    212|        }
  306|    212|    }
  307|       |
  308|  1.50k|    return i;
  309|  1.50k|}
onion_friend_num:
 1445|    306|{
 1446|    810|    for (unsigned int i = 0; i < onion_c->num_friends; ++i) {
  ------------------
  |  Branch (1446:30): [True: 504, False: 306]
  ------------------
 1447|    504|        if (!onion_c->friends_list[i].is_valid) {
  ------------------
  |  Branch (1447:13): [True: 0, False: 504]
  ------------------
 1448|      0|            continue;
 1449|      0|        }
 1450|       |
 1451|    504|        if (pk_equal(public_key, onion_c->friends_list[i].real_public_key)) {
  ------------------
  |  Branch (1451:13): [True: 0, False: 504]
  ------------------
 1452|      0|            return i;
 1453|      0|        }
 1454|    504|    }
 1455|       |
 1456|    306|    return -1;
 1457|    306|}
onion_addfriend:
 1489|    306|{
 1490|    306|    const int num = onion_friend_num(onion_c, public_key);
 1491|       |
 1492|    306|    if (num != -1) {
  ------------------
  |  Branch (1492:9): [True: 0, False: 306]
  ------------------
 1493|      0|        return num;
 1494|      0|    }
 1495|       |
 1496|    306|    unsigned int index = -1;
 1497|       |
 1498|    810|    for (unsigned int i = 0; i < onion_c->num_friends; ++i) {
  ------------------
  |  Branch (1498:30): [True: 504, False: 306]
  ------------------
 1499|    504|        if (!onion_c->friends_list[i].is_valid) {
  ------------------
  |  Branch (1499:13): [True: 0, False: 504]
  ------------------
 1500|      0|            index = i;
 1501|      0|            break;
 1502|      0|        }
 1503|    504|    }
 1504|       |
 1505|    306|    if (index == (uint32_t) -1) {
  ------------------
  |  Branch (1505:9): [True: 306, False: 0]
  ------------------
 1506|    306|        if (realloc_onion_friends(onion_c, onion_c->num_friends + 1) == -1) {
  ------------------
  |  Branch (1506:13): [True: 0, False: 306]
  ------------------
 1507|      0|            return -1;
 1508|      0|        }
 1509|       |
 1510|    306|        index = onion_c->num_friends;
 1511|    306|        onion_c->friends_list[onion_c->num_friends] = empty_onion_friend;
 1512|    306|        ++onion_c->num_friends;
 1513|    306|    }
 1514|       |
 1515|    306|    onion_c->friends_list[index].is_valid = true;
 1516|    306|    memcpy(onion_c->friends_list[index].real_public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   40|    306|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1517|    306|    crypto_new_keypair(onion_c->rng, onion_c->friends_list[index].temp_public_key,
 1518|    306|                       onion_c->friends_list[index].temp_secret_key);
 1519|    306|    return index;
 1520|    306|}
onion_delfriend:
 1528|    306|{
 1529|    306|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1529:9): [True: 0, False: 306]
  ------------------
 1530|      0|        return -1;
 1531|      0|    }
 1532|       |
 1533|       |#if 0
 1534|       |
 1535|       |    if (onion_c->friends_list[friend_num].know_dht_public_key) {
 1536|       |        dht_delfriend(onion_c->dht, onion_c->friends_list[friend_num].dht_public_key, 0);
 1537|       |    }
 1538|       |
 1539|       |#endif
 1540|       |
 1541|    306|    crypto_memzero(&onion_c->friends_list[friend_num], sizeof(Onion_Friend));
 1542|    306|    unsigned int i;
 1543|       |
 1544|    612|    for (i = onion_c->num_friends; i != 0; --i) {
  ------------------
  |  Branch (1544:36): [True: 499, False: 113]
  ------------------
 1545|    499|        if (onion_c->friends_list[i - 1].is_valid) {
  ------------------
  |  Branch (1545:13): [True: 193, False: 306]
  ------------------
 1546|    193|            break;
 1547|    193|        }
 1548|    499|    }
 1549|       |
 1550|    306|    if (onion_c->num_friends != i) {
  ------------------
  |  Branch (1550:9): [True: 119, False: 187]
  ------------------
 1551|    119|        onion_c->num_friends = i;
 1552|    119|        realloc_onion_friends(onion_c, onion_c->num_friends);
 1553|    119|    }
 1554|       |
 1555|    306|    return friend_num;
 1556|    306|}
recv_tcp_relay_handler:
 1568|    306|{
 1569|    306|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1569:9): [True: 0, False: 306]
  ------------------
 1570|      0|        return -1;
 1571|      0|    }
 1572|       |
 1573|    306|    onion_c->friends_list[friend_num].tcp_relay_node_callback = callback;
 1574|    306|    onion_c->friends_list[friend_num].tcp_relay_node_callback_object = object;
 1575|    306|    onion_c->friends_list[friend_num].tcp_relay_node_callback_number = number;
 1576|    306|    return 0;
 1577|    306|}
onion_dht_pk_callback:
 1589|    306|{
 1590|    306|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1590:9): [True: 0, False: 306]
  ------------------
 1591|      0|        return -1;
 1592|      0|    }
 1593|       |
 1594|    306|    onion_c->friends_list[friend_num].dht_pk_callback = function;
 1595|    306|    onion_c->friends_list[friend_num].dht_pk_callback_object = object;
 1596|    306|    onion_c->friends_list[friend_num].dht_pk_callback_number = number;
 1597|    306|    return 0;
 1598|    306|}
oniondata_registerhandler:
 1843|  6.42k|{
 1844|  6.42k|    onion_c->onion_data_handlers[byte].function = cb;
 1845|  6.42k|    onion_c->onion_data_handlers[byte].object = object;
 1846|  6.42k|}
onion_group_announce_register:
 1849|  4.28k|{
 1850|  4.28k|    onion_c->group_announce_response = func;
 1851|  4.28k|    onion_c->group_announce_response_user_data = user_data;
 1852|  4.28k|}
new_onion_client:
 2079|  2.14k|{
 2080|  2.14k|    if (c == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (2080:9): [True: 0, False: 2.14k]
  ------------------
 2081|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2082|      0|    }
 2083|       |
 2084|  2.14k|    Onion_Client *onion_c = (Onion_Client *)mem_alloc(mem, sizeof(Onion_Client));
 2085|       |
 2086|  2.14k|    if (onion_c == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (2086:9): [True: 0, False: 2.14k]
  ------------------
 2087|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2088|      0|    }
 2089|       |
 2090|  2.14k|    onion_c->announce_ping_array = ping_array_new(mem, ANNOUNCE_ARRAY_SIZE, ANNOUNCE_TIMEOUT);
  ------------------
  |  |   23|  2.14k|#define ANNOUNCE_ARRAY_SIZE 256
  ------------------
                  onion_c->announce_ping_array = ping_array_new(mem, ANNOUNCE_ARRAY_SIZE, ANNOUNCE_TIMEOUT);
  ------------------
  |  |   24|  2.14k|#define ANNOUNCE_TIMEOUT 10
  ------------------
 2091|       |
 2092|  2.14k|    if (onion_c->announce_ping_array == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (2092:9): [True: 0, False: 2.14k]
  ------------------
 2093|      0|        mem_delete(mem, onion_c);
 2094|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
 2095|      0|    }
 2096|       |
 2097|  2.14k|    onion_c->mono_time = mono_time;
 2098|  2.14k|    onion_c->logger = logger;
 2099|  2.14k|    onion_c->rng = rng;
 2100|  2.14k|    onion_c->mem = mem;
 2101|  2.14k|    onion_c->dht = nc_get_dht(c);
 2102|  2.14k|    onion_c->net = dht_get_net(onion_c->dht);
 2103|  2.14k|    onion_c->c = c;
 2104|  2.14k|    new_symmetric_key(rng, onion_c->secret_symmetric_key);
 2105|  2.14k|    crypto_new_keypair(rng, onion_c->temp_public_key, onion_c->temp_secret_key);
 2106|  2.14k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, &handle_announce_response, onion_c);
 2107|  2.14k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, &handle_announce_response_old, onion_c);
 2108|  2.14k|    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, &handle_data_response, onion_c);
 2109|  2.14k|    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, &handle_dhtpk_announce, onion_c);
  ------------------
  |  |   58|  2.14k|#define ONION_DATA_DHTPK CRYPTO_PACKET_DHTPK
  |  |  ------------------
  |  |  |  |   81|  2.14k|#define CRYPTO_PACKET_DHTPK         156
  |  |  ------------------
  ------------------
 2110|  2.14k|    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, &handle_dht_dhtpk, onion_c);
  ------------------
  |  |   81|  2.14k|#define CRYPTO_PACKET_DHTPK         156
  ------------------
 2111|  2.14k|    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), &handle_tcp_onion, onion_c);
 2112|       |
 2113|  2.14k|    return onion_c;
 2114|  2.14k|}
kill_onion_client:
 2117|  2.14k|{
 2118|  2.14k|    if (onion_c == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (2118:9): [True: 0, False: 2.14k]
  ------------------
 2119|      0|        return;
 2120|      0|    }
 2121|       |
 2122|  2.14k|    const Memory *mem = onion_c->mem;
 2123|       |
 2124|  2.14k|    ping_array_kill(onion_c->announce_ping_array);
 2125|  2.14k|    realloc_onion_friends(onion_c, 0);
 2126|  2.14k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 2127|  2.14k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 2128|  2.14k|    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 2129|  2.14k|    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   58|  2.14k|#define ONION_DATA_DHTPK CRYPTO_PACKET_DHTPK
  |  |  ------------------
  |  |  |  |   81|  2.14k|#define CRYPTO_PACKET_DHTPK         156
  |  |  ------------------
  ------------------
                  oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 2130|  2.14k|    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   81|  2.14k|#define CRYPTO_PACKET_DHTPK         156
  ------------------
                  cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 2131|  2.14k|    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
 2132|  2.14k|    crypto_memzero(onion_c, sizeof(Onion_Client));
 2133|  2.14k|    mem_delete(mem, onion_c);
 2134|  2.14k|}
onion_client.c:realloc_onion_friends:
 1466|  2.56k|{
 1467|  2.56k|    if (num == 0) {
  ------------------
  |  Branch (1467:9): [True: 2.25k, False: 312]
  ------------------
 1468|  2.25k|        mem_delete(onion_c->mem, onion_c->friends_list);
 1469|  2.25k|        onion_c->friends_list = nullptr;
  ------------------
  |  |   66|  2.25k|#define nullptr NULL
  ------------------
 1470|  2.25k|        return 0;
 1471|  2.25k|    }
 1472|       |
 1473|    312|    Onion_Friend *newonion_friends = (Onion_Friend *)mem_vrealloc(onion_c->mem, onion_c->friends_list, num, sizeof(Onion_Friend));
 1474|       |
 1475|    312|    if (newonion_friends == nullptr) {
  ------------------
  |  |   66|    312|#define nullptr NULL
  ------------------
  |  Branch (1475:9): [True: 0, False: 312]
  ------------------
 1476|      0|        return -1;
 1477|      0|    }
 1478|       |
 1479|    312|    onion_c->friends_list = newonion_friends;
 1480|    312|    return 0;
 1481|    312|}

ping_new:
  340|  2.14k|{
  341|  2.14k|    Ping *ping = (Ping *)mem_alloc(mem, sizeof(Ping));
  342|       |
  343|  2.14k|    if (ping == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (343:9): [True: 0, False: 2.14k]
  ------------------
  344|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  345|      0|    }
  346|       |
  347|  2.14k|    ping->ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   22|  2.14k|#define PING_NUM_MAX 512
  ------------------
                  ping->ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   57|  2.14k|#define PING_TIMEOUT 5
  ------------------
  348|       |
  349|  2.14k|    if (ping->ping_array == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (349:9): [True: 0, False: 2.14k]
  ------------------
  350|      0|        mem_delete(mem, ping);
  351|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  352|      0|    }
  353|       |
  354|  2.14k|    ping->mono_time = mono_time;
  355|  2.14k|    ping->rng = rng;
  356|  2.14k|    ping->dht = dht;
  357|  2.14k|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, &handle_ping_request, dht);
  358|  2.14k|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, &handle_ping_response, dht);
  359|       |
  360|  2.14k|    return ping;
  361|  2.14k|}
ping_kill:
  364|  2.14k|{
  365|  2.14k|    if (ping == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (365:9): [True: 0, False: 2.14k]
  ------------------
  366|      0|        return;
  367|      0|    }
  368|       |
  369|  2.14k|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  370|  2.14k|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  371|  2.14k|    ping_array_kill(ping->ping_array);
  372|       |
  373|  2.14k|    mem_delete(mem, ping);
  374|  2.14k|}

ping_array_new:
   37|  6.42k|{
   38|  6.42k|    if (size == 0 || timeout == 0) {
  ------------------
  |  Branch (38:9): [True: 0, False: 6.42k]
  |  Branch (38:22): [True: 0, False: 6.42k]
  ------------------
   39|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   40|      0|    }
   41|       |
   42|  6.42k|    if ((size & (size - 1)) != 0) {
  ------------------
  |  Branch (42:9): [True: 0, False: 6.42k]
  ------------------
   43|       |        // Not a power of 2.
   44|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   45|      0|    }
   46|       |
   47|  6.42k|    Ping_Array *const empty_array = (Ping_Array *)mem_alloc(mem, sizeof(Ping_Array));
   48|       |
   49|  6.42k|    if (empty_array == nullptr) {
  ------------------
  |  |   66|  6.42k|#define nullptr NULL
  ------------------
  |  Branch (49:9): [True: 0, False: 6.42k]
  ------------------
   50|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   51|      0|    }
   52|       |
   53|  6.42k|    empty_array->mem = mem;
   54|  6.42k|    empty_array->entries = (Ping_Array_Entry *)mem_valloc(mem, size, sizeof(Ping_Array_Entry));
   55|       |
   56|  6.42k|    if (empty_array->entries == nullptr) {
  ------------------
  |  |   66|  6.42k|#define nullptr NULL
  ------------------
  |  Branch (56:9): [True: 0, False: 6.42k]
  ------------------
   57|      0|        mem_delete(mem, empty_array);
   58|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   59|      0|    }
   60|       |
   61|  6.42k|    empty_array->last_deleted = 0;
   62|  6.42k|    empty_array->last_added = 0;
   63|  6.42k|    empty_array->total_size = size;
   64|  6.42k|    empty_array->timeout = timeout;
   65|  6.42k|    return empty_array;
   66|  6.42k|}
ping_array_kill:
   77|  6.42k|{
   78|  6.42k|    if (array == nullptr) {
  ------------------
  |  |   66|  6.42k|#define nullptr NULL
  ------------------
  |  Branch (78:9): [True: 0, False: 6.42k]
  ------------------
   79|      0|        return;
   80|      0|    }
   81|       |
   82|  6.42k|    while (array->last_deleted != array->last_added) {
  ------------------
  |  Branch (82:12): [True: 0, False: 6.42k]
  ------------------
   83|      0|        const uint32_t index = array->last_deleted % array->total_size;
   84|      0|        clear_entry(array, index);
   85|      0|        ++array->last_deleted;
   86|      0|    }
   87|       |
   88|  6.42k|    mem_delete(array->mem, array->entries);
   89|  6.42k|    mem_delete(array->mem, array);
   90|  6.42k|}

shared_key_cache_new:
   47|  14.9k|{
   48|  14.9k|    if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   66|  29.9k|#define nullptr NULL
  ------------------
                  if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   66|  29.9k|#define nullptr NULL
  ------------------
  |  Branch (48:9): [True: 0, False: 14.9k]
  |  Branch (48:33): [True: 0, False: 14.9k]
  |  Branch (48:63): [True: 0, False: 14.9k]
  |  Branch (48:79): [True: 0, False: 14.9k]
  ------------------
   49|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   50|      0|    }
   51|       |
   52|       |    // Time must not be zero, since we use that as special value for empty slots
   53|  14.9k|    if (mono_time_get(mono_time) == 0) {
  ------------------
  |  Branch (53:9): [True: 0, False: 14.9k]
  ------------------
   54|       |        // Fail loudly in debug environments
   55|      0|        assert(false);
   56|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   57|      0|    }
   58|       |
   59|  14.9k|    Shared_Key_Cache *res = (Shared_Key_Cache *)mem_alloc(mem, sizeof(Shared_Key_Cache));
   60|  14.9k|    if (res == nullptr) {
  ------------------
  |  |   66|  14.9k|#define nullptr NULL
  ------------------
  |  Branch (60:9): [True: 0, False: 14.9k]
  ------------------
   61|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   62|      0|    }
   63|       |
   64|  14.9k|    res->self_secret_key = self_secret_key;
   65|  14.9k|    res->mono_time = mono_time;
   66|  14.9k|    res->mem = mem;
   67|  14.9k|    res->keys_per_slot = keys_per_slot;
   68|       |    // We take one byte from the public key for each bucket and store keys_per_slot elements there
   69|  14.9k|    const size_t cache_size = 256 * keys_per_slot;
   70|  14.9k|    res->keys = (Shared_Key *)mem_valloc(mem, cache_size, sizeof(Shared_Key));
   71|       |
   72|  14.9k|    if (res->keys == nullptr) {
  ------------------
  |  |   66|  14.9k|#define nullptr NULL
  ------------------
  |  Branch (72:9): [True: 0, False: 14.9k]
  ------------------
   73|      0|        mem_delete(mem, res);
   74|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
   75|      0|    }
   76|       |
   77|  14.9k|    crypto_memlock(res->keys, cache_size * sizeof(Shared_Key));
   78|       |
   79|  14.9k|    return res;
   80|  14.9k|}
shared_key_cache_free:
   83|  14.9k|{
   84|  14.9k|    if (cache == nullptr) {
  ------------------
  |  |   66|  14.9k|#define nullptr NULL
  ------------------
  |  Branch (84:9): [True: 0, False: 14.9k]
  ------------------
   85|      0|        return;
   86|      0|    }
   87|       |
   88|  14.9k|    const size_t cache_size = 256 * cache->keys_per_slot;
   89|       |    // Don't leave key material in memory
   90|  14.9k|    crypto_memzero(cache->keys, cache_size * sizeof (Shared_Key));
   91|  14.9k|    crypto_memunlock(cache->keys, cache_size * sizeof (Shared_Key));
   92|  14.9k|    mem_delete(cache->mem, cache->keys);
   93|  14.9k|    mem_delete(cache->mem, cache);
   94|  14.9k|}

state_load:
   14|  2.73k|{
   15|  2.73k|    if (state_load_callback == nullptr || data == nullptr) {
  ------------------
  |  |   66|  5.46k|#define nullptr NULL
  ------------------
                  if (state_load_callback == nullptr || data == nullptr) {
  ------------------
  |  |   66|  2.73k|#define nullptr NULL
  ------------------
  |  Branch (15:9): [True: 0, False: 2.73k]
  |  Branch (15:43): [True: 0, False: 2.73k]
  ------------------
   16|      0|        LOGGER_ERROR(log, "state_load() called with invalid args.");
  ------------------
  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   17|      0|        return -1;
   18|      0|    }
   19|       |
   20|       |
   21|  2.73k|    const uint32_t size_head = sizeof(uint32_t) * 2;
   22|       |
   23|  35.5k|    while (length >= size_head) {
  ------------------
  |  Branch (23:12): [True: 33.2k, False: 2.29k]
  ------------------
   24|  33.2k|        uint32_t length_sub;
   25|  33.2k|        lendian_bytes_to_host32(&length_sub, data);
   26|       |
   27|  33.2k|        uint32_t cookie_type;
   28|  33.2k|        lendian_bytes_to_host32(&cookie_type, data + sizeof(uint32_t));
   29|       |
   30|  33.2k|        data += size_head;
   31|  33.2k|        length -= size_head;
   32|       |
   33|  33.2k|        if (length < length_sub) {
  ------------------
  |  Branch (33:13): [True: 281, False: 32.9k]
  ------------------
   34|       |            /* file truncated */
   35|    281|            LOGGER_ERROR(log, "state file too short: %u < %u", length, length_sub);
  ------------------
  |  |   83|    281|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    281|    do {                                                                         \
  |  |  |  |   73|    281|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    562|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    281|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    281|        }                                                                        \
  |  |  |  |   76|    281|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   36|    281|            return -1;
   37|    281|        }
   38|       |
   39|  32.9k|        if (lendian_to_host16(cookie_type >> 16) != cookie_inner) {
  ------------------
  |  Branch (39:13): [True: 48, False: 32.8k]
  ------------------
   40|       |            /* something is not matching up in a bad way, give up */
   41|     48|            LOGGER_ERROR(log, "state file garbled: %04x != %04x", cookie_type >> 16, cookie_inner);
  ------------------
  |  |   83|     48|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|     48|    do {                                                                         \
  |  |  |  |   73|     48|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|     96|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|     48|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|     48|        }                                                                        \
  |  |  |  |   76|     48|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   42|     48|            return -1;
   43|     48|        }
   44|       |
   45|  32.8k|        const uint16_t type = lendian_to_host16(cookie_type & 0xFFFF);
   46|       |
   47|  32.8k|        switch (state_load_callback(outer, data, length_sub, type)) {
  ------------------
  |  Branch (47:17): [True: 0, False: 32.8k]
  ------------------
   48|  32.7k|            case STATE_LOAD_STATUS_CONTINUE: {
  ------------------
  |  Branch (48:13): [True: 32.7k, False: 108]
  ------------------
   49|  32.7k|                data += length_sub;
   50|  32.7k|                length -= length_sub;
   51|  32.7k|                break;
   52|      0|            }
   53|       |
   54|    107|            case STATE_LOAD_STATUS_ERROR: {
  ------------------
  |  Branch (54:13): [True: 107, False: 32.7k]
  ------------------
   55|    107|                LOGGER_ERROR(log, "Error occcured in state file (type: 0x%02x).", type);
  ------------------
  |  |   83|    107|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    107|    do {                                                                         \
  |  |  |  |   73|    107|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|    214|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    107|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    107|        }                                                                        \
  |  |  |  |   76|    107|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   56|    107|                return -1;
   57|      0|            }
   58|       |
   59|      1|            case STATE_LOAD_STATUS_END: {
  ------------------
  |  Branch (59:13): [True: 1, False: 32.8k]
  ------------------
   60|      1|                return 0;
   61|      0|            }
   62|  32.8k|        }
   63|  32.8k|    }
   64|       |
   65|  2.29k|    if (length != 0) {
  ------------------
  |  Branch (65:9): [True: 500, False: 1.79k]
  ------------------
   66|    500|        LOGGER_ERROR(log, "unparsed data in state file of length %u", length);
  ------------------
  |  |   83|    500|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    500|    do {                                                                         \
  |  |  |  |   73|    500|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  1.00k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    500|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    500|        }                                                                        \
  |  |  |  |   76|    500|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   67|    500|        return -1;
   68|    500|    }
   69|       |
   70|  1.79k|    return 0;
   71|  2.29k|}
state_write_section_header:
   74|  18.4k|{
   75|  18.4k|    host_to_lendian_bytes32(data, len);
   76|  18.4k|    data += sizeof(uint32_t);
   77|  18.4k|    host_to_lendian_bytes32(data, (host_to_lendian16(cookie_type) << 16) | host_to_lendian16(section_type));
   78|  18.4k|    data += sizeof(uint32_t);
   79|  18.4k|    return data;
   80|  18.4k|}
lendian_to_host16:
   83|   102k|{
   84|       |#ifdef WORDS_BIGENDIAN
   85|       |    return (lendian << 8) | (lendian >> 8);
   86|       |#else
   87|   102k|    return lendian;
   88|   102k|#endif
   89|   102k|}
host_to_lendian16:
   92|  36.8k|{
   93|  36.8k|    return lendian_to_host16(host);
   94|  36.8k|}
host_to_lendian_bytes64:
   97|    266|{
   98|       |#ifdef WORDS_BIGENDIAN
   99|       |    num = ((num << 8) & 0xFF00FF00FF00FF00) | ((num >> 8) & 0xFF00FF00FF00FF);
  100|       |    num = ((num << 16) & 0xFFFF0000FFFF0000) | ((num >> 16) & 0xFFFF0000FFFF);
  101|       |    num = (num << 32) | (num >> 32);
  102|       |#endif
  103|    266|    memcpy(dest, &num, sizeof(uint64_t));
  104|    266|}
lendian_bytes_to_host64:
  107|    450|{
  108|    450|    uint64_t d;
  109|    450|    memcpy(&d, lendian, sizeof(uint64_t));
  110|       |#ifdef WORDS_BIGENDIAN
  111|       |    d = ((d << 8) & 0xFF00FF00FF00FF00) | ((d >> 8) & 0xFF00FF00FF00FF);
  112|       |    d = ((d << 16) & 0xFFFF0000FFFF0000) | ((d >> 16) & 0xFFFF0000FFFF);
  113|       |    d = (d << 32) | (d >> 32);
  114|       |#endif
  115|    450|    *dest = d;
  116|    450|}
host_to_lendian_bytes32:
  119|  43.5k|{
  120|       |#ifdef WORDS_BIGENDIAN
  121|       |    num = ((num << 8) & 0xFF00FF00) | ((num >> 8) & 0xFF00FF);
  122|       |    num = (num << 16) | (num >> 16);
  123|       |#endif
  124|  43.5k|    memcpy(dest, &num, sizeof(uint32_t));
  125|  43.5k|}
lendian_bytes_to_host32:
  128|  73.5k|{
  129|  73.5k|    uint32_t d;
  130|  73.5k|    memcpy(&d, lendian, sizeof(uint32_t));
  131|       |#ifdef WORDS_BIGENDIAN
  132|       |    d = ((d << 8) & 0xFF00FF00) | ((d >> 8) & 0xFF00FF);
  133|       |    d = (d << 16) | (d >> 16);
  134|       |#endif
  135|  73.5k|    *dest = d;
  136|  73.5k|}
host_to_lendian_bytes16:
  139|  2.42k|{
  140|       |#ifdef WORDS_BIGENDIAN
  141|       |    num = (num << 8) | (num >> 8);
  142|       |#endif
  143|  2.42k|    memcpy(dest, &num, sizeof(uint16_t));
  144|  2.42k|}
lendian_bytes_to_host16:
  147|  4.28k|{
  148|  4.28k|    uint16_t d;
  149|  4.28k|    memcpy(&d, lendian, sizeof(uint16_t));
  150|       |#ifdef WORDS_BIGENDIAN
  151|       |    d = (d << 8) | (d >> 8);
  152|       |#endif
  153|  4.28k|    *dest = d;
  154|  4.28k|}

tox_new:
  629|  2.14k|{
  630|  2.14k|    struct Tox_Options *default_options = nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  631|       |
  632|  2.14k|    if (options == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (632:9): [True: 0, False: 2.14k]
  ------------------
  633|      0|        Tox_Err_Options_New err;
  634|      0|        default_options = tox_options_new(&err);
  635|       |
  636|      0|        switch (err) {
  ------------------
  |  Branch (636:17): [True: 0, False: 0]
  ------------------
  637|      0|            case TOX_ERR_OPTIONS_NEW_OK: {
  ------------------
  |  Branch (637:13): [True: 0, False: 0]
  ------------------
  638|      0|                break;
  639|      0|            }
  640|       |
  641|      0|            case TOX_ERR_OPTIONS_NEW_MALLOC: {
  ------------------
  |  Branch (641:13): [True: 0, False: 0]
  ------------------
  642|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  643|      0|                return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  644|      0|            }
  645|      0|        }
  646|      0|    }
  647|       |
  648|  2.14k|    const struct Tox_Options *const opts = options != nullptr ? options : default_options;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (648:44): [True: 2.14k, False: 0]
  ------------------
  649|  2.14k|    assert(opts != nullptr);
  650|       |
  651|      0|    const Tox_System *sys = tox_options_get_operating_system(opts);
  652|  2.14k|    const Tox_System default_system = tox_default_system();
  653|       |
  654|  2.14k|    if (sys == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (654:9): [True: 0, False: 2.14k]
  ------------------
  655|      0|        sys = &default_system;
  656|      0|    }
  657|       |
  658|  2.14k|    if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (658:9): [True: 0, False: 2.14k]
  |  Branch (658:32): [True: 0, False: 2.14k]
  |  Branch (658:54): [True: 0, False: 2.14k]
  ------------------
  659|       |        // TODO(iphydf): Not quite right, but similar.
  660|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  661|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  662|      0|    }
  663|       |
  664|  2.14k|    Messenger_Options m_options = {0};
  665|       |
  666|  2.14k|    bool load_savedata_sk = false;
  667|  2.14k|    bool load_savedata_tox = false;
  668|       |
  669|  2.14k|    if (tox_options_get_savedata_type(opts) != TOX_SAVEDATA_TYPE_NONE) {
  ------------------
  |  Branch (669:9): [True: 2.14k, False: 0]
  ------------------
  670|  2.14k|        if (tox_options_get_savedata_data(opts) == nullptr || tox_options_get_savedata_length(opts) == 0) {
  ------------------
  |  |   66|  4.28k|#define nullptr NULL
  ------------------
  |  Branch (670:13): [True: 0, False: 2.14k]
  |  Branch (670:63): [True: 0, False: 2.14k]
  ------------------
  671|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  672|      0|            tox_options_free(default_options);
  673|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  674|      0|        }
  675|  2.14k|    }
  676|       |
  677|  2.14k|    if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_SECRET_KEY) {
  ------------------
  |  Branch (677:9): [True: 0, False: 2.14k]
  ------------------
  678|      0|        if (tox_options_get_savedata_length(opts) != TOX_SECRET_KEY_SIZE) {
  ------------------
  |  |  224|      0|#define TOX_SECRET_KEY_SIZE            32
  ------------------
  |  Branch (678:13): [True: 0, False: 0]
  ------------------
  679|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  680|      0|            tox_options_free(default_options);
  681|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  682|      0|        }
  683|       |
  684|      0|        load_savedata_sk = true;
  685|  2.14k|    } else if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_TOX_SAVE) {
  ------------------
  |  Branch (685:16): [True: 2.14k, False: 0]
  ------------------
  686|  2.14k|        if (tox_options_get_savedata_length(opts) < TOX_ENC_SAVE_MAGIC_LENGTH) {
  ------------------
  |  |   10|  2.14k|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (686:13): [True: 1, False: 2.14k]
  ------------------
  687|      1|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   34|      1|    do {                              \
  |  |   35|      1|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      2|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 1]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  688|      1|            tox_options_free(default_options);
  689|      1|            return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  690|      1|        }
  691|       |
  692|  2.14k|        if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |    9|  2.14k|#define TOX_ENC_SAVE_MAGIC_NUMBER ((const uint8_t *)"toxEsave")
  ------------------
                      if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |   10|  2.14k|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (692:13): [True: 1, False: 2.14k]
  ------------------
  693|      1|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_ENCRYPTED);
  ------------------
  |  |   34|      1|    do {                              \
  |  |   35|      1|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      2|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 1]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  694|      1|            tox_options_free(default_options);
  695|      1|            return nullptr;
  ------------------
  |  |   66|      1|#define nullptr NULL
  ------------------
  696|      1|        }
  697|       |
  698|  2.14k|        load_savedata_tox = true;
  699|  2.14k|    }
  700|       |
  701|  2.14k|    m_options.ipv6enabled = tox_options_get_ipv6_enabled(opts);
  702|  2.14k|    m_options.udp_disabled = !tox_options_get_udp_enabled(opts);
  703|  2.14k|    m_options.port_range[0] = tox_options_get_start_port(opts);
  704|  2.14k|    m_options.port_range[1] = tox_options_get_end_port(opts);
  705|  2.14k|    m_options.tcp_server_port = tox_options_get_tcp_port(opts);
  706|  2.14k|    m_options.hole_punching_enabled = tox_options_get_hole_punching_enabled(opts);
  707|  2.14k|    m_options.local_discovery_enabled = tox_options_get_local_discovery_enabled(opts);
  708|  2.14k|    m_options.dht_announcements_enabled = tox_options_get_dht_announcements_enabled(opts);
  709|       |
  710|  2.14k|    if (m_options.udp_disabled) {
  ------------------
  |  Branch (710:9): [True: 0, False: 2.14k]
  ------------------
  711|      0|        m_options.local_discovery_enabled = false;
  712|      0|    }
  713|       |
  714|  2.14k|    Tox *tox = (Tox *)mem_alloc(sys->mem, sizeof(Tox));
  715|       |
  716|  2.14k|    if (tox == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (716:9): [True: 0, False: 2.14k]
  ------------------
  717|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  718|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  719|      0|    }
  720|       |
  721|  2.14k|    tox->log_callback = tox_options_get_log_callback(opts);
  722|  2.14k|    m_options.log_callback = tox_log_handler;
  723|  2.14k|    m_options.log_context = tox;
  724|  2.14k|    m_options.log_user_data = tox_options_get_log_user_data(opts);
  725|       |
  726|  2.14k|    switch (tox_options_get_proxy_type(opts)) {
  727|      0|        case TOX_PROXY_TYPE_HTTP: {
  ------------------
  |  Branch (727:9): [True: 0, False: 2.14k]
  ------------------
  728|      0|            m_options.proxy_info.proxy_type = TCP_PROXY_HTTP;
  729|      0|            break;
  730|      0|        }
  731|       |
  732|      0|        case TOX_PROXY_TYPE_SOCKS5: {
  ------------------
  |  Branch (732:9): [True: 0, False: 2.14k]
  ------------------
  733|      0|            m_options.proxy_info.proxy_type = TCP_PROXY_SOCKS5;
  734|      0|            break;
  735|      0|        }
  736|       |
  737|  2.14k|        case TOX_PROXY_TYPE_NONE: {
  ------------------
  |  Branch (737:9): [True: 2.14k, False: 0]
  ------------------
  738|  2.14k|            m_options.proxy_info.proxy_type = TCP_PROXY_NONE;
  739|  2.14k|            break;
  740|      0|        }
  741|       |
  742|      0|        default: {
  ------------------
  |  Branch (742:9): [True: 0, False: 2.14k]
  ------------------
  743|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_TYPE);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  744|      0|            tox_options_free(default_options);
  745|      0|            mem_delete(sys->mem, tox);
  746|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  747|      0|        }
  748|  2.14k|    }
  749|       |
  750|  2.14k|    tox->sys = *sys;
  751|       |
  752|  2.14k|    if (m_options.proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (752:9): [True: 0, False: 2.14k]
  ------------------
  753|      0|        if (tox_options_get_proxy_port(opts) == 0) {
  ------------------
  |  Branch (753:13): [True: 0, False: 0]
  ------------------
  754|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_PORT);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  755|      0|            tox_options_free(default_options);
  756|      0|            mem_delete(sys->mem, tox);
  757|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  758|      0|        }
  759|       |
  760|      0|        ip_init(&m_options.proxy_info.ip_port.ip, m_options.ipv6enabled);
  761|       |
  762|      0|        if (m_options.ipv6enabled) {
  ------------------
  |  Branch (762:13): [True: 0, False: 0]
  ------------------
  763|      0|            m_options.proxy_info.ip_port.ip.family = net_family_unspec();
  764|      0|        }
  765|       |
  766|      0|        const char *const proxy_host = tox_options_get_proxy_host(opts);
  767|       |
  768|      0|        if (proxy_host == nullptr
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (768:13): [True: 0, False: 0]
  ------------------
  769|      0|                || !addr_resolve_or_parse_ip(tox->sys.ns, proxy_host, &m_options.proxy_info.ip_port.ip, nullptr)) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (769:20): [True: 0, False: 0]
  ------------------
  770|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_HOST);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  771|       |            // TODO(irungentoo): TOX_ERR_NEW_PROXY_NOT_FOUND if domain.
  772|      0|            tox_options_free(default_options);
  773|      0|            mem_delete(sys->mem, tox);
  774|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  775|      0|        }
  776|       |
  777|      0|        m_options.proxy_info.ip_port.port = net_htons(tox_options_get_proxy_port(opts));
  778|      0|    }
  779|       |
  780|  2.14k|    tox->mono_time = mono_time_new(tox->sys.mem, sys->mono_time_callback, sys->mono_time_user_data);
  781|       |
  782|  2.14k|    if (tox->mono_time == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (782:9): [True: 0, False: 2.14k]
  ------------------
  783|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  784|      0|        tox_options_free(default_options);
  785|      0|        mem_delete(sys->mem, tox);
  786|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  787|      0|    }
  788|       |
  789|  2.14k|    if (tox_options_get_experimental_thread_safety(opts)) {
  ------------------
  |  Branch (789:9): [True: 0, False: 2.14k]
  ------------------
  790|      0|        tox->mutex = (pthread_mutex_t *)mem_alloc(sys->mem, sizeof(pthread_mutex_t));
  791|       |
  792|      0|        if (tox->mutex == nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (792:13): [True: 0, False: 0]
  ------------------
  793|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  794|      0|            tox_options_free(default_options);
  795|      0|            mem_delete(sys->mem, tox);
  796|      0|            return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  797|      0|        }
  798|       |
  799|       |
  800|      0|        pthread_mutexattr_t attr;
  801|       |
  802|      0|        pthread_mutexattr_init(&attr);
  803|      0|        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
  804|      0|        pthread_mutex_init(tox->mutex, &attr);
  805|  2.14k|    } else {
  806|  2.14k|        tox->mutex = nullptr;
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  807|  2.14k|    }
  808|       |
  809|  2.14k|    tox_lock(tox);
  810|       |
  811|  2.14k|    Messenger_Error m_error;
  812|  2.14k|    tox->m = new_messenger(tox->mono_time, tox->sys.mem, tox->sys.rng, tox->sys.ns, &m_options, &m_error);
  813|       |
  814|  2.14k|    if (tox->m == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (814:9): [True: 0, False: 2.14k]
  ------------------
  815|      0|        switch (m_error) {
  ------------------
  |  Branch (815:17): [True: 0, False: 0]
  ------------------
  816|      0|            case MESSENGER_ERROR_PORT:
  ------------------
  |  Branch (816:13): [True: 0, False: 0]
  ------------------
  817|      0|            case MESSENGER_ERROR_TCP_SERVER: {
  ------------------
  |  Branch (817:13): [True: 0, False: 0]
  ------------------
  818|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PORT_ALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  819|      0|                break;
  820|      0|            }
  821|      0|            case MESSENGER_ERROR_OTHER:
  ------------------
  |  Branch (821:13): [True: 0, False: 0]
  ------------------
  822|      0|            case MESSENGER_ERROR_NONE: {
  ------------------
  |  Branch (822:13): [True: 0, False: 0]
  ------------------
  823|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  824|      0|                break;
  825|      0|            }
  826|      0|        }
  827|       |
  828|      0|        mono_time_free(tox->sys.mem, tox->mono_time);
  829|      0|        tox_options_free(default_options);
  830|      0|        tox_unlock(tox);
  831|       |
  832|      0|        if (tox->mutex != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (832:13): [True: 0, False: 0]
  ------------------
  833|      0|            pthread_mutex_destroy(tox->mutex);
  834|      0|        }
  835|       |
  836|      0|        mem_delete(sys->mem, tox->mutex);
  837|      0|        mem_delete(sys->mem, tox);
  838|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  839|      0|    }
  840|       |
  841|  2.14k|    if (new_groupchats(tox->mono_time, tox->m) == nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (841:9): [True: 0, False: 2.14k]
  ------------------
  842|      0|        kill_messenger(tox->m);
  843|       |
  844|      0|        mono_time_free(tox->sys.mem, tox->mono_time);
  845|      0|        tox_options_free(default_options);
  846|      0|        tox_unlock(tox);
  847|       |
  848|      0|        if (tox->mutex != nullptr) {
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  |  Branch (848:13): [True: 0, False: 0]
  ------------------
  849|      0|            pthread_mutex_destroy(tox->mutex);
  850|      0|        }
  851|       |
  852|      0|        mem_delete(sys->mem, tox->mutex);
  853|      0|        mem_delete(sys->mem, tox);
  854|       |
  855|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   34|      0|    do {                              \
  |  |   35|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  856|      0|        return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  857|      0|    }
  858|       |
  859|  2.14k|    if (load_savedata_tox
  ------------------
  |  Branch (859:9): [True: 2.14k, False: 0]
  ------------------
  860|  2.14k|            && tox_load(tox, tox_options_get_savedata_data(opts), tox_options_get_savedata_length(opts)) == -1) {
  ------------------
  |  Branch (860:16): [True: 634, False: 1.50k]
  ------------------
  861|    634|        kill_groupchats(tox->m->conferences_object);
  862|    634|        kill_messenger(tox->m);
  863|       |
  864|    634|        mono_time_free(tox->sys.mem, tox->mono_time);
  865|    634|        tox_options_free(default_options);
  866|    634|        tox_unlock(tox);
  867|       |
  868|    634|        if (tox->mutex != nullptr) {
  ------------------
  |  |   66|    634|#define nullptr NULL
  ------------------
  |  Branch (868:13): [True: 0, False: 634]
  ------------------
  869|      0|            pthread_mutex_destroy(tox->mutex);
  870|      0|        }
  871|       |
  872|    634|        mem_delete(sys->mem, tox->mutex);
  873|    634|        mem_delete(sys->mem, tox);
  874|       |
  875|    634|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   34|    634|    do {                              \
  |  |   35|    634|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|  1.26k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 634]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|    634|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  876|    634|        return nullptr;
  ------------------
  |  |   66|    634|#define nullptr NULL
  ------------------
  877|    634|    }
  878|       |
  879|  1.50k|    if (load_savedata_sk) {
  ------------------
  |  Branch (879:9): [True: 0, False: 1.50k]
  ------------------
  880|      0|        load_secret_key(tox->m->net_crypto, tox_options_get_savedata_data(opts));
  881|      0|    }
  882|       |
  883|  1.50k|    m_callback_namechange(tox->m, tox_friend_name_handler);
  884|  1.50k|    m_callback_core_connection(tox->m, tox_self_connection_status_handler);
  885|  1.50k|    m_callback_statusmessage(tox->m, tox_friend_status_message_handler);
  886|  1.50k|    m_callback_userstatus(tox->m, tox_friend_status_handler);
  887|  1.50k|    m_callback_connectionstatus(tox->m, tox_friend_connection_status_handler);
  888|  1.50k|    m_callback_typingchange(tox->m, tox_friend_typing_handler);
  889|  1.50k|    m_callback_read_receipt(tox->m, tox_friend_read_receipt_handler);
  890|  1.50k|    m_callback_friendrequest(tox->m, tox_friend_request_handler);
  891|  1.50k|    m_callback_friendmessage(tox->m, tox_friend_message_handler);
  892|  1.50k|    callback_file_control(tox->m, tox_file_recv_control_handler);
  893|  1.50k|    callback_file_reqchunk(tox->m, tox_file_chunk_request_handler);
  894|  1.50k|    callback_file_sendrequest(tox->m, tox_file_recv_handler);
  895|  1.50k|    callback_file_data(tox->m, tox_file_recv_chunk_handler);
  896|  1.50k|    dht_callback_get_nodes_response(tox->m->dht, tox_dht_get_nodes_response_handler);
  897|  1.50k|    g_callback_group_invite(tox->m->conferences_object, tox_conference_invite_handler);
  898|  1.50k|    g_callback_group_connected(tox->m->conferences_object, tox_conference_connected_handler);
  899|  1.50k|    g_callback_group_message(tox->m->conferences_object, tox_conference_message_handler);
  900|  1.50k|    g_callback_group_title(tox->m->conferences_object, tox_conference_title_handler);
  901|  1.50k|    g_callback_peer_name(tox->m->conferences_object, tox_conference_peer_name_handler);
  902|  1.50k|    g_callback_peer_list_changed(tox->m->conferences_object, tox_conference_peer_list_changed_handler);
  903|  1.50k|    custom_lossy_packet_registerhandler(tox->m, tox_friend_lossy_packet_handler);
  904|  1.50k|    custom_lossless_packet_registerhandler(tox->m, tox_friend_lossless_packet_handler);
  905|       |
  906|  1.50k|#ifndef VANILLA_NACL
  907|  1.50k|    m_callback_group_invite(tox->m, tox_group_invite_handler);
  908|  1.50k|    gc_callback_message(tox->m, tox_group_message_handler);
  909|  1.50k|    gc_callback_private_message(tox->m, tox_group_private_message_handler);
  910|  1.50k|    gc_callback_custom_packet(tox->m, tox_group_custom_packet_handler);
  911|  1.50k|    gc_callback_custom_private_packet(tox->m, tox_group_custom_private_packet_handler);
  912|  1.50k|    gc_callback_moderation(tox->m, tox_group_moderation_handler);
  913|  1.50k|    gc_callback_nick_change(tox->m, tox_group_peer_name_handler);
  914|  1.50k|    gc_callback_status_change(tox->m, tox_group_peer_status_handler);
  915|  1.50k|    gc_callback_topic_change(tox->m, tox_group_topic_handler);
  916|  1.50k|    gc_callback_peer_limit(tox->m, tox_group_peer_limit_handler);
  917|  1.50k|    gc_callback_privacy_state(tox->m, tox_group_privacy_state_handler);
  918|  1.50k|    gc_callback_topic_lock(tox->m, tox_group_topic_lock_handler);
  919|  1.50k|    gc_callback_password(tox->m, tox_group_password_handler);
  920|  1.50k|    gc_callback_peer_join(tox->m, tox_group_peer_join_handler);
  921|  1.50k|    gc_callback_peer_exit(tox->m, tox_group_peer_exit_handler);
  922|  1.50k|    gc_callback_self_join(tox->m, tox_group_self_join_handler);
  923|  1.50k|    gc_callback_rejected(tox->m, tox_group_join_fail_handler);
  924|  1.50k|    gc_callback_voice_state(tox->m, tox_group_voice_state_handler);
  925|  1.50k|#endif
  926|       |
  927|  1.50k|    tox_options_free(default_options);
  928|       |
  929|  1.50k|    tox_unlock(tox);
  930|       |
  931|  1.50k|    SET_ERROR_PARAMETER(error, TOX_ERR_NEW_OK);
  ------------------
  |  |   34|  1.50k|    do {                              \
  |  |   35|  1.50k|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|  3.01k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (35:13): [True: 0, False: 1.50k]
  |  |  ------------------
  |  |   36|      0|            *param = x;               \
  |  |   37|      0|        }                             \
  |  |   38|  1.50k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (38:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  932|       |
  933|  1.50k|    return tox;
  934|  2.14k|}
tox_kill:
  937|  1.50k|{
  938|  1.50k|    if (tox == nullptr) {
  ------------------
  |  |   66|  1.50k|#define nullptr NULL
  ------------------
  |  Branch (938:9): [True: 0, False: 1.50k]
  ------------------
  939|      0|        return;
  940|      0|    }
  941|       |
  942|  1.50k|    tox_lock(tox);
  943|  1.50k|    LOGGER_ASSERT(tox->m->log, tox->m->msi_packet == nullptr, "Attempted to kill tox while toxav is still alive");
  ------------------
  |  |   92|  1.50k|    do {                                           \
  |  |   93|  1.50k|        if (!(cond)) {                             \
  |  |  ------------------
  |  |  |  Branch (93:13): [True: 0, False: 1.50k]
  |  |  ------------------
  |  |   94|      0|            LOGGER_ERROR(log, "Assertion failed"); \
  |  |  ------------------
  |  |  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   95|      0|            LOGGER_FATAL(log, __VA_ARGS__);        \
  |  |  ------------------
  |  |  |  |   86|      0|    do {                                \
  |  |  |  |   87|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  |   83|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|    do {                                                                         \
  |  |  |  |  |  |  |  |   73|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   21|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   74|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |  |  |   75|      0|        }                                                                        \
  |  |  |  |  |  |  |  |   76|      0|    } while (0)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |   88|      0|        abort();                        \
  |  |  |  |   89|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   96|      0|        }                                          \
  |  |   97|  1.50k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (97:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  944|  1.50k|    kill_groupchats(tox->m->conferences_object);
  945|  1.50k|    kill_messenger(tox->m);
  946|  1.50k|    mono_time_free(tox->sys.mem, tox->mono_time);
  947|  1.50k|    tox_unlock(tox);
  948|       |
  949|  1.50k|    if (tox->mutex != nullptr) {
  ------------------
  |  |   66|  1.50k|#define nullptr NULL
  ------------------
  |  Branch (949:9): [True: 0, False: 1.50k]
  ------------------
  950|      0|        pthread_mutex_destroy(tox->mutex);
  951|      0|        mem_delete(tox->sys.mem, tox->mutex);
  952|      0|    }
  953|       |
  954|  1.50k|    mem_delete(tox->sys.mem, tox);
  955|  1.50k|}
tox_get_savedata_size:
  969|  3.01k|{
  970|  3.01k|    assert(tox != nullptr);
  971|      0|    tox_lock(tox);
  972|  3.01k|    const size_t ret = 2 * sizeof(uint32_t)
  973|  3.01k|                       + messenger_size(tox->m)
  974|  3.01k|                       + conferences_size(tox->m->conferences_object)
  975|  3.01k|                       + end_size();
  976|  3.01k|    tox_unlock(tox);
  977|  3.01k|    return ret;
  978|  3.01k|}
tox_get_savedata:
  981|  1.50k|{
  982|  1.50k|    assert(tox != nullptr);
  983|       |
  984|  1.50k|    if (savedata == nullptr) {
  ------------------
  |  |   66|  1.50k|#define nullptr NULL
  ------------------
  |  Branch (984:9): [True: 0, False: 1.50k]
  ------------------
  985|      0|        return;
  986|      0|    }
  987|       |
  988|  1.50k|    memset(savedata, 0, tox_get_savedata_size(tox));
  989|       |
  990|  1.50k|    tox_lock(tox);
  991|       |
  992|  1.50k|    const uint32_t size32 = sizeof(uint32_t);
  993|       |
  994|       |    // write cookie
  995|  1.50k|    memset(savedata, 0, size32);
  996|  1.50k|    savedata += size32;
  997|  1.50k|    host_to_lendian_bytes32(savedata, STATE_COOKIE_GLOBAL);
  ------------------
  |  |   26|  1.50k|#define STATE_COOKIE_GLOBAL 0x15ed1b1f
  ------------------
  998|  1.50k|    savedata += size32;
  999|       |
 1000|  1.50k|    savedata = messenger_save(tox->m, savedata);
 1001|  1.50k|    savedata = conferences_save(tox->m->conferences_object, savedata);
 1002|  1.50k|    end_save(savedata);
 1003|       |
 1004|  1.50k|    tox_unlock(tox);
 1005|  1.50k|}
tox.c:tox_log_handler:
   74|  86.9k|{
   75|  86.9k|    Tox *tox = (Tox *)context;
   76|  86.9k|    assert(tox != nullptr);
   77|       |
   78|  86.9k|    if (tox->log_callback != nullptr) {
  ------------------
  |  |   66|  86.9k|#define nullptr NULL
  ------------------
  |  Branch (78:9): [True: 0, False: 86.9k]
  ------------------
   79|      0|        tox->log_callback(tox, (Tox_Log_Level)level, file, line, func, message, userdata);
   80|      0|    }
   81|  86.9k|}
tox.c:tox_load:
  609|  2.14k|{
  610|  2.14k|    uint32_t data32[2];
  611|  2.14k|    const uint32_t cookie_len = sizeof(data32);
  612|       |
  613|  2.14k|    if (length < cookie_len) {
  ------------------
  |  Branch (613:9): [True: 0, False: 2.14k]
  ------------------
  614|      0|        return -1;
  615|      0|    }
  616|       |
  617|  2.14k|    memcpy(data32, data, sizeof(uint32_t));
  618|  2.14k|    lendian_bytes_to_host32(data32 + 1, data + sizeof(uint32_t));
  619|       |
  620|  2.14k|    if (data32[0] != 0 || data32[1] != STATE_COOKIE_GLOBAL) {
  ------------------
  |  |   26|  2.14k|#define STATE_COOKIE_GLOBAL 0x15ed1b1f
  ------------------
  |  Branch (620:9): [True: 1, False: 2.14k]
  |  Branch (620:27): [True: 1, False: 2.13k]
  ------------------
  621|      2|        return -1;
  622|      2|    }
  623|       |
  624|  2.13k|    return state_load(tox->m->log, state_load_callback, tox, data + cookie_len,
  625|  2.13k|                      length - cookie_len, STATE_COOKIE_TYPE);
  ------------------
  |  |   28|  2.13k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
  626|  2.14k|}
tox.c:state_load_callback:
  583|  32.3k|{
  584|  32.3k|    const Tox *tox = (const Tox *)outer;
  585|  32.3k|    State_Load_Status status = STATE_LOAD_STATUS_CONTINUE;
  586|       |
  587|  32.3k|    if (messenger_load_state_section(tox->m, data, length, type, &status)
  ------------------
  |  Branch (587:9): [True: 31.5k, False: 803]
  ------------------
  588|  32.3k|            || conferences_load_state_section(tox->m->conferences_object, data, length, type, &status)) {
  ------------------
  |  Branch (588:16): [True: 287, False: 516]
  ------------------
  589|  31.8k|        return status;
  590|  31.8k|    }
  591|       |
  592|    516|    if (type == STATE_TYPE_END) {
  ------------------
  |  Branch (592:9): [True: 2, False: 514]
  ------------------
  593|      2|        if (length != 0) {
  ------------------
  |  Branch (593:13): [True: 1, False: 1]
  ------------------
  594|      1|            return STATE_LOAD_STATUS_ERROR;
  595|      1|        }
  596|       |
  597|      1|        return STATE_LOAD_STATUS_END;
  598|      2|    }
  599|       |
  600|    514|    LOGGER_ERROR(tox->m->log, "Load state: contains unrecognized part (len %u, type %u)",
  ------------------
  |  |   83|    514|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   72|    514|    do {                                                                         \
  |  |  |  |   73|    514|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   21|  1.02k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   74|    514|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   75|    514|        }                                                                        \
  |  |  |  |   76|    514|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (76:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  601|    514|                 length, type);
  602|       |
  603|    514|    return STATE_LOAD_STATUS_CONTINUE;
  604|    516|}
tox.c:end_size:
  958|  3.01k|{
  959|  3.01k|    return 2 * sizeof(uint32_t);
  960|  3.01k|}
tox.c:end_save:
  964|  1.50k|{
  965|  1.50k|    state_write_section_header(data, STATE_COOKIE_TYPE, 0, STATE_TYPE_END);
  ------------------
  |  |   28|  1.50k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
  966|  1.50k|}

tox_options_get_ipv6_enabled:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_set_ipv6_enabled:
  143|  2.14k|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|  2.14k|{ \
  145|  2.14k|    options->ns##name = name; \
  146|  2.14k|}
tox_options_get_udp_enabled:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_set_udp_enabled:
  143|  2.14k|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|  2.14k|{ \
  145|  2.14k|    options->ns##name = name; \
  146|  2.14k|}
tox_options_get_proxy_type:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_set_proxy_type:
  143|  2.14k|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|  2.14k|{ \
  145|  2.14k|    options->ns##name = name; \
  146|  2.14k|}
tox_options_get_start_port:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_get_end_port:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_get_tcp_port:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_get_hole_punching_enabled:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_set_hole_punching_enabled:
  143|  2.14k|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|  2.14k|{ \
  145|  2.14k|    options->ns##name = name; \
  146|  2.14k|}
tox_options_get_savedata_type:
  139|  6.42k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  6.42k|{ \
  141|  6.42k|    return options->ns##name; \
  142|  6.42k|} \
tox_options_set_savedata_type:
  143|  2.14k|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|  2.14k|{ \
  145|  2.14k|    options->ns##name = name; \
  146|  2.14k|}
tox_options_get_savedata_length:
  139|  6.42k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  6.42k|{ \
  141|  6.42k|    return options->ns##name; \
  142|  6.42k|} \
tox_options_get_log_callback:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_get_log_user_data:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_get_local_discovery_enabled:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_set_local_discovery_enabled:
  143|  2.14k|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|  2.14k|{ \
  145|  2.14k|    options->ns##name = name; \
  146|  2.14k|}
tox_options_get_dht_announcements_enabled:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_set_dht_announcements_enabled:
  143|  2.14k|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|  2.14k|{ \
  145|  2.14k|    options->ns##name = name; \
  146|  2.14k|}
tox_options_get_experimental_thread_safety:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_set_experimental_thread_safety:
  143|  2.14k|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|  2.14k|{ \
  145|  2.14k|    options->ns##name = name; \
  146|  2.14k|}
tox_options_get_operating_system:
  139|  2.14k|type tox_options_get_##ns##name(const struct Tox_Options *options) \
  140|  2.14k|{ \
  141|  2.14k|    return options->ns##name; \
  142|  2.14k|} \
tox_options_set_operating_system:
  143|  2.14k|void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
  144|  2.14k|{ \
  145|  2.14k|    options->ns##name = name; \
  146|  2.14k|}
tox_options_get_savedata_data:
  169|  6.42k|{
  170|  6.42k|    return options->savedata_data;
  171|  6.42k|}
tox_options_set_savedata_data:
  174|  2.14k|{
  175|  2.14k|    options->savedata_data = data;
  176|  2.14k|    options->savedata_length = length;
  177|  2.14k|}
tox_options_default:
  180|  2.14k|{
  181|  2.14k|    if (options != nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (181:9): [True: 2.14k, False: 0]
  ------------------
  182|  2.14k|        const struct Tox_Options default_options = {0};
  183|  2.14k|        *options = default_options;
  184|  2.14k|        tox_options_set_ipv6_enabled(options, true);
  185|  2.14k|        tox_options_set_udp_enabled(options, true);
  186|  2.14k|        tox_options_set_proxy_type(options, TOX_PROXY_TYPE_NONE);
  187|  2.14k|        tox_options_set_hole_punching_enabled(options, true);
  188|  2.14k|        tox_options_set_local_discovery_enabled(options, true);
  189|  2.14k|        tox_options_set_dht_announcements_enabled(options, true);
  190|  2.14k|        tox_options_set_experimental_thread_safety(options, false);
  191|  2.14k|    }
  192|  2.14k|}
tox_options_new:
  195|  2.14k|{
  196|  2.14k|    struct Tox_Options *options = (struct Tox_Options *)calloc(1, sizeof(struct Tox_Options));
  197|       |
  198|  2.14k|    if (options != nullptr) {
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
  |  Branch (198:9): [True: 2.14k, False: 0]
  ------------------
  199|  2.14k|        tox_options_default(options);
  200|  2.14k|        SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_OK);
  ------------------
  |  |   13|  2.14k|    do {                              \
  |  |   14|  2.14k|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|  4.28k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (14:13): [True: 2.14k, False: 0]
  |  |  ------------------
  |  |   15|  2.14k|            *param = x;               \
  |  |   16|  2.14k|        }                             \
  |  |   17|  2.14k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (17:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  201|  2.14k|        return options;
  202|  2.14k|    }
  203|       |
  204|      0|    SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_MALLOC);
  ------------------
  |  |   13|      0|    do {                              \
  |  |   14|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   66|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (14:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   15|      0|            *param = x;               \
  |  |   16|      0|        }                             \
  |  |   17|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (17:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  205|      0|    return nullptr;
  ------------------
  |  |   66|      0|#define nullptr NULL
  ------------------
  206|  2.14k|}
tox_options_free:
  209|  4.28k|{
  210|  4.28k|    free(options);
  211|  4.28k|}

tox_default_system:
   26|  2.14k|{
   27|  2.14k|    const Tox_System sys = {
   28|  2.14k|        nullptr,  // mono_time_callback
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
   29|  2.14k|        nullptr,  // mono_time_user_data
  ------------------
  |  |   66|  2.14k|#define nullptr NULL
  ------------------
   30|  2.14k|        system_random(),
   31|  2.14k|        system_network(),
   32|  2.14k|        system_memory(),
   33|  2.14k|    };
   34|  2.14k|    return sys;
   35|  2.14k|}
tox_lock:
   38|  8.16k|{
   39|  8.16k|    if (tox->mutex != nullptr) {
  ------------------
  |  |   66|  8.16k|#define nullptr NULL
  ------------------
  |  Branch (39:9): [True: 0, False: 8.16k]
  ------------------
   40|      0|        pthread_mutex_lock(tox->mutex);
   41|      0|    }
   42|  8.16k|}
tox_unlock:
   45|  8.16k|{
   46|  8.16k|    if (tox->mutex != nullptr) {
  ------------------
  |  |   66|  8.16k|#define nullptr NULL
  ------------------
  |  Branch (46:9): [True: 0, False: 8.16k]
  ------------------
   47|      0|        pthread_mutex_unlock(tox->mutex);
   48|      0|    }
   49|  8.16k|}

free_uint8_t_pointer_array:
   28|  4.45k|{
   29|  4.45k|    if (ary == nullptr) {
  ------------------
  |  |   66|  4.45k|#define nullptr NULL
  ------------------
  |  Branch (29:9): [True: 4.14k, False: 311]
  ------------------
   30|  4.14k|        return;
   31|  4.14k|    }
   32|       |
   33|    627|    for (size_t i = 0; i < n_items; ++i) {
  ------------------
  |  Branch (33:24): [True: 316, False: 311]
  ------------------
   34|    316|        if (ary[i] != nullptr) {
  ------------------
  |  |   66|    316|#define nullptr NULL
  ------------------
  |  Branch (34:13): [True: 316, False: 0]
  ------------------
   35|    316|            mem_delete(mem, ary[i]);
   36|    316|        }
   37|    316|    }
   38|       |
   39|    311|    mem_delete(mem, ary);
   40|    311|}
data_checksum:
   43|    237|{
   44|    237|    uint8_t checksum[2] = {0};
   45|    237|    uint16_t check;
   46|       |
   47|  8.76k|    for (uint32_t i = 0; i < length; ++i) {
  ------------------
  |  Branch (47:26): [True: 8.53k, False: 237]
  ------------------
   48|  8.53k|        checksum[i % 2] ^= data[i];
   49|  8.53k|    }
   50|       |
   51|    237|    memcpy(&check, checksum, sizeof(check));
   52|    237|    return check;
   53|    237|}
create_recursive_mutex:
   56|  2.14k|{
   57|  2.14k|    pthread_mutexattr_t attr;
   58|       |
   59|  2.14k|    if (pthread_mutexattr_init(&attr) != 0) {
  ------------------
  |  Branch (59:9): [True: 0, False: 2.14k]
  ------------------
   60|      0|        return -1;
   61|      0|    }
   62|       |
   63|  2.14k|    if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE) != 0) {
  ------------------
  |  Branch (63:9): [True: 0, False: 2.14k]
  ------------------
   64|      0|        pthread_mutexattr_destroy(&attr);
   65|      0|        return -1;
   66|      0|    }
   67|       |
   68|       |    /* Create queue mutex */
   69|  2.14k|    if (pthread_mutex_init(mutex, &attr) != 0) {
  ------------------
  |  Branch (69:9): [True: 0, False: 2.14k]
  ------------------
   70|      0|        pthread_mutexattr_destroy(&attr);
   71|      0|        return -1;
   72|      0|    }
   73|       |
   74|  2.14k|    pthread_mutexattr_destroy(&attr);
   75|       |
   76|  2.14k|    return 0;
   77|  2.14k|}
memeq:
   80|  1.87k|{
   81|  1.87k|    return a_size == b_size && memcmp(a, b, a_size) == 0;
  ------------------
  |  Branch (81:12): [True: 1.60k, False: 269]
  |  Branch (81:32): [True: 1.60k, False: 0]
  ------------------
   82|  1.87k|}
min_u16:
  124|  1.92k|{
  125|  1.92k|    return a < b ? a : b;
  ------------------
  |  Branch (125:12): [True: 1.92k, False: 0]
  ------------------
  126|  1.92k|}
min_u32:
  128|     50|{
  129|     50|    return a < b ? a : b;
  ------------------
  |  Branch (129:12): [True: 24, False: 26]
  ------------------
  130|     50|}
jenkins_one_at_a_time_hash:
  137|    283|{
  138|    283|    uint32_t hash = 0;
  139|       |
  140|  9.33k|    for (uint32_t i = 0; i < len; ++i) {
  ------------------
  |  Branch (140:26): [True: 9.05k, False: 283]
  ------------------
  141|  9.05k|        hash += key[i];
  142|  9.05k|        hash += (uint32_t)((uint64_t)hash << 10);
  143|  9.05k|        hash ^= hash >> 6;
  144|  9.05k|    }
  145|       |
  146|    283|    hash += (uint32_t)((uint64_t)hash << 3);
  147|    283|    hash ^= hash >> 11;
  148|    283|    hash += (uint32_t)((uint64_t)hash << 15);
  149|    283|    return hash;
  150|    283|}

