LLVMFuzzerTestOneInput:
   57|  1.40k|{
   58|  1.40k|    Fuzz_Data input{data, size};
   59|  1.40k|    TestSaveDataLoading(input);
   60|  1.40k|    return 0;  // Non-zero return values are reserved for future use.
   61|  1.40k|}
toxsave_fuzz_test.cc:_ZN12_GLOBAL__N_119TestSaveDataLoadingERN3tox4test9Fuzz_DataE:
   16|  1.40k|{
   17|  1.40k|    Tox_Err_Options_New error_options;
   18|       |
   19|  1.40k|    struct Tox_Options *tox_options = tox_options_new(&error_options);
   20|       |
   21|  1.40k|    assert(tox_options != nullptr);
  ------------------
  |  Branch (21:5): [True: 1.40k, False: 0]
  ------------------
   22|  1.40k|    assert(error_options == TOX_ERR_OPTIONS_NEW_OK);
  ------------------
  |  Branch (22:5): [True: 1.40k, False: 0]
  ------------------
   23|       |
   24|  1.40k|    const size_t savedata_size = input.size();
   25|  1.40k|    CONSUME_OR_RETURN(const uint8_t *savedata, input, savedata_size);
  ------------------
  |  |  138|  1.40k|    if ((INPUT).size() < (SIZE)) {           \
  |  |  ------------------
  |  |  |  Branch (138:9): [True: 0, False: 1.40k]
  |  |  ------------------
  |  |  139|      0|        return;                              \
  |  |  140|      0|    }                                        \
  |  |  141|  1.40k|    DECL = (INPUT).consume(__func__, (SIZE))
  ------------------
   26|       |
   27|  1.40k|    tox_options_set_experimental_groups_persistence(tox_options, true);
   28|       |
   29|       |    // pass test data to Tox
   30|  1.40k|    tox_options_set_savedata_data(tox_options, savedata, savedata_size);
   31|  1.40k|    tox_options_set_savedata_type(tox_options, TOX_SAVEDATA_TYPE_TOX_SAVE);
   32|       |
   33|  1.40k|    Tox_Options_Testing tox_options_testing;
   34|  1.40k|    SimulatedEnvironment env;
   35|  1.40k|    auto node = env.create_node(33445);
   36|  1.40k|    tox_options_testing.operating_system = &node->system;
   37|       |
   38|  1.40k|    Tox_Err_New_Testing err_testing;
   39|  1.40k|    Tox *tox = tox_new_testing(tox_options, nullptr, &tox_options_testing, &err_testing);
   40|  1.40k|    tox_options_free(tox_options);
   41|  1.40k|    if (tox == nullptr) {
  ------------------
  |  Branch (41:9): [True: 425, False: 981]
  ------------------
   42|       |        // Tox save was invalid, we're finished here
   43|    425|        return;
   44|    425|    }
   45|       |
   46|       |    // verify that the file can be saved again
   47|    981|    std::vector<uint8_t> new_savedata(tox_get_savedata_size(tox));
   48|    981|    tox_get_savedata(tox, new_savedata.data());
   49|       |
   50|    981|    tox_kill(tox);
   51|    981|}

_ZN3tox4test16FakeNetworkStackC2ERNS0_15NetworkUniverseERK2IP:
   98|  1.40k|    : universe_(universe)
   99|  1.40k|    , node_ip_(node_ip)
  100|  1.40k|{
  101|  1.40k|}
_ZN3tox4test16FakeNetworkStackD2Ev:
  103|  1.40k|FakeNetworkStack::~FakeNetworkStack() = default;
_ZN3tox4test16FakeNetworkStack9c_networkEv:
  105|  1.40k|struct Network FakeNetworkStack::c_network() { return Network{&kNetworkVtable, this}; }
_ZN3tox4test16FakeNetworkStack6socketEiii:
  108|  2.81k|{
  109|  2.81k|    std::lock_guard<std::mutex> lock(mutex_);
  110|  2.81k|    int fd = next_fd_++;
  111|       |
  112|  2.81k|    std::unique_ptr<FakeSocket> sock;
  113|  2.81k|    if (type == SOCK_DGRAM) {
  ------------------
  |  Branch (113:9): [True: 2.81k, False: 0]
  ------------------
  114|  2.81k|        if (universe_.is_verbose()) {
  ------------------
  |  Branch (114:13): [True: 0, False: 2.81k]
  ------------------
  115|      0|            std::cerr << "[FakeNetworkStack] create UDP socket fd=" << fd << std::endl;
  116|      0|        }
  117|  2.81k|        sock = std::make_unique<FakeUdpSocket>(universe_);
  118|  2.81k|    } else if (type == SOCK_STREAM) {
  ------------------
  |  Branch (118:16): [True: 0, False: 0]
  ------------------
  119|      0|        if (universe_.is_verbose()) {
  ------------------
  |  Branch (119:13): [True: 0, False: 0]
  ------------------
  120|      0|            std::cerr << "[FakeNetworkStack] create TCP socket fd=" << fd << std::endl;
  121|      0|        }
  122|      0|        sock = std::make_unique<FakeTcpSocket>(universe_);
  123|      0|    } else {
  124|       |        // Unknown type
  125|      0|        return net_socket_from_native(-1);
  126|      0|    }
  127|       |
  128|  2.81k|    sockets_[fd] = std::move(sock);
  129|  2.81k|    sockets_[fd]->set_ip(node_ip_);
  130|  2.81k|    return net_socket_from_native(fd);
  131|  2.81k|}
_ZN3tox4test16FakeNetworkStack8get_sockE6Socket:
  134|  12.6k|{
  135|  12.6k|    std::lock_guard<std::mutex> lock(mutex_);
  136|  12.6k|    auto it = sockets_.find(net_socket_to_native(sock));
  137|  12.6k|    if (it != sockets_.end()) {
  ------------------
  |  Branch (137:9): [True: 12.6k, False: 0]
  ------------------
  138|  12.6k|        return it->second.get();
  139|  12.6k|    }
  140|      0|    return nullptr;
  141|  12.6k|}
_ZN3tox4test16FakeNetworkStack5closeE6Socket:
  144|  1.40k|{
  145|  1.40k|    std::lock_guard<std::mutex> lock(mutex_);
  146|  1.40k|    int fd = net_socket_to_native(sock);
  147|  1.40k|    auto it = sockets_.find(fd);
  148|  1.40k|    if (it == sockets_.end()) {
  ------------------
  |  Branch (148:9): [True: 0, False: 1.40k]
  ------------------
  149|      0|        errno = EBADF;
  150|      0|        return -1;
  151|      0|    }
  152|  1.40k|    it->second->close();
  153|  1.40k|    sockets_.erase(it);
  154|  1.40k|    return 0;
  155|  1.40k|}
_ZN3tox4test16FakeNetworkStack4bindE6SocketPK7IP_Port:
  159|  4.21k|{
  160|  4.21k|    if (auto *s = get_sock(sock)) {
  ------------------
  |  Branch (160:15): [True: 4.21k, False: 0]
  ------------------
  161|  4.21k|        int ret = s->bind(addr);
  162|  4.21k|        if (universe_.is_verbose() && ret == 0) {
  ------------------
  |  Branch (162:13): [True: 0, False: 4.21k]
  |  Branch (162:39): [True: 0, False: 0]
  ------------------
  163|      0|            char ip_str[TOX_INET_ADDRSTRLEN];
  164|      0|            ip_parse_addr(&s->ip_address(), ip_str, sizeof(ip_str));
  165|      0|            std::cerr << "[FakeNetworkStack] bound socket to " << ip_str << ":" << s->local_port()
  166|      0|                      << std::endl;
  167|      0|        }
  168|  4.21k|        return ret;
  169|  4.21k|    }
  170|  4.21k|    errno = EBADF;
  171|      0|    return -1;
  172|  4.21k|}
_ZN3tox4test16FakeNetworkStack15socket_nonblockE6Socketb:
  257|  1.40k|{
  258|  1.40k|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (258:15): [True: 1.40k, False: 0]
  ------------------
  259|  1.40k|        return s->socket_nonblock(nonblock);
  260|  1.40k|    errno = EBADF;
  261|      0|    return -1;
  262|  1.40k|}
_ZN3tox4test16FakeNetworkStack10getsockoptE6SocketiiPvPm:
  265|  1.40k|{
  266|  1.40k|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (266:15): [True: 1.40k, False: 0]
  ------------------
  267|  1.40k|        return s->getsockopt(level, optname, optval, optlen);
  268|  1.40k|    errno = EBADF;
  269|      0|    return -1;
  270|  1.40k|}
_ZN3tox4test16FakeNetworkStack10setsockoptE6SocketiiPKvm:
  274|  5.61k|{
  275|  5.61k|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (275:15): [True: 5.61k, False: 0]
  ------------------
  276|  5.61k|        return s->setsockopt(level, optname, optval, optlen);
  277|  5.61k|    errno = EBADF;
  278|      0|    return -1;
  279|  5.61k|}
_ZN3tox4test16FakeNetworkStack21get_bound_udp_socketsEv:
  292|  1.40k|{
  293|  1.40k|    std::lock_guard<std::mutex> lock(mutex_);
  294|  1.40k|    std::vector<FakeUdpSocket *> result;
  295|  1.40k|    for (const auto &pair : sockets_) {
  ------------------
  |  Branch (295:27): [True: 1.40k, False: 1.40k]
  ------------------
  296|  1.40k|        FakeSocket *s = pair.second.get();
  297|  1.40k|        if (s->type() == SOCK_DGRAM && s->local_port() != 0) {
  ------------------
  |  Branch (297:13): [True: 1.40k, False: 0]
  |  Branch (297:40): [True: 1.40k, False: 0]
  ------------------
  298|  1.40k|            result.push_back(static_cast<FakeUdpSocket *>(s));
  299|  1.40k|        }
  300|  1.40k|    }
  301|  1.40k|    return result;
  302|  1.40k|}
fake_network_stack.cc:_ZNK3tox4test3$_0clEPv6Socket:
   13|  1.40k|                 Socket sock) { return static_cast<FakeNetworkStack *>(obj)->close(sock); },
fake_network_stack.cc:_ZNK3tox4test3$_2clEPv6SocketPK7IP_Port:
   17|  2.80k|        [](void *_Nonnull obj, Socket sock, const IP_Port *_Nonnull addr) {
   18|  2.80k|            return static_cast<FakeNetworkStack *>(obj)->bind(sock, addr);
   19|  2.80k|        },
fake_network_stack.cc:_ZNK3tox4test4$_10clEPviii:
   45|  1.40k|          int proto) { return static_cast<FakeNetworkStack *>(obj)->socket(domain, type, proto); },
fake_network_stack.cc:_ZNK3tox4test4$_11clEPv6Socketb:
   47|  1.40k|        [](void *_Nonnull obj, Socket sock, bool nonblock) {
   48|  1.40k|            return static_cast<FakeNetworkStack *>(obj)->socket_nonblock(sock, nonblock);
   49|  1.40k|        },
fake_network_stack.cc:_ZNK3tox4test4$_12clEPv6SocketiiS2_Pm:
   52|  1.40k|            size_t *_Nonnull optlen) {
   53|  1.40k|            return static_cast<FakeNetworkStack *>(obj)->getsockopt(
   54|  1.40k|                sock, level, optname, optval, optlen);
   55|  1.40k|        },
fake_network_stack.cc:_ZNK3tox4test4$_13clEPv6SocketiiPKvm:
   58|  5.61k|            size_t optlen) {
   59|  5.61k|            return static_cast<FakeNetworkStack *>(obj)->setsockopt(
   60|  5.61k|                sock, level, optname, optval, optlen);
   61|  5.61k|        },

_ZN3tox4test10FakeSocketC2ERNS0_15NetworkUniverseEi:
   19|  2.81k|    : universe_(universe)
   20|  2.81k|    , type_(type)
   21|  2.81k|{
   22|  2.81k|    ip_init(&ip_, false);
   23|  2.81k|    ip_.ip.v4.uint32 = net_htonl(0x7F000001);
   24|  2.81k|}
_ZN3tox4test10FakeSocketD2Ev:
   26|  2.81k|FakeSocket::~FakeSocket() = default;
_ZN3tox4test10FakeSocket10getsockoptEiiPvPm:
   35|  1.40k|{
   36|  1.40k|    return 0;
   37|  1.40k|}
_ZN3tox4test10FakeSocket10setsockoptEiiPKvm:
   39|  5.61k|{
   40|  5.61k|    return 0;
   41|  5.61k|}
_ZN3tox4test10FakeSocket15socket_nonblockEb:
   43|  1.40k|{
   44|  1.40k|    nonblocking_ = nonblock;
   45|  1.40k|    return 0;
   46|  1.40k|}
_ZN3tox4test13FakeUdpSocketC2ERNS0_15NetworkUniverseE:
   51|  2.81k|    : FakeSocket(universe, SOCK_DGRAM)
   52|  2.81k|{
   53|  2.81k|}
_ZN3tox4test13FakeUdpSocketD2Ev:
   55|  2.81k|FakeUdpSocket::~FakeUdpSocket() { close_impl(); }
_ZN3tox4test13FakeUdpSocket5closeEv:
   58|  1.40k|{
   59|  1.40k|    std::lock_guard<std::mutex> lock(mutex_);
   60|  1.40k|    close_impl();
   61|  1.40k|    return 0;
   62|  1.40k|}
_ZN3tox4test13FakeUdpSocket10close_implEv:
   65|  4.21k|{
   66|  4.21k|    if (local_port_ != 0) {
  ------------------
  |  Branch (66:9): [True: 2.81k, False: 1.40k]
  ------------------
   67|  2.81k|        universe_.unbind_udp(ip_, local_port_);
   68|  2.81k|        local_port_ = 0;
   69|  2.81k|    }
   70|  4.21k|}
_ZN3tox4test13FakeUdpSocket4bindEPK7IP_Port:
   73|  4.21k|{
   74|  4.21k|    std::lock_guard<std::mutex> lock(mutex_);
   75|  4.21k|    if (local_port_ != 0)
  ------------------
  |  Branch (75:9): [True: 0, False: 4.21k]
  ------------------
   76|      0|        return -1;  // Already bound
   77|       |
   78|  4.21k|    uint16_t port = addr->port;
   79|  4.21k|    if (port == 0) {
  ------------------
  |  Branch (79:9): [True: 0, False: 4.21k]
  ------------------
   80|      0|        port = universe_.find_free_port(ip_);
   81|  4.21k|    } else {
   82|  4.21k|        port = net_ntohs(port);
   83|  4.21k|    }
   84|       |
   85|  4.21k|    if (universe_.bind_udp(ip_, port, this)) {
  ------------------
  |  Branch (85:9): [True: 2.81k, False: 1.40k]
  ------------------
   86|  2.81k|        local_port_ = port;
   87|  2.81k|        return 0;
   88|  2.81k|    }
   89|  4.21k|    errno = EADDRINUSE;
   90|  1.40k|    return -1;
   91|  4.21k|}

_ZNK3tox4test10FakeSocket4typeEv:
   59|  1.40k|    int type() const { return type_; }
_ZNK3tox4test10FakeSocket10local_portEv:
   60|  1.40k|    uint16_t local_port() const { return local_port_; }
_ZN3tox4test10FakeSocket6set_ipERK2IP:
   63|  2.81k|    void set_ip(const IP &ip) { ip_ = ip; }

_ZNK3tox4test15NetworkUniverse11IP_Port_KeyltERKS2_:
   35|  15.4k|{
   36|  15.4k|    if (port != other.port)
  ------------------
  |  Branch (36:9): [True: 7.02k, False: 8.42k]
  ------------------
   37|  7.02k|        return port < other.port;
   38|  8.42k|    if (ip.family.value != other.ip.family.value)
  ------------------
  |  Branch (38:9): [True: 0, False: 8.42k]
  ------------------
   39|      0|        return ip.family.value < other.ip.family.value;
   40|       |
   41|  8.42k|    if (net_family_is_ipv4(ip.family)) {
  ------------------
  |  Branch (41:9): [True: 8.42k, False: 0]
  ------------------
   42|  8.42k|        return ip.ip.v4.uint32 < other.ip.ip.v4.uint32;
   43|  8.42k|    }
   44|       |
   45|      0|    return std::memcmp(&ip.ip.v6, &other.ip.ip.v6, sizeof(ip.ip.v6)) < 0;
   46|  8.42k|}
_ZN3tox4test15NetworkUniverseC2Ev:
   48|  1.40k|NetworkUniverse::NetworkUniverse() { }
_ZN3tox4test15NetworkUniverseD2Ev:
   49|  1.40k|NetworkUniverse::~NetworkUniverse() { }
_ZN3tox4test15NetworkUniverse8bind_udpE2IPtPNS0_13FakeUdpSocketE:
   52|  4.21k|{
   53|  4.21k|    std::lock_guard<std::recursive_mutex> lock(mutex_);
   54|  4.21k|    IP_Port_Key key{ip, port};
   55|  4.21k|    if (udp_bindings_.count(key))
  ------------------
  |  Branch (55:9): [True: 1.40k, False: 2.81k]
  ------------------
   56|  1.40k|        return false;
   57|  2.81k|    udp_bindings_[key] = socket;
   58|  2.81k|    return true;
   59|  4.21k|}
_ZN3tox4test15NetworkUniverse10unbind_udpE2IPt:
   62|  2.81k|{
   63|  2.81k|    std::lock_guard<std::recursive_mutex> lock(mutex_);
   64|  2.81k|    udp_bindings_.erase({ip, port});
   65|  2.81k|}
_ZNK3tox4test15NetworkUniverse10is_verboseEv:
  292|  8.43k|bool NetworkUniverse::is_verbose() const { return verbose_; }

_ZN3tox4test9Fuzz_DataC2EPKhm:
   25|  1.40k|        : data_(input_data)
   26|  1.40k|        , base_(input_data)
   27|  1.40k|        , size_(input_size)
   28|  1.40k|    {
   29|  1.40k|    }
_ZNK3tox4test9Fuzz_Data4sizeEv:
  101|  2.81k|    std::size_t size() const { return size_; }
_ZN3tox4test9Fuzz_Data7consumeEPKcm:
  107|  1.40k|    {
  108|  1.40k|        if (count > size_)
  ------------------
  |  Branch (108:13): [True: 0, False: 1.40k]
  ------------------
  109|      0|            return nullptr;
  110|  1.40k|        const uint8_t *_Nonnull val = data_;
  111|  1.40k|        if (FUZZ_DEBUG) {
  ------------------
  |  Branch (111:13): [Folded, False: 1.40k]
  ------------------
  112|      0|            if (count == 1) {
  ------------------
  |  Branch (112:17): [True: 0, False: 0]
  ------------------
  113|      0|                std::printf("consume@%zu(%s): %d (0x%02x)\n", pos(), func, val[0], val[0]);
  114|      0|            } else if (count != 0) {
  ------------------
  |  Branch (114:24): [True: 0, False: 0]
  ------------------
  115|      0|                std::printf("consume@%zu(%s): %02x..%02x[%zu]\n", pos(), func, val[0],
  116|      0|                    val[count - 1], count);
  117|      0|            }
  118|      0|        }
  119|  1.40k|        data_ += count;
  120|  1.40k|        size_ -= count;
  121|  1.40k|        return val;
  122|  1.40k|    }

_ZN3tox4test10Simulation5clockEv:
  155|  1.40k|    FakeClock &clock() { return *clock_; }
_ZN3tox4test10Simulation3netEv:
  157|  1.40k|    NetworkUniverse &net() { return *net_; }
_ZN3tox4test13SimulatedNode12fake_networkEv:
  201|  2.81k|    FakeNetworkStack &fake_network() { return *network_; }
_ZN3tox4test9LogFilterC2Ev:
   51|  1.40k|    LogFilter() = default;

_ZN3tox4test11ClockSystemD2Ev:
    5|  1.40k|ClockSystem::~ClockSystem() = default;

_ZN3tox4test11EnvironmentD2Ev:
    5|  2.81k|Environment::~Environment() = default;

_ZN3tox4test9FakeClockC2Em:
    6|  1.40k|    : now_ms_(start_time_ms)
    7|  1.40k|{
    8|  1.40k|}
_ZNK3tox4test9FakeClock15current_time_msEv:
   10|  1.40k|uint64_t FakeClock::current_time_ms() const { return now_ms_; }

_ZN3tox4test10FakeMemoryC2Ev:
   25|  2.81k|FakeMemory::FakeMemory() = default;
_ZN3tox4test10FakeMemoryD2Ev:
   26|  2.81k|FakeMemory::~FakeMemory() = default;
_ZN3tox4test10FakeMemory6mallocEm:
   29|  90.2k|{
   30|  90.2k|    bool fail = failure_injector_ && failure_injector_(size);
  ------------------
  |  Branch (30:17): [True: 0, False: 90.2k]
  |  Branch (30:38): [True: 0, False: 0]
  ------------------
   31|       |
   32|  90.2k|    if (observer_) {
  ------------------
  |  Branch (32:9): [True: 0, False: 90.2k]
  ------------------
   33|      0|        observer_(!fail);
   34|      0|    }
   35|       |
   36|  90.2k|    if (fail) {
  ------------------
  |  Branch (36:9): [True: 0, False: 90.2k]
  ------------------
   37|      0|        return nullptr;
   38|      0|    }
   39|       |
   40|  90.2k|    void *ptr = std::malloc(size + sizeof(Header));
   41|  90.2k|    if (!ptr) {
  ------------------
  |  Branch (41:9): [True: 0, False: 90.2k]
  ------------------
   42|      0|        return nullptr;
   43|      0|    }
   44|       |
   45|  90.2k|    Header *header = static_cast<Header *>(ptr);
   46|  90.2k|    header->size = size;
   47|  90.2k|    header->magic = kMagic;
   48|       |
   49|  90.2k|    on_allocation(size);
   50|       |
   51|  90.2k|    return header + 1;
   52|  90.2k|}
_ZN3tox4test10FakeMemory7reallocEPvm:
   55|  45.4k|{
   56|  45.4k|    if (!ptr) {
  ------------------
  |  Branch (56:9): [True: 15.9k, False: 29.4k]
  ------------------
   57|  15.9k|        return malloc(size);
   58|  15.9k|    }
   59|       |
   60|  29.4k|    Header *old_header = static_cast<Header *>(ptr) - 1;
   61|  29.4k|    if (old_header->magic != kMagic) {
  ------------------
  |  Branch (61:9): [True: 0, False: 29.4k]
  ------------------
   62|      0|        if (old_header->magic == kFreeMagic) {
  ------------------
  |  Branch (62:13): [True: 0, False: 0]
  ------------------
   63|      0|            std::cerr << "[FakeMemory] realloc: Double realloc/free detected at " << ptr
   64|      0|                      << " (header=" << old_header << ")" << std::endl;
   65|      0|        } else {
   66|      0|            std::cerr << "[FakeMemory] realloc: Invalid pointer (wrong magic 0x" << std::hex
   67|      0|                      << old_header->magic << ") at " << ptr << " (header=" << old_header << ")"
   68|      0|                      << std::endl;
   69|      0|        }
   70|      0|        std::abort();
   71|      0|    }
   72|       |
   73|  29.4k|    bool fail = failure_injector_ && failure_injector_(size);
  ------------------
  |  Branch (73:17): [True: 0, False: 29.4k]
  |  Branch (73:38): [True: 0, False: 0]
  ------------------
   74|       |
   75|  29.4k|    if (observer_) {
  ------------------
  |  Branch (75:9): [True: 0, False: 29.4k]
  ------------------
   76|      0|        observer_(!fail);
   77|      0|    }
   78|       |
   79|  29.4k|    if (fail) {
  ------------------
  |  Branch (79:9): [True: 0, False: 29.4k]
  ------------------
   80|      0|        return nullptr;
   81|      0|    }
   82|       |
   83|  29.4k|    size_t old_size = old_header->size;
   84|  29.4k|    void *new_ptr = std::realloc(old_header, size + sizeof(Header));
   85|  29.4k|    if (!new_ptr) {
  ------------------
  |  Branch (85:9): [True: 0, False: 29.4k]
  ------------------
   86|      0|        return nullptr;
   87|      0|    }
   88|       |
   89|  29.4k|    on_deallocation(old_size);
   90|  29.4k|    on_allocation(size);
   91|       |
   92|  29.4k|    Header *header = static_cast<Header *>(new_ptr);
   93|  29.4k|    header->size = size;
   94|  29.4k|    header->magic = kMagic;
   95|       |
   96|  29.4k|    return header + 1;
   97|  29.4k|}
_ZN3tox4test10FakeMemory4freeEPv:
  100|  1.09M|{
  101|  1.09M|    if (!ptr) {
  ------------------
  |  Branch (101:9): [True: 1.00M, False: 90.2k]
  ------------------
  102|  1.00M|        return;
  103|  1.00M|    }
  104|       |
  105|  90.2k|    Header *header = static_cast<Header *>(ptr) - 1;
  106|  90.2k|    if (header->magic != kMagic) {
  ------------------
  |  Branch (106:9): [True: 0, False: 90.2k]
  ------------------
  107|      0|        if (header->magic == kFreeMagic) {
  ------------------
  |  Branch (107:13): [True: 0, False: 0]
  ------------------
  108|      0|            std::cerr << "[FakeMemory] free: Double free detected at " << ptr
  109|      0|                      << " (header=" << header << ")" << std::endl;
  110|      0|        } else {
  111|      0|            std::cerr << "[FakeMemory] free: Invalid pointer (wrong magic 0x" << std::hex
  112|      0|                      << header->magic << ") at " << ptr << " (header=" << header << ")"
  113|      0|                      << std::endl;
  114|      0|        }
  115|      0|        std::abort();
  116|      0|    }
  117|       |
  118|  90.2k|    size_t size = header->size;
  119|  90.2k|    on_deallocation(size);
  120|  90.2k|    header->magic = kFreeMagic;  // Mark as free
  121|  90.2k|    std::free(header);
  122|  90.2k|}
_ZN3tox4test10FakeMemory8c_memoryEv:
  131|  2.81k|struct Memory FakeMemory::c_memory() { return Memory{&kFakeMemoryVtable, this}; }
_ZN3tox4test10FakeMemory13on_allocationEm:
  138|   119k|{
  139|   119k|    size_t current = current_allocation_.fetch_add(size) + size;
  140|   119k|    size_t max = max_allocation_.load(std::memory_order_relaxed);
  141|   119k|    while (current > max && !max_allocation_.compare_exchange_weak(max, current)) { }
  ------------------
  |  Branch (141:12): [True: 109k, False: 10.3k]
  |  Branch (141:29): [True: 0, False: 109k]
  ------------------
  142|   119k|}
_ZN3tox4test10FakeMemory15on_deallocationEm:
  144|   119k|void FakeMemory::on_deallocation(size_t size) { current_allocation_.fetch_sub(size); }
fake_memory.cc:_ZNK3tox4test3$_0clEPvj:
   15|  74.2k|                           uint32_t size) { return static_cast<FakeMemory *>(obj)->malloc(size); },
fake_memory.cc:_ZNK3tox4test3$_1clEPvS2_j:
   18|  45.4k|          uint32_t size) { return static_cast<FakeMemory *>(obj)->realloc(ptr, size); },
fake_memory.cc:_ZNK3tox4test3$_2clEPvS2_:
   20|  1.09M|    = [](void *_Nonnull obj, void *_Nullable ptr) { static_cast<FakeMemory *>(obj)->free(ptr); },

_ZN3tox4test10FakeRandomC2Em:
   21|  2.81k|    : rng_(seed)
   22|  2.81k|{
   23|  2.81k|}
_ZN3tox4test10FakeRandom5bytesEPhm:
   48|  21.2k|{
   49|  21.2k|    if (entropy_source_) {
  ------------------
  |  Branch (49:9): [True: 0, False: 21.2k]
  ------------------
   50|      0|        entropy_source_(out, count);
   51|  21.2k|    } else {
   52|  21.2k|        std::uniform_int_distribution<uint16_t> dist(0, 255);
   53|  21.2k|        std::generate_n(out, count, [&]() { return static_cast<uint8_t>(dist(rng_)); });
   54|  21.2k|    }
   55|       |
   56|  21.2k|    if (observer_) {
  ------------------
  |  Branch (56:9): [True: 0, False: 21.2k]
  ------------------
   57|      0|        observer_(out, count);
   58|      0|    }
   59|  21.2k|}
_ZN3tox4test10FakeRandom8c_randomEv:
   61|  2.81k|struct Random FakeRandom::c_random() { return Random{&kFakeRandomVtable, this}; }
fake_random.cc:_ZZN3tox4test10FakeRandom5bytesEPhmENK3$_0clEv:
   53|   547k|        std::generate_n(out, count, [&]() { return static_cast<uint8_t>(dist(rng_)); });
fake_random.cc:_ZNK3tox4test3$_1clEPvPhj:
   14|  21.2k|          uint32_t length) { static_cast<FakeRandom *>(obj)->bytes(bytes, length); },

_ZN3tox4test12MemorySystemD2Ev:
    5|  2.81k|MemorySystem::~MemorySystem() = default;

_ZN3tox4test13NetworkSystemD2Ev:
    5|  1.40k|NetworkSystem::~NetworkSystem() = default;
_ZN3tox4test7make_ipEj:
    8|  2.81k|{
    9|  2.81k|    IP ip;
   10|  2.81k|    ip_init(&ip, false);
   11|  2.81k|    ip.ip.v4.uint32 = net_htonl(ipv4);
   12|  2.81k|    return ip;
   13|  2.81k|}
_ZN3tox4test12make_node_ipEj:
   16|  2.81k|{
   17|       |    // Use 20.x.y.z range: 20. (id >> 16) . (id >> 8) . (id & 0xFF)
   18|  2.81k|    return make_ip(0x14000000 | (node_id & 0x00FFFFFF));
   19|  2.81k|}

_ZN3tox4test12RandomSystemD2Ev:
    5|  2.81k|RandomSystem::~RandomSystem() = default;

_ZN3tox4test20SimulatedEnvironmentC2Ev:
    8|  1.40k|    : sim_(std::make_unique<Simulation>())
    9|  1.40k|    , global_random_(std::make_unique<FakeRandom>(12345))
   10|  1.40k|    , global_memory_(std::make_unique<FakeMemory>())
   11|  1.40k|{
   12|  1.40k|}
_ZN3tox4test20SimulatedEnvironmentD2Ev:
   14|  1.40k|SimulatedEnvironment::~SimulatedEnvironment() = default;
_ZN3tox4test20SimulatedEnvironment11create_nodeEt:
   37|  1.40k|{
   38|  1.40k|    auto scoped = std::make_unique<ScopedToxSystem>();
   39|  1.40k|    scoped->node = sim_->create_node();
   40|       |
   41|       |    // Bind port
   42|  1.40k|    if (port != 0) {
  ------------------
  |  Branch (42:9): [True: 1.40k, False: 0]
  ------------------
   43|  1.40k|        Socket s = scoped->node->fake_network().socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
   44|  1.40k|        IP_Port addr;
   45|  1.40k|        ip_init(&addr.ip, false);
   46|  1.40k|        addr.ip.ip.v4.uint32 = 0;
   47|  1.40k|        addr.port = net_htons(port);
   48|  1.40k|        scoped->node->fake_network().bind(s, &addr);
   49|  1.40k|    }
   50|       |
   51|       |    // Get Primary Endpoint for Fuzzer
   52|  1.40k|    scoped->endpoint = scoped->node->get_primary_socket();
   53|       |
   54|       |    // Use global Random and Memory for legacy compatibility.
   55|  1.40k|    scoped->c_random = global_random_->c_random();
   56|  1.40k|    scoped->c_memory = global_memory_->c_memory();
   57|       |
   58|       |    // Use Node's Network
   59|  1.40k|    scoped->c_network = scoped->node->c_network;
   60|       |
   61|       |    // Setup System
   62|  1.40k|    scoped->system.mem = &scoped->c_memory;
   63|  1.40k|    scoped->system.ns = &scoped->c_network;
   64|  1.40k|    scoped->system.rng = &scoped->c_random;
   65|       |
   66|  1.40k|    scoped->system.mono_time_user_data = &sim_->clock();
   67|  1.40k|    scoped->system.mono_time_callback = [](void *_Nullable user_data) -> uint64_t {
   68|  1.40k|        return static_cast<FakeClock *>(user_data)->current_time_ms();
   69|  1.40k|    };
   70|       |
   71|  1.40k|    return scoped;
   72|  1.40k|}
simulated_environment.cc:_ZZN3tox4test20SimulatedEnvironment11create_nodeEtENK3$_0clEPv:
   67|  1.40k|    scoped->system.mono_time_callback = [](void *_Nullable user_data) -> uint64_t {
   68|  1.40k|        return static_cast<FakeClock *>(user_data)->current_time_ms();
   69|  1.40k|    };

_ZN3tox4test10SimulationC2Ev:
   97|  1.40k|    : clock_(std::make_unique<FakeClock>())
   98|  1.40k|    , net_(std::make_unique<NetworkUniverse>())
   99|  1.40k|{
  100|  1.40k|}
_ZN3tox4test10SimulationD2Ev:
  102|  1.40k|Simulation::~Simulation() = default;
_ZN3tox4test10Simulation11create_nodeEv:
  236|  1.40k|{
  237|  1.40k|    auto node = std::make_unique<SimulatedNode>(*this, ++node_count_);
  238|  1.40k|    if (net_->is_verbose()) {
  ------------------
  |  Branch (238:9): [True: 0, False: 1.40k]
  ------------------
  239|      0|        uint32_t ip4 = net_ntohl(node->ip.ip.v4.uint32);
  240|      0|        std::cerr << "[Simulation] Created node " << node_count_ << " with IP "
  241|      0|                  << ((ip4 >> 24) & 0xFF) << "." << ((ip4 >> 16) & 0xFF) << "."
  242|      0|                  << ((ip4 >> 8) & 0xFF) << "." << (ip4 & 0xFF) << std::endl;
  243|      0|    }
  244|  1.40k|    return node;
  245|  1.40k|}
_ZN3tox4test13SimulatedNodeC2ERNS0_10SimulationEj:
  250|  1.40k|    : sim_(sim)
  251|  1.40k|    , network_(std::make_unique<FakeNetworkStack>(sim.net(), make_node_ip(node_id)))
  252|  1.40k|    , random_(std::make_unique<FakeRandom>(12345 + node_id))  // Unique seed
  253|  1.40k|    , memory_(std::make_unique<FakeMemory>())
  254|  1.40k|    , c_network(network_->c_network())
  255|  1.40k|    , c_random(random_->c_random())
  256|  1.40k|    , c_memory(memory_->c_memory())
  257|  1.40k|    , ip(make_node_ip(node_id))
  258|  1.40k|{
  259|  1.40k|}
_ZN3tox4test13SimulatedNodeD2Ev:
  261|  1.40k|SimulatedNode::~SimulatedNode() = default;
_ZN3tox4test13SimulatedNode18get_primary_socketEv:
  331|  1.40k|{
  332|  1.40k|    auto sockets = network_->get_bound_udp_sockets();
  333|  1.40k|    if (sockets.empty())
  ------------------
  |  Branch (333:9): [True: 0, False: 1.40k]
  ------------------
  334|      0|        return nullptr;
  335|  1.40k|    return sockets.front();  // Return the first one bound
  336|  1.40k|}

cmp_init:
  837|  35.6k|                                         cmp_writer *write) {
  838|  35.6k|  ctx->error = CMP_ERROR_NONE;
  839|  35.6k|  ctx->buf = buf;
  840|  35.6k|  ctx->read = read;
  841|  35.6k|  ctx->skip = skip;
  842|  35.6k|  ctx->write = write;
  843|  35.6k|}
cmp_write_pfix:
  859|  3.47k|bool cmp_write_pfix(cmp_ctx_t *ctx, uint8_t c) {
  860|  3.47k|  if (c <= 0x7F)
  ------------------
  |  Branch (860:7): [True: 3.47k, False: 0]
  ------------------
  861|  3.47k|    return write_fixed_value(ctx, c);
  862|       |
  863|      0|  ctx->error = CMP_ERROR_INPUT_VALUE_TOO_LARGE;
  864|       |  return false;
  865|  3.47k|}
cmp_write_u8:
  938|     20|bool cmp_write_u8(cmp_ctx_t *ctx, uint8_t c) {
  939|     20|  if (!write_type_marker(ctx, U8_MARKER))
  ------------------
  |  Branch (939:7): [True: 0, False: 20]
  ------------------
  940|      0|    return false;
  941|       |
  942|     20|  return ctx->write(ctx, &c, sizeof(uint8_t)) == sizeof(uint8_t);
  943|     20|}
cmp_write_u16:
  945|    344|bool cmp_write_u16(cmp_ctx_t *ctx, uint16_t s) {
  946|    344|  if (!write_type_marker(ctx, U16_MARKER))
  ------------------
  |  Branch (946:7): [True: 0, False: 344]
  ------------------
  947|      0|    return false;
  948|       |
  949|    344|  s = be16(s);
  950|       |
  951|    344|  return ctx->write(ctx, &s, sizeof(uint16_t)) == sizeof(uint16_t);
  952|    344|}
cmp_write_uinteger:
  972|  3.84k|bool cmp_write_uinteger(cmp_ctx_t *ctx, uint64_t u) {
  973|  3.84k|  if (u <= 0x7F)
  ------------------
  |  Branch (973:7): [True: 3.47k, False: 364]
  ------------------
  974|  3.47k|    return cmp_write_pfix(ctx, (uint8_t)u);
  975|    364|  if (u <= 0xFF)
  ------------------
  |  Branch (975:7): [True: 20, False: 344]
  ------------------
  976|     20|    return cmp_write_u8(ctx, (uint8_t)u);
  977|    344|  if (u <= 0xFFFF)
  ------------------
  |  Branch (977:7): [True: 344, False: 0]
  ------------------
  978|    344|    return cmp_write_u16(ctx, (uint16_t)u);
  979|      0|  if (u <= 0xFFFFFFFF)
  ------------------
  |  Branch (979:7): [True: 0, False: 0]
  ------------------
  980|      0|    return cmp_write_u32(ctx, (uint32_t)u);
  981|       |
  982|      0|  return cmp_write_u64(ctx, u);
  983|      0|}
cmp_write_nil:
 1041|     72|bool cmp_write_nil(cmp_ctx_t *ctx) {
 1042|     72|  return write_type_marker(ctx, NIL_MARKER);
 1043|     72|}
cmp_write_true:
 1045|     12|bool cmp_write_true(cmp_ctx_t *ctx) {
 1046|     12|  return write_type_marker(ctx, TRUE_MARKER);
 1047|     12|}
cmp_write_false:
 1049|    244|bool cmp_write_false(cmp_ctx_t *ctx) {
 1050|    244|  return write_type_marker(ctx, FALSE_MARKER);
 1051|    244|}
cmp_write_bool:
 1053|    256|bool cmp_write_bool(cmp_ctx_t *ctx, bool b) {
 1054|    256|  if (b)
  ------------------
  |  Branch (1054:7): [True: 12, False: 244]
  ------------------
 1055|     12|    return cmp_write_true(ctx);
 1056|       |
 1057|    244|  return cmp_write_false(ctx);
 1058|    256|}
cmp_write_bin8_marker:
 1205|  3.42k|bool cmp_write_bin8_marker(cmp_ctx_t *ctx, uint8_t size) {
 1206|  3.42k|  if (!write_type_marker(ctx, BIN8_MARKER))
  ------------------
  |  Branch (1206:7): [True: 0, False: 3.42k]
  ------------------
 1207|      0|    return false;
 1208|       |
 1209|  3.42k|  if (ctx->write(ctx, &size, sizeof(uint8_t)) == sizeof(uint8_t))
  ------------------
  |  Branch (1209:7): [True: 3.42k, False: 0]
  ------------------
 1210|  3.42k|    return true;
 1211|       |
 1212|      0|  ctx->error = CMP_ERROR_LENGTH_WRITING;
 1213|       |  return false;
 1214|  3.42k|}
cmp_write_bin8:
 1216|  3.16k|bool cmp_write_bin8(cmp_ctx_t *ctx, const void *data, uint8_t size) {
 1217|  3.16k|  if (!cmp_write_bin8_marker(ctx, size))
  ------------------
  |  Branch (1217:7): [True: 0, False: 3.16k]
  ------------------
 1218|      0|    return false;
 1219|       |
 1220|  3.16k|  if (size == 0)
  ------------------
  |  Branch (1220:7): [True: 0, False: 3.16k]
  ------------------
 1221|      0|    return true;
 1222|       |
 1223|  3.16k|  if (ctx->write(ctx, data, size) == size)
  ------------------
  |  Branch (1223:7): [True: 3.16k, False: 0]
  ------------------
 1224|  3.16k|    return true;
 1225|       |
 1226|      0|  ctx->error = CMP_ERROR_DATA_WRITING;
 1227|       |  return false;
 1228|  3.16k|}
cmp_write_bin16_marker:
 1230|    344|bool cmp_write_bin16_marker(cmp_ctx_t *ctx, uint16_t size) {
 1231|    344|  if (!write_type_marker(ctx, BIN16_MARKER))
  ------------------
  |  Branch (1231:7): [True: 0, False: 344]
  ------------------
 1232|      0|    return false;
 1233|       |
 1234|    344|  size = be16(size);
 1235|       |
 1236|    344|  if (ctx->write(ctx, &size, sizeof(uint16_t)) == sizeof(uint16_t))
  ------------------
  |  Branch (1236:7): [True: 344, False: 0]
  ------------------
 1237|    344|    return true;
 1238|       |
 1239|      0|  ctx->error = CMP_ERROR_LENGTH_WRITING;
 1240|       |  return false;
 1241|    344|}
cmp_write_bin16:
 1243|    344|bool cmp_write_bin16(cmp_ctx_t *ctx, const void *data, uint16_t size) {
 1244|    344|  if (!cmp_write_bin16_marker(ctx, size))
  ------------------
  |  Branch (1244:7): [True: 0, False: 344]
  ------------------
 1245|      0|    return false;
 1246|       |
 1247|    344|  if (size == 0)
  ------------------
  |  Branch (1247:7): [True: 0, False: 344]
  ------------------
 1248|      0|    return true;
 1249|       |
 1250|    344|  if (ctx->write(ctx, data, size) == size)
  ------------------
  |  Branch (1250:7): [True: 344, False: 0]
  ------------------
 1251|    344|    return true;
 1252|       |
 1253|      0|  ctx->error = CMP_ERROR_DATA_WRITING;
 1254|       |  return false;
 1255|    344|}
cmp_write_bin_marker:
 1284|    256|bool cmp_write_bin_marker(cmp_ctx_t *ctx, uint32_t size) {
 1285|    256|  if (size <= 0xFF)
  ------------------
  |  Branch (1285:7): [True: 256, False: 0]
  ------------------
 1286|    256|    return cmp_write_bin8_marker(ctx, (uint8_t)size);
 1287|      0|  if (size <= 0xFFFF)
  ------------------
  |  Branch (1287:7): [True: 0, False: 0]
  ------------------
 1288|      0|    return cmp_write_bin16_marker(ctx, (uint16_t)size);
 1289|       |
 1290|      0|  return cmp_write_bin32_marker(ctx, size);
 1291|      0|}
cmp_write_bin:
 1293|  3.51k|bool cmp_write_bin(cmp_ctx_t *ctx, const void *data, uint32_t size) {
 1294|  3.51k|  if (size <= 0xFF)
  ------------------
  |  Branch (1294:7): [True: 3.16k, False: 344]
  ------------------
 1295|  3.16k|    return cmp_write_bin8(ctx, data, (uint8_t)size);
 1296|    344|  if (size <= 0xFFFF)
  ------------------
  |  Branch (1296:7): [True: 344, False: 0]
  ------------------
 1297|    344|    return cmp_write_bin16(ctx, data, (uint16_t)size);
 1298|       |
 1299|      0|  return cmp_write_bin32(ctx, data, size);
 1300|    344|}
cmp_write_fixarray:
 1302|  4.27k|bool cmp_write_fixarray(cmp_ctx_t *ctx, uint8_t size) {
 1303|  4.27k|  if (size <= FIXARRAY_SIZE)
  ------------------
  |  Branch (1303:7): [True: 4.27k, False: 0]
  ------------------
 1304|  4.27k|    return write_fixed_value(ctx, FIXARRAY_MARKER | size);
 1305|       |
 1306|      0|  ctx->error = CMP_ERROR_INPUT_VALUE_TOO_LARGE;
 1307|       |  return false;
 1308|  4.27k|}
cmp_write_array16:
 1310|      8|bool cmp_write_array16(cmp_ctx_t *ctx, uint16_t size) {
 1311|      8|  if (!write_type_marker(ctx, ARRAY16_MARKER))
  ------------------
  |  Branch (1311:7): [True: 0, False: 8]
  ------------------
 1312|      0|    return false;
 1313|       |
 1314|      8|  size = be16(size);
 1315|       |
 1316|      8|  if (ctx->write(ctx, &size, sizeof(uint16_t)) == sizeof(uint16_t))
  ------------------
  |  Branch (1316:7): [True: 8, False: 0]
  ------------------
 1317|      8|    return true;
 1318|       |
 1319|      0|  ctx->error = CMP_ERROR_LENGTH_WRITING;
 1320|       |  return false;
 1321|      8|}
cmp_write_array:
 1336|  4.28k|bool cmp_write_array(cmp_ctx_t *ctx, uint32_t size) {
 1337|  4.28k|  if (size <= FIXARRAY_SIZE)
  ------------------
  |  Branch (1337:7): [True: 4.27k, False: 8]
  ------------------
 1338|  4.27k|    return cmp_write_fixarray(ctx, (uint8_t)size);
 1339|      8|  if (size <= 0xFFFF)
  ------------------
  |  Branch (1339:7): [True: 8, False: 0]
  ------------------
 1340|      8|    return cmp_write_array16(ctx, (uint16_t)size);
 1341|       |
 1342|      0|  return cmp_write_array32(ctx, size);
 1343|      8|}
cmp_read_uchar:
 2144|  26.7k|bool cmp_read_uchar(cmp_ctx_t *ctx, uint8_t *c) {
 2145|  26.7k|  cmp_object_t obj;
 2146|       |
 2147|  26.7k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2147:7): [True: 697, False: 26.0k]
  ------------------
 2148|    697|    return false;
 2149|       |
 2150|  26.0k|  switch (obj.type) {
 2151|  18.1k|    case CMP_TYPE_POSITIVE_FIXNUM:
  ------------------
  |  Branch (2151:5): [True: 18.1k, False: 7.87k]
  ------------------
 2152|  23.4k|    case CMP_TYPE_UINT8: {
  ------------------
  |  Branch (2152:5): [True: 5.34k, False: 20.6k]
  ------------------
 2153|  23.4k|      *c = obj.as.u8;
 2154|  23.4k|      return true;
 2155|  18.1k|    }
 2156|    247|    case CMP_TYPE_NEGATIVE_FIXNUM:
  ------------------
  |  Branch (2156:5): [True: 247, False: 25.7k]
  ------------------
 2157|    819|    case CMP_TYPE_SINT8: {
  ------------------
  |  Branch (2157:5): [True: 572, False: 25.4k]
  ------------------
 2158|    819|      if (obj.as.s8 >= 0) {
  ------------------
  |  Branch (2158:11): [True: 572, False: 247]
  ------------------
 2159|    572|        *c = (uint8_t)obj.as.s8;
 2160|    572|        return true;
 2161|    572|      }
 2162|    247|      break;
 2163|    819|    }
 2164|  1.71k|    default:
  ------------------
  |  Branch (2164:5): [True: 1.71k, False: 24.3k]
  ------------------
 2165|  1.71k|      break;
 2166|  26.0k|  }
 2167|       |
 2168|  1.96k|  ctx->error = CMP_ERROR_INVALID_TYPE;
 2169|       |  return false;
 2170|  26.0k|}
cmp_read_ushort:
 2172|  50.9k|bool cmp_read_ushort(cmp_ctx_t *ctx, uint16_t *s) {
 2173|  50.9k|  cmp_object_t obj;
 2174|       |
 2175|  50.9k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2175:7): [True: 1.00k, False: 49.8k]
  ------------------
 2176|  1.00k|    return false;
 2177|       |
 2178|  49.8k|  switch (obj.type) {
 2179|  30.4k|    case CMP_TYPE_POSITIVE_FIXNUM:
  ------------------
  |  Branch (2179:5): [True: 30.4k, False: 19.4k]
  ------------------
 2180|  47.1k|    case CMP_TYPE_UINT8: {
  ------------------
  |  Branch (2180:5): [True: 16.6k, False: 33.2k]
  ------------------
 2181|  47.1k|      *s = obj.as.u8;
 2182|  47.1k|      return true;
 2183|  30.4k|    }
 2184|    645|    case CMP_TYPE_UINT16: {
  ------------------
  |  Branch (2184:5): [True: 645, False: 49.2k]
  ------------------
 2185|    645|      *s = obj.as.u16;
 2186|    645|      return true;
 2187|  30.4k|    }
 2188|    103|    case CMP_TYPE_NEGATIVE_FIXNUM:
  ------------------
  |  Branch (2188:5): [True: 103, False: 49.7k]
  ------------------
 2189|    139|    case CMP_TYPE_SINT8: {
  ------------------
  |  Branch (2189:5): [True: 36, False: 49.8k]
  ------------------
 2190|    139|      if (obj.as.s8 >= 0) {
  ------------------
  |  Branch (2190:11): [True: 36, False: 103]
  ------------------
 2191|     36|        *s = (uint8_t)obj.as.s8;
 2192|     36|        return true;
 2193|     36|      }
 2194|    103|      break;
 2195|    139|    }
 2196|    103|    case CMP_TYPE_SINT16: {
  ------------------
  |  Branch (2196:5): [True: 78, False: 49.8k]
  ------------------
 2197|     78|      if (obj.as.s16 >= 0) {
  ------------------
  |  Branch (2197:11): [True: 44, False: 34]
  ------------------
 2198|     44|        *s = (uint16_t)obj.as.s16;
 2199|     44|        return true;
 2200|     44|      }
 2201|     34|      break;
 2202|     78|    }
 2203|  1.92k|    default:
  ------------------
  |  Branch (2203:5): [True: 1.92k, False: 47.9k]
  ------------------
 2204|  1.92k|      break;
 2205|  49.8k|  }
 2206|       |
 2207|  2.05k|  ctx->error = CMP_ERROR_INVALID_TYPE;
 2208|       |  return false;
 2209|  49.8k|}
cmp_read_uint:
 2211|  27.4k|bool cmp_read_uint(cmp_ctx_t *ctx, uint32_t *i) {
 2212|  27.4k|  cmp_object_t obj;
 2213|       |
 2214|  27.4k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2214:7): [True: 2.53k, False: 24.9k]
  ------------------
 2215|  2.53k|    return false;
 2216|       |
 2217|  24.9k|  switch (obj.type) {
 2218|  18.2k|    case CMP_TYPE_POSITIVE_FIXNUM:
  ------------------
  |  Branch (2218:5): [True: 18.2k, False: 6.72k]
  ------------------
 2219|  18.3k|    case CMP_TYPE_UINT8: {
  ------------------
  |  Branch (2219:5): [True: 165, False: 24.7k]
  ------------------
 2220|  18.3k|      *i = obj.as.u8;
 2221|  18.3k|      return true;
 2222|  18.2k|    }
 2223|  1.38k|    case CMP_TYPE_UINT16: {
  ------------------
  |  Branch (2223:5): [True: 1.38k, False: 23.5k]
  ------------------
 2224|  1.38k|      *i = obj.as.u16;
 2225|  1.38k|      return true;
 2226|  18.2k|    }
 2227|    966|    case CMP_TYPE_UINT32: {
  ------------------
  |  Branch (2227:5): [True: 966, False: 23.9k]
  ------------------
 2228|    966|      *i = obj.as.u32;
 2229|    966|      return true;
 2230|  18.2k|    }
 2231|    872|    case CMP_TYPE_NEGATIVE_FIXNUM:
  ------------------
  |  Branch (2231:5): [True: 872, False: 24.0k]
  ------------------
 2232|    907|    case CMP_TYPE_SINT8: {
  ------------------
  |  Branch (2232:5): [True: 35, False: 24.9k]
  ------------------
 2233|    907|      if (obj.as.s8 >= 0) {
  ------------------
  |  Branch (2233:11): [True: 35, False: 872]
  ------------------
 2234|     35|        *i = (uint8_t)obj.as.s8;
 2235|     35|        return true;
 2236|     35|      }
 2237|    872|      break;
 2238|    907|    }
 2239|    872|    case CMP_TYPE_SINT16: {
  ------------------
  |  Branch (2239:5): [True: 52, False: 24.8k]
  ------------------
 2240|     52|      if (obj.as.s16 >= 0) {
  ------------------
  |  Branch (2240:11): [True: 34, False: 18]
  ------------------
 2241|     34|        *i = (uint16_t)obj.as.s16;
 2242|     34|        return true;
 2243|     34|      }
 2244|     18|      break;
 2245|     52|    }
 2246|  1.05k|    case CMP_TYPE_SINT32: {
  ------------------
  |  Branch (2246:5): [True: 1.05k, False: 23.8k]
  ------------------
 2247|  1.05k|      if (obj.as.s32 >= 0) {
  ------------------
  |  Branch (2247:11): [True: 989, False: 67]
  ------------------
 2248|    989|        *i = (uint32_t)obj.as.s32;
 2249|    989|        return true;
 2250|    989|      }
 2251|     67|      break;
 2252|  1.05k|    }
 2253|  2.19k|    default:
  ------------------
  |  Branch (2253:5): [True: 2.19k, False: 22.7k]
  ------------------
 2254|  2.19k|      break;
 2255|  24.9k|  }
 2256|       |
 2257|  3.15k|  ctx->error = CMP_ERROR_INVALID_TYPE;
 2258|       |  return false;
 2259|  24.9k|}
cmp_read_nil:
 2382|     51|bool cmp_read_nil(cmp_ctx_t *ctx) {
 2383|     51|  cmp_object_t obj;
 2384|       |
 2385|     51|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2385:7): [True: 3, False: 48]
  ------------------
 2386|      3|    return false;
 2387|       |
 2388|     48|  if (obj.type == CMP_TYPE_NIL)
  ------------------
  |  Branch (2388:7): [True: 28, False: 20]
  ------------------
 2389|     28|    return true;
 2390|       |
 2391|     20|  ctx->error = CMP_ERROR_INVALID_TYPE;
 2392|       |  return false;
 2393|     48|}
cmp_read_bool:
 2395|  21.1k|bool cmp_read_bool(cmp_ctx_t *ctx, bool *b) {
 2396|  21.1k|  cmp_object_t obj;
 2397|       |
 2398|  21.1k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2398:7): [True: 465, False: 20.7k]
  ------------------
 2399|    465|    return false;
 2400|       |
 2401|  20.7k|  if (obj.type != CMP_TYPE_BOOLEAN) {
  ------------------
  |  Branch (2401:7): [True: 1.84k, False: 18.8k]
  ------------------
 2402|  1.84k|    ctx->error = CMP_ERROR_INVALID_TYPE;
 2403|  1.84k|    return false;
 2404|  1.84k|  }
 2405|       |
 2406|  18.8k|  if (obj.as.boolean) {
  ------------------
  |  Branch (2406:7): [True: 309, False: 18.5k]
  ------------------
 2407|    309|    *b = true;
 2408|  18.5k|  } else {
 2409|  18.5k|    *b = false;
 2410|  18.5k|  }
 2411|       |
 2412|       |  return true;
 2413|  20.7k|}
cmp_read_bin_size:
 2479|  4.54k|bool cmp_read_bin_size(cmp_ctx_t *ctx, uint32_t *size) {
 2480|  4.54k|  cmp_object_t obj;
 2481|       |
 2482|  4.54k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2482:7): [True: 12, False: 4.53k]
  ------------------
 2483|     12|    return false;
 2484|       |
 2485|  4.53k|  switch (obj.type) {
 2486|  3.96k|    case CMP_TYPE_BIN8:
  ------------------
  |  Branch (2486:5): [True: 3.96k, False: 564]
  ------------------
 2487|  4.31k|    case CMP_TYPE_BIN16:
  ------------------
  |  Branch (2487:5): [True: 350, False: 4.18k]
  ------------------
 2488|  4.32k|    case CMP_TYPE_BIN32: {
  ------------------
  |  Branch (2488:5): [True: 10, False: 4.52k]
  ------------------
 2489|  4.32k|      *size = obj.as.bin_size;
 2490|  4.32k|      return true;
 2491|  4.31k|    }
 2492|    204|    default: {
  ------------------
  |  Branch (2492:5): [True: 204, False: 4.32k]
  ------------------
 2493|    204|      ctx->error = CMP_ERROR_INVALID_TYPE;
 2494|       |      return false;
 2495|  4.31k|    }
 2496|  4.53k|  }
 2497|  4.53k|}
cmp_read_array:
 2519|  82.3k|bool cmp_read_array(cmp_ctx_t *ctx, uint32_t *size) {
 2520|  82.3k|  cmp_object_t obj;
 2521|       |
 2522|  82.3k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2522:7): [True: 726, False: 81.6k]
  ------------------
 2523|    726|    return false;
 2524|       |
 2525|  81.6k|  switch (obj.type) {
 2526|  71.3k|    case CMP_TYPE_FIXARRAY:
  ------------------
  |  Branch (2526:5): [True: 71.3k, False: 10.3k]
  ------------------
 2527|  71.4k|    case CMP_TYPE_ARRAY16:
  ------------------
  |  Branch (2527:5): [True: 66, False: 81.5k]
  ------------------
 2528|  71.4k|    case CMP_TYPE_ARRAY32: {
  ------------------
  |  Branch (2528:5): [True: 10, False: 81.6k]
  ------------------
 2529|  71.4k|      *size = obj.as.array_size;
 2530|  71.4k|      return true;
 2531|  71.4k|    }
 2532|  10.2k|    default: {
  ------------------
  |  Branch (2532:5): [True: 10.2k, False: 71.4k]
  ------------------
 2533|  10.2k|      ctx->error = CMP_ERROR_INVALID_TYPE;
 2534|       |      return false;
 2535|  71.4k|    }
 2536|  81.6k|  }
 2537|  81.6k|}
cmp_read_object:
 2810|   213k|bool cmp_read_object(cmp_ctx_t *ctx, cmp_object_t *obj) {
 2811|   213k|  uint8_t type_marker = 0;
 2812|       |
 2813|   213k|  if (!read_type_marker(ctx, &type_marker))
  ------------------
  |  Branch (2813:7): [True: 1.23k, False: 212k]
  ------------------
 2814|  1.23k|    return false;
 2815|       |
 2816|   212k|  if (!type_marker_to_cmp_type(type_marker, &obj->type)) {
  ------------------
  |  Branch (2816:7): [True: 334, False: 211k]
  ------------------
 2817|    334|    ctx->error = CMP_ERROR_INVALID_TYPE;
 2818|    334|    return false;
 2819|    334|  }
 2820|       |
 2821|   211k|  return read_obj_data(ctx, type_marker, obj);
 2822|   212k|}
cmp.c:write_fixed_value:
  245|  7.75k|static bool write_fixed_value(cmp_ctx_t *ctx, uint8_t value) {
  246|  7.75k|  if (write_byte(ctx, value))
  ------------------
  |  Branch (246:7): [True: 7.75k, False: 0]
  ------------------
  247|  7.75k|    return true;
  248|       |
  249|      0|  ctx->error = CMP_ERROR_FIXED_VALUE_WRITING;
  250|       |  return false;
  251|  7.75k|}
cmp.c:write_byte:
  207|  12.2k|static bool write_byte(cmp_ctx_t *ctx, uint8_t x) {
  208|  12.2k|  return ctx->write(ctx, &x, sizeof(uint8_t)) == sizeof(uint8_t);
  209|  12.2k|}
cmp.c:write_type_marker:
  237|  4.46k|static bool write_type_marker(cmp_ctx_t *ctx, uint8_t marker) {
  238|  4.46k|  if (write_byte(ctx, marker))
  ------------------
  |  Branch (238:7): [True: 4.46k, False: 0]
  ------------------
  239|  4.46k|    return true;
  240|       |
  241|      0|  ctx->error = CMP_ERROR_TYPE_MARKER_WRITING;
  242|       |  return false;
  243|  4.46k|}
cmp.c:sbe16:
  127|    295|static int16_t sbe16(int16_t x) {
  128|    295|  return (int16_t)be16((uint16_t)x);
  129|    295|}
cmp.c:sbe32:
  138|  1.51k|static int32_t sbe32(int32_t x) {
  139|  1.51k|  return (int32_t)be32((uint32_t)x);
  140|  1.51k|}
cmp.c:sbe64:
  149|     67|static int64_t sbe64(int64_t x) {
  150|     67|  return (int64_t)be64((uint64_t)x);
  151|     67|}
cmp.c:be16:
  119|  14.6k|static uint16_t be16(uint16_t x) {
  120|  14.6k|  if (!is_bigendian())
  ------------------
  |  Branch (120:7): [True: 14.6k, False: 0]
  ------------------
  121|  14.6k|    return ((x >> 8) & 0x00ff)
  122|  14.6k|         | ((x << 8) & 0xff00);
  123|       |
  124|      0|  return x;
  125|  14.6k|}
cmp.c:is_bigendian:
  109|  20.0k|static bool is_bigendian(void) {
  110|       |#ifdef WORDS_BIGENDIAN
  111|       |  return WORDS_BIGENDIAN;
  112|       |#else
  113|  20.0k|  const int32_t i_ = 1;
  114|  20.0k|  const char *i_bytes = (const char *)&i_;
  115|  20.0k|  return *i_bytes == 0;
  116|  20.0k|#endif /* WORDS_BIGENDIAN */
  117|  20.0k|}
cmp.c:be32:
  131|  5.29k|static uint32_t be32(uint32_t x) {
  132|  5.29k|  if (!is_bigendian())
  ------------------
  |  Branch (132:7): [True: 5.29k, False: 0]
  ------------------
  133|  5.29k|    return ((uint32_t)be16((uint16_t)(x & 0xffff)) << 16) | (uint32_t)be16((uint16_t)(x >> 16));
  134|       |
  135|      0|  return x;
  136|  5.29k|}
cmp.c:be64:
  142|    133|static uint64_t be64(uint64_t x) {
  143|    133|  if (!is_bigendian())
  ------------------
  |  Branch (143:7): [True: 133, False: 0]
  ------------------
  144|    133|    return ((uint64_t)be32((uint32_t)(x & 0xffffffff)) << 32) | (uint64_t)be32((uint32_t)(x >> 32));
  145|       |
  146|      0|  return x;
  147|    133|}
cmp.c:read_type_marker:
  228|   213k|static bool read_type_marker(cmp_ctx_t *ctx, uint8_t *marker) {
  229|   213k|  if (read_byte(ctx, marker)) {
  ------------------
  |  Branch (229:7): [True: 212k, False: 1.23k]
  ------------------
  230|   212k|    return true;
  231|   212k|  }
  232|       |
  233|  1.23k|  ctx->error = CMP_ERROR_TYPE_MARKER_READING;
  234|       |  return false;
  235|   213k|}
cmp.c:read_byte:
  203|   213k|static bool read_byte(cmp_ctx_t *ctx, uint8_t *x) {
  204|   213k|  return ctx->read(ctx, x, sizeof(uint8_t));
  205|   213k|}
cmp.c:type_marker_to_cmp_type:
  253|   212k|static bool type_marker_to_cmp_type(uint8_t type_marker, uint8_t *cmp_type) {
  254|   212k|  if (type_marker <= 0x7F) {
  ------------------
  |  Branch (254:7): [True: 71.6k, False: 140k]
  ------------------
  255|  71.6k|    *cmp_type = CMP_TYPE_POSITIVE_FIXNUM;
  256|  71.6k|    return true;
  257|  71.6k|  }
  258|       |
  259|   140k|  if (type_marker <= 0x8F) {
  ------------------
  |  Branch (259:7): [True: 518, False: 139k]
  ------------------
  260|    518|    *cmp_type = CMP_TYPE_FIXMAP;
  261|    518|    return true;
  262|    518|  }
  263|       |
  264|   139k|  if (type_marker <= 0x9F) {
  ------------------
  |  Branch (264:7): [True: 71.5k, False: 68.2k]
  ------------------
  265|  71.5k|    *cmp_type = CMP_TYPE_FIXARRAY;
  266|  71.5k|    return true;
  267|  71.5k|  }
  268|       |
  269|  68.2k|  if (type_marker <= 0xBF) {
  ------------------
  |  Branch (269:7): [True: 1.77k, False: 66.4k]
  ------------------
  270|  1.77k|    *cmp_type = CMP_TYPE_FIXSTR;
  271|  1.77k|    return true;
  272|  1.77k|  }
  273|       |
  274|  66.4k|  if (type_marker >= 0xE0) {
  ------------------
  |  Branch (274:7): [True: 4.31k, False: 62.1k]
  ------------------
  275|  4.31k|    *cmp_type = CMP_TYPE_NEGATIVE_FIXNUM;
  276|  4.31k|    return true;
  277|  4.31k|  }
  278|       |
  279|  62.1k|  switch (type_marker) {
  280|    421|    case NIL_MARKER: {
  ------------------
  |  Branch (280:5): [True: 421, False: 61.7k]
  ------------------
  281|    421|      *cmp_type = CMP_TYPE_NIL;
  282|    421|      return true;
  283|      0|    }
  284|  18.7k|    case FALSE_MARKER: {
  ------------------
  |  Branch (284:5): [True: 18.7k, False: 43.4k]
  ------------------
  285|  18.7k|      *cmp_type = CMP_TYPE_BOOLEAN;
  286|  18.7k|      return true;
  287|      0|    }
  288|    529|    case TRUE_MARKER: {
  ------------------
  |  Branch (288:5): [True: 529, False: 61.6k]
  ------------------
  289|    529|      *cmp_type = CMP_TYPE_BOOLEAN;
  290|    529|      return true;
  291|      0|    }
  292|  4.53k|    case BIN8_MARKER: {
  ------------------
  |  Branch (292:5): [True: 4.53k, False: 57.6k]
  ------------------
  293|  4.53k|      *cmp_type = CMP_TYPE_BIN8;
  294|  4.53k|      return true;
  295|      0|    }
  296|    436|    case BIN16_MARKER: {
  ------------------
  |  Branch (296:5): [True: 436, False: 61.7k]
  ------------------
  297|    436|      *cmp_type = CMP_TYPE_BIN16;
  298|    436|      return true;
  299|      0|    }
  300|  2.57k|    case BIN32_MARKER: {
  ------------------
  |  Branch (300:5): [True: 2.57k, False: 59.6k]
  ------------------
  301|  2.57k|      *cmp_type = CMP_TYPE_BIN32;
  302|  2.57k|      return true;
  303|      0|    }
  304|    166|    case EXT8_MARKER: {
  ------------------
  |  Branch (304:5): [True: 166, False: 62.0k]
  ------------------
  305|    166|      *cmp_type = CMP_TYPE_EXT8;
  306|    166|      return true;
  307|      0|    }
  308|    158|    case EXT16_MARKER: {
  ------------------
  |  Branch (308:5): [True: 158, False: 62.0k]
  ------------------
  309|    158|      *cmp_type = CMP_TYPE_EXT16;
  310|    158|      return true;
  311|      0|    }
  312|    102|    case EXT32_MARKER: {
  ------------------
  |  Branch (312:5): [True: 102, False: 62.0k]
  ------------------
  313|    102|      *cmp_type = CMP_TYPE_EXT32;
  314|    102|      return true;
  315|      0|    }
  316|     72|    case FLOAT_MARKER: {
  ------------------
  |  Branch (316:5): [True: 72, False: 62.1k]
  ------------------
  317|     72|      *cmp_type = CMP_TYPE_FLOAT;
  318|     72|      return true;
  319|      0|    }
  320|    717|    case DOUBLE_MARKER: {
  ------------------
  |  Branch (320:5): [True: 717, False: 61.4k]
  ------------------
  321|    717|      *cmp_type = CMP_TYPE_DOUBLE;
  322|    717|      return true;
  323|      0|    }
  324|  22.1k|    case U8_MARKER: {
  ------------------
  |  Branch (324:5): [True: 22.1k, False: 40.0k]
  ------------------
  325|  22.1k|      *cmp_type = CMP_TYPE_UINT8;
  326|  22.1k|      return true;
  327|      0|    }
  328|  3.38k|    case U16_MARKER: {
  ------------------
  |  Branch (328:5): [True: 3.38k, False: 58.7k]
  ------------------
  329|  3.38k|      *cmp_type = CMP_TYPE_UINT16;
  330|  3.38k|      return true;
  331|      0|    }
  332|  1.60k|    case U32_MARKER: {
  ------------------
  |  Branch (332:5): [True: 1.60k, False: 60.5k]
  ------------------
  333|  1.60k|      *cmp_type = CMP_TYPE_UINT32;
  334|  1.60k|      return true;
  335|      0|    }
  336|    132|    case U64_MARKER: {
  ------------------
  |  Branch (336:5): [True: 132, False: 62.0k]
  ------------------
  337|    132|      *cmp_type = CMP_TYPE_UINT64;
  338|    132|      return true;
  339|      0|    }
  340|    705|    case S8_MARKER: {
  ------------------
  |  Branch (340:5): [True: 705, False: 61.4k]
  ------------------
  341|    705|      *cmp_type = CMP_TYPE_SINT8;
  342|    705|      return true;
  343|      0|    }
  344|    329|    case S16_MARKER: {
  ------------------
  |  Branch (344:5): [True: 329, False: 61.8k]
  ------------------
  345|    329|      *cmp_type = CMP_TYPE_SINT16;
  346|    329|      return true;
  347|      0|    }
  348|  1.55k|    case S32_MARKER: {
  ------------------
  |  Branch (348:5): [True: 1.55k, False: 60.6k]
  ------------------
  349|  1.55k|      *cmp_type = CMP_TYPE_SINT32;
  350|  1.55k|      return true;
  351|      0|    }
  352|    103|    case S64_MARKER: {
  ------------------
  |  Branch (352:5): [True: 103, False: 62.0k]
  ------------------
  353|    103|      *cmp_type = CMP_TYPE_SINT64;
  354|    103|      return true;
  355|      0|    }
  356|    102|    case FIXEXT1_MARKER: {
  ------------------
  |  Branch (356:5): [True: 102, False: 62.0k]
  ------------------
  357|    102|      *cmp_type = CMP_TYPE_FIXEXT1;
  358|    102|      return true;
  359|      0|    }
  360|     96|    case FIXEXT2_MARKER: {
  ------------------
  |  Branch (360:5): [True: 96, False: 62.0k]
  ------------------
  361|     96|      *cmp_type = CMP_TYPE_FIXEXT2;
  362|     96|      return true;
  363|      0|    }
  364|  2.02k|    case FIXEXT4_MARKER: {
  ------------------
  |  Branch (364:5): [True: 2.02k, False: 60.1k]
  ------------------
  365|  2.02k|      *cmp_type = CMP_TYPE_FIXEXT4;
  366|  2.02k|      return true;
  367|      0|    }
  368|     86|    case FIXEXT8_MARKER: {
  ------------------
  |  Branch (368:5): [True: 86, False: 62.0k]
  ------------------
  369|     86|      *cmp_type = CMP_TYPE_FIXEXT8;
  370|     86|      return true;
  371|      0|    }
  372|    112|    case FIXEXT16_MARKER: {
  ------------------
  |  Branch (372:5): [True: 112, False: 62.0k]
  ------------------
  373|    112|      *cmp_type = CMP_TYPE_FIXEXT16;
  374|    112|      return true;
  375|      0|    }
  376|     79|    case STR8_MARKER: {
  ------------------
  |  Branch (376:5): [True: 79, False: 62.1k]
  ------------------
  377|     79|      *cmp_type = CMP_TYPE_STR8;
  378|     79|      return true;
  379|      0|    }
  380|    111|    case STR16_MARKER: {
  ------------------
  |  Branch (380:5): [True: 111, False: 62.0k]
  ------------------
  381|    111|      *cmp_type = CMP_TYPE_STR16;
  382|    111|      return true;
  383|      0|    }
  384|     79|    case STR32_MARKER: {
  ------------------
  |  Branch (384:5): [True: 79, False: 62.1k]
  ------------------
  385|     79|      *cmp_type = CMP_TYPE_STR32;
  386|     79|      return true;
  387|      0|    }
  388|    333|    case ARRAY16_MARKER: {
  ------------------
  |  Branch (388:5): [True: 333, False: 61.8k]
  ------------------
  389|    333|      *cmp_type = CMP_TYPE_ARRAY16;
  390|    333|      return true;
  391|      0|    }
  392|     70|    case ARRAY32_MARKER: {
  ------------------
  |  Branch (392:5): [True: 70, False: 62.1k]
  ------------------
  393|     70|      *cmp_type = CMP_TYPE_ARRAY32;
  394|     70|      return true;
  395|      0|    }
  396|    231|    case MAP16_MARKER: {
  ------------------
  |  Branch (396:5): [True: 231, False: 61.9k]
  ------------------
  397|    231|      *cmp_type = CMP_TYPE_MAP16;
  398|    231|      return true;
  399|      0|    }
  400|     85|    case MAP32_MARKER: {
  ------------------
  |  Branch (400:5): [True: 85, False: 62.0k]
  ------------------
  401|     85|      *cmp_type = CMP_TYPE_MAP32;
  402|     85|      return true;
  403|      0|    }
  404|    334|    default: {
  ------------------
  |  Branch (404:5): [True: 334, False: 61.8k]
  ------------------
  405|       |      return false;
  406|      0|    }
  407|  62.1k|  }
  408|  62.1k|}
cmp.c:read_obj_data:
  618|   211k|                                          cmp_object_t *obj) {
  619|   211k|  switch (obj->type) {
  620|  71.6k|    case CMP_TYPE_POSITIVE_FIXNUM: {
  ------------------
  |  Branch (620:5): [True: 71.6k, False: 139k]
  ------------------
  621|  71.6k|      obj->as.u8 = type_marker;
  622|  71.6k|      return true;
  623|      0|    }
  624|  4.31k|    case CMP_TYPE_NEGATIVE_FIXNUM: {
  ------------------
  |  Branch (624:5): [True: 4.31k, False: 207k]
  ------------------
  625|  4.31k|      obj->as.s8 = (int8_t)type_marker;
  626|  4.31k|      return true;
  627|      0|    }
  628|    421|    case CMP_TYPE_NIL: {
  ------------------
  |  Branch (628:5): [True: 421, False: 211k]
  ------------------
  629|    421|      obj->as.u8 = 0;
  630|    421|      return true;
  631|      0|    }
  632|  19.2k|    case CMP_TYPE_BOOLEAN: {
  ------------------
  |  Branch (632:5): [True: 19.2k, False: 192k]
  ------------------
  633|  19.2k|      switch (type_marker) {
  634|    529|        case TRUE_MARKER: {
  ------------------
  |  Branch (634:9): [True: 529, False: 18.7k]
  ------------------
  635|    529|          obj->as.boolean = true;
  636|    529|          return true;
  637|      0|        }
  638|  18.7k|        case FALSE_MARKER: {
  ------------------
  |  Branch (638:9): [True: 18.7k, False: 529]
  ------------------
  639|  18.7k|          obj->as.boolean = false;
  640|  18.7k|          return true;
  641|      0|        }
  642|      0|        default:
  ------------------
  |  Branch (642:9): [True: 0, False: 19.2k]
  ------------------
  643|      0|          break;
  644|  19.2k|      }
  645|      0|      ctx->error = CMP_ERROR_INTERNAL;
  646|      0|      return false;
  647|  19.2k|    }
  648|  22.1k|    case CMP_TYPE_UINT8: {
  ------------------
  |  Branch (648:5): [True: 22.1k, False: 189k]
  ------------------
  649|  22.1k|      if (!ctx->read(ctx, &obj->as.u8, sizeof(uint8_t))) {
  ------------------
  |  Branch (649:11): [True: 19, False: 22.1k]
  ------------------
  650|     19|        ctx->error = CMP_ERROR_DATA_READING;
  651|     19|        return false;
  652|     19|      }
  653|  22.1k|      return true;
  654|  22.1k|    }
  655|  3.38k|    case CMP_TYPE_UINT16: {
  ------------------
  |  Branch (655:5): [True: 3.38k, False: 208k]
  ------------------
  656|  3.38k|      if (!ctx->read(ctx, &obj->as.u16, sizeof(uint16_t))) {
  ------------------
  |  Branch (656:11): [True: 1.34k, False: 2.03k]
  ------------------
  657|  1.34k|        ctx->error = CMP_ERROR_DATA_READING;
  658|  1.34k|        return false;
  659|  1.34k|      }
  660|  2.03k|      obj->as.u16 = be16(obj->as.u16);
  661|  2.03k|      return true;
  662|  3.38k|    }
  663|  1.60k|    case CMP_TYPE_UINT32: {
  ------------------
  |  Branch (663:5): [True: 1.60k, False: 210k]
  ------------------
  664|  1.60k|      if (!ctx->read(ctx, &obj->as.u32, sizeof(uint32_t))) {
  ------------------
  |  Branch (664:11): [True: 329, False: 1.27k]
  ------------------
  665|    329|        ctx->error = CMP_ERROR_DATA_READING;
  666|    329|        return false;
  667|    329|      }
  668|  1.27k|      obj->as.u32 = be32(obj->as.u32);
  669|  1.27k|      return true;
  670|  1.60k|    }
  671|    132|    case CMP_TYPE_UINT64: {
  ------------------
  |  Branch (671:5): [True: 132, False: 211k]
  ------------------
  672|    132|      if (!ctx->read(ctx, &obj->as.u64, sizeof(uint64_t))) {
  ------------------
  |  Branch (672:11): [True: 66, False: 66]
  ------------------
  673|     66|        ctx->error = CMP_ERROR_DATA_READING;
  674|     66|        return false;
  675|     66|      }
  676|     66|      obj->as.u64 = be64(obj->as.u64);
  677|     66|      return true;
  678|    132|    }
  679|    705|    case CMP_TYPE_SINT8: {
  ------------------
  |  Branch (679:5): [True: 705, False: 210k]
  ------------------
  680|    705|      if (!ctx->read(ctx, &obj->as.s8, sizeof(int8_t))) {
  ------------------
  |  Branch (680:11): [True: 18, False: 687]
  ------------------
  681|     18|        ctx->error = CMP_ERROR_DATA_READING;
  682|     18|        return false;
  683|     18|      }
  684|    687|      return true;
  685|    705|    }
  686|    329|    case CMP_TYPE_SINT16: {
  ------------------
  |  Branch (686:5): [True: 329, False: 211k]
  ------------------
  687|    329|      if (!ctx->read(ctx, &obj->as.s16, sizeof(int16_t))) {
  ------------------
  |  Branch (687:11): [True: 34, False: 295]
  ------------------
  688|     34|        ctx->error = CMP_ERROR_DATA_READING;
  689|     34|        return false;
  690|     34|      }
  691|    295|      obj->as.s16 = sbe16(obj->as.s16);
  692|    295|      return true;
  693|    329|    }
  694|  1.55k|    case CMP_TYPE_SINT32: {
  ------------------
  |  Branch (694:5): [True: 1.55k, False: 210k]
  ------------------
  695|  1.55k|      if (!ctx->read(ctx, &obj->as.s32, sizeof(int32_t))) {
  ------------------
  |  Branch (695:11): [True: 35, False: 1.51k]
  ------------------
  696|     35|        ctx->error = CMP_ERROR_DATA_READING;
  697|     35|        return false;
  698|     35|      }
  699|  1.51k|      obj->as.s32 = sbe32(obj->as.s32);
  700|  1.51k|      return true;
  701|  1.55k|    }
  702|    103|    case CMP_TYPE_SINT64: {
  ------------------
  |  Branch (702:5): [True: 103, False: 211k]
  ------------------
  703|    103|      if (!ctx->read(ctx, &obj->as.s64, sizeof(int64_t))) {
  ------------------
  |  Branch (703:11): [True: 36, False: 67]
  ------------------
  704|     36|        ctx->error = CMP_ERROR_DATA_READING;
  705|     36|        return false;
  706|     36|      }
  707|     67|      obj->as.s64 = sbe64(obj->as.s64);
  708|     67|      return true;
  709|    103|    }
  710|     72|    case CMP_TYPE_FLOAT: {
  ------------------
  |  Branch (710:5): [True: 72, False: 211k]
  ------------------
  711|       |#ifndef CMP_NO_FLOAT
  712|       |      char bytes[4];
  713|       |
  714|       |      if (!ctx->read(ctx, bytes, 4)) {
  715|       |        ctx->error = CMP_ERROR_DATA_READING;
  716|       |        return false;
  717|       |      }
  718|       |      obj->as.flt = decode_befloat(bytes);
  719|       |      return true;
  720|       |#else /* CMP_NO_FLOAT */
  721|     72|      ctx->error = CMP_ERROR_DISABLED_FLOATING_POINT;
  722|     72|      return false;
  723|    103|#endif /* CMP_NO_FLOAT */
  724|    103|    }
  725|    717|    case CMP_TYPE_DOUBLE: {
  ------------------
  |  Branch (725:5): [True: 717, False: 210k]
  ------------------
  726|       |#ifndef CMP_NO_FLOAT
  727|       |      char bytes[8];
  728|       |
  729|       |      if (!ctx->read(ctx, bytes, 8)) {
  730|       |        ctx->error = CMP_ERROR_DATA_READING;
  731|       |        return false;
  732|       |      }
  733|       |      obj->as.dbl = decode_bedouble(bytes);
  734|       |      return true;
  735|       |#else /* CMP_NO_FLOAT */
  736|    717|      ctx->error = CMP_ERROR_DISABLED_FLOATING_POINT;
  737|    717|      return false;
  738|    103|#endif /* CMP_NO_FLOAT */
  739|    103|    }
  740|  4.53k|    case CMP_TYPE_BIN8:
  ------------------
  |  Branch (740:5): [True: 4.53k, False: 207k]
  ------------------
  741|  4.97k|    case CMP_TYPE_BIN16:
  ------------------
  |  Branch (741:5): [True: 436, False: 211k]
  ------------------
  742|  7.54k|    case CMP_TYPE_BIN32:
  ------------------
  |  Branch (742:5): [True: 2.57k, False: 209k]
  ------------------
  743|  7.54k|      return read_type_size(ctx, type_marker, obj->type, &obj->as.bin_size);
  744|  1.77k|    case CMP_TYPE_FIXSTR:
  ------------------
  |  Branch (744:5): [True: 1.77k, False: 209k]
  ------------------
  745|  1.85k|    case CMP_TYPE_STR8:
  ------------------
  |  Branch (745:5): [True: 79, False: 211k]
  ------------------
  746|  1.96k|    case CMP_TYPE_STR16:
  ------------------
  |  Branch (746:5): [True: 111, False: 211k]
  ------------------
  747|  2.04k|    case CMP_TYPE_STR32:
  ------------------
  |  Branch (747:5): [True: 79, False: 211k]
  ------------------
  748|  2.04k|      return read_type_size(ctx, type_marker, obj->type, &obj->as.str_size);
  749|  71.5k|    case CMP_TYPE_FIXARRAY:
  ------------------
  |  Branch (749:5): [True: 71.5k, False: 140k]
  ------------------
  750|  71.8k|    case CMP_TYPE_ARRAY16:
  ------------------
  |  Branch (750:5): [True: 333, False: 211k]
  ------------------
  751|  71.9k|    case CMP_TYPE_ARRAY32:
  ------------------
  |  Branch (751:5): [True: 70, False: 211k]
  ------------------
  752|  71.9k|      return read_type_size(ctx, type_marker, obj->type, &obj->as.array_size);
  753|    518|    case CMP_TYPE_FIXMAP:
  ------------------
  |  Branch (753:5): [True: 518, False: 211k]
  ------------------
  754|    749|    case CMP_TYPE_MAP16:
  ------------------
  |  Branch (754:5): [True: 231, False: 211k]
  ------------------
  755|    834|    case CMP_TYPE_MAP32:
  ------------------
  |  Branch (755:5): [True: 85, False: 211k]
  ------------------
  756|    834|      return read_type_size(ctx, type_marker, obj->type, &obj->as.map_size);
  757|    102|    case CMP_TYPE_FIXEXT1: {
  ------------------
  |  Branch (757:5): [True: 102, False: 211k]
  ------------------
  758|    102|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (758:11): [True: 34, False: 68]
  ------------------
  759|     34|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  760|     34|        return false;
  761|     34|      }
  762|     68|      obj->as.ext.size = 1;
  763|     68|      return true;
  764|    102|    }
  765|     96|    case CMP_TYPE_FIXEXT2: {
  ------------------
  |  Branch (765:5): [True: 96, False: 211k]
  ------------------
  766|     96|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (766:11): [True: 18, False: 78]
  ------------------
  767|     18|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  768|     18|        return false;
  769|     18|      }
  770|     78|      obj->as.ext.size = 2;
  771|     78|      return true;
  772|     96|    }
  773|  2.02k|    case CMP_TYPE_FIXEXT4: {
  ------------------
  |  Branch (773:5): [True: 2.02k, False: 209k]
  ------------------
  774|  2.02k|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (774:11): [True: 20, False: 2.00k]
  ------------------
  775|     20|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  776|     20|        return false;
  777|     20|      }
  778|  2.00k|      obj->as.ext.size = 4;
  779|  2.00k|      return true;
  780|  2.02k|    }
  781|     86|    case CMP_TYPE_FIXEXT8: {
  ------------------
  |  Branch (781:5): [True: 86, False: 211k]
  ------------------
  782|     86|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (782:11): [True: 18, False: 68]
  ------------------
  783|     18|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  784|     18|        return false;
  785|     18|      }
  786|     68|      obj->as.ext.size = 8;
  787|     68|      return true;
  788|     86|    }
  789|    112|    case CMP_TYPE_FIXEXT16: {
  ------------------
  |  Branch (789:5): [True: 112, False: 211k]
  ------------------
  790|    112|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (790:11): [True: 11, False: 101]
  ------------------
  791|     11|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  792|     11|        return false;
  793|     11|      }
  794|    101|      obj->as.ext.size = 16;
  795|    101|      return true;
  796|    112|    }
  797|    166|    case CMP_TYPE_EXT8: {
  ------------------
  |  Branch (797:5): [True: 166, False: 211k]
  ------------------
  798|    166|      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
  ------------------
  |  Branch (798:11): [True: 66, False: 100]
  ------------------
  799|     66|        return false;
  800|     66|      }
  801|    100|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (801:11): [True: 34, False: 66]
  ------------------
  802|     34|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  803|     34|        return false;
  804|     34|      }
  805|     66|      return true;
  806|    100|    }
  807|    158|    case CMP_TYPE_EXT16: {
  ------------------
  |  Branch (807:5): [True: 158, False: 211k]
  ------------------
  808|    158|      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
  ------------------
  |  Branch (808:11): [True: 37, False: 121]
  ------------------
  809|     37|        return false;
  810|     37|      }
  811|    121|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (811:11): [True: 66, False: 55]
  ------------------
  812|     66|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  813|     66|        return false;
  814|     66|      }
  815|     55|      return true;
  816|    121|    }
  817|    102|    case CMP_TYPE_EXT32: {
  ------------------
  |  Branch (817:5): [True: 102, False: 211k]
  ------------------
  818|    102|      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
  ------------------
  |  Branch (818:11): [True: 11, False: 91]
  ------------------
  819|     11|        return false;
  820|     11|      }
  821|     91|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (821:11): [True: 18, False: 73]
  ------------------
  822|     18|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  823|     18|        return false;
  824|     18|      }
  825|     73|      return true;
  826|     91|    }
  827|      0|    default:
  ------------------
  |  Branch (827:5): [True: 0, False: 211k]
  ------------------
  828|      0|      break;
  829|   211k|  }
  830|       |
  831|      0|  ctx->error = CMP_ERROR_INVALID_TYPE;
  832|       |  return false;
  833|   211k|}
cmp.c:read_type_size:
  412|  82.7k|                                           uint32_t *size) {
  413|  82.7k|  uint8_t u8temp = 0;
  414|  82.7k|  uint16_t u16temp = 0;
  415|  82.7k|  uint32_t u32temp = 0;
  416|       |
  417|  82.7k|  switch (cmp_type) {
  418|      0|    case CMP_TYPE_POSITIVE_FIXNUM: {
  ------------------
  |  Branch (418:5): [True: 0, False: 82.7k]
  ------------------
  419|      0|      *size = 0;
  420|      0|      return true;
  421|      0|    }
  422|    518|    case CMP_TYPE_FIXMAP: {
  ------------------
  |  Branch (422:5): [True: 518, False: 82.2k]
  ------------------
  423|    518|      *size = type_marker & FIXMAP_SIZE;
  424|    518|      return true;
  425|      0|    }
  426|  71.5k|    case CMP_TYPE_FIXARRAY: {
  ------------------
  |  Branch (426:5): [True: 71.5k, False: 11.2k]
  ------------------
  427|  71.5k|      *size = type_marker & FIXARRAY_SIZE;
  428|  71.5k|      return true;
  429|      0|    }
  430|  1.77k|    case CMP_TYPE_FIXSTR: {
  ------------------
  |  Branch (430:5): [True: 1.77k, False: 81.0k]
  ------------------
  431|  1.77k|      *size = type_marker & FIXSTR_SIZE;
  432|  1.77k|      return true;
  433|      0|    }
  434|      0|    case CMP_TYPE_NIL: {
  ------------------
  |  Branch (434:5): [True: 0, False: 82.7k]
  ------------------
  435|      0|      *size = 0;
  436|      0|      return true;
  437|      0|    }
  438|      0|    case CMP_TYPE_BOOLEAN: {
  ------------------
  |  Branch (438:5): [True: 0, False: 82.7k]
  ------------------
  439|      0|      *size = 0;
  440|      0|      return true;
  441|      0|    }
  442|  4.53k|    case CMP_TYPE_BIN8: {
  ------------------
  |  Branch (442:5): [True: 4.53k, False: 78.2k]
  ------------------
  443|  4.53k|      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
  ------------------
  |  Branch (443:11): [True: 10, False: 4.52k]
  ------------------
  444|     10|        ctx->error = CMP_ERROR_LENGTH_READING;
  445|     10|        return false;
  446|     10|      }
  447|  4.52k|      *size = u8temp;
  448|  4.52k|      return true;
  449|  4.53k|    }
  450|    436|    case CMP_TYPE_BIN16: {
  ------------------
  |  Branch (450:5): [True: 436, False: 82.3k]
  ------------------
  451|    436|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (451:11): [True: 18, False: 418]
  ------------------
  452|     18|        ctx->error = CMP_ERROR_LENGTH_READING;
  453|     18|        return false;
  454|     18|      }
  455|    418|      *size = be16(u16temp);
  456|    418|      return true;
  457|    436|    }
  458|  2.57k|    case CMP_TYPE_BIN32: {
  ------------------
  |  Branch (458:5): [True: 2.57k, False: 80.2k]
  ------------------
  459|  2.57k|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (459:11): [True: 607, False: 1.97k]
  ------------------
  460|    607|        ctx->error = CMP_ERROR_LENGTH_READING;
  461|    607|        return false;
  462|    607|      }
  463|  1.97k|      *size = be32(u32temp);
  464|  1.97k|      return true;
  465|  2.57k|    }
  466|    166|    case CMP_TYPE_EXT8: {
  ------------------
  |  Branch (466:5): [True: 166, False: 82.6k]
  ------------------
  467|    166|      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
  ------------------
  |  Branch (467:11): [True: 66, False: 100]
  ------------------
  468|     66|        ctx->error = CMP_ERROR_LENGTH_READING;
  469|     66|        return false;
  470|     66|      }
  471|    100|      *size = u8temp;
  472|    100|      return true;
  473|    166|    }
  474|    158|    case CMP_TYPE_EXT16: {
  ------------------
  |  Branch (474:5): [True: 158, False: 82.6k]
  ------------------
  475|    158|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (475:11): [True: 37, False: 121]
  ------------------
  476|     37|        ctx->error = CMP_ERROR_LENGTH_READING;
  477|     37|        return false;
  478|     37|      }
  479|    121|      *size = be16(u16temp);
  480|    121|      return true;
  481|    158|    }
  482|    102|    case CMP_TYPE_EXT32: {
  ------------------
  |  Branch (482:5): [True: 102, False: 82.6k]
  ------------------
  483|    102|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (483:11): [True: 11, False: 91]
  ------------------
  484|     11|        ctx->error = CMP_ERROR_LENGTH_READING;
  485|     11|        return false;
  486|     11|      }
  487|     91|      *size = be32(u32temp);
  488|     91|      return true;
  489|    102|    }
  490|      0|    case CMP_TYPE_FLOAT: {
  ------------------
  |  Branch (490:5): [True: 0, False: 82.7k]
  ------------------
  491|      0|      *size = 4;
  492|      0|      return true;
  493|    102|    }
  494|      0|    case CMP_TYPE_DOUBLE: {
  ------------------
  |  Branch (494:5): [True: 0, False: 82.7k]
  ------------------
  495|      0|      *size = 8;
  496|      0|      return true;
  497|    102|    }
  498|      0|    case CMP_TYPE_UINT8: {
  ------------------
  |  Branch (498:5): [True: 0, False: 82.7k]
  ------------------
  499|      0|      *size = 1;
  500|      0|      return true;
  501|    102|    }
  502|      0|    case CMP_TYPE_UINT16: {
  ------------------
  |  Branch (502:5): [True: 0, False: 82.7k]
  ------------------
  503|      0|      *size = 2;
  504|      0|      return true;
  505|    102|    }
  506|      0|    case CMP_TYPE_UINT32: {
  ------------------
  |  Branch (506:5): [True: 0, False: 82.7k]
  ------------------
  507|      0|      *size = 4;
  508|      0|      return true;
  509|    102|    }
  510|      0|    case CMP_TYPE_UINT64: {
  ------------------
  |  Branch (510:5): [True: 0, False: 82.7k]
  ------------------
  511|      0|      *size = 8;
  512|      0|      return true;
  513|    102|    }
  514|      0|    case CMP_TYPE_SINT8: {
  ------------------
  |  Branch (514:5): [True: 0, False: 82.7k]
  ------------------
  515|      0|      *size = 1;
  516|      0|      return true;
  517|    102|    }
  518|      0|    case CMP_TYPE_SINT16: {
  ------------------
  |  Branch (518:5): [True: 0, False: 82.7k]
  ------------------
  519|      0|      *size = 2;
  520|      0|      return true;
  521|    102|    }
  522|      0|    case CMP_TYPE_SINT32: {
  ------------------
  |  Branch (522:5): [True: 0, False: 82.7k]
  ------------------
  523|      0|      *size = 4;
  524|      0|      return true;
  525|    102|    }
  526|      0|    case CMP_TYPE_SINT64: {
  ------------------
  |  Branch (526:5): [True: 0, False: 82.7k]
  ------------------
  527|      0|      *size = 8;
  528|      0|      return true;
  529|    102|    }
  530|      0|    case CMP_TYPE_FIXEXT1: {
  ------------------
  |  Branch (530:5): [True: 0, False: 82.7k]
  ------------------
  531|      0|      *size = 1;
  532|      0|      return true;
  533|    102|    }
  534|      0|    case CMP_TYPE_FIXEXT2: {
  ------------------
  |  Branch (534:5): [True: 0, False: 82.7k]
  ------------------
  535|      0|      *size = 2;
  536|      0|      return true;
  537|    102|    }
  538|      0|    case CMP_TYPE_FIXEXT4: {
  ------------------
  |  Branch (538:5): [True: 0, False: 82.7k]
  ------------------
  539|      0|      *size = 4;
  540|      0|      return true;
  541|    102|    }
  542|      0|    case CMP_TYPE_FIXEXT8: {
  ------------------
  |  Branch (542:5): [True: 0, False: 82.7k]
  ------------------
  543|      0|      *size = 8;
  544|      0|      return true;
  545|    102|    }
  546|      0|    case CMP_TYPE_FIXEXT16: {
  ------------------
  |  Branch (546:5): [True: 0, False: 82.7k]
  ------------------
  547|      0|      *size = 16;
  548|      0|      return true;
  549|    102|    }
  550|     79|    case CMP_TYPE_STR8: {
  ------------------
  |  Branch (550:5): [True: 79, False: 82.7k]
  ------------------
  551|     79|      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
  ------------------
  |  Branch (551:11): [True: 11, False: 68]
  ------------------
  552|     11|        ctx->error = CMP_ERROR_DATA_READING;
  553|     11|        return false;
  554|     11|      }
  555|     68|      *size = u8temp;
  556|     68|      return true;
  557|     79|    }
  558|    111|    case CMP_TYPE_STR16: {
  ------------------
  |  Branch (558:5): [True: 111, False: 82.6k]
  ------------------
  559|    111|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (559:11): [True: 10, False: 101]
  ------------------
  560|     10|        ctx->error = CMP_ERROR_DATA_READING;
  561|     10|        return false;
  562|     10|      }
  563|    101|      *size = be16(u16temp);
  564|    101|      return true;
  565|    111|    }
  566|     79|    case CMP_TYPE_STR32: {
  ------------------
  |  Branch (566:5): [True: 79, False: 82.7k]
  ------------------
  567|     79|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (567:11): [True: 11, False: 68]
  ------------------
  568|     11|        ctx->error = CMP_ERROR_DATA_READING;
  569|     11|        return false;
  570|     11|      }
  571|     68|      *size = be32(u32temp);
  572|     68|      return true;
  573|     79|    }
  574|    333|    case CMP_TYPE_ARRAY16: {
  ------------------
  |  Branch (574:5): [True: 333, False: 82.4k]
  ------------------
  575|    333|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (575:11): [True: 128, False: 205]
  ------------------
  576|    128|        ctx->error = CMP_ERROR_DATA_READING;
  577|    128|        return false;
  578|    128|      }
  579|    205|      *size = be16(u16temp);
  580|    205|      return true;
  581|    333|    }
  582|     70|    case CMP_TYPE_ARRAY32: {
  ------------------
  |  Branch (582:5): [True: 70, False: 82.7k]
  ------------------
  583|     70|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (583:11): [True: 34, False: 36]
  ------------------
  584|     34|        ctx->error = CMP_ERROR_DATA_READING;
  585|     34|        return false;
  586|     34|      }
  587|     36|      *size = be32(u32temp);
  588|     36|      return true;
  589|     70|    }
  590|    231|    case CMP_TYPE_MAP16: {
  ------------------
  |  Branch (590:5): [True: 231, False: 82.5k]
  ------------------
  591|    231|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (591:11): [True: 19, False: 212]
  ------------------
  592|     19|        ctx->error = CMP_ERROR_DATA_READING;
  593|     19|        return false;
  594|     19|      }
  595|    212|      *size = be16(u16temp);
  596|    212|      return true;
  597|    231|    }
  598|     85|    case CMP_TYPE_MAP32: {
  ------------------
  |  Branch (598:5): [True: 85, False: 82.7k]
  ------------------
  599|     85|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (599:11): [True: 19, False: 66]
  ------------------
  600|     19|        ctx->error = CMP_ERROR_DATA_READING;
  601|     19|        return false;
  602|     19|      }
  603|     66|      *size = be32(u32temp);
  604|     66|      return true;
  605|     85|    }
  606|      0|    case CMP_TYPE_NEGATIVE_FIXNUM: {
  ------------------
  |  Branch (606:5): [True: 0, False: 82.7k]
  ------------------
  607|      0|      *size = 0;
  608|      0|      return true;
  609|     85|    }
  610|      0|    default: {
  ------------------
  |  Branch (610:5): [True: 0, False: 82.7k]
  ------------------
  611|      0|      ctx->error = CMP_ERROR_INVALID_TYPE;
  612|       |      return false;
  613|     85|    }
  614|  82.7k|  }
  615|  82.7k|}

dht_get_self_public_key:
  159|  9.58k|{
  160|  9.58k|    return dht->self_public_key;
  161|  9.58k|}
dht_get_self_secret_key:
  163|  5.61k|{
  164|  5.61k|    return dht->self_secret_key;
  165|  5.61k|}
id_closest:
  227|    150|{
  228|  4.95k|    for (size_t i = 0; i < CRYPTO_PUBLIC_KEY_SIZE; ++i) {
  ------------------
  |  |   44|  4.95k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (228:24): [True: 4.80k, False: 150]
  ------------------
  229|  4.80k|        const uint8_t distance1 = pk[i] ^ pk1[i];
  230|  4.80k|        const uint8_t distance2 = pk[i] ^ pk2[i];
  231|       |
  232|  4.80k|        if (distance1 < distance2) {
  ------------------
  |  Branch (232:13): [True: 0, False: 4.80k]
  ------------------
  233|      0|            return 1;
  234|      0|        }
  235|       |
  236|  4.80k|        if (distance1 > distance2) {
  ------------------
  |  Branch (236:13): [True: 0, False: 4.80k]
  ------------------
  237|      0|            return 2;
  238|      0|        }
  239|  4.80k|    }
  240|       |
  241|    150|    return 0;
  242|    150|}
packed_node_size:
  361|  11.7k|{
  362|  11.7k|    if (net_family_is_ipv4(ip_family) || net_family_is_tcp_ipv4(ip_family)) {
  ------------------
  |  Branch (362:9): [True: 2.94k, False: 8.82k]
  |  Branch (362:42): [True: 0, False: 8.82k]
  ------------------
  363|  2.94k|        return PACKED_NODE_SIZE_IP4;
  ------------------
  |  |   74|  2.94k|#define PACKED_NODE_SIZE_IP4 (1 + SIZE_IP4 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   25|  2.94k|#define SIZE_IP4 4
  |  |  ------------------
  |  |               #define PACKED_NODE_SIZE_IP4 (1 + SIZE_IP4 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   44|  2.94k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  364|  2.94k|    }
  365|       |
  366|  8.82k|    if (net_family_is_ipv6(ip_family) || net_family_is_tcp_ipv6(ip_family)) {
  ------------------
  |  Branch (366:9): [True: 2.94k, False: 5.88k]
  |  Branch (366:42): [True: 5.88k, False: 0]
  ------------------
  367|  8.82k|        return PACKED_NODE_SIZE_IP6;
  ------------------
  |  |   75|  8.82k|#define PACKED_NODE_SIZE_IP6 (1 + SIZE_IP6 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   26|  8.82k|#define SIZE_IP6 16
  |  |  ------------------
  |  |               #define PACKED_NODE_SIZE_IP6 (1 + SIZE_IP6 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   44|  8.82k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  368|  8.82k|    }
  369|       |
  370|      0|    return -1;
  371|  8.82k|}
pack_nodes:
  421|  3.45k|{
  422|  3.45k|    const uint32_t size = bin_pack_obj_array_b_size(bin_pack_node_handler, nodes, number, logger);
  423|  3.45k|    if (!bin_pack_obj_array_b(bin_pack_node_handler, nodes, number, logger, data, length)) {
  ------------------
  |  Branch (423:9): [True: 0, False: 3.45k]
  ------------------
  424|      0|        return -1;
  425|      0|    }
  426|  3.45k|    return size;
  427|  3.45k|}
unpack_nodes:
  431|  2.01k|{
  432|  2.01k|    uint32_t num = 0;
  433|  2.01k|    uint32_t len_processed = 0;
  434|       |
  435|  13.0k|    while (num < max_num_nodes && len_processed < length) {
  ------------------
  |  Branch (435:12): [True: 12.4k, False: 555]
  |  Branch (435:35): [True: 11.8k, False: 596]
  ------------------
  436|  11.8k|        const int ipp_size = unpack_ip_port(&nodes[num].ip_port, data + len_processed, length - len_processed, tcp_enabled);
  437|       |
  438|  11.8k|        if (ipp_size == -1) {
  ------------------
  |  Branch (438:13): [True: 764, False: 11.1k]
  ------------------
  439|    764|            break;
  440|    764|        }
  441|       |
  442|  11.1k|        len_processed += ipp_size;
  443|       |
  444|  11.1k|        if (len_processed + CRYPTO_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |   44|  11.1k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (444:13): [True: 98, False: 11.0k]
  ------------------
  445|     98|            return -1;
  446|     98|        }
  447|       |
  448|  11.0k|        memcpy(nodes[num].public_key, data + len_processed, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|  11.0k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  449|  11.0k|        len_processed += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   44|  11.0k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  450|  11.0k|        ++num;
  451|       |
  452|  11.0k|#ifndef NDEBUG
  453|  11.0k|        const uint32_t increment = ipp_size + CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   44|  11.0k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  454|  11.0k|        assert(increment == PACKED_NODE_SIZE_IP4 || increment == PACKED_NODE_SIZE_IP6);
  ------------------
  |  Branch (454:9): [True: 9.90k, False: 1.11k]
  |  Branch (454:9): [True: 1.11k, False: 0]
  ------------------
  455|  11.0k|#endif /* NDEBUG */
  456|  11.0k|    }
  457|       |
  458|  1.91k|    if (num == 0 && max_num_nodes > 0 && length > 0) {
  ------------------
  |  Branch (458:9): [True: 299, False: 1.61k]
  |  Branch (458:21): [True: 299, False: 0]
  |  Branch (458:42): [True: 298, False: 1]
  ------------------
  459|    298|        return -1;
  460|    298|    }
  461|       |
  462|  1.61k|    if (processed_data_len != nullptr) {
  ------------------
  |  |   63|  1.61k|#define nullptr NULL
  ------------------
  |  Branch (462:9): [True: 270, False: 1.34k]
  ------------------
  463|    270|        *processed_data_len = len_processed;
  464|    270|    }
  465|       |
  466|  1.61k|    return num;
  467|  1.91k|}
get_close_nodes:
  752|  2.80k|{
  753|  2.80k|    return get_somewhat_close_nodes(
  754|  2.80k|               dht->cur_time, public_key, nodes_list,
  755|  2.80k|               sa_family, dht->close_clientlist,
  756|  2.80k|               dht->friends_list, dht->num_friends,
  757|  2.80k|               is_lan, want_announce);
  758|  2.80k|}
dht_addfriend:
 1590|  2.80k|{
 1591|  2.80k|    const uint32_t friend_num = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);
 1592|       |
 1593|  2.80k|    if (friend_num != UINT32_MAX) { /* Is friend already in DHT? */
  ------------------
  |  Branch (1593:9): [True: 0, False: 2.80k]
  ------------------
 1594|      0|        DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
 1595|      0|        const uint32_t tmp_lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1596|       |
 1597|      0|        if (tmp_lock_token == 0) {
  ------------------
  |  Branch (1597:13): [True: 0, False: 0]
  ------------------
 1598|      0|            return -1;
 1599|      0|        }
 1600|       |
 1601|      0|        return 0;
 1602|      0|    }
 1603|       |
 1604|  2.80k|    DHT_Friend *const temp = (DHT_Friend *)mem_vrealloc(dht->mem, dht->friends_list, dht->num_friends + 1, sizeof(DHT_Friend));
 1605|       |
 1606|  2.80k|    if (temp == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
  |  Branch (1606:9): [True: 0, False: 2.80k]
  ------------------
 1607|      0|        return -1;
 1608|      0|    }
 1609|       |
 1610|  2.80k|    dht->friends_list = temp;
 1611|  2.80k|    DHT_Friend *const dht_friend = &dht->friends_list[dht->num_friends];
 1612|  2.80k|    *dht_friend = empty_dht_friend;
 1613|  2.80k|    memcpy(dht_friend->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|  2.80k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1614|       |
 1615|  2.80k|    dht_friend->nat.nat_ping_id = random_u64(dht->rng);
 1616|  2.80k|    ++dht->num_friends;
 1617|       |
 1618|  2.80k|    *lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1619|  2.80k|    assert(*lock_token != 0); // Friend was newly allocated
  ------------------
  |  Branch (1619:5): [True: 2.80k, False: 0]
  ------------------
 1620|       |
 1621|  2.80k|    dht_friend->num_to_bootstrap = get_close_nodes(dht, dht_friend->public_key, dht_friend->to_bootstrap, net_family_unspec(),
 1622|  2.80k|                                   true, false);
 1623|       |
 1624|  2.80k|    return 0;
 1625|  2.80k|}
cryptopacket_registerhandler:
 2431|  5.61k|{
 2432|  5.61k|    dht->cryptopackethandlers[byte].function = cb;
 2433|  5.61k|    dht->cryptopackethandlers[byte].object = object;
 2434|  5.61k|}
dht_callback_nodes_response:
 2479|    981|{
 2480|    981|    dht->nodes_response_callback = function;
 2481|    981|}
new_dht:
 2508|  1.40k|{
 2509|  1.40k|    if (net == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2509:9): [True: 0, False: 1.40k]
  ------------------
 2510|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2511|      0|    }
 2512|       |
 2513|  1.40k|    DHT *const dht = (DHT *)mem_alloc(mem, sizeof(DHT));
 2514|       |
 2515|  1.40k|    if (dht == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2515:9): [True: 0, False: 1.40k]
  ------------------
 2516|      0|        LOGGER_ERROR(log, "failed to allocate DHT struct (%lu bytes)", (unsigned long)sizeof(DHT));
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2517|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2518|      0|    }
 2519|       |
 2520|  1.40k|    dht->ns = ns;
 2521|  1.40k|    dht->mono_time = mono_time;
 2522|  1.40k|    dht->cur_time = mono_time_get(mono_time);
 2523|  1.40k|    dht->log = log;
 2524|  1.40k|    dht->net = net;
 2525|  1.40k|    dht->rng = rng;
 2526|  1.40k|    dht->mem = mem;
 2527|       |
 2528|  1.40k|    dht->hole_punching_enabled = hole_punching_enabled;
 2529|  1.40k|    dht->lan_discovery_enabled = lan_discovery_enabled;
 2530|       |
 2531|  1.40k|    struct Ping *temp_ping = ping_new(mem, mono_time, rng, dht, net);
 2532|       |
 2533|  1.40k|    if (temp_ping == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2533:9): [True: 0, False: 1.40k]
  ------------------
 2534|      0|        LOGGER_ERROR(log, "failed to initialise ping");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2535|      0|        kill_dht(dht);
 2536|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2537|      0|    }
 2538|       |
 2539|  1.40k|    dht->ping = temp_ping;
 2540|       |
 2541|  1.40k|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, &handle_nodes_request, dht);
 2542|  1.40k|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, &handle_nodes_response, dht);
 2543|  1.40k|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, &cryptopacket_handle, dht);
 2544|  1.40k|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, &handle_lan_discovery, dht);
 2545|  1.40k|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, &handle_nat_ping, dht);
  ------------------
  |  |   71|  1.40k|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
 2546|       |
 2547|  1.40k|#ifdef CHECK_ANNOUNCE_NODE
 2548|  1.40k|    networking_registerhandler(dht->net, NET_PACKET_DATA_SEARCH_RESPONSE, &handle_data_search_response, dht);
 2549|  1.40k|#endif /* CHECK_ANNOUNCE_NODE */
 2550|       |
 2551|  1.40k|    crypto_new_keypair(rng, dht->self_public_key, dht->self_secret_key);
 2552|       |
 2553|  1.40k|    Shared_Key_Cache *const temp_shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|  1.40k|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   55|  1.40k|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2554|       |
 2555|  1.40k|    if (temp_shared_keys_recv == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2555:9): [True: 0, False: 1.40k]
  ------------------
 2556|      0|        LOGGER_ERROR(log, "failed to initialise shared key cache");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2557|      0|        kill_dht(dht);
 2558|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2559|      0|    }
 2560|       |
 2561|  1.40k|    dht->shared_keys_recv = temp_shared_keys_recv;
 2562|       |
 2563|  1.40k|    Shared_Key_Cache *const temp_shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|  1.40k|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   55|  1.40k|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2564|       |
 2565|  1.40k|    if (temp_shared_keys_sent == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2565:9): [True: 0, False: 1.40k]
  ------------------
 2566|      0|        LOGGER_ERROR(log, "failed to initialise shared key cache");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2567|      0|        kill_dht(dht);
 2568|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2569|      0|    }
 2570|       |
 2571|  1.40k|    dht->shared_keys_sent = temp_shared_keys_sent;
 2572|       |
 2573|  1.40k|    Ping_Array *const temp_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   49|  1.40k|#define DHT_PING_ARRAY_SIZE 512
  ------------------
                  Ping_Array *const temp_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   46|  1.40k|#define PING_TIMEOUT 5
  ------------------
 2574|       |
 2575|  1.40k|    if (temp_ping_array == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2575:9): [True: 0, False: 1.40k]
  ------------------
 2576|      0|        LOGGER_ERROR(log, "failed to initialise ping array");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2577|      0|        kill_dht(dht);
 2578|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2579|      0|    }
 2580|       |
 2581|  1.40k|    dht->dht_ping_array = temp_ping_array;
 2582|       |
 2583|  4.21k|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
  ------------------
  |  |   64|  4.21k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2583:26): [True: 2.80k, False: 1.40k]
  ------------------
 2584|  2.80k|        uint8_t random_public_key_bytes[CRYPTO_PUBLIC_KEY_SIZE];
 2585|  2.80k|        uint8_t random_secret_key_bytes[CRYPTO_SECRET_KEY_SIZE];
 2586|       |
 2587|  2.80k|        crypto_new_keypair(rng, random_public_key_bytes, random_secret_key_bytes);
 2588|       |
 2589|  2.80k|        uint32_t token; // We don't intend to delete these ever, but need to pass the token
 2590|  2.80k|        if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                      if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
  |  Branch (2590:13): [True: 0, False: 2.80k]
  ------------------
 2591|      0|            LOGGER_ERROR(log, "failed to add initial random seed DHT friends");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2592|      0|            kill_dht(dht);
 2593|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2594|      0|        }
 2595|  2.80k|    }
 2596|       |
 2597|  1.40k|    if (dht->num_friends != DHT_FAKE_FRIEND_NUMBER) {
  ------------------
  |  |   64|  1.40k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2597:9): [True: 0, False: 1.40k]
  ------------------
 2598|      0|        LOGGER_ERROR(log, "the RNG provided seems to be broken: it generated the same keypair twice");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2599|      0|        kill_dht(dht);
 2600|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2601|      0|    }
 2602|       |
 2603|  1.40k|    return dht;
 2604|  1.40k|}
kill_dht:
 2628|  1.40k|{
 2629|  1.40k|    if (dht == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2629:9): [True: 0, False: 1.40k]
  ------------------
 2630|      0|        return;
 2631|      0|    }
 2632|       |
 2633|  1.40k|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 2634|  1.40k|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 2635|  1.40k|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 2636|  1.40k|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 2637|  1.40k|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   71|  1.40k|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 2638|       |
 2639|  1.40k|    shared_key_cache_free(dht->shared_keys_recv);
 2640|  1.40k|    shared_key_cache_free(dht->shared_keys_sent);
 2641|  1.40k|    ping_array_kill(dht->dht_ping_array);
 2642|  1.40k|    ping_kill(dht->mem, dht->ping);
 2643|  1.40k|    mem_delete(dht->mem, dht->friends_list);
 2644|  1.40k|    mem_delete(dht->mem, dht->loaded_nodes_list);
 2645|  1.40k|    crypto_memzero(dht->self_secret_key, sizeof(dht->self_secret_key));
 2646|  1.40k|    mem_delete(dht->mem, dht);
 2647|  1.40k|}
dht_size:
 2660|  2.94k|{
 2661|  2.94k|    uint32_t numv4 = 0;
 2662|  2.94k|    uint32_t numv6 = 0;
 2663|       |
 2664|  13.2k|    for (uint32_t i = 0; i < dht->loaded_num_nodes; ++i) {
  ------------------
  |  Branch (2664:26): [True: 10.3k, False: 2.94k]
  ------------------
 2665|  10.3k|        numv4 += net_family_is_ipv4(dht->loaded_nodes_list[i].ip_port.ip.family) ? 1 : 0;
  ------------------
  |  Branch (2665:18): [True: 9.76k, False: 588]
  ------------------
 2666|  10.3k|        numv6 += net_family_is_ipv6(dht->loaded_nodes_list[i].ip_port.ip.family) ? 1 : 0;
  ------------------
  |  Branch (2666:18): [True: 588, False: 9.76k]
  ------------------
 2667|  10.3k|    }
 2668|       |
 2669|  3.01M|    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
  ------------------
  |  |   38|  3.01M|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   35|  3.01M|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   34|  3.01M|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   32|  3.01M|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2669:26): [True: 3.01M, False: 2.94k]
  ------------------
 2670|  3.01M|        numv4 += dht->close_clientlist[i].assoc4.timestamp != 0 ? 1 : 0;
  ------------------
  |  Branch (2670:18): [True: 0, False: 3.01M]
  ------------------
 2671|  3.01M|        numv6 += dht->close_clientlist[i].assoc6.timestamp != 0 ? 1 : 0;
  ------------------
  |  Branch (2671:18): [True: 0, False: 3.01M]
  ------------------
 2672|  3.01M|    }
 2673|       |
 2674|  8.82k|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER && i < dht->num_friends; ++i) {
  ------------------
  |  |   64|  17.6k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2674:26): [True: 5.88k, False: 2.94k]
  |  Branch (2674:56): [True: 5.88k, False: 0]
  ------------------
 2675|  5.88k|        const DHT_Friend *const fr = &dht->friends_list[i];
 2676|       |
 2677|  52.9k|        for (uint32_t j = 0; j < MAX_FRIEND_CLIENTS; ++j) {
  ------------------
  |  |   32|  52.9k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  |  Branch (2677:30): [True: 47.0k, False: 5.88k]
  ------------------
 2678|  47.0k|            numv4 += fr->client_list[j].assoc4.timestamp != 0 ? 1 : 0;
  ------------------
  |  Branch (2678:22): [True: 0, False: 47.0k]
  ------------------
 2679|  47.0k|            numv6 += fr->client_list[j].assoc6.timestamp != 0 ? 1 : 0;
  ------------------
  |  Branch (2679:22): [True: 0, False: 47.0k]
  ------------------
 2680|  47.0k|        }
 2681|  5.88k|    }
 2682|       |
 2683|  2.94k|    const uint32_t size32 = sizeof(uint32_t);
 2684|  2.94k|    const uint32_t sizesubhead = size32 * 2;
 2685|       |
 2686|  2.94k|    return size32 + sizesubhead + packed_node_size(net_family_ipv4()) * numv4 + packed_node_size(net_family_ipv6()) * numv6;
 2687|  2.94k|}
dht_save:
 2691|    981|{
 2692|    981|    host_to_lendian_bytes32(data, DHT_STATE_COOKIE_GLOBAL);
  ------------------
  |  | 2651|    981|#define DHT_STATE_COOKIE_GLOBAL 0x159000d
  ------------------
 2693|    981|    data += sizeof(uint32_t);
 2694|       |
 2695|    981|    uint8_t *const old_data = data;
 2696|       |
 2697|       |    /* get right offset. we write the actual header later. */
 2698|    981|    data = state_write_section_header(data, DHT_STATE_COOKIE_TYPE, 0, 0);
  ------------------
  |  | 2653|    981|#define DHT_STATE_COOKIE_TYPE      0x11ce
  ------------------
 2699|       |
 2700|    981|    Node_format *clients = (Node_format *)mem_valloc(dht->mem, MAX_SAVED_DHT_NODES, sizeof(Node_format));
  ------------------
  |  | 2656|    981|#define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   64|    981|#define DHT_FAKE_FRIEND_NUMBER 2
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   32|    981|#define MAX_FRIEND_CLIENTS 8
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   38|    981|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   35|    981|#define LCLIENT_LENGTH 128
  |  |  |  |  ------------------
  |  |  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|    981|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   32|    981|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2701|       |
 2702|    981|    if (clients == nullptr) {
  ------------------
  |  |   63|    981|#define nullptr NULL
  ------------------
  |  Branch (2702:9): [True: 0, False: 981]
  ------------------
 2703|      0|        LOGGER_ERROR(dht->log, "could not allocate %u nodes", (unsigned int)MAX_SAVED_DHT_NODES);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2704|      0|        return;
 2705|      0|    }
 2706|       |
 2707|    981|    uint32_t num = 0;
 2708|       |
 2709|    981|    if (dht->loaded_num_nodes > 0) {
  ------------------
  |  Branch (2709:9): [True: 161, False: 820]
  ------------------
 2710|    161|        memcpy(clients, dht->loaded_nodes_list, sizeof(Node_format) * dht->loaded_num_nodes);
 2711|    161|        num += dht->loaded_num_nodes;
 2712|    161|    }
 2713|       |
 2714|  1.00M|    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
  ------------------
  |  |   38|  1.00M|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   35|  1.00M|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   34|  1.00M|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   32|  1.00M|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2714:26): [True: 1.00M, False: 981]
  ------------------
 2715|  1.00M|        if (dht->close_clientlist[i].assoc4.timestamp != 0) {
  ------------------
  |  Branch (2715:13): [True: 0, False: 1.00M]
  ------------------
 2716|      0|            memcpy(clients[num].public_key, dht->close_clientlist[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2717|      0|            clients[num].ip_port = dht->close_clientlist[i].assoc4.ip_port;
 2718|      0|            ++num;
 2719|      0|        }
 2720|       |
 2721|  1.00M|        if (dht->close_clientlist[i].assoc6.timestamp != 0) {
  ------------------
  |  Branch (2721:13): [True: 0, False: 1.00M]
  ------------------
 2722|      0|            memcpy(clients[num].public_key, dht->close_clientlist[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2723|      0|            clients[num].ip_port = dht->close_clientlist[i].assoc6.ip_port;
 2724|      0|            ++num;
 2725|      0|        }
 2726|  1.00M|    }
 2727|       |
 2728|  2.94k|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER && i < dht->num_friends; ++i) {
  ------------------
  |  |   64|  5.88k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2728:26): [True: 1.96k, False: 981]
  |  Branch (2728:56): [True: 1.96k, False: 0]
  ------------------
 2729|  1.96k|        const DHT_Friend *const fr = &dht->friends_list[i];
 2730|       |
 2731|  17.6k|        for (uint32_t j = 0; j < MAX_FRIEND_CLIENTS; ++j) {
  ------------------
  |  |   32|  17.6k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  |  Branch (2731:30): [True: 15.6k, False: 1.96k]
  ------------------
 2732|  15.6k|            if (fr->client_list[j].assoc4.timestamp != 0) {
  ------------------
  |  Branch (2732:17): [True: 0, False: 15.6k]
  ------------------
 2733|      0|                memcpy(clients[num].public_key, fr->client_list[j].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2734|      0|                clients[num].ip_port = fr->client_list[j].assoc4.ip_port;
 2735|      0|                ++num;
 2736|      0|            }
 2737|       |
 2738|  15.6k|            if (fr->client_list[j].assoc6.timestamp != 0) {
  ------------------
  |  Branch (2738:17): [True: 0, False: 15.6k]
  ------------------
 2739|      0|                memcpy(clients[num].public_key, fr->client_list[j].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2740|      0|                clients[num].ip_port = fr->client_list[j].assoc6.ip_port;
 2741|      0|                ++num;
 2742|      0|            }
 2743|  15.6k|        }
 2744|  1.96k|    }
 2745|       |
 2746|    981|    state_write_section_header(
 2747|    981|        old_data, DHT_STATE_COOKIE_TYPE, pack_nodes(dht->log, data, sizeof(Node_format) * num, clients, num),
  ------------------
  |  | 2653|    981|#define DHT_STATE_COOKIE_TYPE      0x11ce
  ------------------
 2748|    981|        DHT_STATE_TYPE_NODES);
  ------------------
  |  | 2654|    981|#define DHT_STATE_TYPE_NODES       4
  ------------------
 2749|       |
 2750|    981|    mem_delete(dht->mem, clients);
 2751|    981|}
dht_load:
 2829|    707|{
 2830|    707|    const uint32_t cookie_len = sizeof(uint32_t);
 2831|       |
 2832|    707|    if (length > cookie_len) {
  ------------------
  |  Branch (2832:9): [True: 641, False: 66]
  ------------------
 2833|    641|        uint32_t data32;
 2834|    641|        lendian_bytes_to_host32(&data32, data);
 2835|       |
 2836|    641|        if (data32 == DHT_STATE_COOKIE_GLOBAL) {
  ------------------
  |  | 2651|    641|#define DHT_STATE_COOKIE_GLOBAL 0x159000d
  ------------------
  |  Branch (2836:13): [True: 621, False: 20]
  ------------------
 2837|    621|            return state_load(dht->log, dht_load_state_callback, dht, data + cookie_len,
 2838|    621|                              length - cookie_len, DHT_STATE_COOKIE_TYPE);
  ------------------
  |  | 2653|    621|#define DHT_STATE_COOKIE_TYPE      0x11ce
  ------------------
 2839|    621|        }
 2840|    641|    }
 2841|       |
 2842|     86|    return -1;
 2843|    707|}
DHT.c:bin_pack_node_handler:
  414|  8.49k|{
  415|  8.49k|    const Node_format *nodes = (const Node_format *)arr;
  416|  8.49k|    return bin_pack_ip_port(bp, logger, &nodes[index].ip_port)
  ------------------
  |  Branch (416:12): [True: 8.49k, False: 0]
  ------------------
  417|  8.49k|           && bin_pack_bin_b(bp, nodes[index].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|  8.49k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (417:15): [True: 8.49k, False: 0]
  ------------------
  418|  8.49k|}
DHT.c:get_somewhat_close_nodes:
  723|  2.80k|{
  724|  14.0k|    for (uint16_t i = 0; i < MAX_SENT_NODES; ++i) {
  ------------------
  |  |   43|  14.0k|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (724:26): [True: 11.2k, False: 2.80k]
  ------------------
  725|  11.2k|        nodes_list[i] = empty_node_format;
  726|  11.2k|    }
  727|       |
  728|  2.80k|    uint32_t num_nodes = 0;
  729|  2.80k|    get_close_nodes_inner(
  730|  2.80k|        cur_time, public_key,
  731|  2.80k|        nodes_list, &num_nodes,
  732|  2.80k|        sa_family, close_clientlist, LCLIENT_LIST,
  ------------------
  |  |   38|  2.80k|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   35|  2.80k|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   34|  2.80k|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   32|  2.80k|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  733|  2.80k|        is_lan, want_announce);
  734|       |
  735|  7.02k|    for (uint16_t i = 0; i < friends_list_size; ++i) {
  ------------------
  |  Branch (735:26): [True: 4.21k, False: 2.80k]
  ------------------
  736|  4.21k|        const DHT_Friend *dht_friend = &friends_list[i];
  737|       |
  738|  4.21k|        get_close_nodes_inner(
  739|  4.21k|            cur_time, public_key,
  740|  4.21k|            nodes_list, &num_nodes,
  741|  4.21k|            sa_family, dht_friend->client_list, MAX_FRIEND_CLIENTS,
  ------------------
  |  |   32|  4.21k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  742|  4.21k|            is_lan, want_announce);
  743|  4.21k|    }
  744|       |
  745|  2.80k|    return num_nodes;
  746|  2.80k|}
DHT.c:get_close_nodes_inner:
  657|  7.02k|{
  658|  7.02k|    if (!net_family_is_ipv4(sa_family) && !net_family_is_ipv6(sa_family) && !net_family_is_unspec(sa_family)) {
  ------------------
  |  Branch (658:9): [True: 7.02k, False: 0]
  |  Branch (658:43): [True: 7.02k, False: 0]
  |  Branch (658:77): [True: 0, False: 7.02k]
  ------------------
  659|      0|        return;
  660|      0|    }
  661|       |
  662|  7.02k|    uint32_t num_nodes = *num_nodes_ptr;
  663|       |
  664|  2.91M|    for (uint32_t i = 0; i < client_list_length; ++i) {
  ------------------
  |  Branch (664:26): [True: 2.90M, False: 7.02k]
  ------------------
  665|  2.90M|        const Client_data *const client = &client_list[i];
  666|  2.90M|        const IPPTsPng *ipptp;
  667|       |
  668|  2.90M|        if (net_family_is_ipv4(sa_family)) {
  ------------------
  |  Branch (668:13): [True: 0, False: 2.90M]
  ------------------
  669|      0|            ipptp = &client->assoc4;
  670|  2.90M|        } else if (net_family_is_ipv6(sa_family)) {
  ------------------
  |  Branch (670:20): [True: 0, False: 2.90M]
  ------------------
  671|      0|            ipptp = &client->assoc6;
  672|  2.90M|        } else if (client->assoc4.timestamp >= client->assoc6.timestamp) {
  ------------------
  |  Branch (672:20): [True: 2.90M, False: 0]
  ------------------
  673|  2.90M|            ipptp = &client->assoc4;
  674|  2.90M|        } else {
  675|      0|            ipptp = &client->assoc6;
  676|      0|        }
  677|       |
  678|       |        /* node not in a good condition? */
  679|  2.90M|        if (assoc_timeout(cur_time, ipptp)) {
  ------------------
  |  Branch (679:13): [True: 2.90M, False: 0]
  ------------------
  680|  2.90M|            continue;
  681|  2.90M|        }
  682|       |
  683|       |        /* don't send LAN ips to non LAN peers */
  684|      0|        if (ip_is_lan(&ipptp->ip_port.ip) && !is_lan) {
  ------------------
  |  Branch (684:13): [True: 0, False: 0]
  |  Branch (684:46): [True: 0, False: 0]
  ------------------
  685|      0|            continue;
  686|      0|        }
  687|       |
  688|      0|#ifdef CHECK_ANNOUNCE_NODE
  689|       |
  690|      0|        if (want_announce && !client->announce_node) {
  ------------------
  |  Branch (690:13): [True: 0, False: 0]
  |  Branch (690:30): [True: 0, False: 0]
  ------------------
  691|      0|            continue;
  692|      0|        }
  693|       |
  694|      0|#endif /* CHECK_ANNOUNCE_NODE */
  695|       |
  696|       |        /* node already in list? */
  697|      0|        if (index_of_node_pk(nodes_list, num_nodes, client->public_key) != UINT32_MAX) {
  ------------------
  |  Branch (697:13): [True: 0, False: 0]
  ------------------
  698|      0|            continue;
  699|      0|        }
  700|       |
  701|      0|        if (num_nodes < MAX_SENT_NODES) {
  ------------------
  |  |   43|      0|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (701:13): [True: 0, False: 0]
  ------------------
  702|      0|            memcpy(nodes_list[num_nodes].public_key, client->public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  703|      0|            nodes_list[num_nodes].ip_port = ipptp->ip_port;
  704|      0|            ++num_nodes;
  705|      0|        } else {
  706|       |            // TODO(zugz): this could be made significantly more efficient by
  707|       |            // using a version of add_to_list which works with a sorted list.
  708|      0|            add_to_list(nodes_list, MAX_SENT_NODES, client->public_key, &ipptp->ip_port, public_key);
  ------------------
  |  |   43|      0|#define MAX_SENT_NODES 4
  ------------------
  709|      0|        }
  710|      0|    }
  711|       |
  712|  7.02k|    *num_nodes_ptr = num_nodes;
  713|  7.02k|}
DHT.c:index_of_friend_pk:
  486|  2.80k|{
  487|  2.80k|    assert(size == 0 || array != nullptr);
  ------------------
  |  Branch (487:5): [True: 1.40k, False: 1.40k]
  |  Branch (487:5): [True: 1.40k, False: 0]
  ------------------
  488|  4.21k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (488:26): [True: 1.40k, False: 2.80k]
  ------------------
  489|  1.40k|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (489:13): [True: 0, False: 1.40k]
  ------------------
  490|      0|            return i;
  491|      0|        }
  492|  1.40k|    }
  493|       |
  494|  2.80k|    return UINT32_MAX;
  495|  2.80k|}
DHT.c:dht_friend_lock:
 1536|  2.80k|{
 1537|       |    // find first free slot
 1538|  2.80k|    uint8_t lock_num;
 1539|  2.80k|    uint32_t lock_token = 0;
 1540|  2.80k|    for (lock_num = 0; lock_num < DHT_FRIEND_MAX_LOCKS; ++lock_num) {
  ------------------
  |  |   52|  2.80k|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1540:24): [True: 2.80k, False: 0]
  ------------------
 1541|  2.80k|        lock_token = UINT32_C(1) << lock_num;
 1542|  2.80k|        if ((dht_friend->lock_flags & lock_token) == 0) {
  ------------------
  |  Branch (1542:13): [True: 2.80k, False: 0]
  ------------------
 1543|  2.80k|            break;
 1544|  2.80k|        }
 1545|  2.80k|    }
 1546|       |
 1547|       |    // One of the conditions would be enough, but static analyzers don't get that
 1548|  2.80k|    if (lock_token == 0 || lock_num == DHT_FRIEND_MAX_LOCKS) {
  ------------------
  |  |   52|  2.80k|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1548:9): [True: 0, False: 2.80k]
  |  Branch (1548:28): [True: 0, False: 2.80k]
  ------------------
 1549|      0|        return 0;
 1550|      0|    }
 1551|       |
 1552|       |    // Claim that slot
 1553|  2.80k|    dht_friend->lock_flags |= lock_token;
 1554|       |
 1555|  2.80k|    dht_friend->callbacks[lock_num].ip_callback = ip_callback;
 1556|  2.80k|    dht_friend->callbacks[lock_num].data = data;
 1557|  2.80k|    dht_friend->callbacks[lock_num].number = number;
 1558|       |
 1559|  2.80k|    return lock_token;
 1560|  2.80k|}
DHT.c:assoc_timeout:
  206|  2.90M|{
  207|  2.90M|    return (assoc->timestamp + BAD_NODE_TIMEOUT) <= cur_time;
  ------------------
  |  |   57|  2.90M|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   52|  2.90M|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   55|  2.90M|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   52|  2.90M|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   56|  2.90M|#define PING_ROUNDTRIP 2
  |  |  ------------------
  ------------------
  208|  2.90M|}
DHT.c:dht_load_state_callback:
 2784|    604|{
 2785|    604|    DHT *dht = (DHT *)outer;
 2786|       |
 2787|    604|    switch (type) {
 2788|    538|        case DHT_STATE_TYPE_NODES: {
  ------------------
  |  | 2654|    538|#define DHT_STATE_TYPE_NODES       4
  ------------------
  |  Branch (2788:9): [True: 538, False: 66]
  ------------------
 2789|    538|            if (length == 0) {
  ------------------
  |  Branch (2789:17): [True: 10, False: 528]
  ------------------
 2790|     10|                break;
 2791|     10|            }
 2792|       |
 2793|    528|            mem_delete(dht->mem, dht->loaded_nodes_list);
 2794|       |
 2795|       |            // Copy to loaded_clients_list
 2796|    528|            Node_format *nodes = (Node_format *)mem_valloc(dht->mem, MAX_SAVED_DHT_NODES, sizeof(Node_format));
  ------------------
  |  | 2656|    528|#define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   64|    528|#define DHT_FAKE_FRIEND_NUMBER 2
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   32|    528|#define MAX_FRIEND_CLIENTS 8
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   38|    528|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   35|    528|#define LCLIENT_LENGTH 128
  |  |  |  |  ------------------
  |  |  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|    528|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   32|    528|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2797|       |
 2798|    528|            if (nodes == nullptr) {
  ------------------
  |  |   63|    528|#define nullptr NULL
  ------------------
  |  Branch (2798:17): [True: 0, False: 528]
  ------------------
 2799|      0|                LOGGER_ERROR(dht->log, "could not allocate %u nodes", (unsigned int)MAX_SAVED_DHT_NODES);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2800|      0|                dht->loaded_num_nodes = 0;
 2801|      0|                break;
 2802|      0|            }
 2803|       |
 2804|    528|            const int num = unpack_nodes(nodes, MAX_SAVED_DHT_NODES, nullptr, data, length, false);
  ------------------
  |  | 2656|    528|#define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   64|    528|#define DHT_FAKE_FRIEND_NUMBER 2
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   32|    528|#define MAX_FRIEND_CLIENTS 8
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   38|    528|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   35|    528|#define LCLIENT_LENGTH 128
  |  |  |  |  ------------------
  |  |  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|    528|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   32|    528|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                          const int num = unpack_nodes(nodes, MAX_SAVED_DHT_NODES, nullptr, data, length, false);
  ------------------
  |  |   63|    528|#define nullptr NULL
  ------------------
 2805|       |
 2806|    528|            if (num < 0) {
  ------------------
  |  Branch (2806:17): [True: 36, False: 492]
  ------------------
 2807|       |                // Unpack error happened, we ignore it.
 2808|     36|                dht->loaded_num_nodes = 0;
 2809|    492|            } else {
 2810|    492|                dht->loaded_num_nodes = num;
 2811|    492|            }
 2812|       |
 2813|    528|            dht->loaded_nodes_list = nodes;
 2814|       |
 2815|    528|            break;
 2816|    528|        }
 2817|       |
 2818|     66|        default: {
  ------------------
  |  Branch (2818:9): [True: 66, False: 538]
  ------------------
 2819|     66|            LOGGER_ERROR(dht->log, "Load state (DHT): contains unrecognized part (len %u, type %u)",
  ------------------
  |  |   80|     66|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     66|    do {                                                                         \
  |  |  |  |   70|     66|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    132|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 66, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     66|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     66|        }                                                                        \
  |  |  |  |   73|     66|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 66]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2820|     66|                         length, type);
 2821|     66|            break;
 2822|    528|        }
 2823|    604|    }
 2824|       |
 2825|    604|    return STATE_LOAD_STATUS_CONTINUE;
 2826|    604|}

lan_discovery_init:
  405|  1.40k|{
  406|  1.40k|    return fetch_broadcast_info(mem, ns);
  407|  1.40k|}
lan_discovery_kill:
  410|  1.40k|{
  411|  1.40k|    if (broadcast == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (411:9): [True: 0, False: 1.40k]
  ------------------
  412|      0|        return;
  413|      0|    }
  414|       |
  415|  1.40k|    mem_delete(broadcast->mem, broadcast);
  416|  1.40k|}
LAN_discovery.c:fetch_broadcast_info:
  223|  1.40k|{
  224|  1.40k|    Broadcast_Info *broadcast = (Broadcast_Info *)mem_alloc(mem, sizeof(Broadcast_Info));
  225|       |
  226|  1.40k|    if (broadcast == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (226:9): [True: 0, False: 1.40k]
  ------------------
  227|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  228|      0|    }
  229|       |
  230|  1.40k|    broadcast->mem = mem;
  231|       |
  232|  1.40k|    return broadcast;
  233|  1.40k|}

getfriend_id:
  110|  8.96k|{
  111|  15.4k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (111:26): [True: 6.81k, False: 8.68k]
  ------------------
  112|  6.81k|        if (m->friendlist[i].status > 0 && pk_equal(real_pk, m->friendlist[i].real_pk)) {
  ------------------
  |  Branch (112:13): [True: 6.81k, False: 0]
  |  Branch (112:44): [True: 277, False: 6.53k]
  ------------------
  113|    277|            return i;
  114|    277|        }
  115|  6.81k|    }
  116|       |
  117|  8.68k|    return -1;
  118|  8.96k|}
m_addfriend:
  265|    129|{
  266|    129|    if (length > MAX_FRIEND_REQUEST_DATA_SIZE) {
  ------------------
  |  |   20|    129|#define MAX_FRIEND_REQUEST_DATA_SIZE (ONION_CLIENT_MAX_DATA_SIZE - 100)
  |  |  ------------------
  |  |  |  |  175|    129|#define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   45|    129|#define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   60|    129|#define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   49|    129|#define ONION_MAX_PACKET_SIZE 1400
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   58|    129|#define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   70|    129|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   55|    129|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   44|    129|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   29|    129|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   27|    129|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   26|    129|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   28|    129|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   65|    129|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   44|    129|#define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   44|    129|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   70|    129|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   44|    129|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   65|    129|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  172|    129|#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   44|    129|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|    129|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (266:9): [True: 11, False: 118]
  ------------------
  267|     11|        return FAERR_TOOLONG;
  268|     11|    }
  269|       |
  270|    118|    uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
  271|    118|    pk_copy(real_pk, address);
  272|       |
  273|    118|    if (!public_key_valid(real_pk)) {
  ------------------
  |  Branch (273:9): [True: 10, False: 108]
  ------------------
  274|     10|        return FAERR_BADCHECKSUM;
  275|     10|    }
  276|       |
  277|    108|    uint16_t check;
  278|    108|    const uint16_t checksum = data_checksum(address, FRIEND_ADDRESS_SIZE - sizeof(checksum));
  ------------------
  |  |   47|    108|#define FRIEND_ADDRESS_SIZE (CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t) + sizeof(uint16_t))
  |  |  ------------------
  |  |  |  |   44|    108|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  279|    108|    memcpy(&check, address + CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t), sizeof(check));
  ------------------
  |  |   44|    108|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  280|       |
  281|    108|    if (check != checksum) {
  ------------------
  |  Branch (281:9): [True: 0, False: 108]
  ------------------
  282|      0|        return FAERR_BADCHECKSUM;
  283|      0|    }
  284|       |
  285|    108|    if (length < 1) {
  ------------------
  |  Branch (285:9): [True: 10, False: 98]
  ------------------
  286|     10|        return FAERR_NOMESSAGE;
  287|     10|    }
  288|       |
  289|     98|    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (289:9): [True: 10, False: 88]
  ------------------
  290|     10|        return FAERR_OWNKEY;
  291|     10|    }
  292|       |
  293|     88|    const int32_t friend_id = getfriend_id(m, real_pk);
  294|       |
  295|     88|    if (friend_id != -1) {
  ------------------
  |  Branch (295:9): [True: 45, False: 43]
  ------------------
  296|     45|        if (m->friendlist[friend_id].status >= FRIEND_CONFIRMED) {
  ------------------
  |  Branch (296:13): [True: 10, False: 35]
  ------------------
  297|     10|            return FAERR_ALREADYSENT;
  298|     10|        }
  299|       |
  300|     35|        uint32_t nospam;
  301|     35|        memcpy(&nospam, address + CRYPTO_PUBLIC_KEY_SIZE, sizeof(nospam));
  ------------------
  |  |   44|     35|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  302|       |
  303|     35|        if (m->friendlist[friend_id].friendrequest_nospam == nospam) {
  ------------------
  |  Branch (303:13): [True: 18, False: 17]
  ------------------
  304|     18|            return FAERR_ALREADYSENT;
  305|     18|        }
  306|       |
  307|     17|        m->friendlist[friend_id].friendrequest_nospam = nospam;
  308|     17|        return FAERR_SETNEWNOSPAM;
  309|     35|    }
  310|       |
  311|     43|    const int32_t ret = init_new_friend(m, real_pk, FRIEND_ADDED);
  312|       |
  313|     43|    if (ret < 0) {
  ------------------
  |  Branch (313:9): [True: 0, False: 43]
  ------------------
  314|      0|        return ret;
  315|      0|    }
  316|       |
  317|     43|    m->friendlist[ret].friendrequest_timeout = FRIENDREQUEST_TIMEOUT;
  ------------------
  |  |  126|     43|#define FRIENDREQUEST_TIMEOUT 5
  ------------------
  318|     43|    memcpy(m->friendlist[ret].info, data, length);
  319|     43|    m->friendlist[ret].info_size = length;
  320|     43|    memcpy(&m->friendlist[ret].friendrequest_nospam, address + CRYPTO_PUBLIC_KEY_SIZE, sizeof(uint32_t));
  ------------------
  |  |   44|     43|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  321|       |
  322|     43|    return ret;
  323|     43|}
m_addfriend_norequest:
  326|    352|{
  327|    352|    if (!public_key_valid(real_pk)) {
  ------------------
  |  Branch (327:9): [True: 31, False: 321]
  ------------------
  328|     31|        return FAERR_BADCHECKSUM;
  329|     31|    }
  330|       |
  331|    321|    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (331:9): [True: 10, False: 311]
  ------------------
  332|     10|        return FAERR_OWNKEY;
  333|     10|    }
  334|       |
  335|    311|    return m_add_friend_contact_norequest(m, real_pk);
  336|    321|}
m_create_group_connection:
  397|     88|{
  398|     88|    random_bytes(m->rng, chat->m_group_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     88|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  399|     88|    const int friendcon_id = new_friend_connection(m->fr_c, chat->m_group_public_key);
  400|       |
  401|     88|    if (friendcon_id == -1) {
  ------------------
  |  Branch (401:9): [True: 0, False: 88]
  ------------------
  402|      0|        return false;
  403|      0|    }
  404|       |
  405|     88|    const Friend_Conn *connection = get_conn(m->fr_c, friendcon_id);
  406|       |
  407|     88|    if (connection == nullptr) {
  ------------------
  |  |   63|     88|#define nullptr NULL
  ------------------
  |  Branch (407:9): [True: 0, False: 88]
  ------------------
  408|      0|        return false;
  409|      0|    }
  410|       |
  411|     88|    chat->friend_connection_id = friendcon_id;
  412|       |
  413|     88|    if (friend_con_connected(m->fr_c, friendcon_id) == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (413:9): [True: 0, False: 88]
  ------------------
  414|      0|        send_online_packet(m, friendcon_id);
  415|      0|    }
  416|       |
  417|     88|    const int onion_friend_number = friend_conn_get_onion_friendnum(connection);
  418|     88|    Onion_Friend *onion_friend = onion_get_friend(m->onion_c, (uint16_t)onion_friend_number);
  419|       |
  420|     88|    onion_friend_set_gc_public_key(onion_friend, get_chat_id(&chat->chat_public_key));
  421|     88|    onion_friend_set_gc_data(onion_friend, nullptr, 0);
  ------------------
  |  |   63|     88|#define nullptr NULL
  ------------------
  422|       |
  423|       |    return true;
  424|     88|}
m_kill_group_connection:
  430|     88|{
  431|     88|    remove_request_received(m->fr, chat->m_group_public_key);
  432|       |
  433|     88|    friend_connection_callbacks(m->fr_c, chat->friend_connection_id, MESSENGER_CALLBACK_INDEX, nullptr,
  ------------------
  |  |   26|     88|#define MESSENGER_CALLBACK_INDEX 0
  ------------------
                  friend_connection_callbacks(m->fr_c, chat->friend_connection_id, MESSENGER_CALLBACK_INDEX, nullptr,
  ------------------
  |  |   63|     88|#define nullptr NULL
  ------------------
  434|     88|                                nullptr, nullptr, nullptr, 0);
  ------------------
  |  |   63|     88|#define nullptr NULL
  ------------------
                                              nullptr, nullptr, nullptr, 0);
  ------------------
  |  |   63|     88|#define nullptr NULL
  ------------------
                                              nullptr, nullptr, nullptr, 0);
  ------------------
  |  |   63|     88|#define nullptr NULL
  ------------------
  435|       |
  436|     88|    if (friend_con_connected(m->fr_c, chat->friend_connection_id) == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (436:9): [True: 0, False: 88]
  ------------------
  437|      0|        send_offline_packet(m, chat->friend_connection_id);
  438|      0|    }
  439|       |
  440|     88|    kill_friend_connection(m->fr_c, chat->friend_connection_id);
  441|     88|}
m_friend_exists:
  558|    943|{
  559|    943|    return (unsigned int)friendnumber < m->numfriends && m->friendlist[friendnumber].status != 0;
  ------------------
  |  Branch (559:12): [True: 943, False: 0]
  |  Branch (559:58): [True: 943, False: 0]
  ------------------
  560|    943|}
setfriendname:
  662|    300|{
  663|    300|    if (!m_friend_exists(m, friendnumber)) {
  ------------------
  |  Branch (663:9): [True: 0, False: 300]
  ------------------
  664|      0|        return -1;
  665|      0|    }
  666|       |
  667|    300|    if (length > MAX_NAME_LENGTH || length == 0) {
  ------------------
  |  |   39|    600|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (667:9): [True: 158, False: 142]
  |  Branch (667:37): [True: 93, False: 49]
  ------------------
  668|    251|        return -1;
  669|    251|    }
  670|       |
  671|     49|    m->friendlist[friendnumber].name_length = length;
  672|     49|    memcpy(m->friendlist[friendnumber].name, name, length);
  673|     49|    return 0;
  674|    300|}
setname:
  686|    326|{
  687|    326|    if (length > MAX_NAME_LENGTH) {
  ------------------
  |  |   39|    326|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (687:9): [True: 0, False: 326]
  ------------------
  688|      0|        return -1;
  689|      0|    }
  690|       |
  691|    326|    if (m->name_length == length && (length == 0 || memcmp(name, m->name, length) == 0)) {
  ------------------
  |  Branch (691:9): [True: 258, False: 68]
  |  Branch (691:38): [True: 0, False: 258]
  |  Branch (691:53): [True: 82, False: 176]
  ------------------
  692|     82|        return 0;
  693|     82|    }
  694|       |
  695|    244|    if (length > 0) {
  ------------------
  |  Branch (695:9): [True: 244, False: 0]
  ------------------
  696|    244|        memcpy(m->name, name, length);
  697|    244|    }
  698|       |
  699|    244|    m->name_length = length;
  700|       |
  701|    597|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (701:26): [True: 353, False: 244]
  ------------------
  702|    353|        m->friendlist[i].name_sent = false;
  703|    353|    }
  704|       |
  705|    244|    return 0;
  706|    326|}
m_set_statusmessage:
  760|    640|{
  761|    640|    if (length > MAX_STATUSMESSAGE_LENGTH) {
  ------------------
  |  |   41|    640|#define MAX_STATUSMESSAGE_LENGTH 1007
  ------------------
  |  Branch (761:9): [True: 0, False: 640]
  ------------------
  762|      0|        return -1;
  763|      0|    }
  764|       |
  765|    640|    if (m->statusmessage_length == length && (length == 0 || memcmp(m->statusmessage, status, length) == 0)) {
  ------------------
  |  Branch (765:9): [True: 413, False: 227]
  |  Branch (765:47): [True: 0, False: 413]
  |  Branch (765:62): [True: 168, False: 245]
  ------------------
  766|    168|        return 0;
  767|    168|    }
  768|       |
  769|    472|    if (length > 0) {
  ------------------
  |  Branch (769:9): [True: 472, False: 0]
  ------------------
  770|    472|        memcpy(m->statusmessage, status, length);
  771|    472|    }
  772|       |
  773|    472|    m->statusmessage_length = length;
  774|       |
  775|    831|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (775:26): [True: 359, False: 472]
  ------------------
  776|    359|        m->friendlist[i].statusmessage_sent = false;
  777|    359|    }
  778|       |
  779|    472|    return 0;
  780|    640|}
m_set_userstatus:
  813|    583|{
  814|    583|    if (status >= USERSTATUS_INVALID) {
  ------------------
  |  Branch (814:9): [True: 258, False: 325]
  ------------------
  815|    258|        return -1;
  816|    258|    }
  817|       |
  818|    325|    if (m->userstatus == status) {
  ------------------
  |  Branch (818:9): [True: 165, False: 160]
  ------------------
  819|    165|        return 0;
  820|    165|    }
  821|       |
  822|    160|    userstatus_from_int(status, &m->userstatus);
  823|       |
  824|    326|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (824:26): [True: 166, False: 160]
  ------------------
  825|    166|        m->friendlist[i].userstatus_sent = false;
  826|    166|    }
  827|       |
  828|    160|    return 0;
  829|    325|}
m_callback_friendrequest:
  983|    981|{
  984|    981|    m->friend_request = function;
  985|    981|}
m_callback_friendmessage:
  989|    981|{
  990|    981|    m->friend_message = function;
  991|    981|}
m_callback_namechange:
  994|    981|{
  995|    981|    m->friend_namechange = function;
  996|    981|}
m_callback_statusmessage:
  999|    981|{
 1000|    981|    m->friend_statusmessagechange = function;
 1001|    981|}
m_callback_userstatus:
 1004|    981|{
 1005|    981|    m->friend_userstatuschange = function;
 1006|    981|}
m_callback_typingchange:
 1009|    981|{
 1010|    981|    m->friend_typingchange = function;
 1011|    981|}
m_callback_read_receipt:
 1014|    981|{
 1015|    981|    m->read_receipt = function;
 1016|    981|}
m_callback_connectionstatus:
 1019|    981|{
 1020|    981|    m->friend_connectionstatuschange = function;
 1021|    981|}
m_callback_core_connection:
 1024|    981|{
 1025|    981|    m->core_connection_change = function;
 1026|    981|}
m_callback_conference_invite:
 1084|  2.80k|{
 1085|  2.80k|    m->conference_invite = function;
 1086|  2.80k|}
m_callback_group_invite:
 1090|    981|{
 1091|    981|    m->group_invite = function;
 1092|    981|}
callback_file_sendrequest:
 1117|    981|{
 1118|    981|    m->file_sendrequest = function;
 1119|    981|}
callback_file_control:
 1123|    981|{
 1124|    981|    m->file_filecontrol = function;
 1125|    981|}
callback_file_data:
 1129|    981|{
 1130|    981|    m->file_filedata = function;
 1131|    981|}
callback_file_reqchunk:
 1135|    981|{
 1136|    981|    m->file_reqchunk = function;
 1137|    981|}
custom_lossy_packet_registerhandler:
 1869|    981|{
 1870|    981|    m->lossy_packethandler = lossy_packethandler;
 1871|    981|}
custom_lossless_packet_registerhandler:
 1922|    981|{
 1923|    981|    m->lossless_packethandler = lossless_packethandler;
 1924|    981|}
m_register_state_plugin:
 2840|  12.6k|{
 2841|  12.6k|    const uint32_t new_length = m->options.state_plugins_length + 1;
 2842|  12.6k|    Messenger_State_Plugin *temp = (Messenger_State_Plugin *)mem_vrealloc(
 2843|  12.6k|                                       m->mem, m->options.state_plugins, new_length, sizeof(Messenger_State_Plugin));
 2844|       |
 2845|  12.6k|    if (temp == nullptr) {
  ------------------
  |  |   63|  12.6k|#define nullptr NULL
  ------------------
  |  Branch (2845:9): [True: 0, False: 12.6k]
  ------------------
 2846|      0|        return false;
 2847|      0|    }
 2848|       |
 2849|  12.6k|    m->options.state_plugins = temp;
 2850|  12.6k|    m->options.state_plugins_length = new_length;
 2851|       |
 2852|  12.6k|    const uint8_t index = m->options.state_plugins_length - 1;
 2853|  12.6k|    m->options.state_plugins[index].type = type;
 2854|  12.6k|    m->options.state_plugins[index].size = size_callback;
 2855|  12.6k|    m->options.state_plugins[index].load = load_callback;
 2856|  12.6k|    m->options.state_plugins[index].save = save_callback;
 2857|       |
 2858|       |    return true;
 2859|  12.6k|}
messenger_size:
 2878|  1.96k|{
 2879|  1.96k|    return m_state_plugins_size(m);
 2880|  1.96k|}
messenger_save:
 2884|    981|{
 2885|  9.81k|    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
  ------------------
  |  Branch (2885:25): [True: 8.82k, False: 981]
  ------------------
 2886|  8.82k|        const Messenger_State_Plugin plugin = m->options.state_plugins[i];
 2887|  8.82k|        data = plugin.save(m, data);
 2888|  8.82k|    }
 2889|       |
 2890|    981|    return data;
 2891|    981|}
messenger_load_state_section:
 3324|  30.8k|{
 3325|   208k|    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
  ------------------
  |  Branch (3325:25): [True: 207k, False: 938]
  ------------------
 3326|   207k|        const Messenger_State_Plugin *const plugin = &m->options.state_plugins[i];
 3327|       |
 3328|   207k|        if (plugin->type == type) {
  ------------------
  |  Branch (3328:13): [True: 29.8k, False: 177k]
  ------------------
 3329|  29.8k|            *status = plugin->load(m, data, length);
 3330|  29.8k|            return true;
 3331|  29.8k|        }
 3332|   207k|    }
 3333|       |
 3334|    938|    return false;
 3335|  30.8k|}
count_friendlist:
 3343|  2.94k|{
 3344|  2.94k|    uint32_t ret = 0;
 3345|       |
 3346|  3.33k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (3346:26): [True: 390, False: 2.94k]
  ------------------
 3347|    390|        if (m->friendlist[i].status > 0) {
  ------------------
  |  Branch (3347:13): [True: 390, False: 0]
  ------------------
 3348|    390|            ++ret;
 3349|    390|        }
 3350|    390|    }
 3351|       |
 3352|  2.94k|    return ret;
 3353|  2.94k|}
new_messenger:
 3405|  1.40k|{
 3406|  1.40k|    if (options == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3406:9): [True: 0, False: 1.40k]
  ------------------
 3407|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3408|      0|    }
 3409|       |
 3410|  1.40k|    if (error != nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3410:9): [True: 1.40k, False: 0]
  ------------------
 3411|  1.40k|        *error = MESSENGER_ERROR_OTHER;
 3412|  1.40k|    }
 3413|       |
 3414|  1.40k|    Messenger *m = (Messenger *)mem_alloc(mem, sizeof(Messenger));
 3415|       |
 3416|  1.40k|    if (m == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3416:9): [True: 0, False: 1.40k]
  ------------------
 3417|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3418|      0|    }
 3419|       |
 3420|  1.40k|    m->log = options->log;
 3421|  1.40k|    m->mono_time = mono_time;
 3422|  1.40k|    m->mem = mem;
 3423|  1.40k|    m->rng = rng;
 3424|  1.40k|    m->ns = ns;
 3425|  1.40k|    m->forwarding = nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 3426|  1.40k|    m->announce = nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 3427|  1.40k|    m->tcp_server = nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 3428|       |
 3429|  1.40k|    Friend_Requests *fr = friendreq_new(mem);
 3430|  1.40k|    if (fr == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3430:9): [True: 0, False: 1.40k]
  ------------------
 3431|      0|        mem_delete(mem, m);
 3432|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3433|      0|    }
 3434|  1.40k|    m->fr = fr;
 3435|       |
 3436|  1.40k|    unsigned int net_err = 0;
 3437|       |
 3438|  1.40k|    if (!options->udp_disabled && options->proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (3438:9): [True: 1.40k, False: 0]
  |  Branch (3438:35): [True: 0, False: 1.40k]
  ------------------
 3439|       |        // We don't currently support UDP over proxy.
 3440|      0|        LOGGER_INFO(m->log, "UDP enabled and proxy set: disabling UDP");
  ------------------
  |  |   78|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3441|      0|        options->udp_disabled = true;
 3442|      0|    }
 3443|       |
 3444|  1.40k|    Networking_Core *net;
 3445|  1.40k|    if (options->udp_disabled) {
  ------------------
  |  Branch (3445:9): [True: 0, False: 1.40k]
  ------------------
 3446|      0|        net = new_networking_no_udp(m->log, m->mem, m->ns);
 3447|  1.40k|    } else {
 3448|  1.40k|        IP ip;
 3449|  1.40k|        ip_init(&ip, options->ipv6enabled);
 3450|  1.40k|        net = new_networking_ex(m->log, m->mem, m->ns, &ip, options->port_range[0], options->port_range[1], &net_err);
 3451|  1.40k|    }
 3452|       |
 3453|  1.40k|    if (net == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3453:9): [True: 0, False: 1.40k]
  ------------------
 3454|      0|        friendreq_kill(m->fr);
 3455|       |
 3456|      0|        if (error != nullptr && net_err == 1) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3456:13): [True: 0, False: 0]
  |  Branch (3456:33): [True: 0, False: 0]
  ------------------
 3457|      0|            LOGGER_WARNING(m->log, "network initialisation failed (no ports available)");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3458|      0|            *error = MESSENGER_ERROR_PORT;
 3459|      0|        }
 3460|       |
 3461|      0|        mem_delete(mem, m);
 3462|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3463|      0|    }
 3464|  1.40k|    m->net = net;
 3465|       |
 3466|  1.40k|    DHT *dht = new_dht(m->log, m->mem, m->rng, m->ns, m->mono_time, m->net, options->hole_punching_enabled, options->local_discovery_enabled);
 3467|  1.40k|    if (dht == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3467:9): [True: 0, False: 1.40k]
  ------------------
 3468|      0|        kill_networking(m->net);
 3469|      0|        friendreq_kill(m->fr);
 3470|      0|        mem_delete(mem, m);
 3471|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3472|      0|    }
 3473|  1.40k|    m->dht = dht;
 3474|       |
 3475|  1.40k|    Net_Profile *tcp_np = netprof_new(m->log, mem);
 3476|  1.40k|    if (tcp_np == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3476:9): [True: 0, False: 1.40k]
  ------------------
 3477|      0|        LOGGER_WARNING(m->log, "TCP netprof initialisation failed");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3478|      0|        kill_dht(m->dht);
 3479|      0|        kill_networking(m->net);
 3480|      0|        friendreq_kill(m->fr);
 3481|      0|        mem_delete(mem, m);
 3482|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3483|      0|    }
 3484|  1.40k|    m->tcp_np = tcp_np;
 3485|       |
 3486|  1.40k|    Net_Crypto *net_crypto = new_net_crypto(m->log, m->mem, m->rng, m->ns, m->mono_time, m->net, m->dht, &m_dht_funcs, &options->proxy_info, m->tcp_np);
 3487|       |
 3488|  1.40k|    if (net_crypto == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3488:9): [True: 0, False: 1.40k]
  ------------------
 3489|      0|        LOGGER_WARNING(m->log, "net_crypto initialisation failed");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3490|       |
 3491|      0|        netprof_kill(mem, m->tcp_np);
 3492|      0|        kill_dht(m->dht);
 3493|      0|        kill_networking(m->net);
 3494|      0|        friendreq_kill(m->fr);
 3495|      0|        mem_delete(mem, m);
 3496|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3497|      0|    }
 3498|  1.40k|    m->net_crypto = net_crypto;
 3499|       |
 3500|  1.40k|    GC_Announces_List *group_announce = new_gca_list(m->mem);
 3501|  1.40k|    if (group_announce == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3501:9): [True: 0, False: 1.40k]
  ------------------
 3502|      0|        LOGGER_WARNING(m->log, "DHT group chats initialisation failed");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3503|       |
 3504|      0|        kill_net_crypto(m->net_crypto);
 3505|      0|        netprof_kill(mem, m->tcp_np);
 3506|      0|        kill_dht(m->dht);
 3507|      0|        kill_networking(m->net);
 3508|      0|        friendreq_kill(m->fr);
 3509|      0|        mem_delete(mem, m);
 3510|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3511|      0|    }
 3512|  1.40k|    m->group_announce = group_announce;
 3513|       |
 3514|  1.40k|    if (options->dht_announcements_enabled) {
  ------------------
  |  Branch (3514:9): [True: 1.40k, False: 0]
  ------------------
 3515|  1.40k|        m->forwarding = new_forwarding(m->log, m->mem, m->rng, m->mono_time, m->dht, m->net);
 3516|  1.40k|        if (m->forwarding != nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3516:13): [True: 1.40k, False: 0]
  ------------------
 3517|  1.40k|            m->announce = new_announcements(m->log, m->mem, m->rng, m->mono_time, m->forwarding, m->dht, m->net);
 3518|  1.40k|        }
 3519|  1.40k|    }
 3520|       |
 3521|  1.40k|    Onion *onion = new_onion(m->log, m->mem, m->mono_time, m->rng, m->dht, m->net);
 3522|  1.40k|    Onion_Announce *onion_a = new_onion_announce(m->log, m->mem, m->rng, m->mono_time, m->dht, m->net);
 3523|  1.40k|    Onion_Client *onion_c = new_onion_client(m->log, m->mem, m->rng, m->mono_time, m->net_crypto, m->dht, m->net);
 3524|  1.40k|    Friend_Connections *fr_c = nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 3525|       |
 3526|  1.40k|    if (onion_c != nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3526:9): [True: 1.40k, False: 0]
  ------------------
 3527|  1.40k|        fr_c = new_friend_connections(m->log, m->mem, m->mono_time, m->ns, onion_c, m->dht, m->net_crypto, m->net, options->local_discovery_enabled);
 3528|  1.40k|    }
 3529|       |
 3530|  1.40k|    if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3530:10): [True: 1.40k, False: 0]
  |  Branch (3530:49): [True: 0, False: 1.40k]
  |  Branch (3530:77): [True: 0, False: 1.40k]
  ------------------
 3531|  1.40k|            onion == nullptr || onion_a == nullptr || onion_c == nullptr || fr_c == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                          onion == nullptr || onion_a == nullptr || onion_c == nullptr || fr_c == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                          onion == nullptr || onion_a == nullptr || onion_c == nullptr || fr_c == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                          onion == nullptr || onion_a == nullptr || onion_c == nullptr || fr_c == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3531:13): [True: 0, False: 1.40k]
  |  Branch (3531:33): [True: 0, False: 1.40k]
  |  Branch (3531:55): [True: 0, False: 1.40k]
  |  Branch (3531:77): [True: 0, False: 1.40k]
  ------------------
 3532|      0|        LOGGER_WARNING(m->log, "onion initialisation failed");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3533|       |
 3534|      0|        kill_onion(onion);
 3535|      0|        kill_onion_announce(onion_a);
 3536|      0|        kill_onion_client(onion_c);
 3537|      0|        kill_gca(m->group_announce);
 3538|      0|        kill_friend_connections(fr_c);
 3539|      0|        kill_announcements(m->announce);
 3540|      0|        kill_forwarding(m->forwarding);
 3541|      0|        kill_net_crypto(m->net_crypto);
 3542|      0|        netprof_kill(mem, m->tcp_np);
 3543|      0|        kill_dht(m->dht);
 3544|      0|        kill_networking(m->net);
 3545|      0|        friendreq_kill(m->fr);
 3546|      0|        mem_delete(mem, m);
 3547|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3548|      0|    }
 3549|  1.40k|    m->onion = onion;
 3550|  1.40k|    m->onion_a = onion_a;
 3551|  1.40k|    m->onion_c = onion_c;
 3552|  1.40k|    m->fr_c = fr_c;
 3553|       |
 3554|  1.40k|    gca_onion_init(m->group_announce, m->onion_a);
 3555|       |
 3556|  1.40k|    GC_Session *group_handler = new_dht_groupchats(m);
 3557|  1.40k|    if (group_handler == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3557:9): [True: 0, False: 1.40k]
  ------------------
 3558|      0|        LOGGER_WARNING(m->log, "conferences initialisation failed");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3559|       |
 3560|      0|        kill_onion(m->onion);
 3561|      0|        kill_onion_announce(m->onion_a);
 3562|      0|        kill_onion_client(m->onion_c);
 3563|      0|        kill_gca(m->group_announce);
 3564|      0|        kill_friend_connections(m->fr_c);
 3565|      0|        kill_announcements(m->announce);
 3566|      0|        kill_forwarding(m->forwarding);
 3567|      0|        kill_net_crypto(m->net_crypto);
 3568|      0|        netprof_kill(mem, m->tcp_np);
 3569|      0|        kill_dht(m->dht);
 3570|      0|        kill_networking(m->net);
 3571|      0|        friendreq_kill(m->fr);
 3572|      0|        mem_delete(mem, m);
 3573|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3574|      0|    }
 3575|  1.40k|    m->group_handler = group_handler;
 3576|       |
 3577|  1.40k|    if (options->tcp_server_port != 0) {
  ------------------
  |  Branch (3577:9): [True: 0, False: 1.40k]
  ------------------
 3578|      0|        m->tcp_server = new_tcp_server(m->log, m->mem, m->rng, m->ns, options->ipv6enabled, 1,
 3579|      0|                                       &options->tcp_server_port, dht_get_self_secret_key(m->dht),
 3580|      0|                                       m->onion, m->forwarding);
 3581|       |
 3582|      0|        if (m->tcp_server == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3582:13): [True: 0, False: 0]
  ------------------
 3583|      0|            LOGGER_WARNING(m->log, "TCP server initialisation failed");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3584|       |
 3585|      0|            kill_onion(m->onion);
 3586|      0|            kill_onion_announce(m->onion_a);
 3587|      0|            kill_dht_groupchats(m->group_handler);
 3588|      0|            kill_friend_connections(m->fr_c);
 3589|      0|            kill_onion_client(m->onion_c);
 3590|      0|            kill_gca(m->group_announce);
 3591|      0|            kill_announcements(m->announce);
 3592|      0|            kill_forwarding(m->forwarding);
 3593|      0|            kill_net_crypto(m->net_crypto);
 3594|      0|            netprof_kill(mem, m->tcp_np);
 3595|      0|            kill_dht(m->dht);
 3596|      0|            kill_networking(m->net);
 3597|      0|            friendreq_kill(m->fr);
 3598|      0|            mem_delete(mem, m);
 3599|       |
 3600|      0|            if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3600:17): [True: 0, False: 0]
  ------------------
 3601|      0|                *error = MESSENGER_ERROR_TCP_SERVER;
 3602|      0|            }
 3603|       |
 3604|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3605|      0|        }
 3606|      0|    }
 3607|       |
 3608|  1.40k|    m->options = *options;
 3609|  1.40k|    friendreq_init(m->fr, m->fr_c);
 3610|  1.40k|    set_nospam(m->fr, random_u32(m->rng));
 3611|  1.40k|    set_filter_function(m->fr, &friend_already_added, m);
 3612|       |
 3613|  1.40k|    m->lastdump = 0;
 3614|  1.40k|    m->is_receiving_file = 0;
 3615|       |
 3616|  1.40k|    m_register_default_plugins(m);
 3617|  1.40k|    callback_friendrequest(m->fr, m_handle_friend_request, m);
 3618|       |
 3619|  1.40k|    if (error != nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3619:9): [True: 1.40k, False: 0]
  ------------------
 3620|  1.40k|        *error = MESSENGER_ERROR_NONE;
 3621|  1.40k|    }
 3622|       |
 3623|  1.40k|    return m;
 3624|  1.40k|}
kill_messenger:
 3631|  1.40k|{
 3632|  1.40k|    if (m == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3632:9): [True: 0, False: 1.40k]
  ------------------
 3633|      0|        return;
 3634|      0|    }
 3635|       |
 3636|  1.40k|    if (m->tcp_server != nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3636:9): [True: 0, False: 1.40k]
  ------------------
 3637|      0|        kill_tcp_server(m->tcp_server);
 3638|      0|    }
 3639|       |
 3640|  1.40k|    kill_onion(m->onion);
 3641|  1.40k|    kill_onion_announce(m->onion_a);
 3642|  1.40k|    kill_dht_groupchats(m->group_handler);
 3643|  1.40k|    kill_friend_connections(m->fr_c);
 3644|  1.40k|    kill_onion_client(m->onion_c);
 3645|  1.40k|    kill_gca(m->group_announce);
 3646|  1.40k|    kill_announcements(m->announce);
 3647|  1.40k|    kill_forwarding(m->forwarding);
 3648|  1.40k|    kill_net_crypto(m->net_crypto);
 3649|  1.40k|    netprof_kill(m->mem, m->tcp_np);
 3650|  1.40k|    kill_dht(m->dht);
 3651|  1.40k|    kill_networking(m->net);
 3652|       |
 3653|  1.74k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (3653:26): [True: 343, False: 1.40k]
  ------------------
 3654|    343|        clear_receipts(m, i);
 3655|    343|    }
 3656|       |
 3657|  1.40k|    mem_delete(m->mem, m->friendlist);
 3658|  1.40k|    friendreq_kill(m->fr);
 3659|       |
 3660|  1.40k|    mem_delete(m->mem, m->options.state_plugins);
 3661|  1.40k|    mem_delete(m->mem, m);
 3662|  1.40k|}
Messenger.c:init_new_friend:
  182|    343|{
  183|    343|    if (m->numfriends == UINT32_MAX) {
  ------------------
  |  Branch (183:9): [True: 0, False: 343]
  ------------------
  184|      0|        LOGGER_ERROR(m->log, "Friend list full: we have more than 4 billion friends");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  185|       |        /* This is technically incorrect, but close enough. */
  186|      0|        return FAERR_NOMEM;
  187|      0|    }
  188|       |
  189|       |    /* Resize the friend list if necessary. */
  190|    343|    if (realloc_friendlist(m, m->numfriends + 1) != 0) {
  ------------------
  |  Branch (190:9): [True: 0, False: 343]
  ------------------
  191|      0|        return FAERR_NOMEM;
  192|      0|    }
  193|       |
  194|    343|    m->friendlist[m->numfriends] = empty_friend;
  195|       |
  196|    343|    const int friendcon_id = new_friend_connection(m->fr_c, real_pk);
  197|       |
  198|    343|    if (friendcon_id == -1) {
  ------------------
  |  Branch (198:9): [True: 0, False: 343]
  ------------------
  199|      0|        return FAERR_NOMEM;
  200|      0|    }
  201|       |
  202|    800|    for (uint32_t i = 0; i <= m->numfriends; ++i) {
  ------------------
  |  Branch (202:26): [True: 800, False: 0]
  ------------------
  203|    800|        if (m->friendlist[i].status == NOFRIEND) {
  ------------------
  |  Branch (203:13): [True: 343, False: 457]
  ------------------
  204|    343|            m->friendlist[i].status = status;
  205|    343|            m->friendlist[i].friendcon_id = friendcon_id;
  206|    343|            m->friendlist[i].friendrequest_lastsent = 0;
  207|    343|            pk_copy(m->friendlist[i].real_pk, real_pk);
  208|    343|            m->friendlist[i].statusmessage_length = 0;
  209|    343|            m->friendlist[i].userstatus = USERSTATUS_NONE;
  210|    343|            m->friendlist[i].is_typing = false;
  211|    343|            m->friendlist[i].message_id = 0;
  212|    343|            friend_connection_callbacks(m->fr_c, friendcon_id, MESSENGER_CALLBACK_INDEX, &m_handle_status, &m_handle_packet,
  ------------------
  |  |   26|    343|#define MESSENGER_CALLBACK_INDEX 0
  ------------------
  213|    343|                                        &m_handle_lossy_packet, m, i);
  214|       |
  215|    343|            if (m->numfriends == i) {
  ------------------
  |  Branch (215:17): [True: 343, False: 0]
  ------------------
  216|    343|                ++m->numfriends;
  217|    343|            }
  218|       |
  219|    343|            if (friend_con_connected(m->fr_c, friendcon_id) == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (219:17): [True: 0, False: 343]
  ------------------
  220|      0|                send_online_packet(m, friendcon_id);
  221|      0|            }
  222|       |
  223|    343|            return i;
  224|    343|        }
  225|    800|    }
  226|       |
  227|      0|    return FAERR_NOMEM;
  228|    343|}
Messenger.c:set_friend_statusmessage:
  954|    300|{
  955|    300|    if (!m_friend_exists(m, friendnumber)) {
  ------------------
  |  Branch (955:9): [True: 0, False: 300]
  ------------------
  956|      0|        return -1;
  957|      0|    }
  958|       |
  959|    300|    if (length > MAX_STATUSMESSAGE_LENGTH) {
  ------------------
  |  |   41|    300|#define MAX_STATUSMESSAGE_LENGTH 1007
  ------------------
  |  Branch (959:9): [True: 190, False: 110]
  ------------------
  960|    190|        return -1;
  961|    190|    }
  962|       |
  963|    110|    if (length > 0) {
  ------------------
  |  Branch (963:9): [True: 56, False: 54]
  ------------------
  964|     56|        memcpy(m->friendlist[friendnumber].statusmessage, status, length);
  965|     56|    }
  966|       |
  967|    110|    m->friendlist[friendnumber].statusmessage_length = length;
  968|    110|    return 0;
  969|    300|}
Messenger.c:set_friend_userstatus:
  972|    300|{
  973|    300|    userstatus_from_int(status, &m->friendlist[friendnumber].userstatus);
  974|    300|}
Messenger.c:m_add_friend_contact_norequest:
  231|    311|{
  232|    311|    if (getfriend_id(m, real_pk) != -1) {
  ------------------
  |  Branch (232:9): [True: 11, False: 300]
  ------------------
  233|     11|        return FAERR_ALREADYSENT;
  234|     11|    }
  235|       |
  236|    300|    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (236:9): [True: 0, False: 300]
  ------------------
  237|      0|        return FAERR_OWNKEY;
  238|      0|    }
  239|       |
  240|    300|    return init_new_friend(m, real_pk, FRIEND_CONFIRMED);
  241|    300|}
Messenger.c:clear_receipts:
  339|    343|{
  340|    343|    if (!m_friend_exists(m, friendnumber)) {
  ------------------
  |  Branch (340:9): [True: 0, False: 343]
  ------------------
  341|      0|        return -1;
  342|      0|    }
  343|       |
  344|    343|    struct Receipts *receipts = m->friendlist[friendnumber].receipts_start;
  345|       |
  346|    343|    while (receipts != nullptr) {
  ------------------
  |  |   63|    343|#define nullptr NULL
  ------------------
  |  Branch (346:12): [True: 0, False: 343]
  ------------------
  347|      0|        struct Receipts *temp_r = receipts->next;
  348|      0|        mem_delete(m->mem, receipts);
  349|      0|        receipts = temp_r;
  350|      0|    }
  351|       |
  352|    343|    m->friendlist[friendnumber].receipts_start = nullptr;
  ------------------
  |  |   63|    343|#define nullptr NULL
  ------------------
  353|       |    m->friendlist[friendnumber].receipts_end = nullptr;
  ------------------
  |  |   63|    343|#define nullptr NULL
  ------------------
  354|    343|    return 0;
  355|    343|}
Messenger.c:realloc_friendlist:
   89|    343|{
   90|    343|    if (num == 0) {
  ------------------
  |  Branch (90:9): [True: 0, False: 343]
  ------------------
   91|      0|        mem_delete(m->mem, m->friendlist);
   92|      0|        m->friendlist = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   93|      0|        return 0;
   94|      0|    }
   95|       |
   96|    343|    Friend *newfriendlist = (Friend *)mem_vrealloc(m->mem, m->friendlist, num, sizeof(Friend));
   97|       |
   98|    343|    if (newfriendlist == nullptr) {
  ------------------
  |  |   63|    343|#define nullptr NULL
  ------------------
  |  Branch (98:9): [True: 0, False: 343]
  ------------------
   99|      0|        return -1;
  100|      0|    }
  101|       |
  102|    343|    m->friendlist = newfriendlist;
  103|    343|    return 0;
  104|    343|}
Messenger.c:userstatus_from_int:
  783|    460|{
  784|    460|    switch (status) {
  785|    188|        case USERSTATUS_NONE: {
  ------------------
  |  Branch (785:9): [True: 188, False: 272]
  ------------------
  786|    188|            *out_enum = USERSTATUS_NONE;
  787|    188|            return true;
  788|      0|        }
  789|       |
  790|      6|        case USERSTATUS_AWAY: {
  ------------------
  |  Branch (790:9): [True: 6, False: 454]
  ------------------
  791|      6|            *out_enum = USERSTATUS_AWAY;
  792|      6|            return true;
  793|      0|        }
  794|       |
  795|     81|        case USERSTATUS_BUSY: {
  ------------------
  |  Branch (795:9): [True: 81, False: 379]
  ------------------
  796|     81|            *out_enum = USERSTATUS_BUSY;
  797|     81|            return true;
  798|      0|        }
  799|       |
  800|      0|        case USERSTATUS_INVALID: {
  ------------------
  |  Branch (800:9): [True: 0, False: 460]
  ------------------
  801|      0|            *out_enum = USERSTATUS_INVALID;
  802|      0|            return true;
  803|      0|        }
  804|       |
  805|    185|        default: {
  ------------------
  |  Branch (805:9): [True: 185, False: 275]
  ------------------
  806|    185|            *out_enum = USERSTATUS_INVALID;
  807|       |            return false;
  808|      0|        }
  809|    460|    }
  810|    460|}
Messenger.c:m_state_plugins_size:
 2817|  1.96k|{
 2818|  1.96k|    const uint32_t size32 = sizeof(uint32_t);
 2819|  1.96k|    const uint32_t sizesubhead = size32 * 2;
 2820|       |
 2821|  1.96k|    uint32_t size = 0;
 2822|       |
 2823|  1.96k|    for (const Messenger_State_Plugin *plugin = m->options.state_plugins;
 2824|  19.6k|            plugin != m->options.state_plugins + m->options.state_plugins_length;
  ------------------
  |  Branch (2824:13): [True: 17.6k, False: 1.96k]
  ------------------
 2825|  17.6k|            ++plugin) {
 2826|  17.6k|        size += sizesubhead + plugin->size(m);
 2827|  17.6k|    }
 2828|       |
 2829|  1.96k|    return size;
 2830|  1.96k|}
Messenger.c:nc_dht_get_self_secret_key_wrapper:
   63|  1.40k|{
   64|  1.40k|    const DHT *dht = (const DHT *)obj;
   65|  1.40k|    return dht_get_self_secret_key(dht);
   66|  1.40k|}
Messenger.c:m_register_default_plugins:
 3307|  1.40k|{
 3308|  1.40k|    m_register_state_plugin(m, STATE_TYPE_NOSPAMKEYS, nospam_keys_size, load_nospam_keys, save_nospam_keys);
 3309|  1.40k|    m_register_state_plugin(m, STATE_TYPE_DHT, m_dht_size, m_dht_load, save_dht);
 3310|  1.40k|    m_register_state_plugin(m, STATE_TYPE_FRIENDS, saved_friendslist_size, friends_list_load, friends_list_save);
 3311|  1.40k|    m_register_state_plugin(m, STATE_TYPE_NAME, name_size, load_name, save_name);
 3312|  1.40k|    m_register_state_plugin(m, STATE_TYPE_STATUSMESSAGE, status_message_size, load_status_message,
 3313|  1.40k|                            save_status_message);
 3314|  1.40k|    m_register_state_plugin(m, STATE_TYPE_STATUS, status_size, load_status, save_status);
 3315|  1.40k|    if (m->options.groups_persistence_enabled) {
  ------------------
  |  Branch (3315:9): [True: 1.40k, False: 0]
  ------------------
 3316|  1.40k|        m_register_state_plugin(m, STATE_TYPE_GROUPS, saved_groups_size, groups_load, groups_save);
 3317|  1.40k|    }
 3318|  1.40k|    m_register_state_plugin(m, STATE_TYPE_TCP_RELAY, tcp_relay_size, load_tcp_relays, save_tcp_relays);
 3319|  1.40k|    m_register_state_plugin(m, STATE_TYPE_PATH_NODE, path_node_size, load_path_nodes, save_path_nodes);
 3320|  1.40k|}
Messenger.c:nospam_keys_size:
 2895|  3.50k|{
 2896|  3.50k|    return sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SECRET_KEY_SIZE;
  ------------------
  |  |   44|  3.50k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  return sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SECRET_KEY_SIZE;
  ------------------
  |  |   49|  3.50k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 2897|  3.50k|}
Messenger.c:load_nospam_keys:
 2900|    559|{
 2901|    559|    if (length != m_plugin_size(m, STATE_TYPE_NOSPAMKEYS)) {
  ------------------
  |  Branch (2901:9): [True: 1, False: 558]
  ------------------
 2902|      1|        return STATE_LOAD_STATUS_ERROR;
 2903|      1|    }
 2904|       |
 2905|    558|    uint32_t nospam;
 2906|    558|    lendian_bytes_to_host32(&nospam, data);
 2907|    558|    set_nospam(m->fr, nospam);
 2908|    558|    load_secret_key(m->net_crypto, data + sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    558|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2909|       |
 2910|    558|    if (!pk_equal(data + sizeof(uint32_t), nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (2910:9): [True: 5, False: 553]
  ------------------
 2911|      5|        LOGGER_ERROR(m->log, "public key stored in savedata does not match its secret key");
  ------------------
  |  |   80|      5|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      5|    do {                                                                         \
  |  |  |  |   70|      5|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     10|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 5, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      5|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      5|        }                                                                        \
  |  |  |  |   73|      5|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 5]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2912|      5|        return STATE_LOAD_STATUS_ERROR;
 2913|      5|    }
 2914|       |
 2915|    553|    return STATE_LOAD_STATUS_CONTINUE;
 2916|    558|}
Messenger.c:m_plugin_size:
 2862|  6.58k|{
 2863|  22.1k|    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
  ------------------
  |  Branch (2863:25): [True: 22.1k, False: 0]
  ------------------
 2864|  22.1k|        const Messenger_State_Plugin plugin = m->options.state_plugins[i];
 2865|       |
 2866|  22.1k|        if (plugin.type == type) {
  ------------------
  |  Branch (2866:13): [True: 6.58k, False: 15.5k]
  ------------------
 2867|  6.58k|            return plugin.size(m);
 2868|  6.58k|        }
 2869|  22.1k|    }
 2870|       |
 2871|      0|    LOGGER_ERROR(m->log, "Unknown type encountered: %u", type);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2872|       |
 2873|       |    return UINT32_MAX;
 2874|  6.58k|}
Messenger.c:save_nospam_keys:
 2919|    981|{
 2920|    981|    const uint32_t len = m_plugin_size(m, STATE_TYPE_NOSPAMKEYS);
 2921|    981|    static_assert(sizeof(get_nospam(m->fr)) == sizeof(uint32_t), "nospam doesn't fit in a 32 bit int");
 2922|    981|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_NOSPAMKEYS);
  ------------------
  |  |   31|    981|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 2923|    981|    const uint32_t nospam = get_nospam(m->fr);
 2924|    981|    host_to_lendian_bytes32(data, nospam);
 2925|    981|    save_keys(m->net_crypto, data + sizeof(uint32_t));
 2926|    981|    data += len;
 2927|    981|    return data;
 2928|    981|}
Messenger.c:m_dht_size:
 2932|  2.94k|{
 2933|  2.94k|    return dht_size(m->dht);
 2934|  2.94k|}
Messenger.c:m_dht_load:
 2946|    707|{
 2947|    707|    dht_load(m->dht, data, length); // TODO(endoffile78): Should we throw an error if dht_load fails?
 2948|    707|    return STATE_LOAD_STATUS_CONTINUE;
 2949|    707|}
Messenger.c:save_dht:
 2937|    981|{
 2938|    981|    const uint32_t len = m_plugin_size(m, STATE_TYPE_DHT);
 2939|    981|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_DHT);
  ------------------
  |  |   31|    981|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 2940|    981|    dht_save(m->dht, data);
 2941|    981|    data += len;
 2942|    981|    return data;
 2943|    981|}
Messenger.c:saved_friendslist_size:
 2953|  2.94k|{
 2954|  2.94k|    return count_friendlist(m) * friend_size();
 2955|  2.94k|}
Messenger.c:friend_size:
 2709|  4.51k|{
 2710|  4.51k|    uint32_t data = 0;
 2711|  4.51k|    const struct Saved_Friend *const temp = nullptr;
  ------------------
  |  |   63|  4.51k|#define nullptr NULL
  ------------------
 2712|       |
 2713|  4.51k|#define VALUE_MEMBER(data, name) \
 2714|  4.51k|    do {                         \
 2715|  4.51k|        data += sizeof(name);    \
 2716|  4.51k|    } while (0)
 2717|  4.51k|#define ARRAY_MEMBER(data, name) \
 2718|  4.51k|    do {                         \
 2719|  4.51k|        data += sizeof(name);    \
 2720|  4.51k|    } while (0)
 2721|       |
 2722|       |    // Exactly the same in friend_load, friend_save, and friend_size
 2723|  4.51k|    VALUE_MEMBER(data, temp->status);
  ------------------
  |  | 2714|  4.51k|    do {                         \
  |  | 2715|  4.51k|        data += sizeof(name);    \
  |  | 2716|  4.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2716:14): [Folded, False: 4.51k]
  |  |  ------------------
  ------------------
 2724|  4.51k|    ARRAY_MEMBER(data, temp->real_pk);
  ------------------
  |  | 2718|  4.51k|    do {                         \
  |  | 2719|  4.51k|        data += sizeof(name);    \
  |  | 2720|  4.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2720:14): [Folded, False: 4.51k]
  |  |  ------------------
  ------------------
 2725|  4.51k|    ARRAY_MEMBER(data, temp->info);
  ------------------
  |  | 2718|  4.51k|    do {                         \
  |  | 2719|  4.51k|        data += sizeof(name);    \
  |  | 2720|  4.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2720:14): [Folded, False: 4.51k]
  |  |  ------------------
  ------------------
 2726|  4.51k|    ++data; // padding
 2727|  4.51k|    VALUE_MEMBER(data, temp->info_size);
  ------------------
  |  | 2714|  4.51k|    do {                         \
  |  | 2715|  4.51k|        data += sizeof(name);    \
  |  | 2716|  4.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2716:14): [Folded, False: 4.51k]
  |  |  ------------------
  ------------------
 2728|  4.51k|    ARRAY_MEMBER(data, temp->name);
  ------------------
  |  | 2718|  4.51k|    do {                         \
  |  | 2719|  4.51k|        data += sizeof(name);    \
  |  | 2720|  4.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2720:14): [Folded, False: 4.51k]
  |  |  ------------------
  ------------------
 2729|  4.51k|    VALUE_MEMBER(data, temp->name_length);
  ------------------
  |  | 2714|  4.51k|    do {                         \
  |  | 2715|  4.51k|        data += sizeof(name);    \
  |  | 2716|  4.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2716:14): [Folded, False: 4.51k]
  |  |  ------------------
  ------------------
 2730|  4.51k|    ARRAY_MEMBER(data, temp->statusmessage);
  ------------------
  |  | 2718|  4.51k|    do {                         \
  |  | 2719|  4.51k|        data += sizeof(name);    \
  |  | 2720|  4.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2720:14): [Folded, False: 4.51k]
  |  |  ------------------
  ------------------
 2731|  4.51k|    ++data; // padding
 2732|  4.51k|    VALUE_MEMBER(data, temp->statusmessage_length);
  ------------------
  |  | 2714|  4.51k|    do {                         \
  |  | 2715|  4.51k|        data += sizeof(name);    \
  |  | 2716|  4.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2716:14): [Folded, False: 4.51k]
  |  |  ------------------
  ------------------
 2733|  4.51k|    VALUE_MEMBER(data, temp->userstatus);
  ------------------
  |  | 2714|  4.51k|    do {                         \
  |  | 2715|  4.51k|        data += sizeof(name);    \
  |  | 2716|  4.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2716:14): [Folded, False: 4.51k]
  |  |  ------------------
  ------------------
 2734|  4.51k|    data += 3; // padding
 2735|  4.51k|    VALUE_MEMBER(data, temp->friendrequest_nospam);
  ------------------
  |  | 2714|  4.51k|    do {                         \
  |  | 2715|  4.51k|        data += sizeof(name);    \
  |  | 2716|  4.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2716:14): [Folded, False: 4.51k]
  |  |  ------------------
  ------------------
 2736|  4.51k|    ARRAY_MEMBER(data, temp->last_seen_time);
  ------------------
  |  | 2718|  4.51k|    do {                         \
  |  | 2719|  4.51k|        data += sizeof(name);    \
  |  | 2720|  4.51k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2720:14): [Folded, False: 4.51k]
  |  |  ------------------
  ------------------
 2737|       |
 2738|  4.51k|#undef VALUE_MEMBER
 2739|  4.51k|#undef ARRAY_MEMBER
 2740|       |
 2741|  4.51k|    return data;
 2742|  4.51k|}
Messenger.c:friends_list_load:
 3008|    326|{
 3009|    326|    const uint32_t l_friend_size = friend_size();
 3010|       |
 3011|    326|    if (length % l_friend_size != 0) {
  ------------------
  |  Branch (3011:9): [True: 1, False: 325]
  ------------------
 3012|      1|        return STATE_LOAD_STATUS_ERROR; // TODO(endoffile78): error or continue?
 3013|      1|    }
 3014|       |
 3015|    325|    const uint32_t num = length / l_friend_size;
 3016|    325|    const uint8_t *cur_data = data;
 3017|       |
 3018|    885|    for (uint32_t i = 0; i < num; ++i) {
  ------------------
  |  Branch (3018:26): [True: 560, False: 325]
  ------------------
 3019|    560|        struct Saved_Friend temp = { 0 };
 3020|    560|        const uint8_t *next_data = friend_load(&temp, cur_data);
 3021|    560|        assert(next_data - cur_data == l_friend_size);
  ------------------
  |  Branch (3021:9): [True: 560, False: 0]
  ------------------
 3022|       |
 3023|    560|        cur_data = next_data;
 3024|       |
 3025|    560|        if (temp.status >= 3) {
  ------------------
  |  Branch (3025:13): [True: 352, False: 208]
  ------------------
 3026|    352|            const int fnum = m_addfriend_norequest(m, temp.real_pk);
 3027|       |
 3028|    352|            if (fnum < 0) {
  ------------------
  |  Branch (3028:17): [True: 52, False: 300]
  ------------------
 3029|     52|                continue;
 3030|     52|            }
 3031|       |
 3032|    300|            setfriendname(m, fnum, temp.name, net_ntohs(temp.name_length));
 3033|    300|            set_friend_statusmessage(m, fnum, temp.statusmessage, net_ntohs(temp.statusmessage_length));
 3034|    300|            set_friend_userstatus(m, fnum, temp.userstatus);
 3035|    300|            net_unpack_u64(temp.last_seen_time, &m->friendlist[fnum].last_seen_time);
 3036|    300|        } else if (temp.status != 0) {
  ------------------
  |  Branch (3036:20): [True: 129, False: 79]
  ------------------
 3037|       |            /* TODO(irungentoo): This is not a good way to do this. */
 3038|    129|            uint8_t address[FRIEND_ADDRESS_SIZE];
 3039|    129|            pk_copy(address, temp.real_pk);
 3040|    129|            memcpy(address + CRYPTO_PUBLIC_KEY_SIZE, &temp.friendrequest_nospam, sizeof(uint32_t));
  ------------------
  |  |   44|    129|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3041|    129|            uint16_t checksum = data_checksum(address, FRIEND_ADDRESS_SIZE - sizeof(checksum));
  ------------------
  |  |   47|    129|#define FRIEND_ADDRESS_SIZE (CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t) + sizeof(uint16_t))
  |  |  ------------------
  |  |  |  |   44|    129|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 3042|    129|            memcpy(address + CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t), &checksum, sizeof(checksum));
  ------------------
  |  |   44|    129|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3043|    129|            m_addfriend(m, address, temp.info, net_ntohs(temp.info_size));
 3044|    129|        }
 3045|    560|    }
 3046|       |
 3047|    325|    return STATE_LOAD_STATUS_CONTINUE;
 3048|    325|}
Messenger.c:friend_load:
 2781|    560|{
 2782|    560|#define VALUE_MEMBER(data, name)           \
 2783|    560|    do {                                   \
 2784|    560|        memcpy(&name, data, sizeof(name)); \
 2785|    560|        data += sizeof(name);              \
 2786|    560|    } while (0)
 2787|       |
 2788|    560|#define ARRAY_MEMBER(data, name)          \
 2789|    560|    do {                                  \
 2790|    560|        memcpy(name, data, sizeof(name)); \
 2791|    560|        data += sizeof(name);             \
 2792|    560|    } while (0)
 2793|       |
 2794|       |    // Exactly the same in friend_load, friend_save, and friend_size
 2795|    560|    VALUE_MEMBER(data, temp->status);
  ------------------
  |  | 2783|    560|    do {                                   \
  |  | 2784|    560|        memcpy(&name, data, sizeof(name)); \
  |  | 2785|    560|        data += sizeof(name);              \
  |  | 2786|    560|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2786:14): [Folded, False: 560]
  |  |  ------------------
  ------------------
 2796|    560|    ARRAY_MEMBER(data, temp->real_pk);
  ------------------
  |  | 2789|    560|    do {                                  \
  |  | 2790|    560|        memcpy(name, data, sizeof(name)); \
  |  | 2791|    560|        data += sizeof(name);             \
  |  | 2792|    560|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2792:14): [Folded, False: 560]
  |  |  ------------------
  ------------------
 2797|    560|    ARRAY_MEMBER(data, temp->info);
  ------------------
  |  | 2789|    560|    do {                                  \
  |  | 2790|    560|        memcpy(name, data, sizeof(name)); \
  |  | 2791|    560|        data += sizeof(name);             \
  |  | 2792|    560|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2792:14): [Folded, False: 560]
  |  |  ------------------
  ------------------
 2798|    560|    ++data; // padding
 2799|    560|    VALUE_MEMBER(data, temp->info_size);
  ------------------
  |  | 2783|    560|    do {                                   \
  |  | 2784|    560|        memcpy(&name, data, sizeof(name)); \
  |  | 2785|    560|        data += sizeof(name);              \
  |  | 2786|    560|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2786:14): [Folded, False: 560]
  |  |  ------------------
  ------------------
 2800|    560|    ARRAY_MEMBER(data, temp->name);
  ------------------
  |  | 2789|    560|    do {                                  \
  |  | 2790|    560|        memcpy(name, data, sizeof(name)); \
  |  | 2791|    560|        data += sizeof(name);             \
  |  | 2792|    560|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2792:14): [Folded, False: 560]
  |  |  ------------------
  ------------------
 2801|    560|    VALUE_MEMBER(data, temp->name_length);
  ------------------
  |  | 2783|    560|    do {                                   \
  |  | 2784|    560|        memcpy(&name, data, sizeof(name)); \
  |  | 2785|    560|        data += sizeof(name);              \
  |  | 2786|    560|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2786:14): [Folded, False: 560]
  |  |  ------------------
  ------------------
 2802|    560|    ARRAY_MEMBER(data, temp->statusmessage);
  ------------------
  |  | 2789|    560|    do {                                  \
  |  | 2790|    560|        memcpy(name, data, sizeof(name)); \
  |  | 2791|    560|        data += sizeof(name);             \
  |  | 2792|    560|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2792:14): [Folded, False: 560]
  |  |  ------------------
  ------------------
 2803|    560|    ++data; // padding
 2804|    560|    VALUE_MEMBER(data, temp->statusmessage_length);
  ------------------
  |  | 2783|    560|    do {                                   \
  |  | 2784|    560|        memcpy(&name, data, sizeof(name)); \
  |  | 2785|    560|        data += sizeof(name);              \
  |  | 2786|    560|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2786:14): [Folded, False: 560]
  |  |  ------------------
  ------------------
 2805|    560|    VALUE_MEMBER(data, temp->userstatus);
  ------------------
  |  | 2783|    560|    do {                                   \
  |  | 2784|    560|        memcpy(&name, data, sizeof(name)); \
  |  | 2785|    560|        data += sizeof(name);              \
  |  | 2786|    560|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2786:14): [Folded, False: 560]
  |  |  ------------------
  ------------------
 2806|    560|    data += 3; // padding
 2807|    560|    VALUE_MEMBER(data, temp->friendrequest_nospam);
  ------------------
  |  | 2783|    560|    do {                                   \
  |  | 2784|    560|        memcpy(&name, data, sizeof(name)); \
  |  | 2785|    560|        data += sizeof(name);              \
  |  | 2786|    560|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2786:14): [Folded, False: 560]
  |  |  ------------------
  ------------------
 2808|    560|    ARRAY_MEMBER(data, temp->last_seen_time);
  ------------------
  |  | 2789|    560|    do {                                  \
  |  | 2790|    560|        memcpy(name, data, sizeof(name)); \
  |  | 2791|    560|        data += sizeof(name);             \
  |  | 2792|    560|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2792:14): [Folded, False: 560]
  |  |  ------------------
  ------------------
 2809|       |
 2810|    560|#undef VALUE_MEMBER
 2811|    560|#undef ARRAY_MEMBER
 2812|       |
 2813|    560|    return data;
 2814|    560|}
Messenger.c:friends_list_save:
 2958|    981|{
 2959|    981|    const uint32_t len = m_plugin_size(m, STATE_TYPE_FRIENDS);
 2960|    981|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_FRIENDS);
  ------------------
  |  |   31|    981|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 2961|       |
 2962|    981|    uint32_t num = 0;
 2963|    981|    uint8_t *cur_data = data;
 2964|       |
 2965|  1.11k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (2965:26): [True: 130, False: 981]
  ------------------
 2966|    130|        if (m->friendlist[i].status > 0) {
  ------------------
  |  Branch (2966:13): [True: 130, False: 0]
  ------------------
 2967|    130|            struct Saved_Friend temp = { 0 };
 2968|    130|            temp.status = m->friendlist[i].status;
 2969|    130|            memcpy(temp.real_pk, m->friendlist[i].real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    130|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2970|       |
 2971|    130|            if (temp.status < 3) {
  ------------------
  |  Branch (2971:17): [True: 29, False: 101]
  ------------------
 2972|       |                // TODO(iphydf): Use uint16_t and min_u16 here.
 2973|     29|                const size_t friendrequest_length =
 2974|     29|                    min_u32(m->friendlist[i].info_size,
 2975|     29|                            min_u32(SAVED_FRIEND_REQUEST_SIZE, MAX_FRIEND_REQUEST_DATA_SIZE));
  ------------------
  |  | 2691|     29|#define SAVED_FRIEND_REQUEST_SIZE 1024
  ------------------
                                          min_u32(SAVED_FRIEND_REQUEST_SIZE, MAX_FRIEND_REQUEST_DATA_SIZE));
  ------------------
  |  |   20|     29|#define MAX_FRIEND_REQUEST_DATA_SIZE (ONION_CLIENT_MAX_DATA_SIZE - 100)
  |  |  ------------------
  |  |  |  |  175|     29|#define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   45|     29|#define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   60|     29|#define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   49|     29|#define ONION_MAX_PACKET_SIZE 1400
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   58|     29|#define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   70|     29|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   55|     29|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   44|     29|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   29|     29|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   27|     29|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   26|     29|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   28|     29|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   65|     29|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   44|     29|#define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   44|     29|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   70|     29|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   44|     29|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   65|     29|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  172|     29|#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   44|     29|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|     29|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2976|     29|                memcpy(temp.info, m->friendlist[i].info, friendrequest_length);
 2977|       |
 2978|     29|                temp.info_size = net_htons(m->friendlist[i].info_size);
 2979|     29|                temp.friendrequest_nospam = m->friendlist[i].friendrequest_nospam;
 2980|    101|            } else {
 2981|    101|                temp.status = 3;
 2982|    101|                memcpy(temp.name, m->friendlist[i].name, m->friendlist[i].name_length);
 2983|    101|                temp.name_length = net_htons(m->friendlist[i].name_length);
 2984|    101|                memcpy(temp.statusmessage, m->friendlist[i].statusmessage, m->friendlist[i].statusmessage_length);
 2985|    101|                temp.statusmessage_length = net_htons(m->friendlist[i].statusmessage_length);
 2986|    101|                temp.userstatus = m->friendlist[i].userstatus;
 2987|       |
 2988|    101|                net_pack_u64(temp.last_seen_time, m->friendlist[i].last_seen_time);
 2989|    101|            }
 2990|       |
 2991|    130|            uint8_t *next_data = friend_save(&temp, cur_data);
 2992|    130|            assert(next_data - cur_data == friend_size());
  ------------------
  |  Branch (2992:13): [True: 130, False: 0]
  ------------------
 2993|    130|#ifdef __LP64__
 2994|    130|            assert(memcmp(cur_data, &temp, friend_size()) == 0);
  ------------------
  |  Branch (2994:13): [True: 130, False: 0]
  ------------------
 2995|    130|#endif /* __LP64__ */
 2996|    130|            cur_data = next_data;
 2997|    130|            ++num;
 2998|    130|        }
 2999|    130|    }
 3000|       |
 3001|    981|    assert(cur_data - data == num * friend_size());
  ------------------
  |  Branch (3001:5): [True: 981, False: 0]
  ------------------
 3002|    981|    data += len;
 3003|       |
 3004|    981|    return data;
 3005|    981|}
Messenger.c:friend_save:
 2745|    130|{
 2746|    130|#define VALUE_MEMBER(data, name)           \
 2747|    130|    do {                                   \
 2748|    130|        memcpy(data, &name, sizeof(name)); \
 2749|    130|        data += sizeof(name);              \
 2750|    130|    } while (0)
 2751|       |
 2752|    130|#define ARRAY_MEMBER(data, name)          \
 2753|    130|    do {                                  \
 2754|    130|        memcpy(data, name, sizeof(name)); \
 2755|    130|        data += sizeof(name);             \
 2756|    130|    } while (0)
 2757|       |
 2758|       |    // Exactly the same in friend_load, friend_save, and friend_size
 2759|    130|    VALUE_MEMBER(data, temp->status);
  ------------------
  |  | 2747|    130|    do {                                   \
  |  | 2748|    130|        memcpy(data, &name, sizeof(name)); \
  |  | 2749|    130|        data += sizeof(name);              \
  |  | 2750|    130|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2750:14): [Folded, False: 130]
  |  |  ------------------
  ------------------
 2760|    130|    ARRAY_MEMBER(data, temp->real_pk);
  ------------------
  |  | 2753|    130|    do {                                  \
  |  | 2754|    130|        memcpy(data, name, sizeof(name)); \
  |  | 2755|    130|        data += sizeof(name);             \
  |  | 2756|    130|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2756:14): [Folded, False: 130]
  |  |  ------------------
  ------------------
 2761|    130|    ARRAY_MEMBER(data, temp->info);
  ------------------
  |  | 2753|    130|    do {                                  \
  |  | 2754|    130|        memcpy(data, name, sizeof(name)); \
  |  | 2755|    130|        data += sizeof(name);             \
  |  | 2756|    130|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2756:14): [Folded, False: 130]
  |  |  ------------------
  ------------------
 2762|    130|    ++data; // padding
 2763|    130|    VALUE_MEMBER(data, temp->info_size);
  ------------------
  |  | 2747|    130|    do {                                   \
  |  | 2748|    130|        memcpy(data, &name, sizeof(name)); \
  |  | 2749|    130|        data += sizeof(name);              \
  |  | 2750|    130|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2750:14): [Folded, False: 130]
  |  |  ------------------
  ------------------
 2764|    130|    ARRAY_MEMBER(data, temp->name);
  ------------------
  |  | 2753|    130|    do {                                  \
  |  | 2754|    130|        memcpy(data, name, sizeof(name)); \
  |  | 2755|    130|        data += sizeof(name);             \
  |  | 2756|    130|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2756:14): [Folded, False: 130]
  |  |  ------------------
  ------------------
 2765|    130|    VALUE_MEMBER(data, temp->name_length);
  ------------------
  |  | 2747|    130|    do {                                   \
  |  | 2748|    130|        memcpy(data, &name, sizeof(name)); \
  |  | 2749|    130|        data += sizeof(name);              \
  |  | 2750|    130|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2750:14): [Folded, False: 130]
  |  |  ------------------
  ------------------
 2766|    130|    ARRAY_MEMBER(data, temp->statusmessage);
  ------------------
  |  | 2753|    130|    do {                                  \
  |  | 2754|    130|        memcpy(data, name, sizeof(name)); \
  |  | 2755|    130|        data += sizeof(name);             \
  |  | 2756|    130|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2756:14): [Folded, False: 130]
  |  |  ------------------
  ------------------
 2767|    130|    ++data; // padding
 2768|    130|    VALUE_MEMBER(data, temp->statusmessage_length);
  ------------------
  |  | 2747|    130|    do {                                   \
  |  | 2748|    130|        memcpy(data, &name, sizeof(name)); \
  |  | 2749|    130|        data += sizeof(name);              \
  |  | 2750|    130|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2750:14): [Folded, False: 130]
  |  |  ------------------
  ------------------
 2769|    130|    VALUE_MEMBER(data, temp->userstatus);
  ------------------
  |  | 2747|    130|    do {                                   \
  |  | 2748|    130|        memcpy(data, &name, sizeof(name)); \
  |  | 2749|    130|        data += sizeof(name);              \
  |  | 2750|    130|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2750:14): [Folded, False: 130]
  |  |  ------------------
  ------------------
 2770|    130|    data += 3; // padding
 2771|    130|    VALUE_MEMBER(data, temp->friendrequest_nospam);
  ------------------
  |  | 2747|    130|    do {                                   \
  |  | 2748|    130|        memcpy(data, &name, sizeof(name)); \
  |  | 2749|    130|        data += sizeof(name);              \
  |  | 2750|    130|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2750:14): [Folded, False: 130]
  |  |  ------------------
  ------------------
 2772|    130|    ARRAY_MEMBER(data, temp->last_seen_time);
  ------------------
  |  | 2753|    130|    do {                                  \
  |  | 2754|    130|        memcpy(data, name, sizeof(name)); \
  |  | 2755|    130|        data += sizeof(name);             \
  |  | 2756|    130|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2756:14): [Folded, False: 130]
  |  |  ------------------
  ------------------
 2773|       |
 2774|    130|#undef VALUE_MEMBER
 2775|    130|#undef ARRAY_MEMBER
 2776|       |
 2777|    130|    return data;
 2778|    130|}
Messenger.c:name_size:
 3148|  2.94k|{
 3149|  2.94k|    return m->name_length;
 3150|  2.94k|}
Messenger.c:load_name:
 3162|    458|{
 3163|    458|    if (length > 0 && length <= MAX_NAME_LENGTH) {
  ------------------
  |  |   39|    392|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (3163:9): [True: 392, False: 66]
  |  Branch (3163:23): [True: 326, False: 66]
  ------------------
 3164|    326|        setname(m, data, length);
 3165|    326|    }
 3166|       |
 3167|    458|    return STATE_LOAD_STATUS_CONTINUE;
 3168|    458|}
Messenger.c:save_name:
 3153|    981|{
 3154|    981|    const uint32_t len = m_plugin_size(m, STATE_TYPE_NAME);
 3155|    981|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_NAME);
  ------------------
  |  |   31|    981|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3156|    981|    memcpy(data, m->name, len);
 3157|    981|    data += len;
 3158|    981|    return data;
 3159|    981|}
Messenger.c:status_message_size:
 3172|  2.94k|{
 3173|  2.94k|    return m->statusmessage_length;
 3174|  2.94k|}
Messenger.c:load_status_message:
 3186|    738|{
 3187|    738|    if (length > 0 && length <= MAX_STATUSMESSAGE_LENGTH) {
  ------------------
  |  |   41|    650|#define MAX_STATUSMESSAGE_LENGTH 1007
  ------------------
  |  Branch (3187:9): [True: 650, False: 88]
  |  Branch (3187:23): [True: 640, False: 10]
  ------------------
 3188|    640|        m_set_statusmessage(m, data, length);
 3189|    640|    }
 3190|       |
 3191|    738|    return STATE_LOAD_STATUS_CONTINUE;
 3192|    738|}
Messenger.c:save_status_message:
 3177|    981|{
 3178|    981|    const uint32_t len = m_plugin_size(m, STATE_TYPE_STATUSMESSAGE);
 3179|    981|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_STATUSMESSAGE);
  ------------------
  |  |   31|    981|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3180|    981|    memcpy(data, m->statusmessage, len);
 3181|    981|    data += len;
 3182|    981|    return data;
 3183|    981|}
Messenger.c:status_size:
 3196|  2.94k|{
 3197|  2.94k|    return 1;
 3198|  2.94k|}
Messenger.c:load_status:
 3210|    622|{
 3211|    622|    if (length == 1) {
  ------------------
  |  Branch (3211:9): [True: 583, False: 39]
  ------------------
 3212|    583|        m_set_userstatus(m, *data);
 3213|    583|    }
 3214|       |
 3215|    622|    return STATE_LOAD_STATUS_CONTINUE;
 3216|    622|}
Messenger.c:save_status:
 3201|    981|{
 3202|    981|    const uint32_t len = m_plugin_size(m, STATE_TYPE_STATUS);
 3203|    981|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_STATUS);
  ------------------
  |  |   31|    981|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3204|    981|    *data = m->userstatus;
 3205|    981|    data += len;
 3206|    981|    return data;
 3207|    981|}
Messenger.c:saved_groups_size:
 3074|  2.09k|{
 3075|  2.09k|    const GC_Session *session = m->group_handler;
 3076|  2.09k|    return bin_pack_obj_size(pack_groupchats_handler, session, m->log);
 3077|  2.09k|}
Messenger.c:pack_groupchats_handler:
 3067|  2.23k|{
 3068|  2.23k|    const GC_Session *session = (const GC_Session *)obj;
 3069|  2.23k|    pack_groupchats(session, bp);
 3070|       |    return true;  // TODO(iphydf): Return bool from pack functions.
 3071|  2.23k|}
Messenger.c:pack_groupchats:
 3051|  2.23k|{
 3052|  2.23k|    assert(bp != nullptr && c != nullptr);
  ------------------
  |  Branch (3052:5): [True: 2.23k, False: 0]
  |  Branch (3052:5): [True: 2.23k, False: 0]
  ------------------
 3053|  2.23k|    bin_pack_array(bp, gc_count_groups(c));
 3054|       |
 3055|  5.47k|    for (uint32_t i = 0; i < c->chats_index; ++i) { // this loop must match the one in gc_count_groups()
  ------------------
  |  Branch (3055:26): [True: 3.23k, False: 2.23k]
  ------------------
 3056|  3.23k|        const GC_Chat *chat = &c->chats[i];
 3057|       |
 3058|  3.23k|        if (!gc_group_is_valid(chat)) {
  ------------------
  |  Branch (3058:13): [True: 1.80k, False: 1.43k]
  ------------------
 3059|  1.80k|            continue;
 3060|  1.80k|        }
 3061|       |
 3062|  1.43k|        gc_group_save(chat, bp);
 3063|  1.43k|    }
 3064|  2.23k|}
Messenger.c:groups_load:
 3137|  25.3k|{
 3138|  25.3k|    if (!bin_unpack_obj(m->mem, handle_groups_load, m, data, length)) {
  ------------------
  |  Branch (3138:9): [True: 34, False: 25.2k]
  ------------------
 3139|     34|        LOGGER_ERROR(m->log, "msgpack failed to unpack groupchats array");
  ------------------
  |  |   80|     34|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     34|    do {                                                                         \
  |  |  |  |   70|     34|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     68|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 34, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     34|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     34|        }                                                                        \
  |  |  |  |   73|     34|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 34]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3140|     34|        return STATE_LOAD_STATUS_ERROR;
 3141|     34|    }
 3142|       |
 3143|  25.2k|    return STATE_LOAD_STATUS_CONTINUE;
 3144|  25.3k|}
Messenger.c:handle_groups_load:
 3110|  25.3k|{
 3111|  25.3k|    Messenger *m = (Messenger *)obj;
 3112|       |
 3113|  25.3k|    uint32_t num_groups;
 3114|  25.3k|    if (!bin_unpack_array(bu, &num_groups)) {
  ------------------
  |  Branch (3114:9): [True: 34, False: 25.2k]
  ------------------
 3115|     34|        LOGGER_ERROR(m->log, "msgpack failed to unpack groupchats array: expected array");
  ------------------
  |  |   80|     34|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     34|    do {                                                                         \
  |  |  |  |   70|     34|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     68|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 34, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     34|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     34|        }                                                                        \
  |  |  |  |   73|     34|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 34]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3116|     34|        return false;
 3117|     34|    }
 3118|       |
 3119|  25.2k|    LOGGER_DEBUG(m->log, "Loading %u groups", num_groups);
  ------------------
  |  |   77|  25.2k|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  25.2k|    do {                                                                         \
  |  |  |  |   70|  25.2k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  50.5k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 25.2k]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|  25.2k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 25.2k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3120|       |
 3121|  25.4k|    for (uint32_t i = 0; i < num_groups; ++i) {
  ------------------
  |  Branch (3121:26): [True: 25.2k, False: 174]
  ------------------
 3122|  25.2k|        const int group_number = gc_group_load(m->group_handler, bu);
 3123|       |
 3124|  25.2k|        if (group_number < 0) {
  ------------------
  |  Branch (3124:13): [True: 25.1k, False: 112]
  ------------------
 3125|  25.1k|            LOGGER_WARNING(m->log, "Failed to load group %u", i);
  ------------------
  |  |   79|  25.1k|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  25.1k|    do {                                                                         \
  |  |  |  |   70|  25.1k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  50.2k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 25.1k, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|  25.1k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|  25.1k|        }                                                                        \
  |  |  |  |   73|  25.1k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 25.1k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3126|       |            // Can't recover trivially. We may need to skip over some data here.
 3127|  25.1k|            break;
 3128|  25.1k|        }
 3129|  25.2k|    }
 3130|       |
 3131|  25.2k|    LOGGER_DEBUG(m->log, "Successfully loaded %u groups", gc_count_groups(m->group_handler));
  ------------------
  |  |   77|  25.2k|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  25.2k|    do {                                                                         \
  |  |  |  |   70|  25.2k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  50.5k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 25.2k]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|  25.2k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 25.2k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3132|       |
 3133|       |    return true;
 3134|  25.3k|}
Messenger.c:groups_save:
 3080|    981|{
 3081|    981|    const GC_Session *c = m->group_handler;
 3082|       |
 3083|    981|    const uint32_t num_groups = gc_count_groups(c);
 3084|       |
 3085|    981|    if (num_groups == 0) {
  ------------------
  |  Branch (3085:9): [True: 844, False: 137]
  ------------------
 3086|    844|        return data;
 3087|    844|    }
 3088|       |
 3089|    137|    const uint32_t len = m_plugin_size(m, STATE_TYPE_GROUPS);
 3090|       |
 3091|    137|    if (len == 0) {
  ------------------
  |  Branch (3091:9): [True: 0, False: 137]
  ------------------
 3092|      0|        return data;
 3093|      0|    }
 3094|       |
 3095|    137|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_GROUPS);
  ------------------
  |  |   31|    137|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3096|       |
 3097|    137|    if (!bin_pack_obj(pack_groupchats_handler, c, m->log, data, len)) {
  ------------------
  |  Branch (3097:9): [True: 0, False: 137]
  ------------------
 3098|      0|        LOGGER_FATAL(m->log, "failed to pack group chats into buffer of length %u", len);
  ------------------
  |  |   83|      0|    do {                                \
  |  |   84|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   85|      0|        logger_abort();                 \
  |  |   86|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (86:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
 3099|      0|        return data;
 3100|      0|    }
 3101|       |
 3102|    137|    data += len;
 3103|       |
 3104|    137|    LOGGER_DEBUG(m->log, "Saved %u groups (length %u)", num_groups, len);
  ------------------
  |  |   77|    137|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    137|    do {                                                                         \
  |  |  |  |   70|    137|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    274|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 137]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|    137|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 137]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3105|       |
 3106|    137|    return data;
 3107|    137|}
Messenger.c:tcp_relay_size:
 3220|  1.96k|{
 3221|  1.96k|    return NUM_SAVED_TCP_RELAYS * packed_node_size(net_family_tcp_ipv6());
  ------------------
  |  |   43|  1.96k|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
 3222|  1.96k|}
Messenger.c:load_tcp_relays:
 3249|    660|{
 3250|    660|    if (length > 0) {
  ------------------
  |  Branch (3250:9): [True: 594, False: 66]
  ------------------
 3251|    594|        const int num = unpack_nodes(m->loaded_relays, NUM_SAVED_TCP_RELAYS, nullptr, data, length, true);
  ------------------
  |  |   43|    594|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
                      const int num = unpack_nodes(m->loaded_relays, NUM_SAVED_TCP_RELAYS, nullptr, data, length, true);
  ------------------
  |  |   63|    594|#define nullptr NULL
  ------------------
 3252|       |
 3253|    594|        if (num == -1) {
  ------------------
  |  Branch (3253:13): [True: 105, False: 489]
  ------------------
 3254|    105|            m->num_loaded_relays = 0;
 3255|    105|            return STATE_LOAD_STATUS_CONTINUE;
 3256|    105|        }
 3257|       |
 3258|    489|        m->num_loaded_relays = num;
 3259|    489|        m->has_added_relays = false;
 3260|    489|    }
 3261|       |
 3262|    555|    return STATE_LOAD_STATUS_CONTINUE;
 3263|    660|}
Messenger.c:save_tcp_relays:
 3225|    981|{
 3226|    981|    Node_format relays[NUM_SAVED_TCP_RELAYS] = {{{0}}};
 3227|    981|    uint8_t *temp_data = data;
 3228|    981|    data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, 0, STATE_TYPE_TCP_RELAY);
  ------------------
  |  |   31|    981|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3229|       |
 3230|    981|    if (m->num_loaded_relays > 0) {
  ------------------
  |  Branch (3230:9): [True: 31, False: 950]
  ------------------
 3231|     31|        memcpy(relays, m->loaded_relays, sizeof(Node_format) * m->num_loaded_relays);
 3232|     31|    }
 3233|       |
 3234|    981|    uint32_t num = m->num_loaded_relays;
 3235|    981|    num += copy_connected_tcp_relays(m->net_crypto, relays + num, NUM_SAVED_TCP_RELAYS - num);
  ------------------
  |  |   43|    981|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
 3236|       |
 3237|    981|    const int l = pack_nodes(m->log, data, NUM_SAVED_TCP_RELAYS * packed_node_size(net_family_tcp_ipv6()), relays, num);
  ------------------
  |  |   43|    981|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
 3238|       |
 3239|    981|    if (l > 0) {
  ------------------
  |  Branch (3239:9): [True: 31, False: 950]
  ------------------
 3240|     31|        const uint32_t len = l;
 3241|     31|        data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, len, STATE_TYPE_TCP_RELAY);
  ------------------
  |  |   31|     31|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3242|     31|        data += len;
 3243|     31|    }
 3244|       |
 3245|    981|    return data;
 3246|    981|}
Messenger.c:path_node_size:
 3267|  1.96k|{
 3268|  1.96k|    return NUM_SAVED_PATH_NODES * packed_node_size(net_family_tcp_ipv6());
  ------------------
  |  | 2692|  1.96k|#define NUM_SAVED_PATH_NODES 8
  ------------------
 3269|  1.96k|}
Messenger.c:load_path_nodes:
 3289|    480|{
 3290|    480|    if (length > 0) {
  ------------------
  |  Branch (3290:9): [True: 412, False: 68]
  ------------------
 3291|    412|        Node_format nodes[NUM_SAVED_PATH_NODES];
 3292|    412|        const int num = unpack_nodes(nodes, NUM_SAVED_PATH_NODES, nullptr, data, length, false);
  ------------------
  |  | 2692|    412|#define NUM_SAVED_PATH_NODES 8
  ------------------
                      const int num = unpack_nodes(nodes, NUM_SAVED_PATH_NODES, nullptr, data, length, false);
  ------------------
  |  |   63|    412|#define nullptr NULL
  ------------------
 3293|       |
 3294|    412|        if (num == -1) {
  ------------------
  |  Branch (3294:13): [True: 46, False: 366]
  ------------------
 3295|     46|            return STATE_LOAD_STATUS_CONTINUE;
 3296|     46|        }
 3297|       |
 3298|  2.81k|        for (int i = 0; i < num; ++i) {
  ------------------
  |  Branch (3298:25): [True: 2.45k, False: 366]
  ------------------
 3299|  2.45k|            onion_add_bs_path_node(m->onion_c, &nodes[i].ip_port, nodes[i].public_key);
 3300|  2.45k|        }
 3301|    366|    }
 3302|       |
 3303|    434|    return STATE_LOAD_STATUS_CONTINUE;
 3304|    480|}
Messenger.c:save_path_nodes:
 3272|    981|{
 3273|    981|    Node_format nodes[NUM_SAVED_PATH_NODES] = {{{0}}};
 3274|    981|    uint8_t *temp_data = data;
 3275|    981|    data = state_write_section_header(data, STATE_COOKIE_TYPE, 0, STATE_TYPE_PATH_NODE);
  ------------------
  |  |   31|    981|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3276|    981|    const unsigned int num = onion_backup_nodes(m->onion_c, nodes, NUM_SAVED_PATH_NODES);
  ------------------
  |  | 2692|    981|#define NUM_SAVED_PATH_NODES 8
  ------------------
 3277|    981|    const int l = pack_nodes(m->log, data, NUM_SAVED_PATH_NODES * packed_node_size(net_family_tcp_ipv6()), nodes, num);
  ------------------
  |  | 2692|    981|#define NUM_SAVED_PATH_NODES 8
  ------------------
 3278|       |
 3279|    981|    if (l > 0) {
  ------------------
  |  Branch (3279:9): [True: 33, False: 948]
  ------------------
 3280|     33|        const uint32_t len = l;
 3281|     33|        data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, len, STATE_TYPE_PATH_NODE);
  ------------------
  |  |   31|     33|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3282|     33|        data += len;
 3283|     33|    }
 3284|       |
 3285|    981|    return data;
 3286|    981|}

tcp_connections_count:
   74|    112|{
   75|    112|    return tcp_c->tcp_connections_length;
   76|    112|}
set_packet_tcp_connection_callback:
  571|  1.51k|{
  572|  1.51k|    tcp_c->tcp_data_callback = tcp_data_callback;
  573|  1.51k|    tcp_c->tcp_data_callback_object = object;
  574|  1.51k|}
set_oob_packet_tcp_connection_callback:
  578|  1.51k|{
  579|  1.51k|    tcp_c->tcp_oob_callback = tcp_oob_callback;
  580|  1.51k|    tcp_c->tcp_oob_callback_object = object;
  581|  1.51k|}
set_onion_packet_tcp_connection_callback:
  585|  2.80k|{
  586|  2.80k|    tcp_c->tcp_onion_callback = tcp_onion_callback;
  587|  2.80k|    tcp_c->tcp_onion_callback_object = object;
  588|  2.80k|}
tcp_copy_connected_relays:
 1512|    975|{
 1513|    975|    const uint32_t r = random_u32(tcp_c->rng);
 1514|    975|    uint32_t copied = 0;
 1515|       |
 1516|    975|    for (uint32_t i = 0; (i < tcp_c->tcp_connections_length) && (copied < max_num); ++i) {
  ------------------
  |  Branch (1516:26): [True: 0, False: 975]
  |  Branch (1516:65): [True: 0, False: 0]
  ------------------
 1517|      0|        const uint16_t idx = (i + r) % tcp_c->tcp_connections_length;
 1518|       |
 1519|      0|        if (copy_tcp_relay_conn(tcp_c, &tcp_relays[copied], idx)) {
  ------------------
  |  Branch (1519:13): [True: 0, False: 0]
  ------------------
 1520|      0|            ++copied;
 1521|      0|        }
 1522|      0|    }
 1523|       |
 1524|    975|    return copied;
 1525|    975|}
new_tcp_connections:
 1623|  1.51k|{
 1624|  1.51k|    assert(logger != nullptr);
  ------------------
  |  Branch (1624:5): [True: 1.51k, False: 0]
  ------------------
 1625|  1.51k|    assert(mem != nullptr);
  ------------------
  |  Branch (1625:5): [True: 1.51k, False: 0]
  ------------------
 1626|  1.51k|    assert(rng != nullptr);
  ------------------
  |  Branch (1626:5): [True: 1.51k, False: 0]
  ------------------
 1627|  1.51k|    assert(ns != nullptr);
  ------------------
  |  Branch (1627:5): [True: 1.51k, False: 0]
  ------------------
 1628|  1.51k|    assert(mono_time != nullptr);
  ------------------
  |  Branch (1628:5): [True: 1.51k, False: 0]
  ------------------
 1629|       |
 1630|  1.51k|    if (secret_key == nullptr) {
  ------------------
  |  |   63|  1.51k|#define nullptr NULL
  ------------------
  |  Branch (1630:9): [True: 0, False: 1.51k]
  ------------------
 1631|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1632|      0|    }
 1633|       |
 1634|  1.51k|    TCP_Connections *temp = (TCP_Connections *)mem_alloc(mem, sizeof(TCP_Connections));
 1635|       |
 1636|  1.51k|    if (temp == nullptr) {
  ------------------
  |  |   63|  1.51k|#define nullptr NULL
  ------------------
  |  Branch (1636:9): [True: 0, False: 1.51k]
  ------------------
 1637|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1638|      0|    }
 1639|       |
 1640|  1.51k|    temp->net_profile = tcp_np;
 1641|  1.51k|    temp->logger = logger;
 1642|  1.51k|    temp->mem = mem;
 1643|  1.51k|    temp->rng = rng;
 1644|  1.51k|    temp->mono_time = mono_time;
 1645|  1.51k|    temp->ns = ns;
 1646|       |
 1647|  1.51k|    memcpy(temp->self_secret_key, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   49|  1.51k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 1648|  1.51k|    crypto_derive_public_key(temp->self_public_key, temp->self_secret_key);
 1649|  1.51k|    temp->proxy_info = *proxy_info;
 1650|       |
 1651|  1.51k|    return temp;
 1652|  1.51k|}
kill_tcp_connections:
 1757|  1.51k|{
 1758|  1.51k|    if (tcp_c == nullptr) {
  ------------------
  |  |   63|  1.51k|#define nullptr NULL
  ------------------
  |  Branch (1758:9): [True: 0, False: 1.51k]
  ------------------
 1759|      0|        return;
 1760|      0|    }
 1761|       |
 1762|  1.51k|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1762:26): [True: 0, False: 1.51k]
  ------------------
 1763|      0|        kill_tcp_connection(tcp_c->tcp_connections[i].connection);
 1764|      0|    }
 1765|       |
 1766|  1.51k|    crypto_memzero(tcp_c->self_secret_key, sizeof(tcp_c->self_secret_key));
 1767|       |
 1768|  1.51k|    mem_delete(tcp_c->mem, tcp_c->tcp_connections);
 1769|  1.51k|    mem_delete(tcp_c->mem, tcp_c->connections);
 1770|  1.51k|    mem_delete(tcp_c->mem, tcp_c);
 1771|  1.51k|}

new_announcements:
  625|  1.40k|{
  626|  1.40k|    if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (626:9): [True: 0, False: 1.40k]
  |  Branch (626:27): [True: 0, False: 1.40k]
  |  Branch (626:51): [True: 0, False: 1.40k]
  ------------------
  627|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  628|      0|    }
  629|       |
  630|  1.40k|    Announcements *announce = (Announcements *)mem_alloc(mem, sizeof(Announcements));
  631|       |
  632|  1.40k|    if (announce == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (632:9): [True: 0, False: 1.40k]
  ------------------
  633|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  634|      0|    }
  635|       |
  636|  1.40k|    announce->log = log;
  637|  1.40k|    announce->mem = mem;
  638|  1.40k|    announce->rng = rng;
  639|  1.40k|    announce->forwarding = forwarding;
  640|  1.40k|    announce->mono_time = mono_time;
  641|  1.40k|    announce->dht = dht;
  642|  1.40k|    announce->net = net;
  643|  1.40k|    announce->public_key = dht_get_self_public_key(announce->dht);
  644|  1.40k|    announce->secret_key = dht_get_self_secret_key(announce->dht);
  645|  1.40k|    new_hmac_key(announce->rng, announce->hmac_key);
  646|  1.40k|    Shared_Key_Cache *const shared_keys = shared_key_cache_new(log, mono_time, mem, announce->secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   30|  1.40k|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const shared_keys = shared_key_cache_new(log, mono_time, mem, announce->secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   29|  1.40k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  647|  1.40k|    if (shared_keys == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (647:9): [True: 0, False: 1.40k]
  ------------------
  648|      0|        mem_delete(announce->mem, announce);
  649|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  650|      0|    }
  651|  1.40k|    announce->shared_keys = shared_keys;
  652|       |
  653|  1.40k|    announce->start_time = mono_time_get(announce->mono_time);
  654|       |
  655|  1.40k|    set_callback_forwarded_request(forwarding, forwarded_request_callback, announce);
  656|       |
  657|  1.40k|    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, handle_dht_announce_request, announce);
  658|  1.40k|    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, handle_dht_announce_request, announce);
  659|  1.40k|    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, handle_dht_announce_request, announce);
  660|       |
  661|  1.40k|    return announce;
  662|  1.40k|}
kill_announcements:
  665|  1.40k|{
  666|  1.40k|    if (announce == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (666:9): [True: 0, False: 1.40k]
  ------------------
  667|      0|        return;
  668|      0|    }
  669|       |
  670|  1.40k|    set_callback_forwarded_request(announce->forwarding, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  set_callback_forwarded_request(announce->forwarding, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  671|       |
  672|  1.40k|    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  673|  1.40k|    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  674|  1.40k|    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  675|       |
  676|  1.40k|    crypto_memzero(announce->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  125|  1.40k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  677|  1.40k|    shared_key_cache_free(announce->shared_keys);
  678|       |
  679|   360k|    for (uint32_t i = 0; i < ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   67|   360k|#define ANNOUNCE_BUCKETS 32 // ANNOUNCE_BUCKETS = 2 ** ANNOUNCE_BUCKET_PREFIX_LENGTH
  ------------------
                  for (uint32_t i = 0; i < ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   65|   360k|#define ANNOUNCE_BUCKET_SIZE 8
  ------------------
  |  Branch (679:26): [True: 359k, False: 1.40k]
  ------------------
  680|   359k|        mem_delete(announce->mem, announce->entries[i].data);
  681|   359k|    }
  682|       |
  683|  1.40k|    mem_delete(announce->mem, announce);
  684|  1.40k|}

bin_pack_obj_size:
   72|  2.68k|{
   73|  2.68k|    Bin_Pack bp;
   74|  2.68k|    bin_pack_init(&bp, nullptr, 0);
  ------------------
  |  |   63|  2.68k|#define nullptr NULL
  ------------------
   75|  2.68k|    if (!callback(obj, logger, &bp)) {
  ------------------
  |  Branch (75:9): [True: 0, False: 2.68k]
  ------------------
   76|      0|        return UINT32_MAX;
   77|      0|    }
   78|  2.68k|    return bp.bytes_pos;
   79|  2.68k|}
bin_pack_obj:
   82|    721|{
   83|    721|    Bin_Pack bp;
   84|    721|    bin_pack_init(&bp, buf, buf_size);
   85|    721|    return callback(obj, logger, &bp);
   86|    721|}
bin_pack_obj_array_b_size:
   89|  3.45k|{
   90|  3.45k|    Bin_Pack bp;
   91|  3.45k|    bin_pack_init(&bp, nullptr, 0);
  ------------------
  |  |   63|  3.45k|#define nullptr NULL
  ------------------
   92|  3.45k|    if (arr == nullptr) {
  ------------------
  |  |   63|  3.45k|#define nullptr NULL
  ------------------
  |  Branch (92:9): [True: 0, False: 3.45k]
  ------------------
   93|      0|        assert(arr_size == 0);
  ------------------
  |  Branch (93:9): [True: 0, False: 0]
  ------------------
   94|      0|    }
   95|  7.70k|    for (uint32_t i = 0; i < arr_size; ++i) {
  ------------------
  |  Branch (95:26): [True: 4.24k, False: 3.45k]
  ------------------
   96|  4.24k|        if (!callback(arr, i, logger, &bp)) {
  ------------------
  |  Branch (96:13): [True: 0, False: 4.24k]
  ------------------
   97|      0|            return UINT32_MAX;
   98|      0|        }
   99|  4.24k|    }
  100|  3.45k|    return bp.bytes_pos;
  101|  3.45k|}
bin_pack_obj_array_b:
  104|  3.45k|{
  105|  3.45k|    Bin_Pack bp;
  106|  3.45k|    bin_pack_init(&bp, buf, buf_size);
  107|  3.45k|    if (arr == nullptr) {
  ------------------
  |  |   63|  3.45k|#define nullptr NULL
  ------------------
  |  Branch (107:9): [True: 0, False: 3.45k]
  ------------------
  108|      0|        assert(arr_size == 0);
  ------------------
  |  Branch (108:9): [True: 0, False: 0]
  ------------------
  109|      0|    }
  110|  7.70k|    for (uint32_t i = 0; i < arr_size; ++i) {
  ------------------
  |  Branch (110:26): [True: 4.24k, False: 3.45k]
  ------------------
  111|  4.24k|        if (!callback(arr, i, logger, &bp)) {
  ------------------
  |  Branch (111:13): [True: 0, False: 4.24k]
  ------------------
  112|      0|            return false;
  113|      0|        }
  114|  4.24k|    }
  115|  3.45k|    return true;
  116|  3.45k|}
bin_pack_array:
  139|  4.28k|{
  140|  4.28k|    return cmp_write_array(&bp->ctx, size);
  141|  4.28k|}
bin_pack_bool:
  144|    256|{
  145|    256|    return cmp_write_bool(&bp->ctx, val);
  146|    256|}
bin_pack_u08:
  149|  1.02k|{
  150|  1.02k|    return cmp_write_uinteger(&bp->ctx, val);
  151|  1.02k|}
bin_pack_u16:
  154|  2.04k|{
  155|  2.04k|    return cmp_write_uinteger(&bp->ctx, val);
  156|  2.04k|}
bin_pack_u32:
  159|    768|{
  160|    768|    return cmp_write_uinteger(&bp->ctx, val);
  161|    768|}
bin_pack_bin:
  169|  3.76k|{
  170|  3.76k|    if (length == 0) {
  ------------------
  |  Branch (170:9): [True: 256, False: 3.51k]
  ------------------
  171|    256|        return cmp_write_bin_marker(&bp->ctx, 0);
  172|    256|    }
  173|       |
  174|  3.51k|    if (data == nullptr) {
  ------------------
  |  |   63|  3.51k|#define nullptr NULL
  ------------------
  |  Branch (174:9): [True: 0, False: 3.51k]
  ------------------
  175|      0|        return false;
  176|      0|    }
  177|       |
  178|  3.51k|    return cmp_write_bin(&bp->ctx, data, length);
  179|  3.51k|}
bin_pack_nil:
  195|     72|{
  196|     72|    return cmp_write_nil(&bp->ctx);
  197|     72|}
bin_pack_u08_b:
  205|  28.9k|{
  206|  28.9k|    return bp->ctx.write(&bp->ctx, &val, 1) == 1;
  207|  28.9k|}
bin_pack_u16_b:
  210|  9.66k|{
  211|  9.66k|    return bin_pack_u08_b(bp, (val >> 8) & 0xff)
  ------------------
  |  Branch (211:12): [True: 9.66k, False: 0]
  ------------------
  212|  9.66k|           && bin_pack_u08_b(bp, val & 0xff);
  ------------------
  |  Branch (212:15): [True: 9.66k, False: 0]
  ------------------
  213|  9.66k|}
bin_pack_bin_b:
  228|  18.1k|{
  229|  18.1k|    if (length > 0 && data == nullptr) {
  ------------------
  |  |   63|  18.1k|#define nullptr NULL
  ------------------
  |  Branch (229:9): [True: 18.1k, False: 0]
  |  Branch (229:23): [True: 0, False: 18.1k]
  ------------------
  230|      0|        return false;
  231|      0|    }
  232|       |
  233|  18.1k|    return bp->ctx.write(&bp->ctx, data, length) == length;
  234|  18.1k|}
bin_pack.c:bin_pack_init:
   64|  10.3k|{
   65|  10.3k|    bp->bytes = buf;
   66|  10.3k|    bp->bytes_size = buf_size;
   67|  10.3k|    bp->bytes_pos = 0;
   68|  10.3k|    cmp_init(&bp->ctx, bp, null_reader, null_skipper, buf_writer);
   69|  10.3k|}
bin_pack.c:buf_writer:
   35|  67.0k|{
   36|  67.0k|    const uint8_t *const bytes = (const uint8_t *)data;
   37|       |
   38|  67.0k|    if (count == 0) {
  ------------------
  |  Branch (38:9): [True: 0, False: 67.0k]
  ------------------
   39|      0|        return 0;
   40|      0|    }
   41|       |
   42|  67.0k|    if (bytes == nullptr) {
  ------------------
  |  |   63|  67.0k|#define nullptr NULL
  ------------------
  |  Branch (42:9): [True: 0, False: 67.0k]
  ------------------
   43|      0|        return 0;
   44|      0|    }
   45|  67.0k|    Bin_Pack *const bp = (Bin_Pack *)ctx->buf;
   46|  67.0k|    assert(bp != nullptr);
  ------------------
  |  Branch (46:5): [True: 67.0k, False: 0]
  ------------------
   47|  67.0k|    const uint32_t new_pos = bp->bytes_pos + count;
   48|  67.0k|    if (new_pos < bp->bytes_pos) {
  ------------------
  |  Branch (48:9): [True: 0, False: 67.0k]
  ------------------
   49|       |        // 32 bit overflow.
   50|      0|        return 0;
   51|      0|    }
   52|  67.0k|    if (bp->bytes != nullptr) {
  ------------------
  |  |   63|  67.0k|#define nullptr NULL
  ------------------
  |  Branch (52:9): [True: 28.1k, False: 38.8k]
  ------------------
   53|  28.1k|        if (new_pos > bp->bytes_size) {
  ------------------
  |  Branch (53:13): [True: 0, False: 28.1k]
  ------------------
   54|       |            // Buffer too small.
   55|      0|            return 0;
   56|      0|        }
   57|  28.1k|        memcpy(&bp->bytes[bp->bytes_pos], bytes, count);
   58|  28.1k|    }
   59|  67.0k|    bp->bytes_pos += count;
   60|  67.0k|    return count;
   61|  67.0k|}

bin_unpack_obj:
   75|  25.3k|{
   76|  25.3k|    Bin_Unpack bu;
   77|  25.3k|    bin_unpack_init(&bu, mem, buf, buf_size);
   78|  25.3k|    return callback(obj, &bu);
   79|  25.3k|}
bin_unpack_array:
   82|  25.3k|{
   83|  25.3k|    return cmp_read_array(&bu->ctx, size) && *size <= bu->bytes_size;
  ------------------
  |  Branch (83:12): [True: 25.2k, False: 30]
  |  Branch (83:46): [True: 25.2k, False: 4]
  ------------------
   84|  25.3k|}
bin_unpack_array_fixed:
   87|  57.0k|{
   88|  57.0k|    uint32_t size = 0;
   89|  57.0k|    const bool success = cmp_read_array(&bu->ctx, &size) && size == required_size;
  ------------------
  |  Branch (89:26): [True: 46.1k, False: 10.9k]
  |  Branch (89:61): [True: 45.9k, False: 167]
  ------------------
   90|  57.0k|    if (actual_size != nullptr) {
  ------------------
  |  |   63|  57.0k|#define nullptr NULL
  ------------------
  |  Branch (90:9): [True: 25.5k, False: 31.5k]
  ------------------
   91|  25.5k|        *actual_size = size;
   92|  25.5k|    }
   93|  57.0k|    return success;
   94|  57.0k|}
bin_unpack_bool:
   97|  21.1k|{
   98|  21.1k|    return cmp_read_bool(&bu->ctx, val);
   99|  21.1k|}
bin_unpack_u08:
  102|  26.7k|{
  103|  26.7k|    return cmp_read_uchar(&bu->ctx, val);
  104|  26.7k|}
bin_unpack_u16:
  107|  50.9k|{
  108|  50.9k|    return cmp_read_ushort(&bu->ctx, val);
  109|  50.9k|}
bin_unpack_u32:
  112|  27.4k|{
  113|  27.4k|    return cmp_read_uint(&bu->ctx, val);
  114|  27.4k|}
bin_unpack_nil:
  122|     51|{
  123|     51|    return cmp_read_nil(&bu->ctx);
  124|     51|}
bin_unpack_bin_max:
  187|  1.13k|{
  188|  1.13k|    uint32_t bin_size;
  189|  1.13k|    if (!bin_unpack_bin_size(bu, &bin_size) || bin_size > max_data_length) {
  ------------------
  |  Branch (189:9): [True: 35, False: 1.09k]
  |  Branch (189:48): [True: 16, False: 1.08k]
  ------------------
  190|     51|        return false;
  191|     51|    }
  192|       |
  193|  1.08k|    *data_length_ptr = bin_size;
  194|       |
  195|  1.08k|    return bin_unpack_bin_b(bu, data, bin_size);
  196|  1.13k|}
bin_unpack_bin_fixed:
  199|  3.40k|{
  200|  3.40k|    uint32_t bin_size;
  201|  3.40k|    if (!bin_unpack_bin_size(bu, &bin_size) || bin_size != data_length) {
  ------------------
  |  Branch (201:9): [True: 181, False: 3.22k]
  |  Branch (201:48): [True: 53, False: 3.17k]
  ------------------
  202|    234|        return false;
  203|    234|    }
  204|       |
  205|  3.17k|    return bin_unpack_bin_b(bu, data, bin_size);
  206|  3.40k|}
bin_unpack_bin_size:
  209|  4.54k|{
  210|  4.54k|    return cmp_read_bin_size(&bu->ctx, size);
  211|  4.54k|}
bin_unpack_bin_b:
  255|  4.25k|{
  256|  4.25k|    return bu->ctx.read(&bu->ctx, data, length);
  257|  4.25k|}
bin_unpack.c:bin_unpack_init:
   67|  25.3k|{
   68|  25.3k|    bu->mem = mem;
   69|  25.3k|    bu->bytes = buf;
   70|  25.3k|    bu->bytes_size = buf_size;
   71|  25.3k|    cmp_init(&bu->ctx, bu, buf_reader, buf_skipper, null_writer);
   72|  25.3k|}
bin_unpack.c:buf_reader:
   24|   259k|{
   25|   259k|    uint8_t *const bytes = (uint8_t *)data;
   26|       |
   27|   259k|    if (limit == 0) {
  ------------------
  |  Branch (27:9): [True: 378, False: 258k]
  ------------------
   28|    378|        return true;
   29|    378|    }
   30|       |
   31|   258k|    if (bytes == nullptr) {
  ------------------
  |  |   63|   258k|#define nullptr NULL
  ------------------
  |  Branch (31:9): [True: 0, False: 258k]
  ------------------
   32|      0|        return false;
   33|      0|    }
   34|   258k|    Bin_Unpack *const reader = (Bin_Unpack *)ctx->buf;
   35|   258k|    assert(reader != nullptr && reader->bytes != nullptr);
  ------------------
  |  Branch (35:5): [True: 258k, False: 0]
  |  Branch (35:5): [True: 258k, False: 0]
  ------------------
   36|   258k|    if (limit > reader->bytes_size) {
  ------------------
  |  Branch (36:9): [True: 4.32k, False: 254k]
  ------------------
   37|  4.32k|        return false;
   38|  4.32k|    }
   39|   254k|    memcpy(bytes, reader->bytes, limit);
   40|   254k|    reader->bytes += limit;
   41|   254k|    reader->bytes_size -= limit;
   42|       |    return true;
   43|   258k|}

get_enc_key:
   67|    300|{
   68|    300|    return key->enc;
   69|    300|}
get_sig_pk:
   72|    224|{
   73|    224|    return key->sig;
   74|    224|}
get_sig_sk:
   82|    112|{
   83|    112|    return key->sig;
   84|    112|}
get_chat_id:
   87|    238|{
   88|    238|    return key->sig;
   89|    238|}
crypto_memzero:
  115|  30.9k|{
  116|  30.9k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  117|  30.9k|    memzero((uint8_t *)data, length);
  118|       |#else
  119|       |    sodium_memzero(data, length);
  120|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  121|  30.9k|}
crypto_memlock:
  124|  9.97k|{
  125|  9.97k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  126|  9.97k|    return false;
  127|       |#else
  128|       |
  129|       |    return sodium_mlock(data, length) == 0;
  130|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  131|  9.97k|}
crypto_memunlock:
  134|  32.6k|{
  135|  32.6k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  136|  32.6k|    return false;
  137|       |#else
  138|       |
  139|       |    return sodium_munlock(data, length) == 0;
  140|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  141|  32.6k|}
pk_equal:
  144|  85.3k|{
  145|  85.3k|    return memcmp(pk1, pk2, CRYPTO_PUBLIC_KEY_SIZE) == 0;
  ------------------
  |  |   44|  85.3k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  146|  85.3k|}
pk_copy:
  149|  25.9k|{
  150|  25.9k|    memcpy(dest, src, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|  25.9k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  151|  25.9k|}
random_u32:
  183|  2.37k|{
  184|  2.37k|    uint32_t randnum;
  185|  2.37k|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  186|  2.37k|    return randnum;
  187|  2.37k|}
random_u64:
  190|  2.80k|{
  191|  2.80k|    uint64_t randnum;
  192|  2.80k|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  193|  2.80k|    return randnum;
  194|  2.80k|}
public_key_valid:
  216|    470|{
  217|       |    /* Last bit of key is always zero. */
  218|    470|    return public_key[31] < 128;
  219|    470|}
new_symmetric_key:
  421|  4.21k|{
  422|  4.21k|    random_bytes(rng, key, CRYPTO_SYMMETRIC_KEY_SIZE);
  ------------------
  |  |   59|  4.21k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  ------------------
  |  |  |  |   54|  4.21k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  ------------------
  ------------------
  423|  4.21k|}
crypto_new_keypair:
  428|  7.59k|{
  429|  7.59k|    random_bytes(rng, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   49|  7.59k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
  430|  7.59k|    memzero(public_key, CRYPTO_PUBLIC_KEY_SIZE);  // Make MSAN happy
  ------------------
  |  |   44|  7.59k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  431|  7.59k|    crypto_derive_public_key(public_key, secret_key);
  432|  7.59k|    return 0;
  433|  7.59k|}
crypto_derive_public_key:
  437|  9.67k|{
  438|  9.67k|    crypto_scalarmult_curve25519_base(public_key, secret_key);
  439|  9.67k|}
new_hmac_key:
  442|  4.21k|{
  443|  4.21k|    random_bytes(rng, key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  125|  4.21k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  444|  4.21k|}
random_bytes:
  488|  21.2k|{
  489|  21.2k|    rng_bytes(rng, bytes, length);
  490|  21.2k|}

pack_extended_public_key:
   16|    768|{
   17|    768|    uint8_t ext_key[EXT_PUBLIC_KEY_SIZE];
   18|    768|    static_assert(sizeof(ext_key) == sizeof(key->enc) + sizeof(key->sig),
  ------------------
  |  |   67|    768|#define static_assert _Static_assert
  ------------------
   19|    768|                  "extended secret key size is not the sum of the encryption and sign secret key sizes");
   20|    768|    memcpy(ext_key, key->enc, sizeof(key->enc));
   21|    768|    memcpy(&ext_key[sizeof(key->enc)], key->sig, sizeof(key->sig));
   22|       |
   23|    768|    return bin_pack_bin(bp, ext_key, sizeof(ext_key));
   24|    768|}
pack_extended_secret_key:
   27|    512|{
   28|    512|    uint8_t ext_key[EXT_SECRET_KEY_SIZE];
   29|    512|    static_assert(sizeof(ext_key) == sizeof(key->enc) + sizeof(key->sig),
  ------------------
  |  |   67|    512|#define static_assert _Static_assert
  ------------------
   30|    512|                  "extended secret key size is not the sum of the encryption and sign secret key sizes");
   31|    512|    memcpy(ext_key, key->enc, sizeof(key->enc));
   32|    512|    memcpy(&ext_key[sizeof(key->enc)], key->sig, sizeof(key->sig));
   33|       |
   34|    512|    const bool result = bin_pack_bin(bp, ext_key, sizeof(ext_key));
   35|    512|    crypto_memzero(ext_key, sizeof(ext_key));
   36|    512|    return result;
   37|    512|}
unpack_extended_public_key:
   40|    943|{
   41|    943|    uint8_t ext_key[EXT_PUBLIC_KEY_SIZE];
   42|       |
   43|    943|    if (!bin_unpack_bin_fixed(bu, ext_key, sizeof(ext_key))) {
  ------------------
  |  Branch (43:9): [True: 87, False: 856]
  ------------------
   44|     87|        return false;
   45|     87|    }
   46|       |
   47|    856|    memcpy(key->enc, ext_key, sizeof(key->enc));
   48|    856|    memcpy(key->sig, &ext_key[sizeof(key->enc)], sizeof(key->sig));
   49|       |
   50|       |    return true;
   51|    943|}
unpack_extended_secret_key:
   54|    440|{
   55|    440|    uint8_t ext_key[EXT_SECRET_KEY_SIZE];
   56|       |
   57|    440|    if (!bin_unpack_bin_fixed(bu, ext_key, sizeof(ext_key))) {
  ------------------
  |  Branch (57:9): [True: 27, False: 413]
  ------------------
   58|     27|        return false;
   59|     27|    }
   60|       |
   61|    413|    memcpy(key->enc, ext_key, sizeof(key->enc));
   62|    413|    memcpy(key->sig, &ext_key[sizeof(key->enc)], sizeof(key->sig));
   63|    413|    crypto_memzero(ext_key, sizeof(ext_key));
   64|       |
   65|       |    return true;
   66|    440|}

set_callback_forwarded_request:
  329|  2.80k|{
  330|  2.80k|    forwarding->forwarded_request_callback = function;
  331|  2.80k|    forwarding->forwarded_request_callback_object = object;
  332|  2.80k|}
new_forwarding:
  348|  1.40k|{
  349|  1.40k|    if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (349:9): [True: 0, False: 1.40k]
  |  Branch (349:27): [True: 0, False: 1.40k]
  |  Branch (349:51): [True: 0, False: 1.40k]
  ------------------
  350|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  351|      0|    }
  352|       |
  353|  1.40k|    Forwarding *forwarding = (Forwarding *)mem_alloc(mem, sizeof(Forwarding));
  354|       |
  355|  1.40k|    if (forwarding == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (355:9): [True: 0, False: 1.40k]
  ------------------
  356|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  357|      0|    }
  358|       |
  359|  1.40k|    forwarding->log = log;
  360|  1.40k|    forwarding->mem = mem;
  361|  1.40k|    forwarding->rng = rng;
  362|  1.40k|    forwarding->mono_time = mono_time;
  363|  1.40k|    forwarding->dht = dht;
  364|  1.40k|    forwarding->net = net;
  365|       |
  366|  1.40k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, &handle_forward_request, forwarding);
  367|  1.40k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, &handle_forward_reply, forwarding);
  368|  1.40k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, &handle_forwarding, forwarding);
  369|       |
  370|  1.40k|    new_hmac_key(forwarding->rng, forwarding->hmac_key);
  371|       |
  372|  1.40k|    return forwarding;
  373|  1.40k|}
kill_forwarding:
  376|  1.40k|{
  377|  1.40k|    if (forwarding == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (377:9): [True: 0, False: 1.40k]
  ------------------
  378|      0|        return;
  379|      0|    }
  380|       |
  381|  1.40k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  382|  1.40k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  383|  1.40k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  384|       |
  385|  1.40k|    crypto_memzero(forwarding->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  125|  1.40k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  386|       |
  387|  1.40k|    mem_delete(forwarding->mem, forwarding);
  388|  1.40k|}

friend_conn_get_onion_friendnum:
   96|     88|{
   97|     88|    return fc->onion_friendnum;
   98|     88|}
get_conn:
  198|  2.06k|{
  199|  2.06k|    if (!friendconn_id_valid(fr_c, friendcon_id)) {
  ------------------
  |  Branch (199:9): [True: 15, False: 2.04k]
  ------------------
  200|     15|        return nullptr;
  ------------------
  |  |   63|     15|#define nullptr NULL
  ------------------
  201|     15|    }
  202|       |
  203|  2.04k|    return &fr_c->conns[friendcon_id];
  204|  2.06k|}
getfriend_conn_id_pk:
  211|    431|{
  212|  1.00k|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (212:26): [True: 580, False: 429]
  ------------------
  213|    580|        const Friend_Conn *friend_con = get_conn(fr_c, i);
  214|       |
  215|    580|        if (friend_con != nullptr) {
  ------------------
  |  |   63|    580|#define nullptr NULL
  ------------------
  |  Branch (215:13): [True: 580, False: 0]
  ------------------
  216|    580|            if (pk_equal(friend_con->real_public_key, real_pk)) {
  ------------------
  |  Branch (216:17): [True: 2, False: 578]
  ------------------
  217|      2|                return i;
  218|      2|            }
  219|    580|        }
  220|    580|    }
  221|       |
  222|    429|    return -1;
  223|    431|}
friend_con_connected:
  662|    519|{
  663|    519|    const Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  664|       |
  665|    519|    if (friend_con == nullptr) {
  ------------------
  |  |   63|    519|#define nullptr NULL
  ------------------
  |  Branch (665:9): [True: 0, False: 519]
  ------------------
  666|      0|        return 0;
  667|      0|    }
  668|       |
  669|    519|    return friend_con->status;
  670|    519|}
friend_connection_callbacks:
  714|    431|{
  715|    431|    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  716|       |
  717|    431|    if (friend_con == nullptr) {
  ------------------
  |  |   63|    431|#define nullptr NULL
  ------------------
  |  Branch (717:9): [True: 0, False: 431]
  ------------------
  718|      0|        return -1;
  719|      0|    }
  720|       |
  721|    431|    if (index >= MAX_FRIEND_CONNECTION_CALLBACKS) {
  ------------------
  |  |   25|    431|#define MAX_FRIEND_CONNECTION_CALLBACKS 2
  ------------------
  |  Branch (721:9): [True: 0, False: 431]
  ------------------
  722|      0|        return -1;
  723|      0|    }
  724|       |
  725|    431|    if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   63|    862|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   63|    686|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   63|    686|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   63|    343|#define nullptr NULL
  ------------------
  |  Branch (725:9): [True: 343, False: 88]
  |  Branch (725:31): [True: 0, False: 343]
  |  Branch (725:61): [True: 0, False: 343]
  |  Branch (725:89): [True: 0, False: 343]
  ------------------
  726|      0|        LOGGER_ERROR(fr_c->logger, "non-null user data object but null callbacks");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  727|      0|        return -1;
  728|      0|    }
  729|       |
  730|    431|    friend_con->callbacks[index].status_callback = status_callback;
  731|    431|    friend_con->callbacks[index].data_callback = data_callback;
  732|    431|    friend_con->callbacks[index].lossy_data_callback = lossy_data_callback;
  733|       |
  734|    431|    friend_con->callbacks[index].callback_object = object;
  735|    431|    friend_con->callbacks[index].callback_id = number;
  736|       |
  737|    431|    return 0;
  738|    431|}
set_global_status_callback:
  742|  2.80k|{
  743|  2.80k|    if (object != nullptr && global_status_callback == nullptr) {
  ------------------
  |  |   63|  5.61k|#define nullptr NULL
  ------------------
                  if (object != nullptr && global_status_callback == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (743:9): [True: 1.40k, False: 1.40k]
  |  Branch (743:30): [True: 0, False: 1.40k]
  ------------------
  744|      0|        LOGGER_ERROR(fr_c->logger, "non-null user data object but null callback");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  745|      0|        object = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  746|      0|    }
  747|       |
  748|  2.80k|    fr_c->global_status_callback = global_status_callback;
  749|  2.80k|    fr_c->global_status_callback_object = object;
  750|  2.80k|}
new_friend_connection:
  775|    431|{
  776|    431|    int friendcon_id = getfriend_conn_id_pk(fr_c, real_public_key);
  777|       |
  778|    431|    if (friendcon_id != -1) {
  ------------------
  |  Branch (778:9): [True: 2, False: 429]
  ------------------
  779|      2|        ++fr_c->conns[friendcon_id].lock_count;
  780|      2|        return friendcon_id;
  781|      2|    }
  782|       |
  783|    429|    friendcon_id = create_friend_conn(fr_c);
  784|       |
  785|    429|    if (friendcon_id == -1) {
  ------------------
  |  Branch (785:9): [True: 0, False: 429]
  ------------------
  786|      0|        return -1;
  787|      0|    }
  788|       |
  789|    429|    const int32_t onion_friendnum = onion_addfriend(fr_c->onion_c, real_public_key);
  790|       |
  791|    429|    if (onion_friendnum == -1) {
  ------------------
  |  Branch (791:9): [True: 0, False: 429]
  ------------------
  792|      0|        return -1;
  793|      0|    }
  794|       |
  795|    429|    Friend_Conn *const friend_con = &fr_c->conns[friendcon_id];
  796|       |
  797|    429|    friend_con->crypt_connection_id = -1;
  798|    429|    friend_con->status = FRIENDCONN_STATUS_CONNECTING;
  799|    429|    memcpy(friend_con->real_public_key, real_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    429|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  800|    429|    friend_con->onion_friendnum = onion_friendnum;
  801|       |
  802|    429|    recv_tcp_relay_handler(fr_c->onion_c, onion_friendnum, &tcp_relay_node_callback, fr_c, friendcon_id);
  803|    429|    onion_dht_pk_callback(fr_c->onion_c, onion_friendnum, &dht_pk_callback, fr_c, friendcon_id);
  804|       |
  805|    429|    return friendcon_id;
  806|    429|}
kill_friend_connection:
  814|    446|{
  815|    446|    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  816|       |
  817|    446|    if (friend_con == nullptr) {
  ------------------
  |  |   63|    446|#define nullptr NULL
  ------------------
  |  Branch (817:9): [True: 15, False: 431]
  ------------------
  818|     15|        return -1;
  819|     15|    }
  820|       |
  821|    431|    if (friend_con->lock_count > 0) {
  ------------------
  |  Branch (821:9): [True: 2, False: 429]
  ------------------
  822|      2|        --friend_con->lock_count;
  823|      2|        return 0;
  824|      2|    }
  825|       |
  826|    429|    onion_delfriend(fr_c->onion_c, friend_con->onion_friendnum);
  827|    429|    crypto_kill(fr_c->net_crypto, friend_con->crypt_connection_id);
  828|       |
  829|    429|    if (friend_con->dht_lock_token > 0) {
  ------------------
  |  Branch (829:9): [True: 0, False: 429]
  ------------------
  830|      0|        dht_delfriend(fr_c->dht, friend_con->dht_temp_pk, friend_con->dht_lock_token);
  831|      0|        friend_con->dht_lock_token = 0;
  832|      0|    }
  833|       |
  834|    429|    return wipe_friend_conn(fr_c, friendcon_id);
  835|    431|}
set_friend_request_callback:
  842|  1.40k|{
  843|  1.40k|    fr_c->fr_request_callback = fr_request_callback;
  844|  1.40k|    fr_c->fr_request_object = object;
  845|  1.40k|    oniondata_registerhandler(fr_c->onion_c, CRYPTO_PACKET_FRIEND_REQ, fr_request_callback, object);
  ------------------
  |  |   69|  1.40k|#define CRYPTO_PACKET_FRIEND_REQ    32  // Friend request crypto packet ID.
  ------------------
  846|  1.40k|}
new_friend_connections:
  897|  1.40k|{
  898|  1.40k|    if (onion_c == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (898:9): [True: 0, False: 1.40k]
  ------------------
  899|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  900|      0|    }
  901|       |
  902|  1.40k|    Friend_Connections *const temp = (Friend_Connections *)mem_alloc(mem, sizeof(Friend_Connections));
  903|       |
  904|  1.40k|    if (temp == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (904:9): [True: 0, False: 1.40k]
  ------------------
  905|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  906|      0|    }
  907|       |
  908|  1.40k|    temp->local_discovery_enabled = local_discovery_enabled;
  909|       |
  910|  1.40k|    if (temp->local_discovery_enabled) {
  ------------------
  |  Branch (910:9): [True: 1.40k, False: 0]
  ------------------
  911|  1.40k|        temp->broadcast = lan_discovery_init(mem, ns);
  912|       |
  913|  1.40k|        if (temp->broadcast == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (913:13): [True: 0, False: 1.40k]
  ------------------
  914|      0|            LOGGER_ERROR(logger, "could not initialise LAN discovery");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  915|      0|            temp->local_discovery_enabled = false;
  916|      0|        }
  917|  1.40k|    }
  918|       |
  919|  1.40k|    temp->mono_time = mono_time;
  920|  1.40k|    temp->mem = mem;
  921|  1.40k|    temp->logger = logger;
  922|  1.40k|    temp->dht = dht;
  923|  1.40k|    temp->net = net;
  924|  1.40k|    temp->net_crypto = net_crypto;
  925|  1.40k|    temp->onion_c = onion_c;
  926|       |    // Don't include default port in port range
  927|  1.40k|    temp->next_lan_port = TOX_PORTRANGE_FROM + 1;
  ------------------
  |  |   79|  1.40k|#define TOX_PORTRANGE_FROM 33445
  ------------------
  928|       |
  929|  1.40k|    new_connection_handler(temp->net_crypto, &handle_new_connections, temp);
  930|       |
  931|  1.40k|    return temp;
  932|  1.40k|}
kill_friend_connections:
 1014|  1.40k|{
 1015|  1.40k|    if (fr_c == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (1015:9): [True: 0, False: 1.40k]
  ------------------
 1016|      0|        return;
 1017|      0|    }
 1018|       |
 1019|  1.76k|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (1019:26): [True: 358, False: 1.40k]
  ------------------
 1020|    358|        kill_friend_connection(fr_c, i);
 1021|    358|    }
 1022|       |
 1023|       |    // there might be allocated NONE connections
 1024|  1.40k|    if (fr_c->conns != nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (1024:9): [True: 0, False: 1.40k]
  ------------------
 1025|      0|        mem_delete(fr_c->mem, fr_c->conns);
 1026|      0|    }
 1027|       |
 1028|  1.40k|    lan_discovery_kill(fr_c->broadcast);
 1029|  1.40k|    mem_delete(fr_c->mem, fr_c);
 1030|  1.40k|}
friend_connection.c:friendconn_id_valid:
  115|  2.49k|{
  116|  2.49k|    return (unsigned int)friendcon_id < fr_c->num_cons &&
  ------------------
  |  Branch (116:12): [True: 2.49k, False: 0]
  ------------------
  117|  2.49k|           fr_c->conns != nullptr &&
  ------------------
  |  |   63|  4.98k|#define nullptr NULL
  ------------------
  |  Branch (117:12): [True: 2.49k, False: 0]
  ------------------
  118|  2.49k|           fr_c->conns[friendcon_id].status != FRIENDCONN_STATUS_NONE;
  ------------------
  |  Branch (118:12): [True: 2.47k, False: 15]
  ------------------
  119|  2.49k|}
friend_connection.c:create_friend_conn:
  150|    429|{
  151|  1.00k|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (151:26): [True: 578, False: 429]
  ------------------
  152|    578|        if (fr_c->conns[i].status == FRIENDCONN_STATUS_NONE) {
  ------------------
  |  Branch (152:13): [True: 0, False: 578]
  ------------------
  153|      0|            return i;
  154|      0|        }
  155|    578|    }
  156|       |
  157|    429|    if (!realloc_friendconns(fr_c, fr_c->num_cons + 1)) {
  ------------------
  |  Branch (157:9): [True: 0, False: 429]
  ------------------
  158|      0|        return -1;
  159|      0|    }
  160|       |
  161|    429|    const int id = fr_c->num_cons;
  162|    429|    ++fr_c->num_cons;
  163|    429|    fr_c->conns[id] = empty_friend_conn;
  164|       |
  165|    429|    return id;
  166|    429|}
friend_connection.c:realloc_friendconns:
  127|    617|{
  128|    617|    if (num == 0) {
  ------------------
  |  Branch (128:9): [True: 184, False: 433]
  ------------------
  129|    184|        mem_delete(fr_c->mem, fr_c->conns);
  130|    184|        fr_c->conns = nullptr;
  ------------------
  |  |   63|    184|#define nullptr NULL
  ------------------
  131|    184|        return true;
  132|    184|    }
  133|       |
  134|    433|    Friend_Conn *newgroup_cons = (Friend_Conn *)mem_vrealloc(fr_c->mem, fr_c->conns, num, sizeof(Friend_Conn));
  135|       |
  136|    433|    if (newgroup_cons == nullptr) {
  ------------------
  |  |   63|    433|#define nullptr NULL
  ------------------
  |  Branch (136:9): [True: 0, False: 433]
  ------------------
  137|      0|        return false;
  138|      0|    }
  139|       |
  140|    433|    fr_c->conns = newgroup_cons;
  141|       |    return true;
  142|    433|}
friend_connection.c:wipe_friend_conn:
  174|    429|{
  175|    429|    if (!friendconn_id_valid(fr_c, friendcon_id)) {
  ------------------
  |  Branch (175:9): [True: 0, False: 429]
  ------------------
  176|      0|        return -1;
  177|      0|    }
  178|       |
  179|    429|    fr_c->conns[friendcon_id] = empty_friend_conn;
  180|       |
  181|    429|    uint32_t i;
  182|       |
  183|    858|    for (i = fr_c->num_cons; i != 0; --i) {
  ------------------
  |  Branch (183:30): [True: 674, False: 184]
  ------------------
  184|    674|        if (fr_c->conns[i - 1].status != FRIENDCONN_STATUS_NONE) {
  ------------------
  |  Branch (184:13): [True: 245, False: 429]
  ------------------
  185|    245|            break;
  186|    245|        }
  187|    674|    }
  188|       |
  189|    429|    if (fr_c->num_cons != i) {
  ------------------
  |  Branch (189:9): [True: 188, False: 241]
  ------------------
  190|    188|        fr_c->num_cons = i;
  191|    188|        realloc_friendconns(fr_c, fr_c->num_cons);
  192|    188|    }
  193|       |
  194|    429|    return 0;
  195|    429|}

set_nospam:
   54|  1.96k|{
   55|  1.96k|    fr->nospam = num;
   56|  1.96k|}
get_nospam:
   59|    981|{
   60|    981|    return fr->nospam;
   61|    981|}
callback_friendrequest:
   65|  1.40k|{
   66|  1.40k|    fr->handle_friendrequest = function;
   67|  1.40k|    fr->handle_friendrequest_isset = 1;
   68|  1.40k|    fr->handle_friendrequest_object = object;
   69|  1.40k|}
set_filter_function:
   75|  1.40k|{
   76|  1.40k|    fr->filter_function = function;
   77|  1.40k|    fr->filter_function_userdata = userdata;
   78|  1.40k|}
remove_request_received:
  113|     88|{
  114|  2.90k|    for (uint32_t i = 0; i < MAX_RECEIVED_STORED; ++i) {
  ------------------
  |  |   31|  2.90k|#define MAX_RECEIVED_STORED 32
  ------------------
  |  Branch (114:26): [True: 2.81k, False: 88]
  ------------------
  115|  2.81k|        if (pk_equal(fr->received.requests[i], real_pk)) {
  ------------------
  |  Branch (115:13): [True: 0, False: 2.81k]
  ------------------
  116|      0|            crypto_memzero(fr->received.requests[i], CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  117|      0|            return 0;
  118|      0|        }
  119|  2.81k|    }
  120|       |
  121|     88|    return -1;
  122|     88|}
friendreq_init:
  165|  1.40k|{
  166|  1.40k|    set_friend_request_callback(fr_c, &friendreq_handlepacket, fr);
  167|  1.40k|}
friendreq_new:
  170|  1.40k|{
  171|  1.40k|    Friend_Requests *fr = (Friend_Requests *)mem_alloc(mem, sizeof(Friend_Requests));
  172|       |
  173|  1.40k|    if (fr == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (173:9): [True: 0, False: 1.40k]
  ------------------
  174|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  175|      0|    }
  176|       |
  177|  1.40k|    fr->mem = mem;
  178|       |
  179|  1.40k|    return fr;
  180|  1.40k|}
friendreq_kill:
  183|  1.40k|{
  184|  1.40k|    if (fr == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (184:9): [True: 0, False: 1.40k]
  ------------------
  185|      0|        return;
  186|      0|    }
  187|       |
  188|  1.40k|    mem_delete(fr->mem, fr);
  189|  1.40k|}

del_groupchat:
 1344|  2.48k|{
 1345|  2.48k|    Group_c *g = get_group_c(g_c, groupnumber);
 1346|       |
 1347|  2.48k|    if (g == nullptr) {
  ------------------
  |  |   63|  2.48k|#define nullptr NULL
  ------------------
  |  Branch (1347:9): [True: 0, False: 2.48k]
  ------------------
 1348|      0|        return false;
 1349|      0|    }
 1350|       |
 1351|  2.48k|    group_leave(g_c, groupnumber, leave_permanently);
 1352|       |
 1353|  42.3k|    for (uint32_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
  ------------------
  |  |   56|  42.3k|#define MAX_GROUP_CONNECTIONS 16
  ------------------
  |  Branch (1353:26): [True: 39.8k, False: 2.48k]
  ------------------
 1354|  39.8k|        if (g->connections[i].type == GROUPCHAT_CONNECTION_NONE) {
  ------------------
  |  Branch (1354:13): [True: 39.8k, False: 0]
  ------------------
 1355|  39.8k|            continue;
 1356|  39.8k|        }
 1357|       |
 1358|      0|        g->connections[i].type = GROUPCHAT_CONNECTION_NONE;
 1359|      0|        kill_friend_connection(g_c->fr_c, g->connections[i].number);
 1360|      0|    }
 1361|       |
 1362|  4.97k|    for (uint32_t i = 0; i < g->numpeers; ++i) {
  ------------------
  |  Branch (1362:26): [True: 2.48k, False: 2.48k]
  ------------------
 1363|  2.48k|        if (g->peer_on_leave != nullptr) {
  ------------------
  |  |   63|  2.48k|#define nullptr NULL
  ------------------
  |  Branch (1363:13): [True: 0, False: 2.48k]
  ------------------
 1364|      0|            g->peer_on_leave(g->object, groupnumber, g->group[i].object);
 1365|      0|        }
 1366|  2.48k|    }
 1367|       |
 1368|  2.48k|    if (g->group_on_delete != nullptr) {
  ------------------
  |  |   63|  2.48k|#define nullptr NULL
  ------------------
  |  Branch (1368:9): [True: 0, False: 2.48k]
  ------------------
 1369|      0|        g->group_on_delete(g->object, groupnumber);
 1370|      0|    }
 1371|       |
 1372|  2.48k|    return wipe_group_chat(g_c, groupnumber);
 1373|  2.48k|}
g_callback_group_invite:
 1810|    981|{
 1811|    981|    g_c->invite_callback = function;
 1812|    981|}
g_callback_group_connected:
 1816|    981|{
 1817|    981|    g_c->connected_callback = function;
 1818|    981|}
g_callback_group_message:
 1822|    981|{
 1823|    981|    g_c->message_callback = function;
 1824|    981|}
g_callback_peer_name:
 1831|    981|{
 1832|    981|    g_c->peer_name_callback = function;
 1833|    981|}
g_callback_peer_list_changed:
 1840|    981|{
 1841|    981|    g_c->peer_list_changed_callback = function;
 1842|    981|}
g_callback_group_title:
 1846|    981|{
 1847|    981|    g_c->title_callback = function;
 1848|    981|}
conferences_size:
 3475|  1.96k|{
 3476|  1.96k|    return 2 * sizeof(uint32_t) + conferences_section_size(g_c);
 3477|  1.96k|}
conferences_save:
 3480|    981|{
 3481|    981|    const uint32_t len = conferences_section_size(g_c);
 3482|    981|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_CONFERENCES);
  ------------------
  |  |   31|    981|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3483|       |
 3484|  2.38k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3484:26): [True: 1.40k, False: 981]
  ------------------
 3485|  1.40k|        const Group_c *g = get_group_c(g_c, i);
 3486|       |
 3487|  1.40k|        if (g == nullptr || g->status != GROUPCHAT_STATUS_CONNECTED) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
  |  Branch (3487:13): [True: 0, False: 1.40k]
  |  Branch (3487:29): [True: 0, False: 1.40k]
  ------------------
 3488|      0|            continue;
 3489|      0|        }
 3490|       |
 3491|  1.40k|        data = save_conf(g, data);
 3492|  1.40k|    }
 3493|       |
 3494|    981|    return data;
 3495|    981|}
conferences_load_state_section:
 3684|    938|{
 3685|    938|    if (type != STATE_TYPE_CONFERENCES) {
  ------------------
  |  Branch (3685:9): [True: 370, False: 568]
  ------------------
 3686|    370|        return false;
 3687|    370|    }
 3688|       |
 3689|    568|    *status = load_conferences(g_c, data, length);
 3690|       |    return true;
 3691|    938|}
new_groupchats:
 3695|  1.40k|{
 3696|  1.40k|    if (m == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3696:9): [True: 0, False: 1.40k]
  ------------------
 3697|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3698|      0|    }
 3699|       |
 3700|  1.40k|    Group_Chats *temp = (Group_Chats *)mem_alloc(mem, sizeof(Group_Chats));
 3701|       |
 3702|  1.40k|    if (temp == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3702:9): [True: 0, False: 1.40k]
  ------------------
 3703|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3704|      0|    }
 3705|       |
 3706|  1.40k|    temp->mem = mem;
 3707|  1.40k|    temp->mono_time = mono_time;
 3708|  1.40k|    temp->m = m;
 3709|  1.40k|    temp->fr_c = m->fr_c;
 3710|  1.40k|    m_callback_conference_invite(m, &handle_friend_invite_packet);
 3711|       |
 3712|  1.40k|    set_global_status_callback(m->fr_c, &g_handle_any_status, temp);
 3713|       |
 3714|  1.40k|    return temp;
 3715|  1.40k|}
kill_groupchats:
 3749|  1.40k|{
 3750|  1.40k|    if (g_c == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3750:9): [True: 0, False: 1.40k]
  ------------------
 3751|      0|        return;
 3752|      0|    }
 3753|       |
 3754|  3.89k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3754:26): [True: 2.48k, False: 1.40k]
  ------------------
 3755|  2.48k|        del_groupchat(g_c, i, false);
 3756|  2.48k|    }
 3757|       |
 3758|  1.40k|    m_callback_conference_invite(g_c->m, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 3759|  1.40k|    set_global_status_callback(g_c->m->fr_c, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  set_global_status_callback(g_c->m->fr_c, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 3760|       |    g_c->m->conferences_object = nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 3761|  1.40k|    mem_delete(g_c->mem, g_c);
 3762|  1.40k|}
group.c:create_group_chat:
  280|  8.25k|{
  281|   697k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (281:26): [True: 689k, False: 8.25k]
  ------------------
  282|   689k|        if (g_c->chats[i].status == GROUPCHAT_STATUS_NONE) {
  ------------------
  |  Branch (282:13): [True: 0, False: 689k]
  ------------------
  283|      0|            return i;
  284|      0|        }
  285|   689k|    }
  286|       |
  287|  8.25k|    if (realloc_conferences(g_c, g_c->num_chats + 1)) {
  ------------------
  |  Branch (287:9): [True: 8.25k, False: 0]
  ------------------
  288|  8.25k|        const uint16_t id = g_c->num_chats;
  289|  8.25k|        ++g_c->num_chats;
  290|  8.25k|        setup_conference(&g_c->chats[id]);
  291|  8.25k|        return id;
  292|  8.25k|    }
  293|       |
  294|      0|    return -1;
  295|  8.25k|}
group.c:realloc_conferences:
  251|  8.43k|{
  252|  8.43k|    if (num == 0) {
  ------------------
  |  Branch (252:9): [True: 124, False: 8.31k]
  ------------------
  253|    124|        mem_delete(g_c->mem, g_c->chats);
  254|    124|        g_c->chats = nullptr;
  ------------------
  |  |   63|    124|#define nullptr NULL
  ------------------
  255|    124|        return true;
  256|    124|    }
  257|       |
  258|  8.31k|    Group_c *newgroup_chats = (Group_c *)mem_vrealloc(g_c->mem, g_c->chats, num, sizeof(Group_c));
  259|       |
  260|  8.31k|    if (newgroup_chats == nullptr) {
  ------------------
  |  |   63|  8.31k|#define nullptr NULL
  ------------------
  |  Branch (260:9): [True: 0, False: 8.31k]
  ------------------
  261|      0|        return false;
  262|      0|    }
  263|       |
  264|  8.31k|    g_c->chats = newgroup_chats;
  265|       |    return true;
  266|  8.31k|}
group.c:setup_conference:
  269|  16.5k|{
  270|  16.5k|    *g = empty_group_c;
  271|  16.5k|    g->maxfrozen = MAX_FROZEN_DEFAULT;
  ------------------
  |  |   61|  16.5k|#define MAX_FROZEN_DEFAULT 128
  ------------------
  272|  16.5k|}
group.c:addpeer:
  765|  8.18k|{
  766|  8.18k|    Group_c *g = get_group_c(g_c, groupnumber);
  767|  8.18k|    if (g == nullptr) {
  ------------------
  |  |   63|  8.18k|#define nullptr NULL
  ------------------
  |  Branch (767:9): [True: 0, False: 8.18k]
  ------------------
  768|      0|        return -1;
  769|      0|    }
  770|       |
  771|  8.18k|    const int peer_index = fresh ?
  ------------------
  |  Branch (771:28): [True: 8.18k, False: 0]
  ------------------
  772|  8.18k|                           note_peer_active(g_c, groupnumber, peer_number, userdata) :
  773|  8.18k|                           get_peer_index(g, peer_number);
  774|       |
  775|  8.18k|    if (peer_index != -1) {
  ------------------
  |  Branch (775:9): [True: 39, False: 8.14k]
  ------------------
  776|     39|        if (!pk_equal(g->group[peer_index].real_pk, real_pk)) {
  ------------------
  |  Branch (776:13): [True: 5, False: 34]
  ------------------
  777|      5|            LOGGER_ERROR(g_c->m->log, "peer public key is incorrect for peer %d", peer_number);
  ------------------
  |  |   80|      5|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      5|    do {                                                                         \
  |  |  |  |   70|      5|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     10|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 5, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      5|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      5|        }                                                                        \
  |  |  |  |   73|      5|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 5]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  778|      5|            return -1;
  779|      5|        }
  780|       |
  781|     34|        if (fresh || !g->group[peer_index].temp_pk_updated) {
  ------------------
  |  Branch (781:13): [True: 34, False: 0]
  |  Branch (781:22): [True: 0, False: 0]
  ------------------
  782|     34|            pk_copy(g->group[peer_index].temp_pk, temp_pk);
  783|     34|            g->group[peer_index].temp_pk_updated = true;
  784|     34|        }
  785|       |
  786|     34|        return peer_index;
  787|     39|    }
  788|       |
  789|  8.14k|    if (!fresh) {
  ------------------
  |  Branch (789:9): [True: 0, False: 8.14k]
  ------------------
  790|      0|        const int frozen_index = get_frozen_index(g, peer_number);
  791|       |
  792|      0|        if (frozen_index != -1) {
  ------------------
  |  Branch (792:13): [True: 0, False: 0]
  ------------------
  793|      0|            if (!pk_equal(g->frozen[frozen_index].real_pk, real_pk)) {
  ------------------
  |  Branch (793:17): [True: 0, False: 0]
  ------------------
  794|      0|                return -1;
  795|      0|            }
  796|       |
  797|      0|            pk_copy(g->frozen[frozen_index].temp_pk, temp_pk);
  798|       |
  799|      0|            return -1;
  800|      0|        }
  801|      0|    }
  802|       |
  803|  8.14k|    delete_any_peer_with_pk(g_c, groupnumber, real_pk, userdata);
  804|       |
  805|  8.14k|    Group_Peer *temp = (Group_Peer *)mem_vrealloc(g_c->mem, g->group, g->numpeers + 1, sizeof(Group_Peer));
  806|       |
  807|  8.14k|    if (temp == nullptr) {
  ------------------
  |  |   63|  8.14k|#define nullptr NULL
  ------------------
  |  Branch (807:9): [True: 0, False: 8.14k]
  ------------------
  808|      0|        return -1;
  809|      0|    }
  810|       |
  811|  8.14k|    temp[g->numpeers] = empty_group_peer;
  812|  8.14k|    g->group = temp;
  813|       |
  814|  8.14k|    const uint32_t new_index = g->numpeers;
  815|       |
  816|  8.14k|    pk_copy(g->group[new_index].real_pk, real_pk);
  817|  8.14k|    pk_copy(g->group[new_index].temp_pk, temp_pk);
  818|  8.14k|    g->group[new_index].temp_pk_updated = true;
  819|  8.14k|    g->group[new_index].peer_number = peer_number;
  820|  8.14k|    g->group[new_index].last_active = mono_time_get(g_c->mono_time);
  821|  8.14k|    g->group[new_index].is_friend = getfriend_id(g_c->m, real_pk) != -1;
  822|  8.14k|    ++g->numpeers;
  823|       |
  824|  8.14k|    add_to_closest(g, real_pk, temp_pk);
  825|       |
  826|  8.14k|    if (do_gc_callback && g_c->peer_list_changed_callback != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (826:9): [True: 0, False: 8.14k]
  |  Branch (826:27): [True: 0, False: 0]
  ------------------
  827|      0|        g_c->peer_list_changed_callback(g_c->m, groupnumber, userdata);
  828|      0|    }
  829|       |
  830|  8.14k|    if (g->peer_on_join != nullptr) {
  ------------------
  |  |   63|  8.14k|#define nullptr NULL
  ------------------
  |  Branch (830:9): [True: 0, False: 8.14k]
  ------------------
  831|      0|        g->peer_on_join(g->object, groupnumber, new_index);
  832|      0|    }
  833|       |
  834|  8.14k|    return new_index;
  835|  8.14k|}
group.c:note_peer_active:
  677|  8.18k|{
  678|  8.18k|    Group_c *g = get_group_c(g_c, groupnumber);
  679|  8.18k|    if (g == nullptr) {
  ------------------
  |  |   63|  8.18k|#define nullptr NULL
  ------------------
  |  Branch (679:9): [True: 0, False: 8.18k]
  ------------------
  680|      0|        return -1;
  681|      0|    }
  682|       |
  683|  8.18k|    const int peer_index = get_peer_index(g, peer_number);
  684|       |
  685|  8.18k|    if (peer_index != -1) {
  ------------------
  |  Branch (685:9): [True: 0, False: 8.18k]
  ------------------
  686|      0|        g->group[peer_index].last_active = mono_time_get(g_c->mono_time);
  687|      0|        return peer_index;
  688|      0|    }
  689|       |
  690|  8.18k|    const int frozen_index = get_frozen_index(g, peer_number);
  691|       |
  692|  8.18k|    if (frozen_index == -1) {
  ------------------
  |  Branch (692:9): [True: 8.14k, False: 39]
  ------------------
  693|  8.14k|        return -1;
  694|  8.14k|    }
  695|       |
  696|       |    /* Now thaw the peer */
  697|       |
  698|     39|    Group_Peer *temp = (Group_Peer *)mem_vrealloc(g_c->mem, g->group, g->numpeers + 1, sizeof(Group_Peer));
  699|       |
  700|     39|    if (temp == nullptr) {
  ------------------
  |  |   63|     39|#define nullptr NULL
  ------------------
  |  Branch (700:9): [True: 0, False: 39]
  ------------------
  701|      0|        return -1;
  702|      0|    }
  703|       |
  704|     39|    const uint32_t thawed_index = g->numpeers;
  705|       |
  706|     39|    g->group = temp;
  707|     39|    g->group[thawed_index] = g->frozen[frozen_index];
  708|     39|    g->group[thawed_index].temp_pk_updated = false;
  709|     39|    g->group[thawed_index].last_active = mono_time_get(g_c->mono_time);
  710|       |
  711|     39|    add_to_closest(g, g->group[thawed_index].real_pk, g->group[thawed_index].temp_pk);
  712|       |
  713|     39|    ++g->numpeers;
  714|       |
  715|     39|    delete_frozen(g_c->mem, g, frozen_index);
  716|       |
  717|     39|    if (g_c->peer_list_changed_callback != nullptr) {
  ------------------
  |  |   63|     39|#define nullptr NULL
  ------------------
  |  Branch (717:9): [True: 0, False: 39]
  ------------------
  718|      0|        g_c->peer_list_changed_callback(g_c->m, groupnumber, userdata);
  719|      0|    }
  720|       |
  721|     39|    if (g->peer_on_join != nullptr) {
  ------------------
  |  |   63|     39|#define nullptr NULL
  ------------------
  |  Branch (721:9): [True: 0, False: 39]
  ------------------
  722|      0|        g->peer_on_join(g->object, groupnumber, thawed_index);
  723|      0|    }
  724|       |
  725|     39|    g->need_send_name = true;
  726|       |
  727|     39|    return thawed_index;
  728|     39|}
group.c:delete_frozen:
  644|     59|{
  645|     59|    if (frozen_index >= g->numfrozen) {
  ------------------
  |  Branch (645:9): [True: 0, False: 59]
  ------------------
  646|      0|        return false;
  647|      0|    }
  648|       |
  649|     59|    --g->numfrozen;
  650|       |
  651|     59|    if (g->numfrozen == 0) {
  ------------------
  |  Branch (651:9): [True: 54, False: 5]
  ------------------
  652|     54|        mem_delete(mem, g->frozen);
  653|     54|        g->frozen = nullptr;
  ------------------
  |  |   63|     54|#define nullptr NULL
  ------------------
  654|     54|    } else {
  655|      5|        if (g->numfrozen != frozen_index) {
  ------------------
  |  Branch (655:13): [True: 3, False: 2]
  ------------------
  656|      3|            g->frozen[frozen_index] = g->frozen[g->numfrozen];
  657|      3|        }
  658|       |
  659|      5|        Group_Peer *const frozen_temp = (Group_Peer *)mem_vrealloc(mem, g->frozen, g->numfrozen, sizeof(Group_Peer));
  660|       |
  661|      5|        if (frozen_temp == nullptr) {
  ------------------
  |  |   63|      5|#define nullptr NULL
  ------------------
  |  Branch (661:13): [True: 0, False: 5]
  ------------------
  662|      0|            return false;
  663|      0|        }
  664|       |
  665|      5|        g->frozen = frozen_temp;
  666|      5|    }
  667|       |
  668|     59|    return true;
  669|     59|}
group.c:get_peer_index:
  410|  8.18k|{
  411|  8.18k|    for (uint32_t i = 0; i < g->numpeers; ++i) {
  ------------------
  |  Branch (411:26): [True: 0, False: 8.18k]
  ------------------
  412|      0|        if (g->group[i].peer_number == peer_number) {
  ------------------
  |  Branch (412:13): [True: 0, False: 0]
  ------------------
  413|      0|            return i;
  414|      0|        }
  415|      0|    }
  416|       |
  417|  8.18k|    return -1;
  418|  8.18k|}
group.c:get_frozen_index:
  633|  8.18k|{
  634|  8.39k|    for (uint32_t i = 0; i < g->numfrozen; ++i) {
  ------------------
  |  Branch (634:26): [True: 250, False: 8.14k]
  ------------------
  635|    250|        if (g->frozen[i].peer_number == peer_number) {
  ------------------
  |  Branch (635:13): [True: 39, False: 211]
  ------------------
  636|     39|            return i;
  637|     39|        }
  638|    250|    }
  639|       |
  640|  8.14k|    return -1;
  641|  8.18k|}
group.c:delete_any_peer_with_pk:
  732|  8.14k|{
  733|  8.14k|    Group_c *g = get_group_c(g_c, groupnumber);
  734|  8.14k|    if (g == nullptr) {
  ------------------
  |  |   63|  8.14k|#define nullptr NULL
  ------------------
  |  Branch (734:9): [True: 0, False: 8.14k]
  ------------------
  735|      0|        return;
  736|      0|    }
  737|       |
  738|  8.14k|    const int peer_index = peer_in_group(g, real_pk);
  739|       |
  740|  8.14k|    if (peer_index >= 0) {
  ------------------
  |  Branch (740:9): [True: 0, False: 8.14k]
  ------------------
  741|      0|        delpeer(g_c, groupnumber, peer_index, userdata);
  742|      0|    }
  743|       |
  744|  8.14k|    const int frozen_index = frozen_in_group(g, real_pk);
  745|       |
  746|  8.14k|    if (frozen_index >= 0) {
  ------------------
  |  Branch (746:9): [True: 20, False: 8.12k]
  ------------------
  747|     20|        delete_frozen(g_c->mem, g, frozen_index);
  748|     20|    }
  749|  8.14k|}
group.c:peer_in_group:
  350|  8.14k|{
  351|  8.14k|    for (uint32_t i = 0; i < g->numpeers; ++i) {
  ------------------
  |  Branch (351:26): [True: 0, False: 8.14k]
  ------------------
  352|      0|        if (pk_equal(g->group[i].real_pk, real_pk)) {
  ------------------
  |  Branch (352:13): [True: 0, False: 0]
  ------------------
  353|      0|            return i;
  354|      0|        }
  355|      0|    }
  356|       |
  357|  8.14k|    return -1;
  358|  8.14k|}
group.c:frozen_in_group:
  361|  8.14k|{
  362|  8.33k|    for (uint32_t i = 0; i < g->numfrozen; ++i) {
  ------------------
  |  Branch (362:26): [True: 208, False: 8.12k]
  ------------------
  363|    208|        if (pk_equal(g->frozen[i].real_pk, real_pk)) {
  ------------------
  |  Branch (363:13): [True: 20, False: 188]
  ------------------
  364|     20|            return i;
  365|     20|        }
  366|    208|    }
  367|       |
  368|  8.12k|    return -1;
  369|  8.14k|}
group.c:add_to_closest:
  440|  8.18k|{
  441|  8.18k|    if (pk_equal(g->real_pk, real_pk)) {
  ------------------
  |  Branch (441:9): [True: 8.17k, False: 5]
  ------------------
  442|  8.17k|        return false;
  443|  8.17k|    }
  444|       |
  445|      5|    unsigned int index = DESIRED_CLOSEST;
  ------------------
  |  |   55|      5|#define DESIRED_CLOSEST 4
  ------------------
  446|       |
  447|     25|    for (unsigned int i = 0; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   55|     25|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (447:30): [True: 20, False: 5]
  ------------------
  448|     20|        if (g->closest_peers[i].active && pk_equal(real_pk, g->closest_peers[i].real_pk)) {
  ------------------
  |  Branch (448:13): [True: 0, False: 20]
  |  Branch (448:43): [True: 0, False: 0]
  ------------------
  449|      0|            return true;
  450|      0|        }
  451|     20|    }
  452|       |
  453|      5|    for (unsigned int i = 0; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   55|      5|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (453:30): [True: 5, False: 0]
  ------------------
  454|      5|        if (!g->closest_peers[i].active) {
  ------------------
  |  Branch (454:13): [True: 5, False: 0]
  ------------------
  455|      5|            index = i;
  456|      5|            break;
  457|      5|        }
  458|      5|    }
  459|       |
  460|      5|    if (index == DESIRED_CLOSEST) {
  ------------------
  |  |   55|      5|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (460:9): [True: 0, False: 5]
  ------------------
  461|      0|        uint64_t comp_val = calculate_comp_value(g->real_pk, real_pk);
  462|      0|        uint64_t comp_d = 0;
  463|       |
  464|      0|        for (unsigned int i = 0; i < (DESIRED_CLOSEST / 2); ++i) {
  ------------------
  |  |   55|      0|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (464:34): [True: 0, False: 0]
  ------------------
  465|      0|            const uint64_t comp = calculate_comp_value(g->real_pk, g->closest_peers[i].real_pk);
  466|       |
  467|      0|            if (comp > comp_val && comp > comp_d) {
  ------------------
  |  Branch (467:17): [True: 0, False: 0]
  |  Branch (467:36): [True: 0, False: 0]
  ------------------
  468|      0|                index = i;
  469|      0|                comp_d = comp;
  470|      0|            }
  471|      0|        }
  472|       |
  473|      0|        comp_val = calculate_comp_value(real_pk, g->real_pk);
  474|       |
  475|      0|        for (unsigned int i = DESIRED_CLOSEST / 2; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   55|      0|#define DESIRED_CLOSEST 4
  ------------------
                      for (unsigned int i = DESIRED_CLOSEST / 2; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   55|      0|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (475:52): [True: 0, False: 0]
  ------------------
  476|      0|            const uint64_t comp = calculate_comp_value(g->closest_peers[i].real_pk, g->real_pk);
  477|       |
  478|      0|            if (comp > comp_val && comp > comp_d) {
  ------------------
  |  Branch (478:17): [True: 0, False: 0]
  |  Branch (478:36): [True: 0, False: 0]
  ------------------
  479|      0|                index = i;
  480|      0|                comp_d = comp;
  481|      0|            }
  482|      0|        }
  483|      0|    }
  484|       |
  485|      5|    if (index == DESIRED_CLOSEST) {
  ------------------
  |  |   55|      5|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (485:9): [True: 0, False: 5]
  ------------------
  486|      0|        return false;
  487|      0|    }
  488|       |
  489|      5|    uint8_t old_real_pk[CRYPTO_PUBLIC_KEY_SIZE];
  490|      5|    uint8_t old_temp_pk[CRYPTO_PUBLIC_KEY_SIZE];
  491|      5|    bool old = false;
  492|       |
  493|      5|    if (g->closest_peers[index].active) {
  ------------------
  |  Branch (493:9): [True: 0, False: 5]
  ------------------
  494|      0|        memcpy(old_real_pk, g->closest_peers[index].real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  495|      0|        memcpy(old_temp_pk, g->closest_peers[index].temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  496|      0|        old = true;
  497|      0|    }
  498|       |
  499|      5|    g->closest_peers[index].active = true;
  500|      5|    memcpy(g->closest_peers[index].real_pk, real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      5|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  501|      5|    memcpy(g->closest_peers[index].temp_pk, temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      5|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  502|       |
  503|      5|    if (old) {
  ------------------
  |  Branch (503:9): [True: 0, False: 5]
  ------------------
  504|      0|        add_to_closest(g, old_real_pk, old_temp_pk);
  505|      0|    }
  506|       |
  507|      5|    if (g->changed == GROUPCHAT_CLOSEST_CHANGE_NONE) {
  ------------------
  |  Branch (507:9): [True: 5, False: 0]
  ------------------
  508|      5|        g->changed = GROUPCHAT_CLOSEST_CHANGE_ADDED;
  509|      5|    }
  510|       |
  511|       |    return true;
  512|      5|}
group.c:setnick:
 1054|  8.17k|{
 1055|  8.17k|    if (nick_len > MAX_NAME_LENGTH) {
  ------------------
  |  |   39|  8.17k|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (1055:9): [True: 0, False: 8.17k]
  ------------------
 1056|      0|        return false;
 1057|      0|    }
 1058|       |
 1059|  8.17k|    Group_c *g = get_group_c(g_c, groupnumber);
 1060|       |
 1061|  8.17k|    if (g == nullptr) {
  ------------------
  |  |   63|  8.17k|#define nullptr NULL
  ------------------
  |  Branch (1061:9): [True: 0, False: 8.17k]
  ------------------
 1062|      0|        return false;
 1063|      0|    }
 1064|       |
 1065|  8.17k|    g->group[peer_index].nick_updated = true;
 1066|       |
 1067|  8.17k|    if (g_peer_nick_eq(&g->group[peer_index], nick, nick_len)) {
  ------------------
  |  Branch (1067:9): [True: 7.70k, False: 478]
  ------------------
 1068|       |        /* same name as already stored */
 1069|  7.70k|        return true;
 1070|  7.70k|    }
 1071|       |
 1072|    478|    if (nick_len > 0) {
  ------------------
  |  Branch (1072:9): [True: 444, False: 34]
  ------------------
 1073|    444|        memcpy(g->group[peer_index].nick, nick, nick_len);
 1074|    444|    }
 1075|       |
 1076|    478|    g->group[peer_index].nick_len = nick_len;
 1077|       |
 1078|    478|    if (do_gc_callback && g_c->peer_name_callback != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1078:9): [True: 0, False: 478]
  |  Branch (1078:27): [True: 0, False: 0]
  ------------------
 1079|      0|        g_c->peer_name_callback(g_c->m, groupnumber, peer_index, nick, nick_len, userdata);
 1080|      0|    }
 1081|       |
 1082|       |    return true;
 1083|  8.17k|}
group.c:g_peer_nick_eq:
  230|  8.17k|{
  231|  8.17k|    return memeq(peer->nick, peer->nick_len, nick, nick_len);
  232|  8.17k|}
group.c:get_group_c:
  333|  45.7k|{
  334|  45.7k|    if (!is_groupnumber_valid(g_c, groupnumber)) {
  ------------------
  |  Branch (334:9): [True: 0, False: 45.7k]
  ------------------
  335|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  336|      0|    }
  337|       |
  338|  45.7k|    return &g_c->chats[groupnumber];
  339|  45.7k|}
group.c:is_groupnumber_valid:
  239|  45.7k|{
  240|  45.7k|    return groupnumber < g_c->num_chats
  ------------------
  |  Branch (240:12): [True: 45.7k, False: 0]
  ------------------
  241|  45.7k|           && g_c->chats != nullptr
  ------------------
  |  |   63|  91.5k|#define nullptr NULL
  ------------------
  |  Branch (241:15): [True: 45.7k, False: 0]
  ------------------
  242|  45.7k|           && g_c->chats[groupnumber].status != GROUPCHAT_STATUS_NONE;
  ------------------
  |  Branch (242:15): [True: 45.7k, False: 0]
  ------------------
  243|  45.7k|}
group.c:wipe_group_chat:
  309|  8.25k|{
  310|  8.25k|    if (groupnumber >= g_c->num_chats || g_c->chats == nullptr) {
  ------------------
  |  |   63|  8.25k|#define nullptr NULL
  ------------------
  |  Branch (310:9): [True: 0, False: 8.25k]
  |  Branch (310:42): [True: 0, False: 8.25k]
  ------------------
  311|      0|        return false;
  312|      0|    }
  313|       |
  314|  8.25k|    wipe_group_c(g_c->mem, &g_c->chats[groupnumber]);
  315|       |
  316|  8.25k|    uint16_t i;
  317|       |
  318|  16.5k|    for (i = g_c->num_chats; i != 0; --i) {
  ------------------
  |  Branch (318:30): [True: 16.3k, False: 124]
  ------------------
  319|  16.3k|        if (g_c->chats[i - 1].status != GROUPCHAT_STATUS_NONE) {
  ------------------
  |  Branch (319:13): [True: 8.13k, False: 8.25k]
  ------------------
  320|  8.13k|            break;
  321|  8.13k|        }
  322|  16.3k|    }
  323|       |
  324|  8.25k|    if (g_c->num_chats != i) {
  ------------------
  |  Branch (324:9): [True: 181, False: 8.07k]
  ------------------
  325|    181|        g_c->num_chats = i;
  326|    181|        realloc_conferences(g_c, g_c->num_chats);
  327|    181|    }
  328|       |
  329|       |    return true;
  330|  8.25k|}
group.c:wipe_group_c:
  298|  8.25k|{
  299|  8.25k|    mem_delete(mem, g->frozen);
  300|  8.25k|    mem_delete(mem, g->group);
  301|  8.25k|    crypto_memzero(g, sizeof(Group_c));
  302|  8.25k|}
group.c:count_connected:
 2224|  2.48k|{
 2225|  2.48k|    unsigned int count = 0;
 2226|       |
 2227|  42.3k|    for (unsigned int i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
  ------------------
  |  |   56|  42.3k|#define MAX_GROUP_CONNECTIONS 16
  ------------------
  |  Branch (2227:30): [True: 39.8k, False: 2.48k]
  ------------------
 2228|  39.8k|        if (g->connections[i].type == GROUPCHAT_CONNECTION_ONLINE) {
  ------------------
  |  Branch (2228:13): [True: 0, False: 39.8k]
  ------------------
 2229|      0|            ++count;
 2230|      0|        }
 2231|  39.8k|    }
 2232|       |
 2233|  2.48k|    return count;
 2234|  2.48k|}
group.c:group_leave:
 1968|  2.48k|{
 1969|  2.48k|    const Group_c *g = get_group_c(g_c, groupnumber);
 1970|       |
 1971|  2.48k|    if (g == nullptr) {
  ------------------
  |  |   63|  2.48k|#define nullptr NULL
  ------------------
  |  Branch (1971:9): [True: 0, False: 2.48k]
  ------------------
 1972|      0|        return false;
 1973|      0|    }
 1974|       |
 1975|  2.48k|    if (permanent) {
  ------------------
  |  Branch (1975:9): [True: 0, False: 2.48k]
  ------------------
 1976|      0|        return group_kill_peer_send(g_c, groupnumber, g->peer_number);
 1977|  2.48k|    } else {
 1978|  2.48k|        return group_freeze_peer_send(g_c, groupnumber, g->peer_number);
 1979|  2.48k|    }
 1980|  2.48k|}
group.c:group_freeze_peer_send:
 1943|  2.48k|{
 1944|  2.48k|    uint8_t packet[GROUP_MESSAGE_KILL_PEER_LENGTH];
 1945|       |
 1946|  2.48k|    peer_num = net_htons(peer_num);
 1947|  2.48k|    memcpy(packet, &peer_num, sizeof(uint16_t));
 1948|       |
 1949|  2.48k|    return send_message_group(g_c, groupnumber, GROUP_MESSAGE_FREEZE_PEER_ID, packet, sizeof(packet)) > 0;
 1950|  2.48k|}
group.c:send_message_group:
 2630|  2.48k|{
 2631|  2.48k|    assert(len == 0 || data != nullptr);
  ------------------
  |  Branch (2631:5): [True: 0, False: 2.48k]
  |  Branch (2631:5): [True: 2.48k, False: 0]
  ------------------
 2632|  2.48k|    Group_c *g = get_group_c(g_c, groupnumber);
 2633|       |
 2634|  2.48k|    if (g == nullptr) {
  ------------------
  |  |   63|  2.48k|#define nullptr NULL
  ------------------
  |  Branch (2634:9): [True: 0, False: 2.48k]
  ------------------
 2635|      0|        return -1;
 2636|      0|    }
 2637|       |
 2638|  2.48k|    if (len > MAX_GROUP_MESSAGE_DATA_LEN) {
  ------------------
  |  |  188|  2.48k|#define MAX_GROUP_MESSAGE_DATA_LEN (MAX_CRYPTO_DATA_SIZE - (1 + MIN_MESSAGE_PACKET_LEN))
  |  |  ------------------
  |  |  |  |  108|  2.48k|#define MAX_CRYPTO_DATA_SIZE (MAX_CRYPTO_PACKET_SIZE - CRYPTO_DATA_PACKET_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  103|  2.48k|#define MAX_CRYPTO_PACKET_SIZE 1400
  |  |  |  |  ------------------
  |  |  |  |               #define MAX_CRYPTO_DATA_SIZE (MAX_CRYPTO_PACKET_SIZE - CRYPTO_DATA_PACKET_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  105|  2.48k|#define CRYPTO_DATA_PACKET_MIN_SIZE (1 + sizeof(uint16_t) + (sizeof(uint32_t) + sizeof(uint32_t)) + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|  2.48k|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define MAX_GROUP_MESSAGE_DATA_LEN (MAX_CRYPTO_DATA_SIZE - (1 + MIN_MESSAGE_PACKET_LEN))
  |  |  ------------------
  |  |  |  |  209|  2.48k|#define MIN_MESSAGE_PACKET_LEN (sizeof(uint16_t) * 2 + sizeof(uint32_t) + 1)
  |  |  ------------------
  ------------------
  |  Branch (2638:9): [True: 0, False: 2.48k]
  ------------------
 2639|      0|        return -2;
 2640|      0|    }
 2641|       |
 2642|  2.48k|    if (g->status != GROUPCHAT_STATUS_CONNECTED || count_connected(g) == 0) {
  ------------------
  |  Branch (2642:9): [True: 0, False: 2.48k]
  |  Branch (2642:52): [True: 2.48k, False: 0]
  ------------------
 2643|  2.48k|        return -3;
 2644|  2.48k|    }
 2645|       |
 2646|      0|    const uint16_t packet_size = sizeof(uint16_t) + sizeof(uint32_t) + 1 + len;
 2647|      0|    VLA(uint8_t, packet, packet_size);
  ------------------
  |  |   59|      0|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      0|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 2648|      0|    const uint16_t peer_num = net_htons(g->peer_number);
 2649|      0|    memcpy(packet, &peer_num, sizeof(peer_num));
 2650|       |
 2651|      0|    ++g->message_number;
 2652|       |
 2653|      0|    if (g->message_number == 0) {
  ------------------
  |  Branch (2653:9): [True: 0, False: 0]
  ------------------
 2654|      0|        ++g->message_number;
 2655|      0|    }
 2656|       |
 2657|      0|    const uint32_t message_num = net_htonl(g->message_number);
 2658|      0|    memcpy(packet + sizeof(uint16_t), &message_num, sizeof(message_num));
 2659|       |
 2660|      0|    packet[sizeof(uint16_t) + sizeof(uint32_t)] = message_id;
 2661|       |
 2662|      0|    if (len != 0) {
  ------------------
  |  Branch (2662:9): [True: 0, False: 0]
  ------------------
 2663|      0|        memcpy(packet + sizeof(uint16_t) + sizeof(uint32_t) + 1, data, len);
 2664|      0|    }
 2665|       |
 2666|      0|    const unsigned int ret = send_message_all_connections(g_c, g, packet, packet_size, -1);
 2667|       |
 2668|      0|    if (ret == 0) {
  ------------------
  |  Branch (2668:9): [True: 0, False: 0]
  ------------------
 2669|      0|        return -4;
 2670|      0|    }
 2671|       |
 2672|      0|    return ret;
 2673|      0|}
group.c:conferences_section_size:
 3458|  2.94k|{
 3459|  2.94k|    uint32_t len = 0;
 3460|       |
 3461|  7.15k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3461:26): [True: 4.21k, False: 2.94k]
  ------------------
 3462|  4.21k|        const Group_c *g = get_group_c(g_c, i);
 3463|       |
 3464|  4.21k|        if (g == nullptr || g->status != GROUPCHAT_STATUS_CONNECTED) {
  ------------------
  |  |   63|  8.42k|#define nullptr NULL
  ------------------
  |  Branch (3464:13): [True: 0, False: 4.21k]
  |  Branch (3464:29): [True: 0, False: 4.21k]
  ------------------
 3465|      0|            continue;
 3466|      0|        }
 3467|       |
 3468|  4.21k|        len += saved_conf_size(g);
 3469|  4.21k|    }
 3470|       |
 3471|  2.94k|    return len;
 3472|  2.94k|}
group.c:saved_conf_size:
 3390|  4.21k|{
 3391|  4.21k|    uint32_t len = SAVED_CONF_SIZE_CONSTANT + g->title_len;
  ------------------
  |  | 3386|  4.21k|#define SAVED_CONF_SIZE_CONSTANT (1 + GROUP_ID_LENGTH + sizeof(uint32_t) \
  |  |  ------------------
  |  |  |  |   53|  4.21k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   59|  4.21k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   54|  4.21k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 3387|  4.21k|      + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t) + 1)
  ------------------
 3392|       |
 3393|  8.88k|    for (uint32_t j = 0; j < g->numpeers + g->numfrozen; ++j) {
  ------------------
  |  Branch (3393:26): [True: 4.66k, False: 4.21k]
  ------------------
 3394|  4.66k|        const Group_Peer *peer = (j < g->numpeers) ? &g->group[j] : &g->frozen[j - g->numpeers];
  ------------------
  |  Branch (3394:34): [True: 4.21k, False: 456]
  ------------------
 3395|       |
 3396|  4.66k|        if (pk_equal(peer->real_pk, g->real_pk)) {
  ------------------
  |  Branch (3396:13): [True: 4.21k, False: 456]
  ------------------
 3397|  4.21k|            continue;
 3398|  4.21k|        }
 3399|       |
 3400|    456|        len += saved_peer_size(peer);
 3401|    456|    }
 3402|       |
 3403|  4.21k|    return len;
 3404|  4.21k|}
group.c:saved_peer_size:
 3358|    456|{
 3359|    456|    return SAVED_PEER_SIZE_CONSTANT + peer->nick_len;
  ------------------
  |  | 3355|    456|#define SAVED_PEER_SIZE_CONSTANT (2 * CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint16_t) + sizeof(uint64_t) + 1)
  |  |  ------------------
  |  |  |  |   44|    456|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 3360|    456|}
group.c:save_conf:
 3414|  1.40k|{
 3415|  1.40k|    *data = g->type;
 3416|  1.40k|    ++data;
 3417|       |
 3418|  1.40k|    memcpy(data, g->id, GROUP_ID_LENGTH);
  ------------------
  |  |   53|  1.40k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   59|  1.40k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   54|  1.40k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3419|  1.40k|    data += GROUP_ID_LENGTH;
  ------------------
  |  |   53|  1.40k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   59|  1.40k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   54|  1.40k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3420|       |
 3421|  1.40k|    host_to_lendian_bytes32(data, g->message_number + SAVE_OFFSET_MESSAGE_NUMBER);
  ------------------
  |  | 3410|  1.40k|#define SAVE_OFFSET_MESSAGE_NUMBER (1 << 16)
  ------------------
 3422|  1.40k|    data += sizeof(uint32_t);
 3423|       |
 3424|  1.40k|    host_to_lendian_bytes16(data, g->lossy_message_number + SAVE_OFFSET_LOSSY_MESSAGE_NUMBER);
  ------------------
  |  | 3411|  1.40k|#define SAVE_OFFSET_LOSSY_MESSAGE_NUMBER (1 << 13)
  ------------------
 3425|  1.40k|    data += sizeof(uint16_t);
 3426|       |
 3427|  1.40k|    host_to_lendian_bytes16(data, g->peer_number);
 3428|  1.40k|    data += sizeof(uint16_t);
 3429|       |
 3430|  1.40k|    uint8_t *const numsaved_location = data;
 3431|  1.40k|    data += sizeof(uint32_t);
 3432|       |
 3433|  1.40k|    *data = g->title_len;
 3434|  1.40k|    ++data;
 3435|       |
 3436|  1.40k|    memcpy(data, g->title, g->title_len);
 3437|  1.40k|    data += g->title_len;
 3438|       |
 3439|  1.40k|    uint32_t numsaved = 0;
 3440|       |
 3441|  2.96k|    for (uint32_t j = 0; j < g->numpeers + g->numfrozen; ++j) {
  ------------------
  |  Branch (3441:26): [True: 1.55k, False: 1.40k]
  ------------------
 3442|  1.55k|        const Group_Peer *peer = (j < g->numpeers) ? &g->group[j] : &g->frozen[j - g->numpeers];
  ------------------
  |  Branch (3442:34): [True: 1.40k, False: 152]
  ------------------
 3443|       |
 3444|  1.55k|        if (pk_equal(peer->real_pk, g->real_pk)) {
  ------------------
  |  Branch (3444:13): [True: 1.40k, False: 152]
  ------------------
 3445|  1.40k|            continue;
 3446|  1.40k|        }
 3447|       |
 3448|    152|        data = save_peer(peer, data);
 3449|    152|        ++numsaved;
 3450|    152|    }
 3451|       |
 3452|  1.40k|    host_to_lendian_bytes32(numsaved_location, numsaved);
 3453|       |
 3454|  1.40k|    return data;
 3455|  1.40k|}
group.c:save_peer:
 3363|    152|{
 3364|    152|    memcpy(data, peer->real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    152|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3365|    152|    data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   44|    152|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3366|       |
 3367|    152|    memcpy(data, peer->temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    152|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3368|    152|    data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   44|    152|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3369|       |
 3370|    152|    host_to_lendian_bytes16(data, peer->peer_number);
 3371|    152|    data += sizeof(uint16_t);
 3372|       |
 3373|    152|    host_to_lendian_bytes64(data, peer->last_active);
 3374|    152|    data += sizeof(uint64_t);
 3375|       |
 3376|       |    // TODO(iphydf): This looks broken: nick_len can be > 255.
 3377|    152|    *data = peer->nick_len;
 3378|    152|    ++data;
 3379|       |
 3380|    152|    memcpy(data, peer->nick, peer->nick_len);
 3381|    152|    data += peer->nick_len;
 3382|       |
 3383|    152|    return data;
 3384|    152|}
group.c:load_conferences:
 3663|    568|{
 3664|    568|    const State_Load_Status res = load_conferences_helper(g_c, data, length);
 3665|       |
 3666|    568|    if (res == STATE_LOAD_STATUS_CONTINUE) {
  ------------------
  |  Branch (3666:9): [True: 492, False: 76]
  ------------------
 3667|    492|        return res;
 3668|    492|    }
 3669|       |
 3670|       |    // Loading failed, cleanup all Group_c
 3671|       |
 3672|       |    // save locally, because wipe_group_chat(...) modifies it
 3673|     76|    const uint16_t num_groups = g_c->num_chats;
 3674|       |
 3675|  5.77k|    for (uint16_t i = 0; i < num_groups; ++i) {
  ------------------
  |  Branch (3675:26): [True: 5.69k, False: 76]
  ------------------
 3676|  5.69k|        wipe_group_chat(g_c, i);
 3677|  5.69k|    }
 3678|       |
 3679|     76|    return res;
 3680|    568|}
group.c:load_conferences_helper:
 3613|    568|{
 3614|    568|    const uint8_t *init_data = data;
 3615|       |
 3616|  8.74k|    while (length >= (uint32_t)(data - init_data) + SAVED_CONF_SIZE_CONSTANT) {
  ------------------
  |  | 3386|  8.74k|#define SAVED_CONF_SIZE_CONSTANT (1 + GROUP_ID_LENGTH + sizeof(uint32_t) \
  |  |  ------------------
  |  |  |  |   53|  8.74k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   59|  8.74k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   54|  8.74k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 3387|  8.74k|      + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t) + 1)
  ------------------
  |  Branch (3616:12): [True: 8.25k, False: 492]
  ------------------
 3617|  8.25k|        const int groupnumber = create_group_chat(g_c);
 3618|       |
 3619|       |        // Helpful for testing
 3620|  8.25k|        assert(groupnumber != -1);
  ------------------
  |  Branch (3620:9): [True: 8.25k, False: 0]
  ------------------
 3621|       |
 3622|  8.25k|        if (groupnumber == -1) {
  ------------------
  |  Branch (3622:13): [True: 0, False: 8.25k]
  ------------------
 3623|       |            // If this fails there's a serious problem, don't bother with cleanup
 3624|      0|            LOGGER_ERROR(g_c->m->log, "conference creation failed");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3625|      0|            return STATE_LOAD_STATUS_ERROR;
 3626|      0|        }
 3627|       |
 3628|  8.25k|        Group_c *g = &g_c->chats[groupnumber];
 3629|       |
 3630|  8.25k|        const uint32_t consumed = load_group(g, g_c, data, length - (uint32_t)(data - init_data));
 3631|       |
 3632|  8.25k|        if (consumed == 0) {
  ------------------
  |  Branch (3632:13): [True: 71, False: 8.18k]
  ------------------
 3633|       |            // remove partially loaded stuff, wipe_group_chat must be able to wipe a partially loaded group
 3634|     71|            const bool ret = wipe_group_chat(g_c, groupnumber);
 3635|       |
 3636|       |            // HACK: suppress unused variable warning
 3637|     71|            if (!ret) {
  ------------------
  |  Branch (3637:17): [True: 0, False: 71]
  ------------------
 3638|       |                // wipe_group_chat(...) must be able to wipe partially allocated groups
 3639|      0|                assert(ret);
  ------------------
  |  Branch (3639:17): [True: 0, False: 0]
  ------------------
 3640|      0|            }
 3641|       |
 3642|     71|            LOGGER_ERROR(g_c->m->log, "conference loading failed");
  ------------------
  |  |   80|     71|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     71|    do {                                                                         \
  |  |  |  |   70|     71|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    142|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 71, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     71|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     71|        }                                                                        \
  |  |  |  |   73|     71|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 71]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3643|     71|            return STATE_LOAD_STATUS_ERROR;
 3644|     71|        }
 3645|       |
 3646|  8.18k|        data += consumed;
 3647|       |
 3648|  8.18k|        const int peer_index = addpeer(g_c, groupnumber, g->real_pk, dht_get_self_public_key(g_c->m->dht), g->peer_number,
 3649|  8.18k|                                       nullptr, true, false);
  ------------------
  |  |   63|  8.18k|#define nullptr NULL
  ------------------
 3650|       |
 3651|  8.18k|        if (peer_index == -1) {
  ------------------
  |  Branch (3651:13): [True: 5, False: 8.17k]
  ------------------
 3652|      5|            LOGGER_ERROR(g_c->m->log, "adding peer %d failed", g->peer_number);
  ------------------
  |  |   80|      5|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      5|    do {                                                                         \
  |  |  |  |   70|      5|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     10|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 5, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      5|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      5|        }                                                                        \
  |  |  |  |   73|      5|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 5]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3653|      5|            return STATE_LOAD_STATUS_ERROR;
 3654|      5|        }
 3655|       |
 3656|  8.17k|        setnick(g_c, groupnumber, peer_index, g_c->m->name, g_c->m->name_length, nullptr, false);
  ------------------
  |  |   63|  8.17k|#define nullptr NULL
  ------------------
 3657|  8.17k|    }
 3658|       |
 3659|    492|    return STATE_LOAD_STATUS_CONTINUE;
 3660|    568|}
group.c:load_group:
 3506|  8.25k|{
 3507|  8.25k|    const uint8_t *init_data = data;
 3508|       |
 3509|       |    // Initialize to default values so we can unconditionally free in case of an error
 3510|  8.25k|    setup_conference(g);
 3511|       |
 3512|  8.25k|    g->type = *data;
 3513|  8.25k|    ++data;
 3514|       |
 3515|  8.25k|    memcpy(g->id, data, GROUP_ID_LENGTH);
  ------------------
  |  |   53|  8.25k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   59|  8.25k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   54|  8.25k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3516|  8.25k|    data += GROUP_ID_LENGTH;
  ------------------
  |  |   53|  8.25k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   59|  8.25k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   54|  8.25k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3517|       |
 3518|  8.25k|    lendian_bytes_to_host32(&g->message_number, data);
 3519|  8.25k|    data += sizeof(uint32_t);
 3520|       |
 3521|  8.25k|    lendian_bytes_to_host16(&g->lossy_message_number, data);
 3522|  8.25k|    data += sizeof(uint16_t);
 3523|       |
 3524|  8.25k|    lendian_bytes_to_host16(&g->peer_number, data);
 3525|  8.25k|    data += sizeof(uint16_t);
 3526|       |
 3527|  8.25k|    lendian_bytes_to_host32(&g->numfrozen, data);
 3528|  8.25k|    data += sizeof(uint32_t);
 3529|       |
 3530|  8.25k|    g->title_len = *data;
 3531|       |
 3532|  8.25k|    if (g->title_len > MAX_NAME_LENGTH) {
  ------------------
  |  |   39|  8.25k|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (3532:9): [True: 14, False: 8.24k]
  ------------------
 3533|     14|        return 0;
 3534|     14|    }
 3535|       |
 3536|  8.24k|    ++data;
 3537|       |
 3538|  8.24k|    assert((data - init_data) < UINT32_MAX);
  ------------------
  |  Branch (3538:5): [True: 8.24k, False: 0]
  ------------------
 3539|       |
 3540|  8.24k|    if (length < (uint32_t)(data - init_data) + g->title_len) {
  ------------------
  |  Branch (3540:9): [True: 3, False: 8.23k]
  ------------------
 3541|      3|        return 0;
 3542|      3|    }
 3543|       |
 3544|  8.23k|    memcpy(g->title, data, g->title_len);
 3545|  8.23k|    data += g->title_len;
 3546|       |
 3547|  8.65k|    for (uint32_t j = 0; j < g->numfrozen; ++j) {
  ------------------
  |  Branch (3547:26): [True: 473, False: 8.18k]
  ------------------
 3548|       |
 3549|    473|        assert((data - init_data) < UINT32_MAX);
  ------------------
  |  Branch (3549:9): [True: 473, False: 0]
  ------------------
 3550|       |
 3551|    473|        if (length < (uint32_t)(data - init_data) + SAVED_PEER_SIZE_CONSTANT) {
  ------------------
  |  | 3355|    473|#define SAVED_PEER_SIZE_CONSTANT (2 * CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint16_t) + sizeof(uint64_t) + 1)
  |  |  ------------------
  |  |  |  |   44|    473|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (3551:13): [True: 34, False: 439]
  ------------------
 3552|     34|            return 0;
 3553|     34|        }
 3554|       |
 3555|       |        // This is inefficient, but allows us to check data consistency before allocating memory
 3556|    439|        Group_Peer *tmp_frozen = (Group_Peer *)mem_vrealloc(g_c->mem, g->frozen, j + 1, sizeof(Group_Peer));
 3557|       |
 3558|    439|        if (tmp_frozen == nullptr) {
  ------------------
  |  |   63|    439|#define nullptr NULL
  ------------------
  |  Branch (3558:13): [True: 0, False: 439]
  ------------------
 3559|       |            // Memory allocation failure
 3560|      0|            return 0;
 3561|      0|        }
 3562|       |
 3563|    439|        g->frozen = tmp_frozen;
 3564|       |
 3565|    439|        Group_Peer *peer = &g->frozen[j];
 3566|    439|        *peer = empty_group_peer;
 3567|       |
 3568|    439|        pk_copy(peer->real_pk, data);
 3569|    439|        data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   44|    439|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3570|    439|        pk_copy(peer->temp_pk, data);
 3571|    439|        data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   44|    439|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3572|       |
 3573|    439|        lendian_bytes_to_host16(&peer->peer_number, data);
 3574|    439|        data += sizeof(uint16_t);
 3575|       |
 3576|    439|        lendian_bytes_to_host64(&peer->last_active, data);
 3577|    439|        data += sizeof(uint64_t);
 3578|       |
 3579|    439|        peer->nick_len = *data;
 3580|       |
 3581|    439|        if (peer->nick_len > MAX_NAME_LENGTH) {
  ------------------
  |  |   39|    439|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (3581:13): [True: 13, False: 426]
  ------------------
 3582|     13|            return 0;
 3583|     13|        }
 3584|       |
 3585|    426|        ++data;
 3586|    426|        assert((data - init_data) < UINT32_MAX);
  ------------------
  |  Branch (3586:9): [True: 426, False: 0]
  ------------------
 3587|       |
 3588|    426|        if (length < (uint32_t)(data - init_data) + peer->nick_len) {
  ------------------
  |  Branch (3588:13): [True: 7, False: 419]
  ------------------
 3589|      7|            return 0;
 3590|      7|        }
 3591|       |
 3592|    419|        memcpy(peer->nick, data, peer->nick_len);
 3593|    419|        data += peer->nick_len;
 3594|       |
 3595|       |        // NOTE: this relies on friends being loaded before conferences.
 3596|    419|        peer->is_friend = getfriend_id(g_c->m, peer->real_pk) != -1;
 3597|    419|    }
 3598|       |
 3599|  8.18k|    if (g->numfrozen > g->maxfrozen) {
  ------------------
  |  Branch (3599:9): [True: 0, False: 8.18k]
  ------------------
 3600|      0|        g->maxfrozen = g->numfrozen;
 3601|      0|    }
 3602|       |
 3603|  8.18k|    g->status = GROUPCHAT_STATUS_CONNECTED;
 3604|       |
 3605|  8.18k|    pk_copy(g->real_pk, nc_get_self_public_key(g_c->m->net_crypto));
 3606|       |
 3607|  8.18k|    assert((data - init_data) < UINT32_MAX);
  ------------------
  |  Branch (3607:5): [True: 8.18k, False: 0]
  ------------------
 3608|       |
 3609|  8.18k|    return (uint32_t)(data - init_data);
 3610|  8.18k|}

new_gca_list:
  408|  1.40k|{
  409|  1.40k|    GC_Announces_List *announces_list = (GC_Announces_List *)mem_alloc(mem, sizeof(GC_Announces_List));
  410|       |
  411|  1.40k|    if (announces_list == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (411:9): [True: 0, False: 1.40k]
  ------------------
  412|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  413|      0|    }
  414|       |
  415|  1.40k|    announces_list->mem = mem;
  416|       |
  417|  1.40k|    return announces_list;
  418|  1.40k|}
kill_gca:
  421|  1.40k|{
  422|  1.40k|    if (announces_list == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (422:9): [True: 0, False: 1.40k]
  ------------------
  423|      0|        return;
  424|      0|    }
  425|       |
  426|  1.40k|    GC_Announces *root = announces_list->root_announces;
  427|       |
  428|  1.40k|    while (root != nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (428:12): [True: 0, False: 1.40k]
  ------------------
  429|      0|        GC_Announces *next = root->next_announce;
  430|      0|        mem_delete(announces_list->mem, root);
  431|      0|        root = next;
  432|      0|    }
  433|       |
  434|  1.40k|    mem_delete(announces_list->mem, announces_list);
  435|  1.40k|}

gc_peer_id_from_int:
  191|    150|{
  192|    150|    const GC_Peer_Id peer_id = {(force GC_Peer_Id_Value)value};
  193|    150|    return peer_id;
  194|    150|}
gc_peer_number_is_valid:
  234|    150|{
  235|    150|    return peer_number >= 0 && peer_number < (int)chat->numpeers;
  ------------------
  |  Branch (235:12): [True: 150, False: 0]
  |  Branch (235:32): [True: 150, False: 0]
  ------------------
  236|    150|}
get_gc_connection:
  248|    150|{
  249|    150|    GC_Peer *peer = get_gc_peer(chat, peer_number);
  250|       |
  251|    150|    if (peer == nullptr) {
  ------------------
  |  |   63|    150|#define nullptr NULL
  ------------------
  |  Branch (251:9): [True: 0, False: 150]
  ------------------
  252|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  253|      0|    }
  254|       |
  255|    150|    return &peer->gconn;
  256|    150|}
pack_gc_saved_peers:
  419|    256|{
  420|    256|    uint16_t packed_len = 0;
  421|    256|    uint16_t count = 0;
  422|       |
  423|  25.8k|    for (uint32_t i = 0; i < GC_MAX_SAVED_PEERS; ++i) {
  ------------------
  |  |   50|  25.8k|#define GC_MAX_SAVED_PEERS 100
  ------------------
  |  Branch (423:26): [True: 25.6k, False: 256]
  ------------------
  424|  25.6k|        const GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];
  425|       |
  426|  25.6k|        if (!saved_peer_is_valid(saved_peer)) {
  ------------------
  |  Branch (426:13): [True: 24.8k, False: 736]
  ------------------
  427|  24.8k|            continue;
  428|  24.8k|        }
  429|       |
  430|    736|        int packed_ipp_len = 0;
  431|    736|        int packed_tcp_len = 0;
  432|       |
  433|    736|        if (ipport_isset(&saved_peer->ip_port)) {
  ------------------
  |  Branch (433:13): [True: 584, False: 152]
  ------------------
  434|    584|            if (packed_len > length) {
  ------------------
  |  Branch (434:17): [True: 0, False: 584]
  ------------------
  435|      0|                return -1;
  436|      0|            }
  437|       |
  438|    584|            packed_ipp_len = pack_ip_port(chat->log, data + packed_len, length - packed_len, &saved_peer->ip_port);
  439|       |
  440|    584|            if (packed_ipp_len > 0) {
  ------------------
  |  Branch (440:17): [True: 584, False: 0]
  ------------------
  441|    584|                packed_len += packed_ipp_len;
  442|    584|            }
  443|    584|        }
  444|       |
  445|    736|        if (ipport_isset(&saved_peer->tcp_relay.ip_port)) {
  ------------------
  |  Branch (445:13): [True: 512, False: 224]
  ------------------
  446|    512|            if (packed_len > length) {
  ------------------
  |  Branch (446:17): [True: 0, False: 512]
  ------------------
  447|      0|                return -1;
  448|      0|            }
  449|       |
  450|    512|            packed_tcp_len = pack_nodes(chat->log, data + packed_len, length - packed_len, &saved_peer->tcp_relay, 1);
  451|       |
  452|    512|            if (packed_tcp_len > 0) {
  ------------------
  |  Branch (452:17): [True: 512, False: 0]
  ------------------
  453|    512|                packed_len += packed_tcp_len;
  454|    512|            }
  455|    512|        }
  456|       |
  457|    736|        if (packed_len + ENC_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |   85|    736|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   44|    736|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (457:13): [True: 0, False: 736]
  ------------------
  458|      0|            return -1;
  459|      0|        }
  460|       |
  461|    736|        if (packed_tcp_len > 0 || packed_ipp_len > 0) {
  ------------------
  |  Branch (461:13): [True: 512, False: 224]
  |  Branch (461:35): [True: 224, False: 0]
  ------------------
  462|    736|            memcpy(data + packed_len, chat->saved_peers[i].public_key, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |   85|    736|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   44|    736|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  463|    736|            packed_len += ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |   85|    736|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   44|    736|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  464|    736|            ++count;
  465|    736|        } else {
  466|      0|            LOGGER_WARNING(chat->log, "Failed to pack saved peer");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  467|      0|        }
  468|    736|    }
  469|       |
  470|    256|    if (processed != nullptr) {
  ------------------
  |  |   63|    256|#define nullptr NULL
  ------------------
  |  Branch (470:9): [True: 256, False: 0]
  ------------------
  471|    256|        *processed = packed_len;
  472|    256|    }
  473|       |
  474|    256|    return count;
  475|    256|}
unpack_gc_saved_peers:
  478|    110|{
  479|    110|    uint16_t count = 0;
  480|    110|    uint16_t unpacked_len = 0;
  481|       |
  482|    484|    for (size_t i = 0; unpacked_len < length; ++i) {
  ------------------
  |  Branch (482:24): [True: 479, False: 5]
  ------------------
  483|    479|        GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];
  484|       |
  485|    479|        const int ipp_len = unpack_ip_port(&saved_peer->ip_port, data + unpacked_len, length - unpacked_len, false);
  486|       |
  487|    479|        if (ipp_len > 0) {
  ------------------
  |  Branch (487:13): [True: 307, False: 172]
  ------------------
  488|    307|            unpacked_len += ipp_len;
  489|    307|        }
  490|       |
  491|    479|        if (unpacked_len > length) {
  ------------------
  |  Branch (491:13): [True: 0, False: 479]
  ------------------
  492|      0|            return -1;
  493|      0|        }
  494|       |
  495|    479|        uint16_t tcp_len_processed = 0;
  496|    479|        const int tcp_len = unpack_nodes(&saved_peer->tcp_relay, 1, &tcp_len_processed, data + unpacked_len,
  497|    479|                                         length - unpacked_len, true);
  498|       |
  499|    479|        if (tcp_len == 1 && tcp_len_processed > 0) {
  ------------------
  |  Branch (499:13): [True: 269, False: 210]
  |  Branch (499:29): [True: 269, False: 0]
  ------------------
  500|    269|            unpacked_len += tcp_len_processed;
  501|    269|        } else if (ipp_len <= 0) {
  ------------------
  |  Branch (501:20): [True: 103, False: 107]
  ------------------
  502|    103|            LOGGER_WARNING(chat->log, "Failed to unpack saved peer: Invalid connection info.");
  ------------------
  |  |   79|    103|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    103|    do {                                                                         \
  |  |  |  |   70|    103|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    206|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 103, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|    103|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|    103|        }                                                                        \
  |  |  |  |   73|    103|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 103]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  503|    103|            return -1;
  504|    103|        }
  505|       |
  506|    376|        if (unpacked_len + ENC_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |   85|    376|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   44|    376|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (506:13): [True: 2, False: 374]
  ------------------
  507|      2|            return -1;
  508|      2|        }
  509|       |
  510|    374|        if (tcp_len > 0 || ipp_len > 0) {
  ------------------
  |  Branch (510:13): [True: 269, False: 105]
  |  Branch (510:28): [True: 105, False: 0]
  ------------------
  511|    374|            memcpy(saved_peer->public_key, data + unpacked_len, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |   85|    374|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   44|    374|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  512|    374|            unpacked_len += ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |   85|    374|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   44|    374|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  513|    374|            ++count;
  514|    374|        } else {
  515|      0|            LOGGER_ERROR(chat->log, "Unpacked peer with bad connection info");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  516|      0|            return -1;
  517|      0|        }
  518|    374|    }
  519|       |
  520|      5|    return count;
  521|    110|}
gc_get_pk_jenkins_hash:
  580|    150|{
  581|    150|    return jenkins_one_at_a_time_hash(public_key, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |   85|    150|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   44|    150|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  582|    150|}
get_peer_number_of_enc_pk:
  612|    150|{
  613|    150|    for (uint32_t i = 0; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (613:26): [True: 0, False: 150]
  ------------------
  614|      0|        const GC_Connection *gconn = get_gc_connection(chat, i);
  615|       |
  616|      0|        assert(gconn != nullptr);
  ------------------
  |  Branch (616:9): [True: 0, False: 0]
  ------------------
  617|       |
  618|      0|        if (gconn->pending_delete) {
  ------------------
  |  Branch (618:13): [True: 0, False: 0]
  ------------------
  619|      0|            continue;
  620|      0|        }
  621|       |
  622|      0|        if (confirmed && !gconn->confirmed) {
  ------------------
  |  Branch (622:13): [True: 0, False: 0]
  |  Branch (622:26): [True: 0, False: 0]
  ------------------
  623|      0|            continue;
  624|      0|        }
  625|       |
  626|      0|        if (memcmp(gconn->addr.public_key.enc, public_enc_key, ENC_PUBLIC_KEY_SIZE) == 0) {
  ------------------
  |  |   85|      0|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (626:13): [True: 0, False: 0]
  ------------------
  627|      0|            return i;
  628|      0|        }
  629|      0|    }
  630|       |
  631|    150|    return -1;
  632|    150|}
gc_callback_message:
 6453|    981|{
 6454|    981|    GC_Session *c = m->group_handler;
 6455|    981|    c->message = function;
 6456|    981|}
gc_callback_private_message:
 6459|    981|{
 6460|    981|    GC_Session *c = m->group_handler;
 6461|    981|    c->private_message = function;
 6462|    981|}
gc_callback_custom_packet:
 6465|    981|{
 6466|    981|    GC_Session *c = m->group_handler;
 6467|    981|    c->custom_packet = function;
 6468|    981|}
gc_callback_custom_private_packet:
 6471|    981|{
 6472|    981|    GC_Session *c = m->group_handler;
 6473|    981|    c->custom_private_packet = function;
 6474|    981|}
gc_callback_moderation:
 6477|    981|{
 6478|    981|    GC_Session *c = m->group_handler;
 6479|    981|    c->moderation = function;
 6480|    981|}
gc_callback_nick_change:
 6483|    981|{
 6484|    981|    GC_Session *c = m->group_handler;
 6485|    981|    c->nick_change = function;
 6486|    981|}
gc_callback_status_change:
 6489|    981|{
 6490|    981|    GC_Session *c = m->group_handler;
 6491|    981|    c->status_change = function;
 6492|    981|}
gc_callback_topic_change:
 6495|    981|{
 6496|    981|    GC_Session *c = m->group_handler;
 6497|    981|    c->topic_change = function;
 6498|    981|}
gc_callback_topic_lock:
 6501|    981|{
 6502|    981|    GC_Session *c = m->group_handler;
 6503|    981|    c->topic_lock = function;
 6504|    981|}
gc_callback_voice_state:
 6507|    981|{
 6508|    981|    GC_Session *c = m->group_handler;
 6509|    981|    c->voice_state = function;
 6510|    981|}
gc_callback_peer_limit:
 6513|    981|{
 6514|    981|    GC_Session *c = m->group_handler;
 6515|    981|    c->peer_limit = function;
 6516|    981|}
gc_callback_privacy_state:
 6519|    981|{
 6520|    981|    GC_Session *c = m->group_handler;
 6521|    981|    c->privacy_state = function;
 6522|    981|}
gc_callback_password:
 6525|    981|{
 6526|    981|    GC_Session *c = m->group_handler;
 6527|    981|    c->password = function;
 6528|    981|}
gc_callback_peer_join:
 6531|    981|{
 6532|    981|    GC_Session *c = m->group_handler;
 6533|    981|    c->peer_join = function;
 6534|    981|}
gc_callback_peer_exit:
 6537|    981|{
 6538|    981|    GC_Session *c = m->group_handler;
 6539|    981|    c->peer_exit = function;
 6540|    981|}
gc_callback_self_join:
 6543|    981|{
 6544|    981|    GC_Session *c = m->group_handler;
 6545|    981|    c->self_join = function;
 6546|    981|}
gc_callback_rejected:
 6549|    981|{
 6550|    981|    GC_Session *c = m->group_handler;
 6551|    981|    c->rejected = function;
 6552|    981|}
peer_add:
 6649|    150|{
 6650|    150|    if (get_peer_number_of_enc_pk(chat, public_key, false) != -1) {
  ------------------
  |  Branch (6650:9): [True: 0, False: 150]
  ------------------
 6651|      0|        return -2;
 6652|      0|    }
 6653|       |
 6654|    150|    const GC_Peer_Id peer_id = get_new_peer_id(chat);
 6655|       |
 6656|    150|    if (!gc_peer_id_is_valid(peer_id)) {
  ------------------
  |  Branch (6656:9): [True: 0, False: 150]
  ------------------
 6657|      0|        LOGGER_WARNING(chat->log, "Failed to add peer: all peer ID's are taken?");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6658|      0|        return -1;
 6659|      0|    }
 6660|       |
 6661|    150|    const int peer_number = chat->numpeers;
 6662|    150|    int tcp_connection_num = -1;
 6663|       |
 6664|    150|    if (peer_number > 0) {  // we don't need a connection to ourself
  ------------------
  |  Branch (6664:9): [True: 0, False: 150]
  ------------------
 6665|      0|        tcp_connection_num = new_tcp_connection_to(chat->tcp_conn, public_key, 0);
 6666|       |
 6667|      0|        if (tcp_connection_num == -1) {
  ------------------
  |  Branch (6667:13): [True: 0, False: 0]
  ------------------
 6668|      0|            LOGGER_WARNING(chat->log, "Failed to init tcp connection for peer %d", peer_number);
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6669|      0|        }
 6670|      0|    }
 6671|       |
 6672|    150|    GC_Message_Array_Entry *send = (GC_Message_Array_Entry *)mem_valloc(chat->mem, GCC_BUFFER_SIZE, sizeof(GC_Message_Array_Entry));
  ------------------
  |  |   57|    150|#define GCC_BUFFER_SIZE 2048
  ------------------
 6673|    150|    GC_Message_Array_Entry *recv = (GC_Message_Array_Entry *)mem_valloc(chat->mem, GCC_BUFFER_SIZE, sizeof(GC_Message_Array_Entry));
  ------------------
  |  |   57|    150|#define GCC_BUFFER_SIZE 2048
  ------------------
 6674|       |
 6675|    150|    if (send == nullptr || recv == nullptr) {
  ------------------
  |  |   63|    300|#define nullptr NULL
  ------------------
                  if (send == nullptr || recv == nullptr) {
  ------------------
  |  |   63|    150|#define nullptr NULL
  ------------------
  |  Branch (6675:9): [True: 0, False: 150]
  |  Branch (6675:28): [True: 0, False: 150]
  ------------------
 6676|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for gconn buffers");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6677|       |
 6678|      0|        if (tcp_connection_num != -1) {
  ------------------
  |  Branch (6678:13): [True: 0, False: 0]
  ------------------
 6679|      0|            kill_tcp_connection_to(chat->tcp_conn, tcp_connection_num);
 6680|      0|        }
 6681|       |
 6682|      0|        mem_delete(chat->mem, send);
 6683|      0|        mem_delete(chat->mem, recv);
 6684|      0|        return -1;
 6685|      0|    }
 6686|       |
 6687|    150|    GC_Peer *tmp_group = (GC_Peer *)mem_vrealloc(chat->mem, chat->group, chat->numpeers + 1, sizeof(GC_Peer));
 6688|       |
 6689|    150|    if (tmp_group == nullptr) {
  ------------------
  |  |   63|    150|#define nullptr NULL
  ------------------
  |  Branch (6689:9): [True: 0, False: 150]
  ------------------
 6690|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for group mem_vrealloc");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6691|       |
 6692|      0|        if (tcp_connection_num != -1) {
  ------------------
  |  Branch (6692:13): [True: 0, False: 0]
  ------------------
 6693|      0|            kill_tcp_connection_to(chat->tcp_conn, tcp_connection_num);
 6694|      0|        }
 6695|       |
 6696|      0|        mem_delete(chat->mem, send);
 6697|      0|        mem_delete(chat->mem, recv);
 6698|      0|        return -1;
 6699|      0|    }
 6700|       |
 6701|    150|    ++chat->numpeers;
 6702|    150|    chat->group = tmp_group;
 6703|       |
 6704|    150|    chat->group[peer_number] = (GC_Peer) {
 6705|    150|        0
 6706|    150|    };
 6707|       |
 6708|    150|    GC_Connection *gconn = &chat->group[peer_number].gconn;
 6709|       |
 6710|    150|    gconn->send_array = send;
 6711|    150|    gconn->recv_array = recv;
 6712|       |
 6713|    150|    gcc_set_ip_port(gconn, ipp);
 6714|    150|    chat->group[peer_number].role = GR_USER;
 6715|    150|    chat->group[peer_number].peer_id = peer_id;
 6716|    150|    chat->group[peer_number].ignore = false;
 6717|       |
 6718|    150|    crypto_memlock(gconn->session_secret_key, sizeof(gconn->session_secret_key));
 6719|       |
 6720|    150|    create_gc_session_keypair(chat->log, chat->rng, gconn->session_public_key, gconn->session_secret_key);
 6721|       |
 6722|    150|    if (peer_number > 0) {
  ------------------
  |  Branch (6722:9): [True: 0, False: 150]
  ------------------
 6723|      0|        memcpy(gconn->addr.public_key.enc, public_key, ENC_PUBLIC_KEY_SIZE);  // we get the sig key in the handshake
  ------------------
  |  |   85|      0|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 6724|    150|    } else {
 6725|    150|        gconn->addr.public_key = chat->self_public_key;
 6726|    150|    }
 6727|       |
 6728|    150|    const uint64_t tm = mono_time_get(chat->mono_time);
 6729|       |
 6730|    150|    gcc_set_send_message_id(gconn, 1);
 6731|    150|    gconn->public_key_hash = gc_get_pk_jenkins_hash(public_key);
 6732|    150|    gconn->last_received_packet_time = tm;
 6733|    150|    gconn->last_key_rotation = tm;
 6734|    150|    gconn->tcp_connection_num = tcp_connection_num;
 6735|    150|    gconn->friend_number = -1;
 6736|    150|    gconn->last_sent_ip_time = tm;
 6737|    150|    gconn->last_sent_ping_time = tm - (GC_PING_TIMEOUT / 2) + (peer_number % (GC_PING_TIMEOUT / 2));
  ------------------
  |  |   28|    150|#define GC_PING_TIMEOUT 12
  ------------------
                  gconn->last_sent_ping_time = tm - (GC_PING_TIMEOUT / 2) + (peer_number % (GC_PING_TIMEOUT / 2));
  ------------------
  |  |   28|    150|#define GC_PING_TIMEOUT 12
  ------------------
 6738|    150|    gconn->self_is_closer = id_closest(get_chat_id(&chat->chat_public_key),
 6739|    150|                                       get_enc_key(&chat->self_public_key),
 6740|    150|                                       get_enc_key(&gconn->addr.public_key)) == 1;
 6741|    150|    return peer_number;
 6742|    150|}
gc_group_save:
 7466|  1.43k|{
 7467|  1.43k|    gc_save_pack_group(chat, bp);
 7468|  1.43k|}
gc_group_load:
 7471|  25.2k|{
 7472|  25.2k|    const int group_number = get_new_group_index(c->messenger->mem, c);
 7473|       |
 7474|  25.2k|    if (group_number < 0) {
  ------------------
  |  Branch (7474:9): [True: 0, False: 25.2k]
  ------------------
 7475|      0|        return -1;
 7476|      0|    }
 7477|       |
 7478|  25.2k|    const uint64_t tm = mono_time_get(c->messenger->mono_time);
 7479|       |
 7480|  25.2k|    Messenger *m = c->messenger;
 7481|  25.2k|    GC_Chat *chat = &c->chats[group_number];
 7482|       |
 7483|  25.2k|    chat->group_number = group_number;
 7484|  25.2k|    chat->numpeers = 0;
 7485|  25.2k|    chat->net = m->net;
 7486|  25.2k|    chat->mono_time = m->mono_time;
 7487|  25.2k|    chat->log = m->log;
 7488|  25.2k|    chat->mem = m->mem;
 7489|  25.2k|    chat->rng = m->rng;
 7490|  25.2k|    chat->last_ping_interval = tm;
 7491|  25.2k|    chat->friend_connection_id = -1;
 7492|       |
 7493|       |    // Initialise these first, because we may need to log/dealloc things on cleanup.
 7494|  25.2k|    chat->moderation.log = m->log;
 7495|  25.2k|    chat->moderation.mem = m->mem;
 7496|       |
 7497|  25.2k|    if (!gc_load_unpack_group(chat, bu)) {
  ------------------
  |  Branch (7497:9): [True: 25.1k, False: 112]
  ------------------
 7498|  25.1k|        LOGGER_ERROR(chat->log, "Failed to unpack group");
  ------------------
  |  |   80|  25.1k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  25.1k|    do {                                                                         \
  |  |  |  |   70|  25.1k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  50.2k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 25.1k, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|  25.1k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|  25.1k|        }                                                                        \
  |  |  |  |   73|  25.1k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 25.1k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 7499|  25.1k|        return -1;
 7500|  25.1k|    }
 7501|       |
 7502|    112|    init_gc_moderation(chat);
 7503|       |
 7504|    112|    if (!init_gc_tcp_connection(c, chat)) {
  ------------------
  |  Branch (7504:9): [True: 0, False: 112]
  ------------------
 7505|      0|        LOGGER_ERROR(chat->log, "Failed to init tcp connection");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 7506|      0|        return -1;
 7507|      0|    }
 7508|       |
 7509|    112|    if (chat->connection_state == CS_DISCONNECTED) {
  ------------------
  |  Branch (7509:9): [True: 10, False: 102]
  ------------------
 7510|     10|        return group_number;
 7511|     10|    }
 7512|       |
 7513|    102|    if (is_public_chat(chat)) {
  ------------------
  |  Branch (7513:9): [True: 88, False: 14]
  ------------------
 7514|     88|        if (!m_create_group_connection(m, chat)) {
  ------------------
  |  Branch (7514:13): [True: 0, False: 88]
  ------------------
 7515|      0|            LOGGER_ERROR(chat->log, "Failed to initialize group friend connection");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 7516|      0|        }
 7517|     88|    }
 7518|       |
 7519|    102|    return group_number;
 7520|    112|}
new_dht_groupchats:
 8115|  1.40k|{
 8116|  1.40k|    if (m == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (8116:9): [True: 0, False: 1.40k]
  ------------------
 8117|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 8118|      0|    }
 8119|       |
 8120|  1.40k|    GC_Session *c = (GC_Session *)mem_alloc(m->mem, sizeof(GC_Session));
 8121|       |
 8122|  1.40k|    if (c == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (8122:9): [True: 0, False: 1.40k]
  ------------------
 8123|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 8124|      0|    }
 8125|       |
 8126|  1.40k|    c->messenger = m;
 8127|  1.40k|    c->announces_list = m->group_announce;
 8128|  1.40k|    c->tcp_np = m->tcp_np;
 8129|       |
 8130|  1.40k|    networking_registerhandler(m->net, NET_PACKET_GC_LOSSLESS, &handle_gc_udp_packet, m);
 8131|  1.40k|    networking_registerhandler(m->net, NET_PACKET_GC_LOSSY, &handle_gc_udp_packet, m);
 8132|  1.40k|    networking_registerhandler(m->net, NET_PACKET_GC_HANDSHAKE, &handle_gc_udp_packet, m);
 8133|  1.40k|    onion_group_announce_register(m->onion_c, gc_handle_announce_response_callback, c);
 8134|       |
 8135|  1.40k|    return c;
 8136|  1.40k|}
gc_group_exit:
 8194|  7.50k|{
 8195|  7.50k|    chat->flag_exit = true;
 8196|  7.50k|    return group_can_handle_packets(chat) ? send_gc_self_exit(chat, message, length) : 0;
  ------------------
  |  Branch (8196:12): [True: 7.42k, False: 76]
  ------------------
 8197|  7.50k|}
kill_dht_groupchats:
 8207|  1.40k|{
 8208|  1.40k|    if (c == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (8208:9): [True: 0, False: 1.40k]
  ------------------
 8209|      0|        return;
 8210|      0|    }
 8211|       |
 8212|  9.47k|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (8212:26): [True: 8.06k, False: 1.40k]
  ------------------
 8213|  8.06k|        GC_Chat *chat = &c->chats[i];
 8214|       |
 8215|  8.06k|        if (chat->connection_state == CS_NONE) {
  ------------------
  |  Branch (8215:13): [True: 569, False: 7.50k]
  ------------------
 8216|    569|            continue;
 8217|    569|        }
 8218|       |
 8219|  7.50k|        if (kill_group(c, chat) != 0) {
  ------------------
  |  Branch (8219:13): [True: 0, False: 7.50k]
  ------------------
 8220|      0|            LOGGER_WARNING(c->messenger->log, "Failed to send group exit packet");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8221|      0|        }
 8222|  7.50k|    }
 8223|       |
 8224|  1.40k|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSY, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSY, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 8225|  1.40k|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSLESS, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSLESS, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 8226|  1.40k|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_HANDSHAKE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_HANDSHAKE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 8227|  1.40k|    onion_group_announce_register(c->messenger->onion_c, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  onion_group_announce_register(c->messenger->onion_c, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 8228|       |
 8229|  1.40k|    mem_delete(c->messenger->mem, c->chats);
 8230|  1.40k|    mem_delete(c->messenger->mem, c);
 8231|  1.40k|}
gc_group_is_valid:
 8234|  7.64k|{
 8235|  7.64k|    return chat->connection_state != CS_NONE && chat->shared_state.version > 0;
  ------------------
  |  Branch (8235:12): [True: 5.04k, False: 2.60k]
  |  Branch (8235:49): [True: 3.23k, False: 1.81k]
  ------------------
 8236|  7.64k|}
gc_count_groups:
 8253|  3.21k|{
 8254|  3.21k|    uint32_t count = 0;
 8255|       |
 8256|  7.62k|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (8256:26): [True: 4.40k, False: 3.21k]
  ------------------
 8257|  4.40k|        const GC_Chat *chat = &c->chats[i];
 8258|       |
 8259|  4.40k|        if (gc_group_is_valid(chat)) {
  ------------------
  |  Branch (8259:13): [True: 1.79k, False: 2.61k]
  ------------------
 8260|  1.79k|            ++count;
 8261|  1.79k|        }
 8262|  4.40k|    }
 8263|       |
 8264|  3.21k|    return count;
 8265|  3.21k|}
group_chats.c:get_gc_peer:
  239|    150|{
  240|    150|    if (!gc_peer_number_is_valid(chat, peer_number)) {
  ------------------
  |  Branch (240:9): [True: 0, False: 150]
  ------------------
  241|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  242|      0|    }
  243|       |
  244|    150|    return &chat->group[peer_number];
  245|    150|}
group_chats.c:saved_peer_is_valid:
  791|  25.6k|{
  792|  25.6k|    return ipport_isset(&saved_peer->ip_port) || ipport_isset(&saved_peer->tcp_relay.ip_port);
  ------------------
  |  Branch (792:12): [True: 584, False: 25.0k]
  |  Branch (792:50): [True: 152, False: 24.8k]
  ------------------
  793|  25.6k|}
group_chats.c:send_gc_broadcast_message:
 2337|  7.42k|{
 2338|  7.42k|    if (length + GC_BROADCAST_ENC_HEADER_SIZE > MAX_GC_PACKET_SIZE) {
  ------------------
  |  |   58|  7.42k|#define GC_BROADCAST_ENC_HEADER_SIZE 1
  ------------------
                  if (length + GC_BROADCAST_ENC_HEADER_SIZE > MAX_GC_PACKET_SIZE) {
  ------------------
  |  |   54|  7.42k|#define MAX_GC_PACKET_SIZE (MAX_GC_PACKET_CHUNK_SIZE * 100)
  |  |  ------------------
  |  |  |  |   38|  7.42k|#define MAX_GC_PACKET_CHUNK_SIZE 500
  |  |  ------------------
  ------------------
  |  Branch (2338:9): [True: 0, False: 7.42k]
  ------------------
 2339|      0|        LOGGER_ERROR(chat->log, "Failed to broadcast message: invalid length %u", length);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2340|      0|        return false;
 2341|      0|    }
 2342|       |
 2343|  7.42k|    uint8_t *packet = (uint8_t *)mem_balloc(chat->mem, length + GC_BROADCAST_ENC_HEADER_SIZE);
  ------------------
  |  |   58|  7.42k|#define GC_BROADCAST_ENC_HEADER_SIZE 1
  ------------------
 2344|       |
 2345|  7.42k|    if (packet == nullptr) {
  ------------------
  |  |   63|  7.42k|#define nullptr NULL
  ------------------
  |  Branch (2345:9): [True: 0, False: 7.42k]
  ------------------
 2346|      0|        return false;
 2347|      0|    }
 2348|       |
 2349|  7.42k|    const uint16_t packet_len = make_gc_broadcast_header(data, length, packet, bc_type);
 2350|       |
 2351|  7.42k|    const bool ret = send_gc_lossless_packet_all_peers(chat, packet, packet_len, GP_BROADCAST);
 2352|       |
 2353|  7.42k|    mem_delete(chat->mem, packet);
 2354|       |
 2355|  7.42k|    return ret;
 2356|  7.42k|}
group_chats.c:get_peer_number_of_peer_id:
  700|    150|{
  701|    150|    for (uint32_t i = 0; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (701:26): [True: 0, False: 150]
  ------------------
  702|      0|        if (chat->group[i].peer_id.value == peer_id.value) {
  ------------------
  |  Branch (702:13): [True: 0, False: 0]
  ------------------
  703|      0|            return i;
  704|      0|        }
  705|      0|    }
  706|       |
  707|    150|    return -1;
  708|    150|}
group_chats.c:kill_group_friend_connection:
  207|  7.50k|{
  208|  7.50k|    if (chat->friend_connection_id != -1) {
  ------------------
  |  Branch (208:9): [True: 88, False: 7.41k]
  ------------------
  209|     88|        m_kill_group_connection(c->messenger, chat);
  210|     88|    }
  211|  7.50k|}
group_chats.c:make_gc_broadcast_header:
 2321|  7.42k|{
 2322|  7.42k|    packet[0] = bc_type;
 2323|  7.42k|    const uint16_t header_len = sizeof(uint8_t);
 2324|       |
 2325|  7.42k|    if (data != nullptr && length > 0) {
  ------------------
  |  |   63|  14.8k|#define nullptr NULL
  ------------------
  |  Branch (2325:9): [True: 0, False: 7.42k]
  |  Branch (2325:28): [True: 0, False: 0]
  ------------------
 2326|      0|        memcpy(packet + header_len, data, length);
 2327|      0|    }
 2328|       |
 2329|  7.42k|    return length + header_len;
 2330|  7.42k|}
group_chats.c:send_gc_lossless_packet_all_peers:
 2264|  7.42k|{
 2265|  7.42k|    uint32_t sent = 0;
 2266|  7.42k|    uint32_t confirmed_peers = 0;
 2267|       |
 2268|  7.42k|    for (uint32_t i = 1; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (2268:26): [True: 0, False: 7.42k]
  ------------------
 2269|      0|        GC_Connection *gconn = get_gc_connection(chat, i);
 2270|       |
 2271|      0|        assert(gconn != nullptr);
  ------------------
  |  Branch (2271:9): [True: 0, False: 0]
  ------------------
 2272|       |
 2273|      0|        if (!gconn->confirmed) {
  ------------------
  |  Branch (2273:13): [True: 0, False: 0]
  ------------------
 2274|      0|            continue;
 2275|      0|        }
 2276|       |
 2277|      0|        ++confirmed_peers;
 2278|       |
 2279|      0|        if (send_lossless_group_packet(chat, gconn, data, length, type)) {
  ------------------
  |  Branch (2279:13): [True: 0, False: 0]
  ------------------
 2280|      0|            ++sent;
 2281|      0|        }
 2282|      0|    }
 2283|       |
 2284|  7.42k|    return sent > 0 || confirmed_peers == 0;
  ------------------
  |  Branch (2284:12): [True: 0, False: 7.42k]
  |  Branch (2284:24): [True: 7.42k, False: 0]
  ------------------
 2285|  7.42k|}
group_chats.c:get_new_peer_id:
  717|    150|{
  718|    150|    for (uint32_t i = 0; i < UINT32_MAX - 1; ++i) {
  ------------------
  |  Branch (718:26): [True: 150, False: 0]
  ------------------
  719|    150|        const GC_Peer_Id peer_id = gc_peer_id_from_int(i);
  720|    150|        if (get_peer_number_of_peer_id(chat, peer_id) == -1) {
  ------------------
  |  Branch (720:13): [True: 150, False: 0]
  ------------------
  721|    150|            return peer_id;
  722|    150|        }
  723|    150|    }
  724|       |
  725|      0|    return gc_invalid_peer_id();
  726|    150|}
group_chats.c:gc_peer_id_is_valid:
  186|    150|{
  187|    150|    return peer_id.value != GC_INVALID_PEER_ID_VALUE;
  ------------------
  |  |  177|    150|#define GC_INVALID_PEER_ID_VALUE ((force GC_Peer_Id_Value)-1)
  ------------------
  188|    150|}
group_chats.c:add_tcp_relays_to_chat:
 7234|    112|{
 7235|    112|    const Messenger *m = c->messenger;
 7236|       |
 7237|    112|    const uint32_t num_relays = tcp_connections_count(nc_get_tcp_c(m->net_crypto));
 7238|       |
 7239|    112|    if (num_relays == 0) {
  ------------------
  |  Branch (7239:9): [True: 112, False: 0]
  ------------------
 7240|    112|        return;
 7241|    112|    }
 7242|       |
 7243|      0|    Node_format *tcp_relays = (Node_format *)mem_valloc(chat->mem, num_relays, sizeof(Node_format));
 7244|       |
 7245|      0|    if (tcp_relays == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (7245:9): [True: 0, False: 0]
  ------------------
 7246|      0|        return;
 7247|      0|    }
 7248|       |
 7249|      0|    const uint32_t num_copied = tcp_copy_connected_relays(nc_get_tcp_c(m->net_crypto), tcp_relays, (uint16_t)num_relays);
 7250|       |
 7251|      0|    for (uint32_t i = 0; i < num_copied; ++i) {
  ------------------
  |  Branch (7251:26): [True: 0, False: 0]
  ------------------
 7252|      0|        add_tcp_relay_global(chat->tcp_conn, &tcp_relays[i].ip_port, tcp_relays[i].public_key);
 7253|      0|    }
 7254|       |
 7255|      0|    mem_delete(chat->mem, tcp_relays);
 7256|      0|}
group_chats.c:get_new_group_index:
 7204|  25.2k|{
 7205|  25.2k|    if (c == nullptr) {
  ------------------
  |  |   63|  25.2k|#define nullptr NULL
  ------------------
  |  Branch (7205:9): [True: 0, False: 25.2k]
  ------------------
 7206|      0|        return -1;
 7207|      0|    }
 7208|       |
 7209|  1.17M|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (7209:26): [True: 1.16M, False: 8.12k]
  ------------------
 7210|  1.16M|        if (c->chats[i].connection_state == CS_NONE) {
  ------------------
  |  Branch (7210:13): [True: 17.1k, False: 1.14M]
  ------------------
 7211|  17.1k|            return i;
 7212|  17.1k|        }
 7213|  1.16M|    }
 7214|       |
 7215|  8.12k|    if (!realloc_groupchats(mem, c, c->chats_index + 1)) {
  ------------------
  |  Branch (7215:9): [True: 0, False: 8.12k]
  ------------------
 7216|      0|        return -1;
 7217|      0|    }
 7218|       |
 7219|  8.12k|    const int new_index = c->chats_index;
 7220|       |
 7221|  8.12k|    c->chats[new_index] = empty_gc_chat;
 7222|       |
 7223|  89.3k|    for (size_t i = 0; i < sizeof(c->chats[new_index].saved_invites) / sizeof(*c->chats[new_index].saved_invites); ++i) {
  ------------------
  |  Branch (7223:24): [True: 81.2k, False: 8.12k]
  ------------------
 7224|  81.2k|        c->chats[new_index].saved_invites[i] = -1;
 7225|  81.2k|    }
 7226|       |
 7227|  8.12k|    ++c->chats_index;
 7228|       |
 7229|  8.12k|    return new_index;
 7230|  8.12k|}
group_chats.c:realloc_groupchats:
 7186|  8.46k|{
 7187|  8.46k|    if (n == 0) {
  ------------------
  |  Branch (7187:9): [True: 309, False: 8.16k]
  ------------------
 7188|    309|        mem_delete(mem, c->chats);
 7189|    309|        c->chats = nullptr;
  ------------------
  |  |   63|    309|#define nullptr NULL
  ------------------
 7190|    309|        return true;
 7191|    309|    }
 7192|       |
 7193|  8.16k|    GC_Chat *temp = (GC_Chat *)mem_vrealloc(mem, c->chats, n, sizeof(GC_Chat));
 7194|       |
 7195|  8.16k|    if (temp == nullptr) {
  ------------------
  |  |   63|  8.16k|#define nullptr NULL
  ------------------
  |  Branch (7195:9): [True: 0, False: 8.16k]
  ------------------
 7196|      0|        return false;
 7197|      0|    }
 7198|       |
 7199|  8.16k|    c->chats = temp;
 7200|       |    return true;
 7201|  8.16k|}
group_chats.c:init_gc_moderation:
 7308|    112|{
 7309|    112|    memcpy(chat->moderation.founder_public_sig_key,
 7310|    112|           get_sig_pk(&chat->shared_state.founder_public_key), SIG_PUBLIC_KEY_SIZE);
  ------------------
  |  |   95|    112|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   34|    112|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
 7311|    112|    memcpy(chat->moderation.self_public_sig_key, get_sig_pk(&chat->self_public_key), SIG_PUBLIC_KEY_SIZE);
  ------------------
  |  |   95|    112|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   34|    112|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
 7312|    112|    memcpy(chat->moderation.self_secret_sig_key, get_sig_sk(&chat->self_secret_key), SIG_SECRET_KEY_SIZE);
  ------------------
  |  |  100|    112|#define SIG_SECRET_KEY_SIZE            CRYPTO_SIGN_SECRET_KEY_SIZE
  |  |  ------------------
  |  |  |  |   39|    112|#define CRYPTO_SIGN_SECRET_KEY_SIZE    64
  |  |  ------------------
  ------------------
 7313|    112|    chat->moderation.shared_state_version = chat->shared_state.version;
 7314|    112|    chat->moderation.log = chat->log;
 7315|    112|    chat->moderation.mem = chat->mem;
 7316|    112|}
group_chats.c:init_gc_tcp_connection:
 7259|    112|{
 7260|    112|    const Messenger *m = c->messenger;
 7261|       |
 7262|    112|    TCP_Connections *tcp_conn = new_tcp_connections(chat->log, chat->mem, chat->rng, m->ns, chat->mono_time, chat->self_secret_key.enc,
 7263|    112|                                &m->options.proxy_info, c->tcp_np);
 7264|       |
 7265|    112|    if (tcp_conn == nullptr) {
  ------------------
  |  |   63|    112|#define nullptr NULL
  ------------------
  |  Branch (7265:9): [True: 0, False: 112]
  ------------------
 7266|      0|        return false;
 7267|      0|    }
 7268|       |
 7269|    112|    chat->tcp_conn = tcp_conn;
 7270|       |
 7271|    112|    add_tcp_relays_to_chat(c, chat);
 7272|       |
 7273|    112|    set_packet_tcp_connection_callback(chat->tcp_conn, &handle_gc_tcp_packet, c->messenger);
 7274|    112|    set_oob_packet_tcp_connection_callback(chat->tcp_conn, &handle_gc_tcp_oob_packet, c->messenger);
 7275|       |
 7276|       |    return true;
 7277|    112|}
group_chats.c:is_public_chat:
  525|    102|{
  526|    102|    return chat->shared_state.privacy_state == GI_PUBLIC;
  527|    102|}
group_chats.c:group_can_handle_packets:
 6233|  7.50k|{
 6234|  7.50k|    const GC_Conn_State state = chat->connection_state;
 6235|  7.50k|    return state == CS_CONNECTING || state == CS_CONNECTED;
  ------------------
  |  Branch (6235:12): [True: 7.42k, False: 76]
  |  Branch (6235:38): [True: 0, False: 76]
  ------------------
 6236|  7.50k|}
group_chats.c:send_gc_self_exit:
 3359|  7.42k|{
 3360|  7.42k|    if (length > MAX_GC_PART_MESSAGE_SIZE) {
  ------------------
  |  |   27|  7.42k|#define MAX_GC_PART_MESSAGE_SIZE 128
  ------------------
  |  Branch (3360:9): [True: 0, False: 7.42k]
  ------------------
 3361|      0|        return -1;
 3362|      0|    }
 3363|       |
 3364|  7.42k|    if (!send_gc_broadcast_message(chat, partmessage, length, GM_PEER_EXIT)) {
  ------------------
  |  Branch (3364:9): [True: 0, False: 7.42k]
  ------------------
 3365|      0|        return -2;
 3366|      0|    }
 3367|       |
 3368|  7.42k|    return 0;
 3369|  7.42k|}
group_chats.c:group_delete:
 8163|  7.50k|{
 8164|  7.50k|    if (c == nullptr || chat == nullptr) {
  ------------------
  |  |   63|  15.0k|#define nullptr NULL
  ------------------
                  if (c == nullptr || chat == nullptr) {
  ------------------
  |  |   63|  7.50k|#define nullptr NULL
  ------------------
  |  Branch (8164:9): [True: 0, False: 7.50k]
  |  Branch (8164:25): [True: 0, False: 7.50k]
  ------------------
 8165|      0|        if (chat != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (8165:13): [True: 0, False: 0]
  ------------------
 8166|      0|            LOGGER_ERROR(chat->log, "Null pointer");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8167|      0|        }
 8168|       |
 8169|      0|        return;
 8170|      0|    }
 8171|       |
 8172|  7.50k|    group_cleanup(c, chat);
 8173|       |
 8174|  7.50k|    c->chats[chat->group_number] = empty_gc_chat;
 8175|       |
 8176|  7.50k|    uint32_t i;
 8177|       |
 8178|  15.0k|    for (i = c->chats_index; i > 0; --i) {
  ------------------
  |  Branch (8178:30): [True: 14.7k, False: 309]
  ------------------
 8179|  14.7k|        if (c->chats[i - 1].connection_state != CS_NONE) {
  ------------------
  |  Branch (8179:13): [True: 7.19k, False: 7.55k]
  ------------------
 8180|  7.19k|            break;
 8181|  7.19k|        }
 8182|  14.7k|    }
 8183|       |
 8184|  7.50k|    if (c->chats_index != i) {
  ------------------
  |  Branch (8184:9): [True: 346, False: 7.15k]
  ------------------
 8185|    346|        c->chats_index = i;
 8186|       |
 8187|    346|        if (!realloc_groupchats(c->messenger->mem, c, c->chats_index)) {
  ------------------
  |  Branch (8187:13): [True: 0, False: 346]
  ------------------
 8188|      0|            LOGGER_ERROR(c->messenger->log, "Failed to reallocate groupchats array");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8189|      0|        }
 8190|    346|    }
 8191|  7.50k|}
group_chats.c:group_cleanup:
 8139|  7.50k|{
 8140|  7.50k|    kill_group_friend_connection(c, chat);
 8141|       |
 8142|  7.50k|    mod_list_cleanup(&chat->moderation);
 8143|  7.50k|    sanctions_list_cleanup(&chat->moderation);
 8144|       |
 8145|  7.50k|    if (chat->tcp_conn != nullptr) {
  ------------------
  |  |   63|  7.50k|#define nullptr NULL
  ------------------
  |  Branch (8145:9): [True: 112, False: 7.38k]
  ------------------
 8146|    112|        kill_tcp_connections(chat->tcp_conn);
 8147|    112|    }
 8148|       |
 8149|  7.50k|    gcc_cleanup(chat);
 8150|       |
 8151|  7.50k|    if (chat->group != nullptr) {
  ------------------
  |  |   63|  7.50k|#define nullptr NULL
  ------------------
  |  Branch (8151:9): [True: 150, False: 7.35k]
  ------------------
 8152|    150|        mem_delete(chat->mem, chat->group);
 8153|    150|        chat->group = nullptr;
  ------------------
  |  |   63|    150|#define nullptr NULL
  ------------------
 8154|    150|    }
 8155|       |
 8156|  7.50k|    crypto_memunlock(&chat->self_secret_key, sizeof(chat->self_secret_key));
 8157|  7.50k|    crypto_memunlock(&chat->chat_secret_key, sizeof(chat->chat_secret_key));
 8158|  7.50k|    crypto_memunlock(chat->shared_state.password, sizeof(chat->shared_state.password));
 8159|  7.50k|}
group_chats.c:kill_group:
 8200|  7.50k|{
 8201|       |    const int ret = gc_group_exit(c, chat, nullptr, 0);
  ------------------
  |  |   63|  7.50k|#define nullptr NULL
  ------------------
 8202|  7.50k|    group_delete(c, chat);
 8203|  7.50k|    return ret;
 8204|  7.50k|}
group_chats.c:create_gc_session_keypair:
 8301|    150|{
 8302|    150|    if (crypto_new_keypair(rng, public_key, secret_key) != 0) {
  ------------------
  |  Branch (8302:9): [True: 0, False: 150]
  ------------------
 8303|      0|        LOGGER_FATAL(log, "Failed to create group session keypair");
  ------------------
  |  |   83|      0|    do {                                \
  |  |   84|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   85|      0|        logger_abort();                 \
  |  |   86|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (86:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
 8304|      0|    }
 8305|    150|}

gcc_set_send_message_id:
   76|    150|{
   77|    150|    gconn->send_message_id = id;
   78|    150|    gconn->send_array_start = id % GCC_BUFFER_SIZE;
  ------------------
  |  |   57|    150|#define GCC_BUFFER_SIZE 2048
  ------------------
   79|    150|}
gcc_set_ip_port:
  277|    150|{
  278|    150|    if (ipp != nullptr && ipport_isset(ipp)) {
  ------------------
  |  |   63|    300|#define nullptr NULL
  ------------------
  |  Branch (278:9): [True: 0, False: 150]
  |  Branch (278:27): [True: 0, False: 0]
  ------------------
  279|      0|        gconn->addr.ip_port = *ipp;
  280|      0|    }
  281|    150|}
gcc_peer_cleanup:
  701|    150|{
  702|   307k|    for (size_t i = 0; i < GCC_BUFFER_SIZE; ++i) {
  ------------------
  |  |   57|   307k|#define GCC_BUFFER_SIZE 2048
  ------------------
  |  Branch (702:24): [True: 307k, False: 150]
  ------------------
  703|   307k|        mem_delete(mem, gconn->send_array[i].data);
  704|   307k|        mem_delete(mem, gconn->recv_array[i].data);
  705|   307k|    }
  706|       |
  707|    150|    mem_delete(mem, gconn->recv_array);
  708|    150|    mem_delete(mem, gconn->send_array);
  709|       |
  710|    150|    crypto_memunlock(gconn->session_secret_key, sizeof(gconn->session_secret_key));
  711|    150|    crypto_memunlock(gconn->session_shared_key, sizeof(gconn->session_shared_key));
  712|    150|    crypto_memzero(gconn, sizeof(GC_Connection));
  713|    150|}
gcc_cleanup:
  716|  7.50k|{
  717|  7.65k|    for (uint32_t i = 0; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (717:26): [True: 150, False: 7.50k]
  ------------------
  718|    150|        GC_Connection *gconn = get_gc_connection(chat, i);
  719|    150|        assert(gconn != nullptr);
  ------------------
  |  Branch (719:9): [True: 150, False: 0]
  ------------------
  720|       |
  721|    150|        gcc_peer_cleanup(chat->mem, gconn);
  722|    150|    }
  723|  7.50k|}

mod_list_unpack:
   69|    215|{
   70|    215|    if (length < num_mods * MOD_LIST_ENTRY_SIZE) {
  ------------------
  |  |   27|    215|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   95|    215|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|    215|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (70:9): [True: 0, False: 215]
  ------------------
   71|      0|        return -1;
   72|      0|    }
   73|       |
   74|    215|    mod_list_cleanup(moderation);
   75|       |
   76|    215|    if (num_mods == 0) {
  ------------------
  |  Branch (76:9): [True: 0, False: 215]
  ------------------
   77|      0|        return 0;
   78|      0|    }
   79|       |
   80|    215|    uint8_t **tmp_list = (uint8_t **)mem_valloc(moderation->mem, num_mods, sizeof(uint8_t *));
   81|       |
   82|    215|    if (tmp_list == nullptr) {
  ------------------
  |  |   63|    215|#define nullptr NULL
  ------------------
  |  Branch (82:9): [True: 0, False: 215]
  ------------------
   83|      0|        return -1;
   84|      0|    }
   85|       |
   86|    215|    uint16_t unpacked_len = 0;
   87|       |
   88|  3.65k|    for (uint16_t i = 0; i < num_mods; ++i) {
  ------------------
  |  Branch (88:26): [True: 3.44k, False: 215]
  ------------------
   89|  3.44k|        uint8_t *entry = (uint8_t *)mem_balloc(moderation->mem, MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|  3.44k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   95|  3.44k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|  3.44k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   90|       |
   91|  3.44k|        if (entry == nullptr) {
  ------------------
  |  |   63|  3.44k|#define nullptr NULL
  ------------------
  |  Branch (91:13): [True: 0, False: 3.44k]
  ------------------
   92|      0|            free_uint8_t_pointer_array(moderation->mem, tmp_list, i);
   93|      0|            return -1;
   94|      0|        }
   95|       |
   96|  3.44k|        memcpy(entry, &data[i * MOD_LIST_ENTRY_SIZE], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|  3.44k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   95|  3.44k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|  3.44k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      memcpy(entry, &data[i * MOD_LIST_ENTRY_SIZE], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|  3.44k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   95|  3.44k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|  3.44k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   97|  3.44k|        tmp_list[i] = entry;
   98|       |
   99|  3.44k|        unpacked_len += MOD_LIST_ENTRY_SIZE;
  ------------------
  |  |   27|  3.44k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   95|  3.44k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|  3.44k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  100|  3.44k|    }
  101|       |
  102|    215|    moderation->mod_list = tmp_list;
  103|    215|    moderation->num_mods = num_mods;
  104|       |
  105|    215|    qsort(moderation->mod_list, moderation->num_mods, sizeof(uint8_t *), compare_mod_pointers);
  106|       |
  107|    215|    return unpacked_len;
  108|    215|}
mod_list_pack:
  111|    256|{
  112|  4.35k|    for (uint16_t i = 0; i < moderation->num_mods; ++i) {
  ------------------
  |  Branch (112:26): [True: 4.09k, False: 256]
  ------------------
  113|  4.09k|        memcpy(&data[i * MOD_LIST_ENTRY_SIZE], moderation->mod_list[i], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|  4.09k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   95|  4.09k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|  4.09k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      memcpy(&data[i * MOD_LIST_ENTRY_SIZE], moderation->mod_list[i], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|  4.09k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   95|  4.09k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|  4.09k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  114|  4.09k|    }
  115|    256|}
mod_list_cleanup:
  262|  7.71k|{
  263|  7.71k|    free_uint8_t_pointer_array(moderation->mem, moderation->mod_list, moderation->num_mods);
  264|  7.71k|    moderation->num_mods = 0;
  265|       |    moderation->mod_list = nullptr;
  ------------------
  |  |   63|  7.71k|#define nullptr NULL
  ------------------
  266|  7.71k|}
sanctions_list_cleanup:
  911|  7.50k|{
  912|  7.50k|    mem_delete(moderation->mem, moderation->sanctions);
  913|       |
  914|       |    moderation->sanctions = nullptr;
  ------------------
  |  |   63|  7.50k|#define nullptr NULL
  ------------------
  915|  7.50k|    moderation->num_sanctions = 0;
  916|  7.50k|}
group_moderation.c:compare_mod_pointers:
   45|  10.0k|{
   46|  10.0k|    const uint8_t *const *mod_a = (const uint8_t *const *)a;
   47|  10.0k|    const uint8_t *const *mod_b = (const uint8_t *const *)b;
   48|  10.0k|    return memcmp(*mod_a, *mod_b, SIG_PUBLIC_KEY_SIZE);
  ------------------
  |  |   95|  10.0k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   34|  10.0k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
   49|  10.0k|}

gca_onion_init:
   76|  1.40k|{
   77|  1.40k|    onion_announce_extra_data_callback(onion_a, GCA_MAX_SENT_ANNOUNCES * sizeof(GC_Announce), pack_group_announces,
  ------------------
  |  |   35|  1.40k|#define GCA_MAX_SENT_ANNOUNCES 4
  ------------------
   78|  1.40k|                                       group_announce);
   79|  1.40k|}

group_privacy_state_from_int:
   33|  7.50k|{
   34|  7.50k|    switch (value) {
   35|  7.34k|        case GI_PUBLIC: {
  ------------------
  |  Branch (35:9): [True: 7.34k, False: 151]
  ------------------
   36|  7.34k|            *out_enum = GI_PUBLIC;
   37|  7.34k|            return true;
   38|      0|        }
   39|       |
   40|     45|        case GI_PRIVATE: {
  ------------------
  |  Branch (40:9): [True: 45, False: 7.45k]
  ------------------
   41|     45|            *out_enum = GI_PRIVATE;
   42|     45|            return true;
   43|      0|        }
   44|       |
   45|    106|        default: {
  ------------------
  |  Branch (45:9): [True: 106, False: 7.39k]
  ------------------
   46|    106|            *out_enum = GI_PUBLIC;
   47|       |            return false;
   48|      0|        }
   49|  7.50k|    }
   50|  7.50k|}
group_voice_state_from_int:
   53|  7.50k|{
   54|  7.50k|    switch (value) {
   55|  3.70k|        case GV_ALL: {
  ------------------
  |  Branch (55:9): [True: 3.70k, False: 3.79k]
  ------------------
   56|  3.70k|            *out_enum = GV_ALL;
   57|  3.70k|            return true;
   58|      0|        }
   59|       |
   60|     12|        case GV_MODS: {
  ------------------
  |  Branch (60:9): [True: 12, False: 7.48k]
  ------------------
   61|     12|            *out_enum = GV_MODS;
   62|     12|            return true;
   63|      0|        }
   64|       |
   65|      4|        case GV_FOUNDER: {
  ------------------
  |  Branch (65:9): [True: 4, False: 7.49k]
  ------------------
   66|      4|            *out_enum = GV_FOUNDER;
   67|      4|            return true;
   68|      0|        }
   69|       |
   70|  3.77k|        default: {
  ------------------
  |  Branch (70:9): [True: 3.77k, False: 3.72k]
  ------------------
   71|  3.77k|            *out_enum = GV_ALL;
   72|       |            return false;
   73|      0|        }
   74|  7.50k|    }
   75|  7.50k|}
gc_load_unpack_group:
  321|  25.2k|{
  322|  25.2k|    uint32_t actual_size;
  323|  25.2k|    if (!bin_unpack_array_fixed(bu, 7, &actual_size)) {
  ------------------
  |  Branch (323:9): [True: 2.15k, False: 23.0k]
  ------------------
  324|  2.15k|        LOGGER_ERROR(chat->log, "Group info array malformed: %u != 7", actual_size);
  ------------------
  |  |   80|  2.15k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  2.15k|    do {                                                                         \
  |  |  |  |   70|  2.15k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  4.31k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2.15k, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|  2.15k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|  2.15k|        }                                                                        \
  |  |  |  |   73|  2.15k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2.15k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  325|  2.15k|        return false;
  326|  2.15k|    }
  327|       |
  328|  23.0k|    return load_unpack_state_values(chat, bu)
  ------------------
  |  Branch (328:12): [True: 7.50k, False: 15.5k]
  ------------------
  329|  7.50k|           && load_unpack_state_bin(chat, bu)
  ------------------
  |  Branch (329:15): [True: 360, False: 7.14k]
  ------------------
  330|    360|           && load_unpack_topic_info(chat, bu)
  ------------------
  |  Branch (330:15): [True: 290, False: 70]
  ------------------
  331|    290|           && load_unpack_mod_list(chat, bu)
  ------------------
  |  Branch (331:15): [True: 264, False: 26]
  ------------------
  332|    264|           && load_unpack_keys(chat, bu)
  ------------------
  |  Branch (332:15): [True: 194, False: 70]
  ------------------
  333|    194|           && load_unpack_self_info(chat, bu)
  ------------------
  |  Branch (333:15): [True: 150, False: 44]
  ------------------
  334|    150|           && load_unpack_saved_peers(chat, bu);
  ------------------
  |  Branch (334:15): [True: 112, False: 38]
  ------------------
  335|  25.2k|}
gc_save_pack_group:
  468|  1.43k|{
  469|  1.43k|    if (chat->numpeers == 0) {
  ------------------
  |  Branch (469:9): [True: 1.18k, False: 256]
  ------------------
  470|  1.18k|        LOGGER_ERROR(chat->log, "Failed to pack group: numpeers is 0");
  ------------------
  |  |   80|  1.18k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  1.18k|    do {                                                                         \
  |  |  |  |   70|  1.18k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  2.36k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1.18k, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|  1.18k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|  1.18k|        }                                                                        \
  |  |  |  |   73|  1.18k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1.18k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  471|  1.18k|        return;
  472|  1.18k|    }
  473|       |
  474|    256|    bin_pack_array(bp, 7);
  475|       |
  476|    256|    save_pack_state_values(chat, bp); // 1
  477|    256|    save_pack_state_bin(chat, bp); // 2
  478|    256|    save_pack_topic_info(chat, bp); // 3
  479|    256|    save_pack_mod_list(chat, bp); // 4
  480|    256|    save_pack_keys(chat, bp); // 5
  481|    256|    save_pack_self_info(chat, bp); // 6
  482|    256|    save_pack_saved_peers(chat, bp); // 7
  483|    256|}
group_pack.c:load_unpack_state_values:
   78|  23.0k|{
   79|  23.0k|    if (!bin_unpack_array_fixed(bu, 8, nullptr)) {
  ------------------
  |  |   63|  23.0k|#define nullptr NULL
  ------------------
  |  Branch (79:9): [True: 1.90k, False: 21.1k]
  ------------------
   80|  1.90k|        LOGGER_ERROR(chat->log, "Group state values array malformed");
  ------------------
  |  |   80|  1.90k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  1.90k|    do {                                                                         \
  |  |  |  |   70|  1.90k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  3.81k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1.90k, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|  1.90k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|  1.90k|        }                                                                        \
  |  |  |  |   73|  1.90k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1.90k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   81|  1.90k|        return false;
   82|  1.90k|    }
   83|       |
   84|  23.0k|    bool manually_disconnected = false;
   85|  21.1k|    uint8_t privacy_state = 0;
   86|  21.1k|    uint8_t voice_state = 0;
   87|       |
   88|  21.1k|    if (!(bin_unpack_bool(bu, &manually_disconnected)
  ------------------
  |  Branch (88:11): [True: 18.8k, False: 2.31k]
  ------------------
   89|  18.8k|            && bin_unpack_u16(bu, &chat->shared_state.group_name_len)
  ------------------
  |  Branch (89:16): [True: 17.8k, False: 1.01k]
  ------------------
   90|  17.8k|            && bin_unpack_u08(bu, &privacy_state)
  ------------------
  |  Branch (90:16): [True: 16.2k, False: 1.61k]
  ------------------
   91|  16.2k|            && bin_unpack_u16(bu, &chat->shared_state.maxpeers)
  ------------------
  |  Branch (91:16): [True: 14.5k, False: 1.65k]
  ------------------
   92|  14.5k|            && bin_unpack_u16(bu, &chat->shared_state.password_length)
  ------------------
  |  Branch (92:16): [True: 14.1k, False: 368]
  ------------------
   93|  14.1k|            && bin_unpack_u32(bu, &chat->shared_state.version)
  ------------------
  |  Branch (93:16): [True: 12.9k, False: 1.25k]
  ------------------
   94|  12.9k|            && bin_unpack_u32(bu, &chat->shared_state.topic_lock)
  ------------------
  |  Branch (94:16): [True: 8.51k, False: 4.42k]
  ------------------
   95|  13.6k|            && bin_unpack_u08(bu, &voice_state))) {
  ------------------
  |  Branch (95:16): [True: 7.50k, False: 1.01k]
  ------------------
   96|  13.6k|        LOGGER_ERROR(chat->log, "Failed to unpack state value");
  ------------------
  |  |   80|  13.6k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  13.6k|    do {                                                                         \
  |  |  |  |   70|  13.6k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  27.3k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 13.6k, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|  13.6k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|  13.6k|        }                                                                        \
  |  |  |  |   73|  13.6k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 13.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   97|  13.6k|        return false;
   98|  13.6k|    }
   99|       |
  100|  7.50k|    chat->connection_state = manually_disconnected ? CS_DISCONNECTED : CS_CONNECTING;
  ------------------
  |  Branch (100:30): [True: 76, False: 7.42k]
  ------------------
  101|  7.50k|    group_privacy_state_from_int(privacy_state, &chat->shared_state.privacy_state);
  102|  7.50k|    group_voice_state_from_int(voice_state, &chat->shared_state.voice_state);
  103|       |
  104|       |    // we always load saved groups as private in case the group became private while we were offline.
  105|       |    // this will have no detrimental effect if the group is public, as the correct privacy
  106|       |    // state will be set via sync.
  107|  7.50k|    chat->join_type = HJ_PRIVATE;
  108|       |
  109|       |    return true;
  110|  21.1k|}
group_pack.c:load_unpack_state_bin:
  113|  7.50k|{
  114|  7.50k|    if (!bin_unpack_array_fixed(bu, 5, nullptr)) {
  ------------------
  |  |   63|  7.50k|#define nullptr NULL
  ------------------
  |  Branch (114:9): [True: 6.98k, False: 517]
  ------------------
  115|  6.98k|        LOGGER_ERROR(chat->log, "Group state binary array malformed");
  ------------------
  |  |   80|  6.98k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  6.98k|    do {                                                                         \
  |  |  |  |   70|  6.98k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  13.9k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 6.98k, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|  6.98k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|  6.98k|        }                                                                        \
  |  |  |  |   73|  6.98k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 6.98k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  116|  6.98k|        return false;
  117|  6.98k|    }
  118|       |
  119|    517|    if (!bin_unpack_bin_fixed(bu, chat->shared_state_sig, SIGNATURE_SIZE)) {
  ------------------
  |  |   30|    517|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   29|    517|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  |  Branch (119:9): [True: 38, False: 479]
  ------------------
  120|     38|        LOGGER_ERROR(chat->log, "Failed to unpack shared state signature");
  ------------------
  |  |   80|     38|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     38|    do {                                                                         \
  |  |  |  |   70|     38|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     76|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 38, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     38|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     38|        }                                                                        \
  |  |  |  |   73|     38|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 38]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  121|     38|        return false;
  122|     38|    }
  123|       |
  124|    479|    if (!unpack_extended_public_key(&chat->shared_state.founder_public_key, bu)) {
  ------------------
  |  Branch (124:9): [True: 63, False: 416]
  ------------------
  125|     63|        LOGGER_ERROR(chat->log, "Failed to unpack founder public key");
  ------------------
  |  |   80|     63|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     63|    do {                                                                         \
  |  |  |  |   70|     63|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    126|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 63, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     63|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     63|        }                                                                        \
  |  |  |  |   73|     63|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 63]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  126|     63|        return false;
  127|     63|    }
  128|       |
  129|    416|    if (!(bin_unpack_bin_max(bu, chat->shared_state.group_name, &chat->shared_state.group_name_len, sizeof(chat->shared_state.group_name))
  ------------------
  |  Branch (129:11): [True: 393, False: 23]
  ------------------
  130|    393|            && bin_unpack_bin_max(bu, chat->shared_state.password, &chat->shared_state.password_length, sizeof(chat->shared_state.password))
  ------------------
  |  Branch (130:16): [True: 378, False: 15]
  ------------------
  131|    378|            && bin_unpack_bin_fixed(bu, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE))) {
  ------------------
  |  |   26|    378|#define MOD_MODERATION_HASH_SIZE CRYPTO_SHA256_SIZE
  |  |  ------------------
  |  |  |  |   75|    378|#define CRYPTO_SHA256_SIZE             32
  |  |  ------------------
  ------------------
  |  Branch (131:16): [True: 360, False: 18]
  ------------------
  132|     56|        LOGGER_ERROR(chat->log, "Failed to unpack state binary data");
  ------------------
  |  |   80|     56|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     56|    do {                                                                         \
  |  |  |  |   70|     56|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    112|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 56, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     56|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     56|        }                                                                        \
  |  |  |  |   73|     56|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 56]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  133|     56|        return false;
  134|     56|    }
  135|       |
  136|    360|    return true;
  137|    416|}
group_pack.c:load_unpack_topic_info:
  140|    360|{
  141|    360|    if (!bin_unpack_array_fixed(bu, 6, nullptr)) {
  ------------------
  |  |   63|    360|#define nullptr NULL
  ------------------
  |  Branch (141:9): [True: 14, False: 346]
  ------------------
  142|     14|        LOGGER_ERROR(chat->log, "Group topic array malformed");
  ------------------
  |  |   80|     14|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     14|    do {                                                                         \
  |  |  |  |   70|     14|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     28|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 14, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     14|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     14|        }                                                                        \
  |  |  |  |   73|     14|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 14]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  143|     14|        return false;
  144|     14|    }
  145|       |
  146|    346|    if (!(bin_unpack_u32(bu, &chat->topic_info.version)
  ------------------
  |  Branch (146:11): [True: 336, False: 10]
  ------------------
  147|    336|            && bin_unpack_u16(bu, &chat->topic_info.length)
  ------------------
  |  Branch (147:16): [True: 326, False: 10]
  ------------------
  148|    326|            && bin_unpack_u16(bu, &chat->topic_info.checksum)
  ------------------
  |  Branch (148:16): [True: 325, False: 1]
  ------------------
  149|    325|            && bin_unpack_bin_max(bu, chat->topic_info.topic, &chat->topic_info.length, sizeof(chat->topic_info.topic))
  ------------------
  |  Branch (149:16): [True: 312, False: 13]
  ------------------
  150|    312|            && bin_unpack_bin_fixed(bu, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE)
  ------------------
  |  |   95|    312|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   34|    312|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
  |  Branch (150:16): [True: 302, False: 10]
  ------------------
  151|    302|            && bin_unpack_bin_fixed(bu, chat->topic_sig, SIGNATURE_SIZE))) {
  ------------------
  |  |   30|    302|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   29|    302|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  |  Branch (151:16): [True: 290, False: 12]
  ------------------
  152|     56|        LOGGER_ERROR(chat->log, "Failed to unpack topic info");
  ------------------
  |  |   80|     56|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     56|    do {                                                                         \
  |  |  |  |   70|     56|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    112|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 56, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     56|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     56|        }                                                                        \
  |  |  |  |   73|     56|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 56]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  153|     56|        return false;
  154|     56|    }
  155|       |
  156|    290|    return true;
  157|    346|}
group_pack.c:load_unpack_mod_list:
  160|    290|{
  161|    290|    uint32_t actual_size = 0;
  162|    290|    if (!bin_unpack_array_fixed(bu, 2, &actual_size)) {
  ------------------
  |  Branch (162:9): [True: 10, False: 280]
  ------------------
  163|     10|        LOGGER_ERROR(chat->log, "Group mod list array malformed: %u != 2", actual_size);
  ------------------
  |  |   80|     10|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     10|    do {                                                                         \
  |  |  |  |   70|     10|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     20|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 10, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     10|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     10|        }                                                                        \
  |  |  |  |   73|     10|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 10]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  164|     10|        return false;
  165|     10|    }
  166|       |
  167|    280|    if (!bin_unpack_u16(bu, &chat->moderation.num_mods)) {
  ------------------
  |  Branch (167:9): [True: 6, False: 274]
  ------------------
  168|      6|        LOGGER_ERROR(chat->log, "Failed to unpack mod list value");
  ------------------
  |  |   80|      6|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      6|    do {                                                                         \
  |  |  |  |   70|      6|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     12|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 6, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      6|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      6|        }                                                                        \
  |  |  |  |   73|      6|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 6]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  169|      6|        return false;
  170|      6|    }
  171|       |
  172|    274|    if (chat->moderation.num_mods == 0) {
  ------------------
  |  Branch (172:9): [True: 49, False: 225]
  ------------------
  173|     49|        bin_unpack_nil(bu);
  174|     49|        return true;
  175|     49|    }
  176|       |
  177|    225|    if (chat->moderation.num_mods > MOD_MAX_NUM_MODERATORS) {
  ------------------
  |  |   46|    225|#define MOD_MAX_NUM_MODERATORS       ((MOD_MAX_NUM_MODERATORS_LIMIT / 16) + 3)
  |  |  ------------------
  |  |  |  |   43|    225|#define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    225|#define MAX_PACKET_SIZE_NO_HEADERS 49900
  |  |  |  |  ------------------
  |  |  |  |               #define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   27|    225|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   95|    225|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   34|    225|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (177:9): [True: 1, False: 224]
  ------------------
  178|      1|        LOGGER_ERROR(chat->log, "moderation count %u exceeds maximum %u", chat->moderation.num_mods, (unsigned int)MOD_MAX_NUM_MODERATORS);
  ------------------
  |  |   80|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  179|      1|        chat->moderation.num_mods = MOD_MAX_NUM_MODERATORS;
  ------------------
  |  |   46|      1|#define MOD_MAX_NUM_MODERATORS       ((MOD_MAX_NUM_MODERATORS_LIMIT / 16) + 3)
  |  |  ------------------
  |  |  |  |   43|      1|#define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      1|#define MAX_PACKET_SIZE_NO_HEADERS 49900
  |  |  |  |  ------------------
  |  |  |  |               #define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   27|      1|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   95|      1|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   34|      1|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  180|      1|    }
  181|       |
  182|    225|    uint8_t *packed_mod_list = (uint8_t *)mem_balloc(chat->mem, chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|    225|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   95|    225|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|    225|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  183|       |
  184|    225|    if (packed_mod_list == nullptr) {
  ------------------
  |  |   63|    225|#define nullptr NULL
  ------------------
  |  Branch (184:9): [True: 0, False: 225]
  ------------------
  185|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for packed mod list");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  186|      0|        return false;
  187|      0|    }
  188|       |
  189|    225|    const size_t packed_size = chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE;
  ------------------
  |  |   27|    225|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   95|    225|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|    225|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  190|       |
  191|    225|    if (!bin_unpack_bin_fixed(bu, packed_mod_list, packed_size)) {
  ------------------
  |  Branch (191:9): [True: 10, False: 215]
  ------------------
  192|     10|        LOGGER_ERROR(chat->log, "Failed to unpack mod list binary data");
  ------------------
  |  |   80|     10|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     10|    do {                                                                         \
  |  |  |  |   70|     10|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     20|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 10, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     10|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     10|        }                                                                        \
  |  |  |  |   73|     10|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 10]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  193|     10|        mem_delete(chat->mem, packed_mod_list);
  194|     10|        return false;
  195|     10|    }
  196|       |
  197|    215|    if (mod_list_unpack(&chat->moderation, packed_mod_list, packed_size, chat->moderation.num_mods) == -1) {
  ------------------
  |  Branch (197:9): [True: 0, False: 215]
  ------------------
  198|      0|        LOGGER_ERROR(chat->log, "Failed to unpack mod list info");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  199|      0|        mem_delete(chat->mem, packed_mod_list);
  200|      0|        return false;
  201|      0|    }
  202|       |
  203|    215|    mem_delete(chat->mem, packed_mod_list);
  204|       |
  205|       |    return true;
  206|    215|}
group_pack.c:load_unpack_keys:
  209|    264|{
  210|    264|    if (!bin_unpack_array_fixed(bu, 4, nullptr)) {
  ------------------
  |  |   63|    264|#define nullptr NULL
  ------------------
  |  Branch (210:9): [True: 19, False: 245]
  ------------------
  211|     19|        LOGGER_ERROR(chat->log, "Group keys array malformed");
  ------------------
  |  |   80|     19|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     19|    do {                                                                         \
  |  |  |  |   70|     19|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     38|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 19, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     19|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     19|        }                                                                        \
  |  |  |  |   73|     19|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 19]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  212|     19|        return false;
  213|     19|    }
  214|       |
  215|    245|    if (!(unpack_extended_public_key(&chat->chat_public_key, bu)
  ------------------
  |  Branch (215:11): [True: 235, False: 10]
  ------------------
  216|    235|            && unpack_extended_secret_key(&chat->chat_secret_key, bu)
  ------------------
  |  Branch (216:16): [True: 219, False: 16]
  ------------------
  217|    219|            && unpack_extended_public_key(&chat->self_public_key, bu)
  ------------------
  |  Branch (217:16): [True: 205, False: 14]
  ------------------
  218|    205|            && unpack_extended_secret_key(&chat->self_secret_key, bu))) {
  ------------------
  |  Branch (218:16): [True: 194, False: 11]
  ------------------
  219|     51|        LOGGER_ERROR(chat->log, "Failed to unpack keys");
  ------------------
  |  |   80|     51|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     51|    do {                                                                         \
  |  |  |  |   70|     51|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    102|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 51, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     51|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     51|        }                                                                        \
  |  |  |  |   73|     51|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 51]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  220|     51|        return false;
  221|     51|    }
  222|       |
  223|    194|    return true;
  224|    245|}
group_pack.c:load_unpack_self_info:
  227|    194|{
  228|    194|    if (!bin_unpack_array_fixed(bu, 4, nullptr)) {
  ------------------
  |  |   63|    194|#define nullptr NULL
  ------------------
  |  Branch (228:9): [True: 10, False: 184]
  ------------------
  229|     10|        LOGGER_ERROR(chat->log, "Group self info array malformed");
  ------------------
  |  |   80|     10|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     10|    do {                                                                         \
  |  |  |  |   70|     10|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     20|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 10, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     10|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     10|        }                                                                        \
  |  |  |  |   73|     10|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 10]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  230|     10|        return false;
  231|     10|    }
  232|       |
  233|    184|    uint8_t self_nick[MAX_GC_NICK_SIZE];
  234|    184|    uint16_t self_nick_len = 0;
  235|    184|    uint8_t self_role = GR_USER;
  236|    184|    uint8_t self_status = GS_NONE;
  237|       |
  238|    184|    if (!(bin_unpack_u16(bu, &self_nick_len)
  ------------------
  |  Branch (238:11): [True: 183, False: 1]
  ------------------
  239|    183|            && bin_unpack_u08(bu, &self_role)
  ------------------
  |  Branch (239:16): [True: 171, False: 12]
  ------------------
  240|    171|            && bin_unpack_u08(bu, &self_status))) {
  ------------------
  |  Branch (240:16): [True: 161, False: 10]
  ------------------
  241|     23|        LOGGER_ERROR(chat->log, "Failed to unpack self values");
  ------------------
  |  |   80|     23|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     23|    do {                                                                         \
  |  |  |  |   70|     23|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     46|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 23, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     23|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     23|        }                                                                        \
  |  |  |  |   73|     23|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 23]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  242|     23|        return false;
  243|     23|    }
  244|       |
  245|    161|    if (self_nick_len > MAX_GC_NICK_SIZE) {
  ------------------
  |  |   28|    161|#define MAX_GC_NICK_SIZE 128
  ------------------
  |  Branch (245:9): [True: 1, False: 160]
  ------------------
  246|      1|        LOGGER_ERROR(chat->log, "self_nick too big (%u bytes), truncating to %d", self_nick_len, MAX_GC_NICK_SIZE);
  ------------------
  |  |   80|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  247|      1|        self_nick_len = MAX_GC_NICK_SIZE;
  ------------------
  |  |   28|      1|#define MAX_GC_NICK_SIZE 128
  ------------------
  248|      1|    }
  249|       |
  250|    161|    if (!bin_unpack_bin_fixed(bu, self_nick, self_nick_len)) {
  ------------------
  |  Branch (250:9): [True: 11, False: 150]
  ------------------
  251|     11|        LOGGER_ERROR(chat->log, "Failed to unpack self nick bytes");
  ------------------
  |  |   80|     11|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     11|    do {                                                                         \
  |  |  |  |   70|     11|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     22|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 11, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     11|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     11|        }                                                                        \
  |  |  |  |   73|     11|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 11]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  252|     11|        return false;
  253|     11|    }
  254|       |
  255|       |    // we have to add ourself before setting self info
  256|    150|    if (peer_add(chat, nullptr, chat->self_public_key.enc) != 0) {
  ------------------
  |  |   63|    150|#define nullptr NULL
  ------------------
  |  Branch (256:9): [True: 0, False: 150]
  ------------------
  257|      0|        LOGGER_ERROR(chat->log, "Failed to add self to peer list");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  258|      0|        return false;
  259|      0|    }
  260|       |
  261|    150|    if (chat->numpeers == 0) {
  ------------------
  |  Branch (261:9): [True: 0, False: 150]
  ------------------
  262|      0|        LOGGER_ERROR(chat->log, "Failed to unpack self: numpeers should be > 0");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  263|      0|        return false;
  264|      0|    }
  265|       |
  266|    150|    GC_Peer *self = &chat->group[0];
  267|       |
  268|    150|    self->gconn.addr.public_key = chat->self_public_key;
  269|    150|    memcpy(self->nick, self_nick, self_nick_len);
  270|    150|    self->nick_length = self_nick_len;
  271|    150|    self->role = (Group_Role)self_role;
  272|    150|    self->status = (Group_Peer_Status)self_status;
  273|    150|    self->gconn.confirmed = true;
  274|       |
  275|       |    return true;
  276|    150|}
group_pack.c:load_unpack_saved_peers:
  279|    150|{
  280|    150|    if (!bin_unpack_array_fixed(bu, 2, nullptr)) {
  ------------------
  |  |   63|    150|#define nullptr NULL
  ------------------
  |  Branch (280:9): [True: 14, False: 136]
  ------------------
  281|     14|        LOGGER_ERROR(chat->log, "Group saved peers array malformed");
  ------------------
  |  |   80|     14|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     14|    do {                                                                         \
  |  |  |  |   70|     14|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     28|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 14, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     14|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     14|        }                                                                        \
  |  |  |  |   73|     14|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 14]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  282|     14|        return false;
  283|     14|    }
  284|       |
  285|       |    // Saved peers
  286|    136|    uint16_t saved_peers_size = 0;
  287|       |
  288|    136|    if (!bin_unpack_u16(bu, &saved_peers_size)) {
  ------------------
  |  Branch (288:9): [True: 3, False: 133]
  ------------------
  289|      3|        LOGGER_ERROR(chat->log, "Failed to unpack saved peers value");
  ------------------
  |  |   80|      3|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      3|    do {                                                                         \
  |  |  |  |   70|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 3, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      3|        }                                                                        \
  |  |  |  |   73|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 3]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  290|      3|        return false;
  291|      3|    }
  292|       |
  293|    133|    if (saved_peers_size == 0) {
  ------------------
  |  Branch (293:9): [True: 2, False: 131]
  ------------------
  294|      2|        bin_unpack_nil(bu);
  295|      2|        return true;
  296|      2|    }
  297|       |
  298|    131|    uint8_t *saved_peers = (uint8_t *)mem_balloc(chat->mem, saved_peers_size * GC_SAVED_PEER_SIZE);
  ------------------
  |  |   51|    131|#define GC_SAVED_PEER_SIZE (ENC_PUBLIC_KEY_SIZE + sizeof(Node_format) + sizeof(IP_Port))
  |  |  ------------------
  |  |  |  |   85|    131|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   44|    131|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  299|       |
  300|    131|    if (saved_peers == nullptr) {
  ------------------
  |  |   63|    131|#define nullptr NULL
  ------------------
  |  Branch (300:9): [True: 0, False: 131]
  ------------------
  301|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for saved peer list");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  302|      0|        return false;
  303|      0|    }
  304|       |
  305|    131|    if (!bin_unpack_bin_fixed(bu, saved_peers, saved_peers_size)) {
  ------------------
  |  Branch (305:9): [True: 21, False: 110]
  ------------------
  306|     21|        LOGGER_ERROR(chat->log, "Failed to unpack saved peers binary data");
  ------------------
  |  |   80|     21|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     21|    do {                                                                         \
  |  |  |  |   70|     21|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     42|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 21, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     21|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     21|        }                                                                        \
  |  |  |  |   73|     21|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 21]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  307|     21|        mem_delete(chat->mem, saved_peers);
  308|     21|        return false;
  309|     21|    }
  310|       |
  311|    110|    if (unpack_gc_saved_peers(chat, saved_peers, saved_peers_size) == -1) {
  ------------------
  |  Branch (311:9): [True: 105, False: 5]
  ------------------
  312|    105|        LOGGER_ERROR(chat->log, "Failed to unpack saved peers");  // recoverable error
  ------------------
  |  |   80|    105|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    105|    do {                                                                         \
  |  |  |  |   70|    105|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    210|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 105, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|    105|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|    105|        }                                                                        \
  |  |  |  |   73|    105|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 105]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  313|    105|    }
  314|       |
  315|    110|    mem_delete(chat->mem, saved_peers);
  316|       |
  317|       |    return true;
  318|    131|}
group_pack.c:save_pack_state_values:
  338|    256|{
  339|    256|    bin_pack_array(bp, 8);
  340|    256|    bin_pack_bool(bp, chat->connection_state == CS_DISCONNECTED); // 1
  341|    256|    bin_pack_u16(bp, chat->shared_state.group_name_len); // 2
  342|    256|    bin_pack_u08(bp, chat->shared_state.privacy_state); // 3
  343|    256|    bin_pack_u16(bp, chat->shared_state.maxpeers); // 4
  344|    256|    bin_pack_u16(bp, chat->shared_state.password_length); // 5
  345|    256|    bin_pack_u32(bp, chat->shared_state.version); // 6
  346|    256|    bin_pack_u32(bp, chat->shared_state.topic_lock); // 7
  347|    256|    bin_pack_u08(bp, chat->shared_state.voice_state); // 8
  348|    256|}
group_pack.c:save_pack_state_bin:
  351|    256|{
  352|    256|    bin_pack_array(bp, 5);
  353|       |
  354|    256|    bin_pack_bin(bp, chat->shared_state_sig, SIGNATURE_SIZE); // 1
  ------------------
  |  |   30|    256|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   29|    256|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  355|    256|    pack_extended_public_key(&chat->shared_state.founder_public_key, bp); // 2
  356|    256|    bin_pack_bin(bp, chat->shared_state.group_name, chat->shared_state.group_name_len); // 3
  357|    256|    bin_pack_bin(bp, chat->shared_state.password, chat->shared_state.password_length); // 4
  358|    256|    bin_pack_bin(bp, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE); // 5
  ------------------
  |  |   26|    256|#define MOD_MODERATION_HASH_SIZE CRYPTO_SHA256_SIZE
  |  |  ------------------
  |  |  |  |   75|    256|#define CRYPTO_SHA256_SIZE             32
  |  |  ------------------
  ------------------
  359|    256|}
group_pack.c:save_pack_topic_info:
  362|    256|{
  363|    256|    bin_pack_array(bp, 6);
  364|       |
  365|    256|    bin_pack_u32(bp, chat->topic_info.version); // 1
  366|    256|    bin_pack_u16(bp, chat->topic_info.length); // 2
  367|    256|    bin_pack_u16(bp, chat->topic_info.checksum); // 3
  368|    256|    bin_pack_bin(bp, chat->topic_info.topic, chat->topic_info.length); // 4
  369|    256|    bin_pack_bin(bp, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE); // 5
  ------------------
  |  |   95|    256|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   34|    256|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
  370|    256|    bin_pack_bin(bp, chat->topic_sig, SIGNATURE_SIZE); // 6
  ------------------
  |  |   30|    256|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   29|    256|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  371|    256|}
group_pack.c:save_pack_mod_list:
  374|    256|{
  375|    256|    bin_pack_array(bp, 2);
  376|       |
  377|    256|    const uint16_t num_mods = min_u16(chat->moderation.num_mods, MOD_MAX_NUM_MODERATORS);
  ------------------
  |  |   46|    256|#define MOD_MAX_NUM_MODERATORS       ((MOD_MAX_NUM_MODERATORS_LIMIT / 16) + 3)
  |  |  ------------------
  |  |  |  |   43|    256|#define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    256|#define MAX_PACKET_SIZE_NO_HEADERS 49900
  |  |  |  |  ------------------
  |  |  |  |               #define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   27|    256|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   95|    256|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   34|    256|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  378|       |
  379|    256|    if (num_mods == 0) {
  ------------------
  |  Branch (379:9): [True: 0, False: 256]
  ------------------
  380|      0|        bin_pack_u16(bp, num_mods); // 1
  381|      0|        bin_pack_nil(bp); // 2
  382|      0|        return;
  383|      0|    }
  384|       |
  385|    256|    uint8_t *packed_mod_list = (uint8_t *)mem_balloc(chat->mem, num_mods * MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|    256|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   95|    256|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|    256|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  386|       |
  387|       |    // we can still recover without the mod list
  388|    256|    if (packed_mod_list == nullptr) {
  ------------------
  |  |   63|    256|#define nullptr NULL
  ------------------
  |  Branch (388:9): [True: 0, False: 256]
  ------------------
  389|      0|        bin_pack_u16(bp, 0); // 1
  390|      0|        bin_pack_nil(bp); // 2
  391|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for moderation list");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  392|      0|        return;
  393|      0|    }
  394|       |
  395|    256|    bin_pack_u16(bp, num_mods); // 1
  396|       |
  397|    256|    mod_list_pack(&chat->moderation, packed_mod_list);
  398|       |
  399|    256|    const size_t packed_size = num_mods * MOD_LIST_ENTRY_SIZE;
  ------------------
  |  |   27|    256|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   95|    256|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   34|    256|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  400|       |
  401|    256|    bin_pack_bin(bp, packed_mod_list, packed_size); // 2
  402|       |
  403|    256|    mem_delete(chat->mem, packed_mod_list);
  404|    256|}
group_pack.c:save_pack_keys:
  407|    256|{
  408|    256|    bin_pack_array(bp, 4);
  409|       |
  410|    256|    pack_extended_public_key(&chat->chat_public_key, bp); // 1
  411|    256|    pack_extended_secret_key(&chat->chat_secret_key, bp); // 2
  412|    256|    pack_extended_public_key(&chat->self_public_key, bp); // 3
  413|    256|    pack_extended_secret_key(&chat->self_secret_key, bp); // 4
  414|    256|}
group_pack.c:save_pack_self_info:
  417|    256|{
  418|    256|    bin_pack_array(bp, 4);
  419|       |
  420|    256|    GC_Peer *self = &chat->group[0];
  421|       |
  422|    256|    if (self->nick_length > MAX_GC_NICK_SIZE) {
  ------------------
  |  |   28|    256|#define MAX_GC_NICK_SIZE 128
  ------------------
  |  Branch (422:9): [True: 0, False: 256]
  ------------------
  423|      0|        LOGGER_ERROR(chat->log, "self_nick is too big (%u). Truncating to %d", self->nick_length, MAX_GC_NICK_SIZE);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  424|      0|        self->nick_length = MAX_GC_NICK_SIZE;
  ------------------
  |  |   28|      0|#define MAX_GC_NICK_SIZE 128
  ------------------
  425|      0|    }
  426|       |
  427|    256|    bin_pack_u16(bp, self->nick_length); // 1
  428|    256|    bin_pack_u08(bp, (uint8_t)self->role); // 2
  429|    256|    bin_pack_u08(bp, self->status); // 3
  430|    256|    bin_pack_bin(bp, self->nick, self->nick_length); // 4
  431|    256|}
group_pack.c:save_pack_saved_peers:
  434|    256|{
  435|    256|    bin_pack_array(bp, 2);
  436|       |
  437|    256|    uint8_t *saved_peers = (uint8_t *)mem_balloc(chat->mem, GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE);
  ------------------
  |  |   50|    256|#define GC_MAX_SAVED_PEERS 100
  ------------------
                  uint8_t *saved_peers = (uint8_t *)mem_balloc(chat->mem, GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE);
  ------------------
  |  |   51|    256|#define GC_SAVED_PEER_SIZE (ENC_PUBLIC_KEY_SIZE + sizeof(Node_format) + sizeof(IP_Port))
  |  |  ------------------
  |  |  |  |   85|    256|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   44|    256|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  438|       |
  439|       |    // we can still recover without the saved peers list
  440|    256|    if (saved_peers == nullptr) {
  ------------------
  |  |   63|    256|#define nullptr NULL
  ------------------
  |  Branch (440:9): [True: 0, False: 256]
  ------------------
  441|      0|        bin_pack_u16(bp, 0); // 1
  442|      0|        bin_pack_nil(bp); // 2
  443|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for saved peers list");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  444|      0|        return;
  445|      0|    }
  446|       |
  447|    256|    uint16_t packed_size = 0;
  448|    256|    const int count = pack_gc_saved_peers(chat, saved_peers, GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE, &packed_size);
  ------------------
  |  |   50|    256|#define GC_MAX_SAVED_PEERS 100
  ------------------
                  const int count = pack_gc_saved_peers(chat, saved_peers, GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE, &packed_size);
  ------------------
  |  |   51|    256|#define GC_SAVED_PEER_SIZE (ENC_PUBLIC_KEY_SIZE + sizeof(Node_format) + sizeof(IP_Port))
  |  |  ------------------
  |  |  |  |   85|    256|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   44|    256|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  449|       |
  450|    256|    if (count < 0) {
  ------------------
  |  Branch (450:9): [True: 0, False: 256]
  ------------------
  451|      0|        LOGGER_ERROR(chat->log, "Failed to pack saved peers");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  452|      0|    }
  453|       |
  454|    256|    bin_pack_u16(bp, packed_size); // 1
  455|       |
  456|    256|    if (packed_size == 0) {
  ------------------
  |  Branch (456:9): [True: 72, False: 184]
  ------------------
  457|     72|        bin_pack_nil(bp); // 2
  458|     72|        mem_delete(chat->mem, saved_peers);
  459|     72|        return;
  460|     72|    }
  461|       |
  462|    184|    bin_pack_bin(bp, saved_peers, packed_size); // 2
  463|       |
  464|    184|    mem_delete(chat->mem, saved_peers);
  465|    184|}

bs_list_init:
  136|  2.80k|{
  137|  2.80k|    list->mem = mem;
  138|       |
  139|       |    // set initial values
  140|  2.80k|    list->n = 0;
  141|  2.80k|    list->element_size = element_size;
  142|  2.80k|    list->capacity = 0;
  143|  2.80k|    list->data = nullptr;
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
  144|  2.80k|    list->ids = nullptr;
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
  145|  2.80k|    list->cmp_callback = cmp_callback;
  146|       |
  147|  2.80k|    if (initial_capacity != 0) {
  ------------------
  |  Branch (147:9): [True: 1.40k, False: 1.40k]
  ------------------
  148|  1.40k|        if (!resize(list, initial_capacity)) {
  ------------------
  |  Branch (148:13): [True: 0, False: 1.40k]
  ------------------
  149|      0|            return 0;
  150|      0|        }
  151|  1.40k|    }
  152|       |
  153|  2.80k|    list->capacity = initial_capacity;
  154|       |
  155|  2.80k|    return 1;
  156|  2.80k|}
bs_list_free:
  159|  2.80k|{
  160|  2.80k|    if (list == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
  |  Branch (160:9): [True: 0, False: 2.80k]
  ------------------
  161|      0|        return;
  162|      0|    }
  163|       |
  164|       |    // free both arrays
  165|  2.80k|    mem_delete(list->mem, list->data);
  166|  2.80k|    list->data = nullptr;
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
  167|       |
  168|  2.80k|    mem_delete(list->mem, list->ids);
  169|       |    list->ids = nullptr;
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
  170|  2.80k|}
bs_list_find:
  173|    429|{
  174|    429|    const int r = find(list, data);
  175|       |
  176|       |    // return only -1 and positive values
  177|    429|    if (r < 0) {
  ------------------
  |  Branch (177:9): [True: 429, False: 0]
  ------------------
  178|    429|        return -1;
  179|    429|    }
  180|       |
  181|      0|    return list->ids[r];
  182|    429|}
bs_list_add:
  185|    429|{
  186|       |    // find where the new element should be inserted
  187|       |    // see: return value of find()
  188|    429|    int i = find(list, data);
  189|       |
  190|    429|    if (i >= 0) {
  ------------------
  |  Branch (190:9): [True: 0, False: 429]
  ------------------
  191|       |        // already in list
  192|      0|        return false;
  193|      0|    }
  194|       |
  195|    429|    i = ~i;
  196|       |
  197|       |    // increase the size of the arrays if needed
  198|    429|    if (list->n == list->capacity) {
  ------------------
  |  Branch (198:9): [True: 360, False: 69]
  ------------------
  199|       |        // 1.5 * n + 1
  200|    360|        const uint32_t new_capacity = list->n + list->n / 2 + 1;
  201|       |
  202|    360|        if (!resize(list, new_capacity)) {
  ------------------
  |  Branch (202:13): [True: 0, False: 360]
  ------------------
  203|      0|            return false;
  204|      0|        }
  205|       |
  206|    360|        list->capacity = new_capacity;
  207|    360|    }
  208|       |
  209|       |    // insert data to element array
  210|    429|    assert(list->data != nullptr);
  ------------------
  |  Branch (210:5): [True: 429, False: 0]
  ------------------
  211|    429|    memmove(list->data + (i + 1) * list->element_size, list->data + i * list->element_size,
  212|    429|            (list->n - i) * list->element_size);
  213|    429|    memcpy(list->data + i * list->element_size, data, list->element_size);
  214|       |
  215|       |    // insert id to id array
  216|    429|    memmove(&list->ids[i + 1], &list->ids[i], (list->n - i) * sizeof(int));
  217|    429|    list->ids[i] = id;
  218|       |
  219|       |    // increase n
  220|    429|    ++list->n;
  221|       |
  222|       |    return true;
  223|    429|}
bs_list_remove:
  226|    429|{
  227|    429|    const int i = find(list, data);
  228|       |
  229|    429|    if (i < 0) {
  ------------------
  |  Branch (229:9): [True: 0, False: 429]
  ------------------
  230|      0|        return false;
  231|      0|    }
  232|       |
  233|    429|    if (list->ids[i] != id) {
  ------------------
  |  Branch (233:9): [True: 0, False: 429]
  ------------------
  234|       |        // this should never happen
  235|      0|        return false;
  236|      0|    }
  237|       |
  238|       |    // decrease the size of the arrays if needed
  239|    429|    if (list->n < list->capacity / 2) {
  ------------------
  |  Branch (239:9): [True: 60, False: 369]
  ------------------
  240|     60|        const uint32_t new_capacity = list->capacity / 2;
  241|       |
  242|     60|        if (resize(list, new_capacity)) {
  ------------------
  |  Branch (242:13): [True: 60, False: 0]
  ------------------
  243|     60|            list->capacity = new_capacity;
  244|     60|        }
  245|     60|    }
  246|       |
  247|    429|    --list->n;
  248|       |
  249|    429|    memmove(list->data + i * list->element_size, list->data + (i + 1) * list->element_size,
  250|    429|            (list->n - i) * list->element_size);
  251|    429|    memmove(&list->ids[i], &list->ids[i + 1], (list->n - i) * sizeof(int));
  252|       |
  253|       |    return true;
  254|    429|}
list.c:resize:
  110|  1.82k|{
  111|  1.82k|    if (new_size == 0) {
  ------------------
  |  Branch (111:9): [True: 0, False: 1.82k]
  ------------------
  112|      0|        bs_list_free(list);
  113|      0|        return true;
  114|      0|    }
  115|       |
  116|  1.82k|    uint8_t *data = (uint8_t *)mem_brealloc(list->mem, list->data, new_size * list->element_size);
  117|       |
  118|  1.82k|    if (data == nullptr) {
  ------------------
  |  |   63|  1.82k|#define nullptr NULL
  ------------------
  |  Branch (118:9): [True: 0, False: 1.82k]
  ------------------
  119|      0|        return false;
  120|      0|    }
  121|       |
  122|  1.82k|    list->data = data;
  123|       |
  124|  1.82k|    int *ids = (int *)mem_vrealloc(list->mem, list->ids, new_size, sizeof(int));
  125|       |
  126|  1.82k|    if (ids == nullptr) {
  ------------------
  |  |   63|  1.82k|#define nullptr NULL
  ------------------
  |  Branch (126:9): [True: 0, False: 1.82k]
  ------------------
  127|      0|        return false;
  128|      0|    }
  129|       |
  130|  1.82k|    list->ids = ids;
  131|       |
  132|       |    return true;
  133|  1.82k|}
list.c:find:
   45|  1.28k|{
   46|       |    // should work well, but could be improved
   47|  1.28k|    if (list->n == 0) {
  ------------------
  |  Branch (47:9): [True: 368, False: 919]
  ------------------
   48|    368|        return list_index(0);
   49|    368|    }
   50|       |
   51|    919|    uint32_t i = list->n / 2; // current position in the array
   52|    919|    uint32_t delta = i / 2;   // how much we move in the array
   53|       |
   54|    919|    if (delta == 0) {
  ------------------
  |  Branch (54:9): [True: 721, False: 198]
  ------------------
   55|    721|        delta = 1;
   56|    721|    }
   57|       |
   58|    919|    int d = -1; // used to determine if closest match is found
   59|       |    // closest match is found if we move back to where we have already been
   60|       |
   61|  1.44k|    while (true) {
  ------------------
  |  Branch (61:12): [True: 1.44k, Folded]
  ------------------
   62|  1.44k|        const int r = list->cmp_callback(data, list->data + list->element_size * i, list->element_size);
   63|       |
   64|  1.44k|        if (r == 0) {
  ------------------
  |  Branch (64:13): [True: 429, False: 1.02k]
  ------------------
   65|    429|            return i;
   66|    429|        }
   67|       |
   68|  1.02k|        if (r > 0) {
  ------------------
  |  Branch (68:13): [True: 457, False: 563]
  ------------------
   69|       |            // data is greater
   70|       |            // move down
   71|    457|            i += delta;
   72|       |
   73|    457|            if (d == 0 || i == list->n) {
  ------------------
  |  Branch (73:17): [True: 98, False: 359]
  |  Branch (73:27): [True: 216, False: 143]
  ------------------
   74|       |                // reached bottom of list, or closest match
   75|    314|                return list_index(i);
   76|    314|            }
   77|       |
   78|    143|            delta = delta / 2;
   79|       |
   80|    143|            if (delta == 0) {
  ------------------
  |  Branch (80:17): [True: 143, False: 0]
  ------------------
   81|    143|                delta = 1;
   82|    143|                d = 1;
   83|    143|            }
   84|    563|        } else {
   85|       |            // data is smaller
   86|    563|            if (d == 1 || i == 0) {
  ------------------
  |  Branch (86:17): [True: 32, False: 531]
  |  Branch (86:27): [True: 144, False: 387]
  ------------------
   87|       |                // reached top or list or closest match
   88|    176|                return list_index(i);
   89|    176|            }
   90|       |
   91|       |            // move up
   92|    387|            i -= delta;
   93|       |
   94|    387|            delta = delta / 2;
   95|       |
   96|    387|            if (delta == 0) {
  ------------------
  |  Branch (96:17): [True: 387, False: 0]
  ------------------
   97|    387|                delta = 1;
   98|    387|                d = 0;
   99|    387|            }
  100|    387|        }
  101|  1.02k|    }
  102|    919|}
list.c:list_index:
   34|    858|{
   35|    858|    return ~i;
   36|    858|}

logger_new:
   33|  1.40k|{
   34|  1.40k|    Logger *log = (Logger *)mem_alloc(mem, sizeof(Logger));
   35|       |
   36|  1.40k|    if (log == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (36:9): [True: 0, False: 1.40k]
  ------------------
   37|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   38|      0|    }
   39|       |
   40|  1.40k|    log->mem = mem;
   41|       |
   42|  1.40k|    return log;
   43|  1.40k|}
logger_kill:
   46|  1.40k|{
   47|  1.40k|    if (log == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (47:9): [True: 0, False: 1.40k]
  ------------------
   48|      0|        return;
   49|      0|    }
   50|       |
   51|  1.40k|    mem_delete(log->mem, log);
   52|  1.40k|}
logger_callback_log:
   55|  1.40k|{
   56|  1.40k|    assert(log != nullptr);
  ------------------
  |  Branch (56:5): [True: 1.40k, False: 0]
  ------------------
   57|  1.40k|    log->callback = function;
   58|  1.40k|    log->context  = context;
   59|  1.40k|    log->userdata = userdata;
   60|  1.40k|}
logger_write:
   64|  78.0k|{
   65|  78.0k|    if (log == nullptr) {
  ------------------
  |  |   63|  78.0k|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 0, False: 78.0k]
  ------------------
   66|      0|        return;
   67|      0|    }
   68|       |
   69|  78.0k|    if (log->callback == nullptr) {
  ------------------
  |  |   63|  78.0k|#define nullptr NULL
  ------------------
  |  Branch (69:9): [True: 0, False: 78.0k]
  ------------------
   70|      0|        return;
   71|      0|    }
   72|       |
   73|       |    // Only pass the file name, not the entire file path, for privacy reasons.
   74|       |    // The full path may contain PII of the person compiling toxcore (their
   75|       |    // username and directory layout).
   76|  78.0k|    const char *filename = strrchr(file, '/');
   77|  78.0k|    if (filename != nullptr) {
  ------------------
  |  |   63|  78.0k|#define nullptr NULL
  ------------------
  |  Branch (77:9): [True: 78.0k, False: 0]
  ------------------
   78|  78.0k|        file = &filename[1];
   79|  78.0k|    }
   80|       |#if defined(_WIN32) || defined(__CYGWIN__)
   81|       |    // On Windows, the path separator *may* be a backslash, so we look for that
   82|       |    // one too.
   83|       |    const char *windows_filename = strrchr(file, '\\');
   84|       |    file = windows_filename != nullptr ? windows_filename + 1 : file;
   85|       |#endif /* WIN32 */
   86|       |
   87|       |    // Format message
   88|  78.0k|    char msg[1024];
   89|  78.0k|    va_list args;
   90|  78.0k|    va_start(args, format);
   91|  78.0k|    vsnprintf(msg, sizeof(msg), format, args);
   92|  78.0k|    va_end(args);
   93|       |
   94|  78.0k|    log->callback(log->context, level, file, line, func, msg, log->userdata);
   95|  78.0k|}

mem_balloc:
   13|  74.2k|{
   14|  74.2k|    void *const ptr = mem->funcs->malloc_callback(mem->user_data, size);
   15|  74.2k|    return ptr;
   16|  74.2k|}
mem_brealloc:
   19|  45.4k|{
   20|  45.4k|    void *const new_ptr = mem->funcs->realloc_callback(mem->user_data, ptr, size);
   21|  45.4k|    return new_ptr;
   22|  45.4k|}
mem_alloc:
   25|  62.5k|{
   26|  62.5k|    void *const ptr = mem_balloc(mem, size);
   27|  62.5k|    if (ptr != nullptr) {
  ------------------
  |  |   63|  62.5k|#define nullptr NULL
  ------------------
  |  Branch (27:9): [True: 62.5k, False: 0]
  ------------------
   28|  62.5k|        memset(ptr, 0, size);
   29|  62.5k|    }
   30|  62.5k|    return ptr;
   31|  62.5k|}
mem_valloc:
   34|  16.0k|{
   35|  16.0k|    const uint32_t bytes = nmemb * size;
   36|       |
   37|  16.0k|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (37:9): [True: 16.0k, False: 0]
  |  Branch (37:22): [True: 0, False: 16.0k]
  ------------------
   38|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   39|      0|    }
   40|       |
   41|  16.0k|    void *const ptr = mem_alloc(mem, bytes);
   42|  16.0k|    return ptr;
   43|  16.0k|}
mem_vrealloc:
   46|  43.6k|{
   47|  43.6k|    const uint32_t bytes = nmemb * size;
   48|       |
   49|  43.6k|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (49:9): [True: 43.6k, False: 0]
  |  Branch (49:22): [True: 0, False: 43.6k]
  ------------------
   50|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   51|      0|    }
   52|       |
   53|  43.6k|    void *const new_ptr = mem_brealloc(mem, ptr, bytes);
   54|  43.6k|    return new_ptr;
   55|  43.6k|}
mem_delete:
   58|  1.09M|{
   59|  1.09M|    mem->funcs->dealloc_callback(mem->user_data, ptr);
   60|  1.09M|}

mono_time_new:
  111|  1.40k|{
  112|  1.40k|    Mono_Time *mono_time = (Mono_Time *)mem_alloc(mem, sizeof(Mono_Time));
  113|       |
  114|  1.40k|    if (mono_time == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (114:9): [True: 0, False: 1.40k]
  ------------------
  115|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  116|      0|    }
  117|       |
  118|  1.40k|#ifndef ESP_PLATFORM
  119|  1.40k|    pthread_rwlock_t *const rwlock = (pthread_rwlock_t *)mem_alloc(mem, sizeof(pthread_rwlock_t));
  120|       |
  121|  1.40k|    if (rwlock == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (121:9): [True: 0, False: 1.40k]
  ------------------
  122|      0|        mem_delete(mem, mono_time);
  123|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  124|      0|    }
  125|       |
  126|  1.40k|    if (pthread_rwlock_init(rwlock, nullptr) != 0) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (126:9): [True: 0, False: 1.40k]
  ------------------
  127|      0|        mem_delete(mem, rwlock);
  128|      0|        mem_delete(mem, mono_time);
  129|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  130|      0|    }
  131|       |
  132|  1.40k|    mono_time->time_update_lock = rwlock;
  133|  1.40k|#endif /* ESP_PLATFORM */
  134|       |
  135|  1.40k|    mono_time_set_current_time_callback(mono_time, current_time_callback, user_data);
  136|       |
  137|  1.40k|    mono_time->cur_time = 0;
  138|  1.40k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  139|       |    // Maximum reproducibility. Never return time = 0.
  140|  1.40k|    mono_time->base_time = 1000000000;
  141|       |#else
  142|       |    // Never return time = 0 in case time() returns 0 (e.g. on microcontrollers
  143|       |    // without battery-powered RTC or ones where NTP didn't initialise it yet).
  144|       |    mono_time->base_time = max_u64(1, (uint64_t)time(nullptr)) * UINT64_C(1000) - current_time_monotonic(mono_time);
  145|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  146|       |
  147|  1.40k|    mono_time_update(mono_time);
  148|       |
  149|  1.40k|    return mono_time;
  150|  1.40k|}
mono_time_free:
  153|  1.40k|{
  154|  1.40k|    if (mono_time == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (154:9): [True: 0, False: 1.40k]
  ------------------
  155|      0|        return;
  156|      0|    }
  157|  1.40k|#ifndef ESP_PLATFORM
  158|  1.40k|    pthread_rwlock_destroy(mono_time->time_update_lock);
  159|  1.40k|    mem_delete(mem, mono_time->time_update_lock);
  160|  1.40k|#endif /* ESP_PLATFORM */
  161|  1.40k|    mem_delete(mem, mono_time);
  162|  1.40k|}
mono_time_update:
  165|  1.40k|{
  166|  1.40k|    const uint64_t cur_time =
  167|  1.40k|        mono_time->base_time + mono_time->current_time_callback(mono_time->user_data);
  168|       |
  169|  1.40k|#ifndef ESP_PLATFORM
  170|  1.40k|    pthread_rwlock_wrlock(mono_time->time_update_lock);
  171|  1.40k|#endif /* ESP_PLATFORM */
  172|  1.40k|    mono_time->cur_time = cur_time;
  173|  1.40k|#ifndef ESP_PLATFORM
  174|  1.40k|    pthread_rwlock_unlock(mono_time->time_update_lock);
  175|  1.40k|#endif /* ESP_PLATFORM */
  176|  1.40k|}
mono_time_get_ms:
  179|  49.0k|{
  180|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  181|       |    // Fuzzing is only single thread for now, no locking needed */
  182|       |    pthread_rwlock_rdlock(mono_time->time_update_lock);
  183|       |#endif /* !ESP_PLATFORM */
  184|  49.0k|    const uint64_t cur_time = mono_time->cur_time;
  185|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  186|       |    pthread_rwlock_unlock(mono_time->time_update_lock);
  187|       |#endif /* !ESP_PLATFORM */
  188|  49.0k|    return cur_time;
  189|  49.0k|}
mono_time_get:
  192|  47.6k|{
  193|       |    return mono_time_get_ms(mono_time) / UINT64_C(1000);
  194|  47.6k|}
mono_time_set_current_time_callback:
  203|  1.40k|{
  204|  1.40k|    if (current_time_callback == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (204:9): [True: 0, False: 1.40k]
  ------------------
  205|      0|        mono_time->current_time_callback = current_time_monotonic_default;
  206|      0|        mono_time->user_data = mono_time;
  207|  1.40k|    } else {
  208|  1.40k|        mono_time->current_time_callback = current_time_callback;
  209|  1.40k|        mono_time->user_data = user_data;
  210|  1.40k|    }
  211|  1.40k|}

net_socket_to_native:
    9|  14.0k|{
   10|  14.0k|    return (force int)sock.value;
   11|  14.0k|}
net_socket_from_native:
   14|  4.21k|{
   15|  4.21k|    const Socket res = {(force Socket_Value)sock};
   16|  4.21k|    return res;
   17|  4.21k|}
ns_close:
   20|  1.40k|{
   21|  1.40k|    return ns->funcs->close(ns->obj, sock);
   22|  1.40k|}
ns_bind:
   30|  2.80k|{
   31|  2.80k|    return ns->funcs->bind(ns->obj, sock, addr);
   32|  2.80k|}
ns_socket:
   70|  1.40k|{
   71|  1.40k|    return ns->funcs->socket(ns->obj, domain, type, proto);
   72|  1.40k|}
ns_socket_nonblock:
   75|  1.40k|{
   76|  1.40k|    return ns->funcs->socket_nonblock(ns->obj, sock, nonblock);
   77|  1.40k|}
ns_getsockopt:
   80|  1.40k|{
   81|  1.40k|    return ns->funcs->getsockopt(ns->obj, sock, level, optname, optval, optlen);
   82|  1.40k|}
ns_setsockopt:
   85|  5.61k|{
   86|  5.61k|    return ns->funcs->setsockopt(ns->obj, sock, level, optname, optval, optlen);
   87|  5.61k|}
net_pack_u16:
  106|    404|{
  107|    404|    bytes[0] = (v >> 8) & 0xff;
  108|    404|    bytes[1] = v & 0xff;
  109|    404|    return sizeof(v);
  110|    404|}
net_pack_u32:
  113|    202|{
  114|    202|    uint8_t *p = bytes;
  115|    202|    p += net_pack_u16(p, (v >> 16) & 0xffff);
  116|    202|    p += net_pack_u16(p, v & 0xffff);
  117|    202|    return p - bytes;
  118|    202|}
net_pack_u64:
  121|    101|{
  122|    101|    uint8_t *p = bytes;
  123|    101|    p += net_pack_u32(p, (v >> 32) & 0xffffffff);
  124|    101|    p += net_pack_u32(p, v & 0xffffffff);
  125|    101|    return p - bytes;
  126|    101|}
net_unpack_u16:
  135|  1.20k|{
  136|  1.20k|    const uint8_t hi = bytes[0];
  137|  1.20k|    const uint8_t lo = bytes[1];
  138|  1.20k|    *v = ((uint16_t)hi << 8) | lo;
  139|  1.20k|    return sizeof(*v);
  140|  1.20k|}
net_unpack_u32:
  143|    600|{
  144|    600|    const uint8_t *p = bytes;
  145|    600|    uint16_t hi;
  146|    600|    uint16_t lo;
  147|    600|    p += net_unpack_u16(p, &hi);
  148|    600|    p += net_unpack_u16(p, &lo);
  149|    600|    *v = ((uint32_t)hi << 16) | lo;
  150|    600|    return p - bytes;
  151|    600|}
net_unpack_u64:
  154|    300|{
  155|    300|    const uint8_t *p = bytes;
  156|    300|    uint32_t hi;
  157|    300|    uint32_t lo;
  158|    300|    p += net_unpack_u32(p, &hi);
  159|    300|    p += net_unpack_u32(p, &lo);
  160|    300|    *v = ((uint64_t)hi << 32) | lo;
  161|    300|    return p - bytes;
  162|    300|}
net_family_unspec:
  175|  2.80k|{
  176|  2.80k|    return family_unspec;
  177|  2.80k|}
net_family_ipv4:
  180|  19.4k|{
  181|  19.4k|    return family_ipv4;
  182|  19.4k|}
net_family_ipv6:
  185|  6.93k|{
  186|  6.93k|    return family_ipv6;
  187|  6.93k|}
net_family_tcp_ipv4:
  200|    789|{
  201|    789|    return family_tcp_ipv4;
  202|    789|}
net_family_tcp_ipv6:
  205|  5.96k|{
  206|  5.96k|    return family_tcp_ipv6;
  207|  5.96k|}
net_family_is_unspec:
  220|  10.2k|{
  221|  10.2k|    return family.value == family_unspec.value;
  222|  10.2k|}
net_family_is_ipv4:
  225|  2.96M|{
  226|  2.96M|    return family.value == family_ipv4.value;
  227|  2.96M|}
net_family_is_ipv6:
  230|  2.94M|{
  231|  2.94M|    return family.value == family_ipv6.value;
  232|  2.94M|}
net_family_is_tcp_ipv4:
  245|  10.4k|{
  246|  10.4k|    return family.value == family_tcp_ipv4.value;
  247|  10.4k|}
net_family_is_tcp_ipv6:
  250|  5.91k|{
  251|  5.91k|    return family.value == family_tcp_ipv6.value;
  252|  5.91k|}

nc_get_self_public_key:
  172|  9.46k|{
  173|  9.46k|    return c->self_public_key;
  174|  9.46k|}
nc_get_tcp_c:
  182|  2.92k|{
  183|  2.92k|    return c->tcp_c;
  184|  2.92k|}
new_connection_handler:
 1931|  1.40k|{
 1932|  1.40k|    c->new_connection_callback = new_connection_callback;
 1933|  1.40k|    c->new_connection_callback_object = object;
 1934|  1.40k|}
copy_connected_tcp_relays:
 2276|    981|{
 2277|    981|    if (num == 0) {
  ------------------
  |  Branch (2277:9): [True: 6, False: 975]
  ------------------
 2278|      6|        return 0;
 2279|      6|    }
 2280|       |
 2281|    975|    return tcp_copy_connected_relays(c->tcp_c, tcp_relays, num);
 2282|    981|}
crypto_kill:
 2885|    429|{
 2886|    429|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 2887|       |
 2888|    429|    int ret = -1;
 2889|       |
 2890|    429|    if (conn != nullptr) {
  ------------------
  |  |   63|    429|#define nullptr NULL
  ------------------
  |  Branch (2890:9): [True: 0, False: 429]
  ------------------
 2891|      0|        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
  ------------------
  |  Branch (2891:13): [True: 0, False: 0]
  ------------------
 2892|      0|            send_kill_packet(c, crypt_connection_id);
 2893|      0|        }
 2894|       |
 2895|      0|        kill_tcp_connection_to(c->tcp_c, conn->connection_number_tcp);
 2896|       |
 2897|      0|        bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv4, crypt_connection_id);
 2898|      0|        bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv6, crypt_connection_id);
 2899|      0|        clear_temp_packet(c, crypt_connection_id);
 2900|      0|        clear_buffer(c->mem, &conn->send_array);
 2901|      0|        clear_buffer(c->mem, &conn->recv_array);
 2902|      0|        ret = wipe_crypto_connection(c, crypt_connection_id);
 2903|      0|    }
 2904|       |
 2905|    429|    return ret;
 2906|    429|}
new_keys:
 2936|  1.40k|{
 2937|  1.40k|    crypto_new_keypair(c->rng, c->self_public_key, c->self_secret_key);
 2938|  1.40k|}
save_keys:
 2946|    981|{
 2947|    981|    memcpy(keys, c->self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    981|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2948|    981|    memcpy(keys + CRYPTO_PUBLIC_KEY_SIZE, c->self_secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   44|    981|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(keys + CRYPTO_PUBLIC_KEY_SIZE, c->self_secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   49|    981|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 2949|    981|}
load_secret_key:
 2955|    558|{
 2956|    558|    memcpy(c->self_secret_key, sk, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   49|    558|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 2957|    558|    crypto_derive_public_key(c->self_public_key, c->self_secret_key);
 2958|    558|}
new_net_crypto:
 2965|  1.40k|{
 2966|  1.40k|    if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2966:9): [True: 0, False: 1.40k]
  |  Branch (2966:27): [True: 0, False: 1.40k]
  |  Branch (2966:51): [True: 0, False: 1.40k]
  |  Branch (2966:96): [True: 0, False: 1.40k]
  |  Branch (2966:141): [True: 0, False: 1.40k]
  ------------------
 2967|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2968|      0|    }
 2969|       |
 2970|  1.40k|    Net_Crypto *temp = (Net_Crypto *)mem_alloc(mem, sizeof(Net_Crypto));
 2971|       |
 2972|  1.40k|    if (temp == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2972:9): [True: 0, False: 1.40k]
  ------------------
 2973|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2974|      0|    }
 2975|       |
 2976|  1.40k|    temp->log = log;
 2977|  1.40k|    temp->mem = mem;
 2978|  1.40k|    temp->rng = rng;
 2979|  1.40k|    temp->mono_time = mono_time;
 2980|  1.40k|    temp->ns = ns;
 2981|  1.40k|    temp->net = net;
 2982|       |
 2983|  1.40k|    temp->dht = dht;
 2984|  1.40k|    temp->dht_funcs = dht_funcs;
 2985|       |
 2986|  1.40k|    TCP_Connections *const tcp_c = new_tcp_connections(log, mem, rng, ns, mono_time, dht_funcs->get_self_secret_key(dht), proxy_info, tcp_np);
 2987|       |
 2988|  1.40k|    if (tcp_c == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2988:9): [True: 0, False: 1.40k]
  ------------------
 2989|      0|        mem_delete(mem, temp);
 2990|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2991|      0|    }
 2992|       |
 2993|  1.40k|    temp->tcp_c = tcp_c;
 2994|       |
 2995|  1.40k|    set_packet_tcp_connection_callback(temp->tcp_c, &tcp_data_callback, temp);
 2996|  1.40k|    set_oob_packet_tcp_connection_callback(temp->tcp_c, &tcp_oob_callback, temp);
 2997|       |
 2998|  1.40k|    new_keys(temp);
 2999|  1.40k|    new_symmetric_key(rng, temp->secret_symmetric_key);
 3000|       |
 3001|  1.40k|    temp->current_sleep_time = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |  111|  1.40k|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 3002|       |
 3003|  1.40k|    networking_registerhandler(net, NET_PACKET_COOKIE_REQUEST, &udp_handle_cookie_request, temp);
 3004|  1.40k|    networking_registerhandler(net, NET_PACKET_COOKIE_RESPONSE, &udp_handle_packet, temp);
 3005|  1.40k|    networking_registerhandler(net, NET_PACKET_CRYPTO_HS, &udp_handle_packet, temp);
 3006|  1.40k|    networking_registerhandler(net, NET_PACKET_CRYPTO_DATA, &udp_handle_packet, temp);
 3007|       |
 3008|  1.40k|    bs_list_init(&temp->ip_port_list, mem, sizeof(IP_Port), 8, ipport_cmp_handler);
 3009|       |
 3010|  1.40k|    temp->cookie_request_tokens = COOKIE_REQUEST_MAX_TOKENS;
  ------------------
  |  |  212|  1.40k|#define COOKIE_REQUEST_MAX_TOKENS 10
  ------------------
 3011|  1.40k|    temp->cookie_request_last_time = mono_time_get_ms(mono_time);
 3012|       |
 3013|  1.40k|    return temp;
 3014|  1.40k|}
kill_net_crypto:
 3059|  1.40k|{
 3060|  1.40k|    if (c == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (3060:9): [True: 0, False: 1.40k]
  ------------------
 3061|      0|        return;
 3062|      0|    }
 3063|       |
 3064|  1.40k|    const Memory *mem = c->mem;
 3065|       |
 3066|  1.40k|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (3066:26): [True: 0, False: 1.40k]
  ------------------
 3067|      0|        crypto_kill(c, i);
 3068|      0|    }
 3069|       |
 3070|  1.40k|    kill_tcp_connections(c->tcp_c);
 3071|  1.40k|    bs_list_free(&c->ip_port_list);
 3072|  1.40k|    networking_registerhandler(c->net, NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 3073|  1.40k|    networking_registerhandler(c->net, NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 3074|  1.40k|    networking_registerhandler(c->net, NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 3075|  1.40k|    networking_registerhandler(c->net, NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 3076|  1.40k|    crypto_memzero(c, sizeof(Net_Crypto));
 3077|  1.40k|    mem_delete(mem, c);
 3078|  1.40k|}
net_crypto.c:crypt_connection_id_is_valid:
  187|    429|{
  188|    429|    if ((uint32_t)crypt_connection_id >= c->crypto_connections_length) {
  ------------------
  |  Branch (188:9): [True: 429, False: 0]
  ------------------
  189|    429|        return false;
  190|    429|    }
  191|       |
  192|      0|    if (c->crypto_connections == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (192:9): [True: 0, False: 0]
  ------------------
  193|      0|        return false;
  194|      0|    }
  195|       |
  196|      0|    const Crypto_Conn_State status = c->crypto_connections[crypt_connection_id].status;
  197|       |
  198|      0|    return status != CRYPTO_CONN_NO_CONNECTION && status != CRYPTO_CONN_FREE;
  ------------------
  |  Branch (198:12): [True: 0, False: 0]
  |  Branch (198:51): [True: 0, False: 0]
  ------------------
  199|      0|}
net_crypto.c:get_crypto_connection:
  596|    429|{
  597|    429|    if (!crypt_connection_id_is_valid(c, crypt_connection_id)) {
  ------------------
  |  Branch (597:9): [True: 429, False: 0]
  ------------------
  598|    429|        return nullptr;
  ------------------
  |  |   63|    429|#define nullptr NULL
  ------------------
  599|    429|    }
  600|       |
  601|      0|    return &c->crypto_connections[crypt_connection_id];
  602|    429|}

netprof_new:
  139|  2.80k|{
  140|  2.80k|    Net_Profile *np = (Net_Profile *)mem_alloc(mem, sizeof(Net_Profile));
  141|       |
  142|  2.80k|    if (np == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
  |  Branch (142:9): [True: 0, False: 2.80k]
  ------------------
  143|      0|        LOGGER_ERROR(log, "failed to allocate memory for net profiler");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  144|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  145|      0|    }
  146|       |
  147|  2.80k|    return np;
  148|  2.80k|}
netprof_kill:
  151|  2.80k|{
  152|  2.80k|    if (net_profile != nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
  |  Branch (152:9): [True: 2.80k, False: 0]
  ------------------
  153|  2.80k|        mem_delete(mem, net_profile);
  154|  2.80k|    }
  155|  2.80k|}

sock_valid:
   56|  1.40k|{
   57|  1.40k|    const Socket invalid_socket = net_invalid_socket();
   58|  1.40k|    return sock.value != invalid_socket.value;
   59|  1.40k|}
kill_sock:
   94|  1.40k|{
   95|  1.40k|    ns_close(ns, sock);
   96|  1.40k|}
set_socket_nonblock:
   99|  1.40k|{
  100|  1.40k|    return net_set_socket_nonblock(ns, sock);
  101|  1.40k|}
set_socket_nosigpipe:
  104|  1.40k|{
  105|  1.40k|    return net_set_socket_nosigpipe(ns, sock);
  106|  1.40k|}
set_socket_dualstack:
  114|  1.40k|{
  115|  1.40k|    return net_set_socket_dualstack(ns, sock);
  116|  1.40k|}
networking_registerhandler:
  251|  88.4k|{
  252|  88.4k|    net->packethandlers[byte].function = cb;
  253|  88.4k|    net->packethandlers[byte].object = object;
  254|  88.4k|}
new_networking_ex:
  300|  1.40k|{
  301|       |    /* If both from and to are 0, use default port range
  302|       |     * If one is 0 and the other is non-0, use the non-0 value as only port
  303|       |     * If from > to, swap
  304|       |     */
  305|  1.40k|    if (port_from == 0 && port_to == 0) {
  ------------------
  |  Branch (305:9): [True: 1.40k, False: 0]
  |  Branch (305:27): [True: 1.40k, False: 0]
  ------------------
  306|  1.40k|        port_from = TOX_PORTRANGE_FROM;
  ------------------
  |  |   79|  1.40k|#define TOX_PORTRANGE_FROM 33445
  ------------------
  307|  1.40k|        port_to = TOX_PORTRANGE_TO;
  ------------------
  |  |   80|  1.40k|#define TOX_PORTRANGE_TO   33545
  ------------------
  308|  1.40k|    } else if (port_from == 0 && port_to != 0) {
  ------------------
  |  Branch (308:16): [True: 0, False: 0]
  |  Branch (308:34): [True: 0, False: 0]
  ------------------
  309|      0|        port_from = port_to;
  310|      0|    } else if (port_from != 0 && port_to == 0) {
  ------------------
  |  Branch (310:16): [True: 0, False: 0]
  |  Branch (310:34): [True: 0, False: 0]
  ------------------
  311|      0|        port_to = port_from;
  312|      0|    } else if (port_from > port_to) {
  ------------------
  |  Branch (312:16): [True: 0, False: 0]
  ------------------
  313|      0|        const uint16_t temp_port = port_from;
  314|      0|        port_from = port_to;
  315|      0|        port_to = temp_port;
  316|      0|    }
  317|       |
  318|  1.40k|    if (error != nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (318:9): [True: 1.40k, False: 0]
  ------------------
  319|  1.40k|        *error = 2;
  320|  1.40k|    }
  321|       |
  322|       |    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
  323|  1.40k|    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (323:9): [True: 1.40k, False: 0]
  |  Branch (323:44): [True: 0, False: 1.40k]
  ------------------
  324|      0|        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  325|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  326|      0|    }
  327|       |
  328|  1.40k|    Networking_Core *temp = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
  329|       |
  330|  1.40k|    if (temp == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (330:9): [True: 0, False: 1.40k]
  ------------------
  331|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  332|      0|    }
  333|       |
  334|  1.40k|    Net_Profile *np = netprof_new(log, mem);
  335|       |
  336|  1.40k|    if (np == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (336:9): [True: 0, False: 1.40k]
  ------------------
  337|      0|        mem_delete(mem, temp);
  338|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  339|      0|    }
  340|       |
  341|  1.40k|    temp->udp_net_profile = np;
  342|  1.40k|    temp->ns = ns;
  343|  1.40k|    temp->log = log;
  344|  1.40k|    temp->mem = mem;
  345|  1.40k|    temp->family = ip->family;
  346|  1.40k|    temp->port = 0;
  347|       |
  348|       |    /* Initialize our socket. */
  349|       |    /* add log message what we're creating */
  350|  1.40k|    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |   71|  1.40k|#define TOX_SOCK_DGRAM 2
  ------------------
                  temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |   74|  1.40k|#define TOX_PROTO_UDP 2
  ------------------
  351|       |
  352|       |    /* Check for socket error. */
  353|  1.40k|    if (!sock_valid(temp->sock)) {
  ------------------
  |  Branch (353:9): [True: 0, False: 1.40k]
  ------------------
  354|      0|        const int neterror = net_error();
  355|      0|        Net_Strerror error_str;
  356|      0|        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  357|      0|        netprof_kill(mem, temp->udp_net_profile);
  358|      0|        mem_delete(mem, temp);
  359|       |
  360|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (360:13): [True: 0, False: 0]
  ------------------
  361|      0|            *error = 1;
  362|      0|        }
  363|       |
  364|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  365|      0|    }
  366|       |
  367|       |    /* Functions to increase the size of the send and receive UDP buffers.
  368|       |     */
  369|  1.40k|    if (!net_set_socket_buffer_size(ns, temp->sock, 1024 * 1024 * 2)) {
  ------------------
  |  Branch (369:9): [True: 0, False: 1.40k]
  ------------------
  370|      0|        LOGGER_WARNING(log, "failed to set socket buffer size");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  371|      0|    }
  372|       |
  373|       |    /* Enable broadcast on socket */
  374|  1.40k|    if (!net_set_socket_broadcast(ns, temp->sock)) {
  ------------------
  |  Branch (374:9): [True: 0, False: 1.40k]
  ------------------
  375|      0|        LOGGER_ERROR(log, "failed to set socket broadcast");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  376|      0|    }
  377|       |
  378|       |    /* iOS UDP sockets are weird and apparently can SIGPIPE */
  379|  1.40k|    if (!set_socket_nosigpipe(ns, temp->sock)) {
  ------------------
  |  Branch (379:9): [True: 0, False: 1.40k]
  ------------------
  380|      0|        kill_networking(temp);
  381|       |
  382|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (382:13): [True: 0, False: 0]
  ------------------
  383|      0|            *error = 1;
  384|      0|        }
  385|       |
  386|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  387|      0|    }
  388|       |
  389|       |    /* Set socket nonblocking. */
  390|  1.40k|    if (!set_socket_nonblock(ns, temp->sock)) {
  ------------------
  |  Branch (390:9): [True: 0, False: 1.40k]
  ------------------
  391|      0|        kill_networking(temp);
  392|       |
  393|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (393:13): [True: 0, False: 0]
  ------------------
  394|      0|            *error = 1;
  395|      0|        }
  396|       |
  397|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  398|      0|    }
  399|       |
  400|       |    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
  401|  1.40k|    uint16_t *portptr = nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  402|  1.40k|    IP_Port addr;
  403|  1.40k|    ip_init(&addr.ip, net_family_is_ipv6(temp->family));
  404|       |
  405|  1.40k|    if (net_family_is_ipv4(temp->family) || net_family_is_ipv6(temp->family)) {
  ------------------
  |  Branch (405:9): [True: 0, False: 1.40k]
  |  Branch (405:45): [True: 1.40k, False: 0]
  ------------------
  406|  1.40k|        ip_copy(&addr.ip, ip);
  407|  1.40k|        addr.port = 0;
  408|  1.40k|        portptr = &addr.port;
  409|  1.40k|    } else {
  410|      0|        mem_delete(mem, temp);
  411|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  412|      0|    }
  413|       |
  414|  1.40k|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (414:9): [True: 1.40k, False: 0]
  ------------------
  415|  1.40k|        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);
  416|       |
  417|  1.40k|        if (is_dualstack) {
  ------------------
  |  Branch (417:13): [True: 1.40k, False: 0]
  ------------------
  418|  1.40k|            LOGGER_TRACE(log, "Dual-stack socket: enabled");
  ------------------
  |  |   76|  1.40k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  1.40k|    do {                                                                         \
  |  |  |  |   70|  1.40k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  2.80k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 1.40k]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|  1.40k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1.40k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  419|  1.40k|        } else {
  420|      0|            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  421|      0|        }
  422|       |
  423|  1.40k|        if (!net_join_multicast(ns, temp->sock, ip->family)) {
  ------------------
  |  Branch (423:13): [True: 0, False: 1.40k]
  ------------------
  424|      0|            const int neterror = net_error();
  425|      0|            Net_Strerror error_str;
  426|      0|            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   78|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  427|  1.40k|        } else {
  428|  1.40k|            const int neterror = net_error();
  429|  1.40k|            Net_Strerror error_str;
  430|  1.40k|            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   76|  1.40k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  1.40k|    do {                                                                         \
  |  |  |  |   70|  1.40k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  2.80k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 1.40k]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|  1.40k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1.40k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  431|  1.40k|        }
  432|  1.40k|    }
  433|       |
  434|       |    /* A hanging program or a different user might block the standard port.
  435|       |     * As long as it isn't a parameter coming from the commandline,
  436|       |     * try a few ports after it, to see if we can find a "free" one.
  437|       |     *
  438|       |     * If we go on without binding, the first sendto() automatically binds to
  439|       |     * a free port chosen by the system (i.e. anything from 1024 to 65535).
  440|       |     *
  441|       |     * Returning NULL after bind fails has both advantages and disadvantages:
  442|       |     * advantage:
  443|       |     *   we can rely on getting the port in the range 33445..33450, which
  444|       |     *   enables us to tell joe user to open their firewall to a small range
  445|       |     *
  446|       |     * disadvantage:
  447|       |     *   some clients might not test return of tox_new(), blindly assuming that
  448|       |     *   it worked ok (which it did previously without a successful bind)
  449|       |     */
  450|  1.40k|    uint16_t port_to_try = port_from;
  451|  1.40k|    *portptr = net_htons(port_to_try);
  452|       |
  453|  2.80k|    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
  ------------------
  |  Branch (453:38): [True: 2.80k, False: 0]
  ------------------
  454|  2.80k|        const int res = ns_bind(ns, temp->sock, &addr);
  455|       |
  456|  2.80k|        if (res == 0) {
  ------------------
  |  Branch (456:13): [True: 1.40k, False: 1.40k]
  ------------------
  457|  1.40k|            temp->port = *portptr;
  458|       |
  459|  1.40k|            Ip_Ntoa ip_str;
  460|  1.40k|            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
  ------------------
  |  |   77|  1.40k|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|  1.40k|    do {                                                                         \
  |  |  |  |   70|  1.40k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  2.80k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 1.40k]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|  1.40k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1.40k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  461|  1.40k|                         net_ntohs(temp->port));
  462|       |
  463|       |            /* errno isn't reset on success, only set on failure, the failed
  464|       |             * binds with parallel clients yield a -EPERM to the outside if
  465|       |             * errno isn't cleared here */
  466|  1.40k|            if (tries > 0) {
  ------------------
  |  Branch (466:17): [True: 1.40k, False: 0]
  ------------------
  467|  1.40k|                net_clear_error();
  468|  1.40k|            }
  469|       |
  470|  1.40k|            if (error != nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (470:17): [True: 1.40k, False: 0]
  ------------------
  471|  1.40k|                *error = 0;
  472|  1.40k|            }
  473|       |
  474|  1.40k|            return temp;
  475|  1.40k|        }
  476|       |
  477|  1.40k|        ++port_to_try;
  478|       |
  479|  1.40k|        if (port_to_try > port_to) {
  ------------------
  |  Branch (479:13): [True: 0, False: 1.40k]
  ------------------
  480|      0|            port_to_try = port_from;
  481|      0|        }
  482|       |
  483|  1.40k|        *portptr = net_htons(port_to_try);
  484|  1.40k|    }
  485|       |
  486|      0|    Ip_Ntoa ip_str;
  487|      0|    const int neterror = net_error();
  488|      0|    Net_Strerror error_str;
  489|      0|    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u",
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  490|      0|                 neterror, net_strerror(neterror, &error_str), net_ip_ntoa(ip, &ip_str), port_from, port_to);
  491|      0|    kill_networking(temp);
  492|       |
  493|      0|    if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (493:9): [True: 0, False: 0]
  ------------------
  494|      0|        *error = 1;
  495|      0|    }
  496|       |
  497|       |    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  498|  1.40k|}
kill_networking:
  518|  1.40k|{
  519|  1.40k|    if (net == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (519:9): [True: 0, False: 1.40k]
  ------------------
  520|      0|        return;
  521|      0|    }
  522|       |
  523|  1.40k|    if (!net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (523:9): [True: 1.40k, False: 0]
  ------------------
  524|       |        /* Socket is initialized, so we close it. */
  525|  1.40k|        kill_sock(net->ns, net->sock);
  526|  1.40k|    }
  527|       |
  528|  1.40k|    netprof_kill(net->mem, net->udp_net_profile);
  529|  1.40k|    mem_delete(net->mem, net);
  530|  1.40k|}
ip_reset:
  635|  9.83k|{
  636|  9.83k|    if (ip == nullptr) {
  ------------------
  |  |   63|  9.83k|#define nullptr NULL
  ------------------
  |  Branch (636:9): [True: 0, False: 9.83k]
  ------------------
  637|      0|        return;
  638|      0|    }
  639|       |
  640|  9.83k|    *ip = empty_ip;
  641|  9.83k|}
ipport_reset:
  647|  11.5k|{
  648|  11.5k|    if (ipport == nullptr) {
  ------------------
  |  |   63|  11.5k|#define nullptr NULL
  ------------------
  |  Branch (648:9): [True: 0, False: 11.5k]
  ------------------
  649|      0|        return;
  650|      0|    }
  651|       |
  652|  11.5k|    *ipport = empty_ip_port;
  653|  11.5k|}
ip_init:
  657|  9.83k|{
  658|  9.83k|    if (ip == nullptr) {
  ------------------
  |  |   63|  9.83k|#define nullptr NULL
  ------------------
  |  Branch (658:9): [True: 0, False: 9.83k]
  ------------------
  659|      0|        return;
  660|      0|    }
  661|       |
  662|  9.83k|    ip_reset(ip);
  663|  9.83k|    ip->family = ipv6enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (663:18): [True: 2.80k, False: 7.02k]
  ------------------
  664|  9.83k|}
ip_isset:
  668|  1.83k|{
  669|  1.83k|    if (ip == nullptr) {
  ------------------
  |  |   63|  1.83k|#define nullptr NULL
  ------------------
  |  Branch (669:9): [True: 0, False: 1.83k]
  ------------------
  670|      0|        return false;
  671|      0|    }
  672|       |
  673|  1.83k|    return !net_family_is_unspec(ip->family);
  674|  1.83k|}
ipport_isset:
  678|  52.0k|{
  679|  52.0k|    if (ipport == nullptr) {
  ------------------
  |  |   63|  52.0k|#define nullptr NULL
  ------------------
  |  Branch (679:9): [True: 0, False: 52.0k]
  ------------------
  680|      0|        return false;
  681|      0|    }
  682|       |
  683|  52.0k|    if (ipport->port == 0) {
  ------------------
  |  Branch (683:9): [True: 50.2k, False: 1.83k]
  ------------------
  684|  50.2k|        return false;
  685|  50.2k|    }
  686|       |
  687|  1.83k|    return ip_isset(&ipport->ip);
  688|  52.0k|}
ip_copy:
  692|  1.40k|{
  693|  1.40k|    if (source == nullptr || target == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if (source == nullptr || target == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (693:9): [True: 0, False: 1.40k]
  |  Branch (693:30): [True: 0, False: 1.40k]
  ------------------
  694|      0|        return;
  695|      0|    }
  696|       |
  697|  1.40k|    *target = *source;
  698|  1.40k|}
bin_pack_ip_port:
  740|  9.66k|{
  741|  9.66k|    bool is_ipv4;
  742|  9.66k|    uint8_t family;
  743|       |
  744|  9.66k|    if (net_family_is_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (744:9): [True: 8.02k, False: 1.63k]
  ------------------
  745|       |        // TODO(irungentoo): use functions to convert endianness
  746|  8.02k|        is_ipv4 = true;
  747|  8.02k|        family = TOX_AF_INET;
  ------------------
  |  |   65|  8.02k|#define TOX_AF_INET 2
  ------------------
  748|  8.02k|    } else if (net_family_is_tcp_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (748:16): [True: 1.13k, False: 504]
  ------------------
  749|  1.13k|        is_ipv4 = true;
  750|  1.13k|        family = TOX_TCP_INET;
  ------------------
  |  |   67|  1.13k|#define TOX_TCP_INET 130
  ------------------
  751|  1.13k|    } else if (net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (751:16): [True: 474, False: 30]
  ------------------
  752|    474|        is_ipv4 = false;
  753|    474|        family = TOX_AF_INET6;
  ------------------
  |  |   66|    474|#define TOX_AF_INET6 10
  ------------------
  754|    474|    } else if (net_family_is_tcp_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (754:16): [True: 30, False: 0]
  ------------------
  755|     30|        is_ipv4 = false;
  756|     30|        family = TOX_TCP_INET6;
  ------------------
  |  |   68|     30|#define TOX_TCP_INET6 138
  ------------------
  757|     30|    } else {
  758|      0|        Ip_Ntoa ip_str;
  759|       |        // TODO(iphydf): Find out why we're trying to pack invalid IPs, stop
  760|       |        // doing that, and turn this into an error.
  761|      0|        LOGGER_TRACE(logger, "cannot pack invalid IP: %s", net_ip_ntoa(&ip_port->ip, &ip_str));
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  762|      0|        return false;
  763|      0|    }
  764|       |
  765|  9.66k|    return bin_pack_u08_b(bp, family)
  ------------------
  |  Branch (765:12): [True: 9.66k, False: 0]
  ------------------
  766|  9.66k|           && bin_pack_ip(bp, &ip_port->ip, is_ipv4)
  ------------------
  |  Branch (766:15): [True: 9.66k, False: 0]
  ------------------
  767|  9.66k|           && bin_pack_u16_b(bp, net_ntohs(ip_port->port));
  ------------------
  |  Branch (767:15): [True: 9.66k, False: 0]
  ------------------
  768|  9.66k|}
pack_ip_port:
  777|    584|{
  778|    584|    const uint32_t size = bin_pack_obj_size(bin_pack_ip_port_handler, ip_port, logger);
  779|       |
  780|    584|    if (size > length) {
  ------------------
  |  Branch (780:9): [True: 0, False: 584]
  ------------------
  781|      0|        return -1;
  782|      0|    }
  783|       |
  784|    584|    if (!bin_pack_obj(bin_pack_ip_port_handler, ip_port, logger, data, length)) {
  ------------------
  |  Branch (784:9): [True: 0, False: 584]
  ------------------
  785|      0|        return -1;
  786|      0|    }
  787|       |
  788|    584|    assert(size < INT_MAX);
  ------------------
  |  Branch (788:5): [True: 584, False: 0]
  ------------------
  789|    584|    return (int)size;
  790|    584|}
unpack_ip_port:
  793|  12.3k|{
  794|  12.3k|    if (data == nullptr) {
  ------------------
  |  |   63|  12.3k|#define nullptr NULL
  ------------------
  |  Branch (794:9): [True: 0, False: 12.3k]
  ------------------
  795|      0|        return -1;
  796|      0|    }
  797|       |
  798|  12.3k|    bool is_ipv4;
  799|  12.3k|    Family host_family;
  800|       |
  801|  12.3k|    if (data[0] == TOX_AF_INET) {
  ------------------
  |  |   65|  12.3k|#define TOX_AF_INET 2
  ------------------
  |  Branch (801:9): [True: 9.49k, False: 2.87k]
  ------------------
  802|  9.49k|        is_ipv4 = true;
  803|  9.49k|        host_family = net_family_ipv4();
  804|  9.49k|    } else if (data[0] == TOX_TCP_INET) {
  ------------------
  |  |   67|  2.87k|#define TOX_TCP_INET 130
  ------------------
  |  Branch (804:16): [True: 902, False: 1.97k]
  ------------------
  805|    902|        if (!tcp_enabled) {
  ------------------
  |  Branch (805:13): [True: 113, False: 789]
  ------------------
  806|    113|            return -1;
  807|    113|        }
  808|       |
  809|    789|        is_ipv4 = true;
  810|    789|        host_family = net_family_tcp_ipv4();
  811|  1.97k|    } else if (data[0] == TOX_AF_INET6) {
  ------------------
  |  |   66|  1.97k|#define TOX_AF_INET6 10
  ------------------
  |  Branch (811:16): [True: 1.18k, False: 790]
  ------------------
  812|  1.18k|        is_ipv4 = false;
  813|  1.18k|        host_family = net_family_ipv6();
  814|  1.18k|    } else if (data[0] == TOX_TCP_INET6) {
  ------------------
  |  |   68|    790|#define TOX_TCP_INET6 138
  ------------------
  |  Branch (814:16): [True: 93, False: 697]
  ------------------
  815|     93|        if (!tcp_enabled) {
  ------------------
  |  Branch (815:13): [True: 11, False: 82]
  ------------------
  816|     11|            return -1;
  817|     11|        }
  818|       |
  819|     82|        is_ipv4 = false;
  820|     82|        host_family = net_family_tcp_ipv6();
  821|    697|    } else {
  822|    697|        return -1;
  823|    697|    }
  824|       |
  825|  11.5k|    ipport_reset(ip_port);
  826|       |
  827|  11.5k|    if (is_ipv4) {
  ------------------
  |  Branch (827:9): [True: 10.2k, False: 1.26k]
  ------------------
  828|  10.2k|        const uint32_t size = 1 + SIZE_IP4 + sizeof(uint16_t);
  ------------------
  |  |   25|  10.2k|#define SIZE_IP4 4
  ------------------
  829|       |
  830|  10.2k|        if (size > length) {
  ------------------
  |  Branch (830:13): [True: 49, False: 10.2k]
  ------------------
  831|     49|            return -1;
  832|     49|        }
  833|       |
  834|  10.2k|        ip_port->ip.family = host_family;
  835|  10.2k|        memcpy(ip_port->ip.ip.v4.uint8, data + 1, SIZE_IP4);
  ------------------
  |  |   25|  10.2k|#define SIZE_IP4 4
  ------------------
  836|  10.2k|        memcpy(&ip_port->port, data + 1 + SIZE_IP4, sizeof(uint16_t));
  ------------------
  |  |   25|  10.2k|#define SIZE_IP4 4
  ------------------
  837|  10.2k|        return size;
  838|  10.2k|    } else {
  839|  1.26k|        const uint32_t size = 1 + SIZE_IP6 + sizeof(uint16_t);
  ------------------
  |  |   26|  1.26k|#define SIZE_IP6 16
  ------------------
  840|       |
  841|  1.26k|        if (size > length) {
  ------------------
  |  Branch (841:13): [True: 66, False: 1.19k]
  ------------------
  842|     66|            return -1;
  843|     66|        }
  844|       |
  845|  1.19k|        ip_port->ip.family = host_family;
  846|  1.19k|        memcpy(ip_port->ip.ip.v6.uint8, data + 1, SIZE_IP6);
  ------------------
  |  |   26|  1.19k|#define SIZE_IP6 16
  ------------------
  847|  1.19k|        memcpy(&ip_port->port, data + 1 + SIZE_IP6, sizeof(uint16_t));
  ------------------
  |  |   26|  1.19k|#define SIZE_IP6 16
  ------------------
  848|  1.19k|        return size;
  849|  1.26k|    }
  850|  11.5k|}
net_socket:
 1153|  1.40k|{
 1154|  1.40k|    return ns_socket(ns, domain.value, type, protocol);
 1155|  1.40k|}
network.c:bin_pack_ip:
  727|  9.66k|{
  728|  9.66k|    if (is_ipv4) {
  ------------------
  |  Branch (728:9): [True: 9.15k, False: 504]
  ------------------
  729|  9.15k|        return bin_pack_bin_b(bp, ip->ip.v4.uint8, SIZE_IP4);
  ------------------
  |  |   25|  9.15k|#define SIZE_IP4 4
  ------------------
  730|  9.15k|    } else {
  731|    504|        return bin_pack_bin_b(bp, ip->ip.v6.uint8, SIZE_IP6);
  ------------------
  |  |   26|    504|#define SIZE_IP6 16
  ------------------
  732|    504|    }
  733|  9.66k|}
network.c:bin_pack_ip_port_handler:
  771|  1.16k|{
  772|  1.16k|    const IP_Port *ip_port = (const IP_Port *)obj;
  773|  1.16k|    return bin_pack_ip_port(bp, logger, ip_port);
  774|  1.16k|}

new_onion:
  706|  1.40k|{
  707|  1.40k|    if (dht == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (707:9): [True: 0, False: 1.40k]
  ------------------
  708|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  709|      0|    }
  710|       |
  711|  1.40k|    Onion *onion = (Onion *)mem_alloc(mem, sizeof(Onion));
  712|       |
  713|  1.40k|    if (onion == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (713:9): [True: 0, False: 1.40k]
  ------------------
  714|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  715|      0|    }
  716|       |
  717|  1.40k|    onion->log = log;
  718|  1.40k|    onion->dht = dht;
  719|  1.40k|    onion->net = net;
  720|  1.40k|    onion->mono_time = mono_time;
  721|  1.40k|    onion->rng = rng;
  722|  1.40k|    onion->mem = mem;
  723|  1.40k|    new_symmetric_key(rng, onion->secret_symmetric_key);
  724|  1.40k|    onion->timestamp = mono_time_get(onion->mono_time);
  725|       |
  726|  1.40k|    const uint8_t *secret_key = dht_get_self_secret_key(dht);
  727|  1.40k|    Shared_Key_Cache *const temp_shared_keys_1 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   38|  1.40k|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_1 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   37|  1.40k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  728|  1.40k|    Shared_Key_Cache *const temp_shared_keys_2 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   38|  1.40k|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_2 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   37|  1.40k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  729|  1.40k|    Shared_Key_Cache *const temp_shared_keys_3 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   38|  1.40k|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_3 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   37|  1.40k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  730|       |
  731|  1.40k|    if (temp_shared_keys_1 == nullptr || temp_shared_keys_2 == nullptr || temp_shared_keys_3 == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if (temp_shared_keys_1 == nullptr || temp_shared_keys_2 == nullptr || temp_shared_keys_3 == nullptr) {
  ------------------
  |  |   63|  2.80k|#define nullptr NULL
  ------------------
                  if (temp_shared_keys_1 == nullptr || temp_shared_keys_2 == nullptr || temp_shared_keys_3 == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (731:9): [True: 0, False: 1.40k]
  |  Branch (731:42): [True: 0, False: 1.40k]
  |  Branch (731:75): [True: 0, False: 1.40k]
  ------------------
  732|      0|        shared_key_cache_free(temp_shared_keys_3);
  733|      0|        shared_key_cache_free(temp_shared_keys_2);
  734|      0|        shared_key_cache_free(temp_shared_keys_1);
  735|       |        // cppcheck-suppress mismatchAllocDealloc
  736|      0|        kill_onion(onion);
  737|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  738|      0|    }
  739|       |
  740|  1.40k|    onion->shared_keys_1 = temp_shared_keys_1;
  741|  1.40k|    onion->shared_keys_2 = temp_shared_keys_2;
  742|  1.40k|    onion->shared_keys_3 = temp_shared_keys_3;
  743|       |
  744|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, &handle_send_initial, onion);
  745|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, &handle_send_1, onion);
  746|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, &handle_send_2, onion);
  747|       |
  748|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, &handle_recv_3, onion);
  749|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, &handle_recv_2, onion);
  750|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, &handle_recv_1, onion);
  751|       |
  752|  1.40k|    return onion;
  753|  1.40k|}
kill_onion:
  756|  1.40k|{
  757|  1.40k|    if (onion == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (757:9): [True: 0, False: 1.40k]
  ------------------
  758|      0|        return;
  759|      0|    }
  760|       |
  761|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  762|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  763|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  764|       |
  765|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  766|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  767|  1.40k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  768|       |
  769|  1.40k|    crypto_memzero(onion->secret_symmetric_key, sizeof(onion->secret_symmetric_key));
  770|       |
  771|  1.40k|    shared_key_cache_free(onion->shared_keys_1);
  772|  1.40k|    shared_key_cache_free(onion->shared_keys_2);
  773|  1.40k|    shared_key_cache_free(onion->shared_keys_3);
  774|       |
  775|  1.40k|    mem_delete(onion->mem, onion);
  776|  1.40k|}

onion_announce_extra_data_callback:
   76|  1.40k|{
   77|  1.40k|    onion_a->extra_data_max_size = extra_data_max_size;
   78|  1.40k|    onion_a->extra_data_callback = extra_data_callback;
   79|  1.40k|    onion_a->extra_data_object = extra_data_object;
   80|  1.40k|}
new_onion_announce:
  685|  1.40k|{
  686|  1.40k|    if (dht == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (686:9): [True: 0, False: 1.40k]
  ------------------
  687|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  688|      0|    }
  689|       |
  690|  1.40k|    Onion_Announce *onion_a = (Onion_Announce *)mem_alloc(mem, sizeof(Onion_Announce));
  691|       |
  692|  1.40k|    if (onion_a == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (692:9): [True: 0, False: 1.40k]
  ------------------
  693|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  694|      0|    }
  695|       |
  696|  1.40k|    Shared_Key_Cache *const shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht_get_self_secret_key(dht), KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   44|  1.40k|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht_get_self_secret_key(dht), KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   43|  1.40k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  697|  1.40k|    if (shared_keys_recv == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (697:9): [True: 0, False: 1.40k]
  ------------------
  698|      0|        mem_delete(mem, onion_a);
  699|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  700|      0|    }
  701|  1.40k|    onion_a->shared_keys_recv = shared_keys_recv;
  702|       |
  703|  1.40k|    onion_a->log = log;
  704|  1.40k|    onion_a->rng = rng;
  705|  1.40k|    onion_a->mem = mem;
  706|  1.40k|    onion_a->mono_time = mono_time;
  707|  1.40k|    onion_a->dht = dht;
  708|  1.40k|    onion_a->net = net;
  709|  1.40k|    onion_a->extra_data_max_size = 0;
  710|  1.40k|    onion_a->extra_data_callback = nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  711|  1.40k|    onion_a->extra_data_object = nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  712|  1.40k|    new_hmac_key(rng, onion_a->hmac_key);
  713|       |
  714|  1.40k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, &handle_announce_request, onion_a);
  715|  1.40k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, &handle_announce_request_old, onion_a);
  716|  1.40k|    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, &handle_data_request, onion_a);
  717|       |
  718|  1.40k|    return onion_a;
  719|  1.40k|}
kill_onion_announce:
  722|  1.40k|{
  723|  1.40k|    if (onion_a == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (723:9): [True: 0, False: 1.40k]
  ------------------
  724|      0|        return;
  725|      0|    }
  726|       |
  727|  1.40k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  728|  1.40k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  729|  1.40k|    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  730|       |
  731|  1.40k|    crypto_memzero(onion_a->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  125|  1.40k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  732|  1.40k|    shared_key_cache_free(onion_a->shared_keys_recv);
  733|       |
  734|  1.40k|    mem_delete(onion_a->mem, onion_a);
  735|  1.40k|}

onion_get_friend:
  176|     88|{
  177|     88|    return &onion_c->friends_list[friend_num];
  178|     88|}
onion_friend_set_gc_public_key:
  191|     88|{
  192|     88|    memcpy(onion_friend->gc_public_key, public_key, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |   85|     88|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   44|     88|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  193|     88|}
onion_friend_set_gc_data:
  196|     88|{
  197|     88|    if (gc_data_length > 0 && gc_data != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (197:9): [True: 0, False: 88]
  |  Branch (197:31): [True: 0, False: 0]
  ------------------
  198|      0|        memcpy(onion_friend->gc_data, gc_data, gc_data_length);
  199|      0|    }
  200|       |
  201|     88|    onion_friend->gc_data_length = gc_data_length;
  202|       |    onion_friend->is_groupchat = true;
  203|     88|}
onion_add_bs_path_node:
  224|  2.45k|{
  225|  2.45k|    if (!net_family_is_ipv4(ip_port->ip.family) && !net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (225:9): [True: 72, False: 2.37k]
  |  Branch (225:52): [True: 0, False: 72]
  ------------------
  226|      0|        return false;
  227|      0|    }
  228|       |
  229|  59.1k|    for (unsigned int i = 0; i < MAX_PATH_NODES; ++i) {
  ------------------
  |  |   52|  59.1k|#define MAX_PATH_NODES 32
  ------------------
  |  Branch (229:30): [True: 57.8k, False: 1.31k]
  ------------------
  230|  57.8k|        if (pk_equal(public_key, onion_c->path_nodes_bs[i].public_key)) {
  ------------------
  |  Branch (230:13): [True: 1.13k, False: 56.6k]
  ------------------
  231|  1.13k|            return true;
  232|  1.13k|        }
  233|  57.8k|    }
  234|       |
  235|  1.31k|    onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].ip_port = *ip_port;
  ------------------
  |  |   52|  1.31k|#define MAX_PATH_NODES 32
  ------------------
  236|  1.31k|    memcpy(onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].public_key, public_key,
  ------------------
  |  |   52|  1.31k|#define MAX_PATH_NODES 32
  ------------------
  237|  1.31k|           CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|  1.31k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  238|       |
  239|  1.31k|    const uint16_t last = onion_c->path_nodes_index_bs;
  240|  1.31k|    ++onion_c->path_nodes_index_bs;
  241|       |
  242|  1.31k|    if (onion_c->path_nodes_index_bs < last) {
  ------------------
  |  Branch (242:9): [True: 0, False: 1.31k]
  ------------------
  243|      0|        onion_c->path_nodes_index_bs = MAX_PATH_NODES + 1;
  ------------------
  |  |   52|      0|#define MAX_PATH_NODES 32
  ------------------
  244|      0|    }
  245|       |
  246|       |    return true;
  247|  2.45k|}
onion_backup_nodes:
  285|    981|{
  286|    981|    if (max_num == 0) {
  ------------------
  |  Branch (286:9): [True: 0, False: 981]
  ------------------
  287|      0|        return 0;
  288|      0|    }
  289|       |
  290|    981|    const uint16_t num_nodes = min_u16(onion_c->path_nodes_index, MAX_PATH_NODES);
  ------------------
  |  |   52|    981|#define MAX_PATH_NODES 32
  ------------------
  291|    981|    uint16_t i = 0;
  292|       |
  293|    981|    while (i < max_num && i < num_nodes) {
  ------------------
  |  Branch (293:12): [True: 981, False: 0]
  |  Branch (293:27): [True: 0, False: 981]
  ------------------
  294|      0|        nodes[i] = onion_c->path_nodes[(onion_c->path_nodes_index - (1 + i)) % num_nodes];
  295|      0|        ++i;
  296|      0|    }
  297|       |
  298|  1.17k|    for (uint16_t j = 0; i < max_num && j < MAX_PATH_NODES && j < onion_c->path_nodes_index_bs; ++j) {
  ------------------
  |  |   52|  2.33k|#define MAX_PATH_NODES 32
  ------------------
  |  Branch (298:26): [True: 1.15k, False: 17]
  |  Branch (298:41): [True: 1.15k, False: 0]
  |  Branch (298:63): [True: 194, False: 964]
  ------------------
  299|    194|        bool already_saved = false;
  300|       |
  301|    194|        for (uint16_t k = 0; k < num_nodes; ++k) {
  ------------------
  |  Branch (301:30): [True: 0, False: 194]
  ------------------
  302|      0|            if (pk_equal(nodes[k].public_key, onion_c->path_nodes_bs[j].public_key)) {
  ------------------
  |  Branch (302:17): [True: 0, False: 0]
  ------------------
  303|      0|                already_saved = true;
  304|      0|                break;
  305|      0|            }
  306|      0|        }
  307|       |
  308|    194|        if (!already_saved) {
  ------------------
  |  Branch (308:13): [True: 194, False: 0]
  ------------------
  309|    194|            nodes[i] = onion_c->path_nodes_bs[j];
  310|    194|            ++i;
  311|    194|        }
  312|    194|    }
  313|       |
  314|    981|    return i;
  315|    981|}
onion_friend_num:
 1492|    429|{
 1493|    429|    return bs_list_find(&onion_c->friends_lookup, public_key);
 1494|    429|}
onion_addfriend:
 1537|    429|{
 1538|    429|    const int num = onion_friend_num(onion_c, public_key);
 1539|       |
 1540|    429|    if (num != -1) {
  ------------------
  |  Branch (1540:9): [True: 0, False: 429]
  ------------------
 1541|      0|        return num;
 1542|      0|    }
 1543|       |
 1544|    429|    uint32_t index = (uint32_t) -1;
 1545|       |
 1546|  1.00k|    for (uint32_t i = 0; i < onion_c->num_friends; ++i) {
  ------------------
  |  Branch (1546:26): [True: 578, False: 429]
  ------------------
 1547|    578|        if (!onion_c->friends_list[i].is_valid) {
  ------------------
  |  Branch (1547:13): [True: 0, False: 578]
  ------------------
 1548|      0|            index = i;
 1549|      0|            break;
 1550|      0|        }
 1551|    578|    }
 1552|       |
 1553|    429|    if (index == (uint32_t) -1) {
  ------------------
  |  Branch (1553:9): [True: 429, False: 0]
  ------------------
 1554|    429|        if (realloc_onion_friends(onion_c, onion_c->num_friends + 1) == -1) {
  ------------------
  |  Branch (1554:13): [True: 0, False: 429]
  ------------------
 1555|      0|            return -1;
 1556|      0|        }
 1557|       |
 1558|    429|        index = onion_c->num_friends;
 1559|    429|        onion_c->friends_list[onion_c->num_friends] = empty_onion_friend;
 1560|    429|        ++onion_c->num_friends;
 1561|    429|    }
 1562|       |
 1563|    429|    onion_c->friends_list[index].is_valid = true;
 1564|    429|    memcpy(onion_c->friends_list[index].real_public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    429|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1565|    429|    crypto_new_keypair(onion_c->rng, onion_c->friends_list[index].temp_public_key,
 1566|    429|                       onion_c->friends_list[index].temp_secret_key);
 1567|       |
 1568|    429|    if (!bs_list_add(&onion_c->friends_lookup, public_key, index)) {
  ------------------
  |  Branch (1568:9): [True: 0, False: 429]
  ------------------
 1569|      0|        LOGGER_ERROR(onion_c->logger, "Failed to add friend to lookup list (index: %u)", index);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1570|      0|        return -1;
 1571|      0|    }
 1572|       |
 1573|    429|    return index;
 1574|    429|}
onion_delfriend:
 1582|    429|{
 1583|    429|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1583:9): [True: 0, False: 429]
  ------------------
 1584|      0|        return -1;
 1585|      0|    }
 1586|       |
 1587|       |#if 0
 1588|       |
 1589|       |    if (onion_c->friends_list[friend_num].know_dht_public_key) {
 1590|       |        dht_delfriend(onion_c->dht, onion_c->friends_list[friend_num].dht_public_key, 0);
 1591|       |    }
 1592|       |
 1593|       |#endif /* 0 */
 1594|       |
 1595|    429|    if (!bs_list_remove(&onion_c->friends_lookup, onion_c->friends_list[friend_num].real_public_key, friend_num)) {
  ------------------
  |  Branch (1595:9): [True: 0, False: 429]
  ------------------
 1596|      0|        LOGGER_ERROR(onion_c->logger, "Failed to remove friend from lookup list (index: %d)", friend_num);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1597|      0|    }
 1598|       |
 1599|    429|    crypto_memzero(&onion_c->friends_list[friend_num], sizeof(Onion_Friend));
 1600|    429|    uint32_t i;
 1601|       |
 1602|    858|    for (i = onion_c->num_friends; i != 0; --i) {
  ------------------
  |  Branch (1602:36): [True: 674, False: 184]
  ------------------
 1603|    674|        if (onion_c->friends_list[i - 1].is_valid) {
  ------------------
  |  Branch (1603:13): [True: 245, False: 429]
  ------------------
 1604|    245|            break;
 1605|    245|        }
 1606|    674|    }
 1607|       |
 1608|    429|    onion_c->num_friends = i;
 1609|       |
 1610|    429|    return friend_num;
 1611|    429|}
recv_tcp_relay_handler:
 1623|    429|{
 1624|    429|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1624:9): [True: 0, False: 429]
  ------------------
 1625|      0|        return -1;
 1626|      0|    }
 1627|       |
 1628|    429|    onion_c->friends_list[friend_num].tcp_relay_node_callback = callback;
 1629|    429|    onion_c->friends_list[friend_num].tcp_relay_node_callback_object = object;
 1630|    429|    onion_c->friends_list[friend_num].tcp_relay_node_callback_number = number;
 1631|    429|    return 0;
 1632|    429|}
onion_dht_pk_callback:
 1644|    429|{
 1645|    429|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1645:9): [True: 0, False: 429]
  ------------------
 1646|      0|        return -1;
 1647|      0|    }
 1648|       |
 1649|    429|    onion_c->friends_list[friend_num].dht_pk_callback = function;
 1650|    429|    onion_c->friends_list[friend_num].dht_pk_callback_object = object;
 1651|    429|    onion_c->friends_list[friend_num].dht_pk_callback_number = number;
 1652|    429|    return 0;
 1653|    429|}
oniondata_registerhandler:
 1894|  4.21k|{
 1895|  4.21k|    onion_c->onion_data_handlers[byte].function = cb;
 1896|  4.21k|    onion_c->onion_data_handlers[byte].object = object;
 1897|  4.21k|}
onion_group_announce_register:
 1900|  2.80k|{
 1901|  2.80k|    onion_c->group_announce_response = func;
 1902|  2.80k|    onion_c->group_announce_response_user_data = user_data;
 1903|  2.80k|}
new_onion_client:
 2182|  1.40k|{
 2183|  1.40k|    if (c == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2183:9): [True: 0, False: 1.40k]
  ------------------
 2184|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2185|      0|    }
 2186|       |
 2187|  1.40k|    Onion_Client *onion_c = (Onion_Client *)mem_alloc(mem, sizeof(Onion_Client));
 2188|       |
 2189|  1.40k|    if (onion_c == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2189:9): [True: 0, False: 1.40k]
  ------------------
 2190|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2191|      0|    }
 2192|       |
 2193|  1.40k|    Ping_Array *const temp_ping_array = ping_array_new(mem, ANNOUNCE_ARRAY_SIZE, ANNOUNCE_TIMEOUT);
  ------------------
  |  |   37|  1.40k|#define ANNOUNCE_ARRAY_SIZE 256
  ------------------
                  Ping_Array *const temp_ping_array = ping_array_new(mem, ANNOUNCE_ARRAY_SIZE, ANNOUNCE_TIMEOUT);
  ------------------
  |  |   38|  1.40k|#define ANNOUNCE_TIMEOUT 10
  ------------------
 2194|       |
 2195|  1.40k|    if (temp_ping_array == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2195:9): [True: 0, False: 1.40k]
  ------------------
 2196|      0|        mem_delete(mem, onion_c);
 2197|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2198|      0|    }
 2199|  1.40k|    onion_c->announce_ping_array = temp_ping_array;
 2200|       |
 2201|  1.40k|    onion_c->mono_time = mono_time;
 2202|  1.40k|    onion_c->logger = logger;
 2203|  1.40k|    onion_c->rng = rng;
 2204|  1.40k|    onion_c->mem = mem;
 2205|  1.40k|    onion_c->dht = dht;
 2206|  1.40k|    onion_c->net = net;
 2207|  1.40k|    onion_c->c = c;
 2208|  1.40k|    onion_c->friends_list_capacity = 0;
 2209|  1.40k|    bs_list_init(&onion_c->friends_lookup, mem, CRYPTO_PUBLIC_KEY_SIZE, 0, memcmp);
  ------------------
  |  |   44|  1.40k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2210|       |
 2211|  1.40k|    new_symmetric_key(rng, onion_c->secret_symmetric_key);
 2212|  1.40k|    crypto_new_keypair(rng, onion_c->temp_public_key, onion_c->temp_secret_key);
 2213|  1.40k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, &handle_announce_response, onion_c);
 2214|  1.40k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, &handle_announce_response_old, onion_c);
 2215|  1.40k|    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, &handle_data_response, onion_c);
 2216|  1.40k|    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, &handle_dhtpk_announce, onion_c);
  ------------------
  |  |   66|  1.40k|#define ONION_DATA_DHTPK CRYPTO_PACKET_DHTPK
  |  |  ------------------
  |  |  |  |   70|  1.40k|#define CRYPTO_PACKET_DHTPK         156
  |  |  ------------------
  ------------------
 2217|  1.40k|    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, &handle_dht_dhtpk, onion_c);
  ------------------
  |  |   70|  1.40k|#define CRYPTO_PACKET_DHTPK         156
  ------------------
 2218|  1.40k|    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), &handle_tcp_onion, onion_c);
 2219|       |
 2220|  1.40k|    return onion_c;
 2221|  1.40k|}
kill_onion_client:
 2224|  1.40k|{
 2225|  1.40k|    if (onion_c == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (2225:9): [True: 0, False: 1.40k]
  ------------------
 2226|      0|        return;
 2227|      0|    }
 2228|       |
 2229|  1.40k|    const Memory *mem = onion_c->mem;
 2230|       |
 2231|  1.40k|    ping_array_kill(onion_c->announce_ping_array);
 2232|  1.40k|    realloc_onion_friends(onion_c, 0);
 2233|  1.40k|    bs_list_free(&onion_c->friends_lookup);
 2234|  1.40k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 2235|  1.40k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 2236|  1.40k|    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 2237|  1.40k|    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   66|  1.40k|#define ONION_DATA_DHTPK CRYPTO_PACKET_DHTPK
  |  |  ------------------
  |  |  |  |   70|  1.40k|#define CRYPTO_PACKET_DHTPK         156
  |  |  ------------------
  ------------------
                  oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 2238|  1.40k|    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   70|  1.40k|#define CRYPTO_PACKET_DHTPK         156
  ------------------
                  cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 2239|  1.40k|    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 2240|  1.40k|    crypto_memzero(onion_c, sizeof(Onion_Client));
 2241|  1.40k|    mem_delete(mem, onion_c);
 2242|  1.40k|}
onion_client.c:realloc_onion_friends:
 1502|  1.83k|{
 1503|  1.83k|    if (num == 0) {
  ------------------
  |  Branch (1503:9): [True: 1.40k, False: 429]
  ------------------
 1504|  1.40k|        mem_delete(onion_c->mem, onion_c->friends_list);
 1505|  1.40k|        onion_c->friends_list = nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
 1506|  1.40k|        onion_c->friends_list_capacity = 0;
 1507|  1.40k|        return 0;
 1508|  1.40k|    }
 1509|       |
 1510|    429|    if (num <= onion_c->friends_list_capacity) {
  ------------------
  |  Branch (1510:9): [True: 69, False: 360]
  ------------------
 1511|     69|        return 0;
 1512|     69|    }
 1513|       |
 1514|       |    // Geometric growth: Double the capacity or set to num if starting.
 1515|    360|    uint32_t new_capacity = onion_c->friends_list_capacity == 0 ? num : onion_c->friends_list_capacity * 2;
  ------------------
  |  Branch (1515:29): [True: 184, False: 176]
  ------------------
 1516|    360|    if (new_capacity < num) {
  ------------------
  |  Branch (1516:9): [True: 0, False: 360]
  ------------------
 1517|      0|        new_capacity = num;
 1518|      0|    }
 1519|       |
 1520|    360|    Onion_Friend *newonion_friends = (Onion_Friend *)mem_vrealloc(onion_c->mem, onion_c->friends_list, new_capacity, sizeof(Onion_Friend));
 1521|       |
 1522|    360|    if (newonion_friends == nullptr) {
  ------------------
  |  |   63|    360|#define nullptr NULL
  ------------------
  |  Branch (1522:9): [True: 0, False: 360]
  ------------------
 1523|      0|        return -1;
 1524|      0|    }
 1525|       |
 1526|    360|    onion_c->friends_list = newonion_friends;
 1527|    360|    onion_c->friends_list_capacity = new_capacity;
 1528|    360|    return 0;
 1529|    360|}

os_memory:
   37|  1.40k|{
   38|  1.40k|    return &os_memory_obj;
   39|  1.40k|}

os_network:
  569|  1.40k|{
  570|  1.40k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  571|  1.40k|    if ((true)) {
  ------------------
  |  Branch (571:9): [True: 1.40k, Folded]
  ------------------
  572|  1.40k|        return nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  573|  1.40k|    }
  574|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  575|       |#ifdef OS_WIN32
  576|       |    WSADATA wsaData;
  577|       |
  578|       |    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != NO_ERROR) {
  579|       |        return nullptr;
  580|       |    }
  581|       |#endif /* OS_WIN32 */
  582|      0|    return &os_network_obj;
  583|  1.40k|}
net_invalid_socket:
  586|  1.40k|{
  587|  1.40k|    return net_socket_from_native(INVALID_SOCKET);
  ------------------
  |  |  152|  1.40k|#define INVALID_SOCKET (-1)
  ------------------
  588|  1.40k|}
net_htonl:
  591|  5.62k|{
  592|       |    return htonl(hostlong);
  593|  5.62k|}
net_htons:
  596|  6.93k|{
  597|       |    return htons(hostshort);
  598|  6.93k|}
net_ntohs:
  606|  14.6k|{
  607|       |    return ntohs(hostshort);
  608|  14.6k|}
net_join_multicast:
  650|  1.40k|{
  651|  1.40k|#ifndef ESP_PLATFORM
  652|  1.40k|    if (net_family_is_ipv6(family)) {
  ------------------
  |  Branch (652:9): [True: 1.40k, False: 0]
  ------------------
  653|       |        /* multicast local nodes */
  654|  1.40k|        struct ipv6_mreq mreq = {{{{0}}}};
  655|  1.40k|        mreq.ipv6mr_multiaddr.s6_addr[0] = 0xFF;
  656|  1.40k|        mreq.ipv6mr_multiaddr.s6_addr[1] = 0x02;
  657|  1.40k|        mreq.ipv6mr_multiaddr.s6_addr[15] = 0x01;
  658|  1.40k|        mreq.ipv6mr_interface = 0;
  659|       |
  660|  1.40k|        return ns_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) == 0;
  661|  1.40k|    }
  662|      0|#endif /* ESP_PLATFORM */
  663|      0|    return false;
  664|  1.40k|}
net_set_socket_nonblock:
  667|  1.40k|{
  668|       |    return ns_socket_nonblock(ns, sock, true) == 0;
  669|  1.40k|}
net_set_socket_nosigpipe:
  672|  1.40k|{
  673|       |#if defined(__APPLE__)
  674|       |    int set = 1;
  675|       |    return ns_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
  676|       |#else
  677|       |    return true;
  678|  1.40k|#endif /* __APPLE__ */
  679|  1.40k|}
net_set_socket_dualstack:
  692|  1.40k|{
  693|  1.40k|    int ipv6only = 0;
  694|  1.40k|    size_t optsize = sizeof(ipv6only);
  695|  1.40k|    const int res = ns_getsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, &optsize);
  696|       |
  697|  1.40k|    if ((res == 0) && (ipv6only == 0)) {
  ------------------
  |  Branch (697:9): [True: 1.40k, False: 0]
  |  Branch (697:23): [True: 1.40k, False: 0]
  ------------------
  698|  1.40k|        return true;
  699|  1.40k|    }
  700|       |
  701|      0|    ipv6only = 0;
  702|      0|    return ns_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only)) == 0;
  703|  1.40k|}
net_set_socket_buffer_size:
  706|  1.40k|{
  707|  1.40k|    bool ok = true;
  708|       |
  709|  1.40k|    if (ns_setsockopt(ns, sock, SOL_SOCKET, SO_RCVBUF, &size, sizeof(size)) != 0) {
  ------------------
  |  Branch (709:9): [True: 0, False: 1.40k]
  ------------------
  710|      0|        ok = false;
  711|      0|    }
  712|       |
  713|  1.40k|    if (ns_setsockopt(ns, sock, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size)) != 0) {
  ------------------
  |  Branch (713:9): [True: 0, False: 1.40k]
  ------------------
  714|      0|        ok = false;
  715|      0|    }
  716|       |
  717|  1.40k|    return ok;
  718|  1.40k|}
net_set_socket_broadcast:
  721|  1.40k|{
  722|  1.40k|    int broadcast = 1;
  723|  1.40k|    return ns_setsockopt(ns, sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) == 0;
  724|  1.40k|}
net_error:
  727|  1.40k|{
  728|       |#ifdef OS_WIN32
  729|       |    return WSAGetLastError();
  730|       |#else
  731|       |    return errno;
  732|  1.40k|#endif /* OS_WIN32 */
  733|  1.40k|}
net_clear_error:
  736|  1.40k|{
  737|       |#ifdef OS_WIN32
  738|       |    WSASetLastError(0);
  739|       |#else
  740|       |    errno = 0;
  741|  1.40k|#endif /* OS_WIN32 */
  742|  1.40k|}

os_random:
   31|  1.40k|{
   32|  1.40k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
   33|  1.40k|    if ((true)) {
  ------------------
  |  Branch (33:9): [True: 1.40k, Folded]
  ------------------
   34|  1.40k|        return nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
   35|  1.40k|    }
   36|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
   37|       |    // It is safe to call this function more than once and from different
   38|       |    // threads -- subsequent calls won't have any effects.
   39|      0|    if (sodium_init() == -1) {
  ------------------
  |  Branch (39:9): [True: 0, False: 0]
  ------------------
   40|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   41|      0|    }
   42|      0|    return &os_random_obj;
   43|      0|}

ping_new:
  329|  1.40k|{
  330|  1.40k|    Ping *ping = (Ping *)mem_alloc(mem, sizeof(Ping));
  331|       |
  332|  1.40k|    if (ping == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (332:9): [True: 0, False: 1.40k]
  ------------------
  333|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  334|      0|    }
  335|       |
  336|  1.40k|    Ping_Array *const ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   23|  1.40k|#define PING_NUM_MAX 512
  ------------------
                  Ping_Array *const ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   46|  1.40k|#define PING_TIMEOUT 5
  ------------------
  337|       |
  338|  1.40k|    if (ping_array == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (338:9): [True: 0, False: 1.40k]
  ------------------
  339|      0|        mem_delete(mem, ping);
  340|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  341|      0|    }
  342|  1.40k|    ping->ping_array = ping_array;
  343|       |
  344|  1.40k|    ping->mono_time = mono_time;
  345|  1.40k|    ping->rng = rng;
  346|  1.40k|    ping->mem = mem;
  347|  1.40k|    ping->dht = dht;
  348|  1.40k|    ping->net = net;
  349|  1.40k|    networking_registerhandler(ping->net, NET_PACKET_PING_REQUEST, &handle_ping_request, dht);
  350|  1.40k|    networking_registerhandler(ping->net, NET_PACKET_PING_RESPONSE, &handle_ping_response, dht);
  351|       |
  352|  1.40k|    return ping;
  353|  1.40k|}
ping_kill:
  356|  1.40k|{
  357|  1.40k|    if (ping == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (357:9): [True: 0, False: 1.40k]
  ------------------
  358|      0|        return;
  359|      0|    }
  360|       |
  361|  1.40k|    networking_registerhandler(ping->net, NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(ping->net, NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  362|  1.40k|    networking_registerhandler(ping->net, NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
                  networking_registerhandler(ping->net, NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  363|  1.40k|    ping_array_kill(ping->ping_array);
  364|       |
  365|  1.40k|    mem_delete(mem, ping);
  366|  1.40k|}

ping_array_new:
   37|  4.21k|{
   38|  4.21k|    if (size == 0 || timeout == 0) {
  ------------------
  |  Branch (38:9): [True: 0, False: 4.21k]
  |  Branch (38:22): [True: 0, False: 4.21k]
  ------------------
   39|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   40|      0|    }
   41|       |
   42|  4.21k|    if ((size & (size - 1)) != 0) {
  ------------------
  |  Branch (42:9): [True: 0, False: 4.21k]
  ------------------
   43|       |        // Not a power of 2.
   44|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   45|      0|    }
   46|       |
   47|  4.21k|    Ping_Array *const empty_array = (Ping_Array *)mem_alloc(mem, sizeof(Ping_Array));
   48|       |
   49|  4.21k|    if (empty_array == nullptr) {
  ------------------
  |  |   63|  4.21k|#define nullptr NULL
  ------------------
  |  Branch (49:9): [True: 0, False: 4.21k]
  ------------------
   50|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   51|      0|    }
   52|       |
   53|  4.21k|    Ping_Array_Entry *const entries = (Ping_Array_Entry *)mem_valloc(mem, size, sizeof(Ping_Array_Entry));
   54|       |
   55|  4.21k|    if (entries == nullptr) {
  ------------------
  |  |   63|  4.21k|#define nullptr NULL
  ------------------
  |  Branch (55:9): [True: 0, False: 4.21k]
  ------------------
   56|      0|        mem_delete(mem, empty_array);
   57|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   58|      0|    }
   59|  4.21k|    empty_array->entries = entries;
   60|       |
   61|  4.21k|    empty_array->mem = mem;
   62|  4.21k|    empty_array->last_deleted = 0;
   63|  4.21k|    empty_array->last_added = 0;
   64|  4.21k|    empty_array->total_size = size;
   65|  4.21k|    empty_array->timeout = timeout;
   66|  4.21k|    return empty_array;
   67|  4.21k|}
ping_array_kill:
   77|  4.21k|{
   78|  4.21k|    if (array == nullptr) {
  ------------------
  |  |   63|  4.21k|#define nullptr NULL
  ------------------
  |  Branch (78:9): [True: 0, False: 4.21k]
  ------------------
   79|      0|        return;
   80|      0|    }
   81|       |
   82|  4.21k|    while (array->last_deleted != array->last_added) {
  ------------------
  |  Branch (82:12): [True: 0, False: 4.21k]
  ------------------
   83|      0|        const uint32_t index = array->last_deleted % array->total_size;
   84|      0|        clear_entry(array, index);
   85|      0|        ++array->last_deleted;
   86|      0|    }
   87|       |
   88|  4.21k|    mem_delete(array->mem, array->entries);
   89|  4.21k|    mem_delete(array->mem, array);
   90|  4.21k|}

rng_bytes:
    7|  21.2k|{
    8|  21.2k|    rng->funcs->bytes_callback(rng->user_data, bytes, length);
    9|  21.2k|}

shared_key_cache_new:
   50|  9.82k|{
   51|  9.82k|    if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|  19.6k|#define nullptr NULL
  ------------------
                  if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|  19.6k|#define nullptr NULL
  ------------------
  |  Branch (51:9): [True: 0, False: 9.82k]
  |  Branch (51:33): [True: 0, False: 9.82k]
  |  Branch (51:63): [True: 0, False: 9.82k]
  |  Branch (51:79): [True: 0, False: 9.82k]
  ------------------
   52|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   53|      0|    }
   54|       |
   55|       |    // Time must not be zero, since we use that as special value for empty slots
   56|  9.82k|    if (mono_time_get(mono_time) == 0) {
  ------------------
  |  Branch (56:9): [True: 0, False: 9.82k]
  ------------------
   57|       |        // Fail loudly in debug environments
   58|      0|        LOGGER_FATAL(log, "time must not be zero (mono_time not initialised?)");
  ------------------
  |  |   83|      0|    do {                                \
  |  |   84|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   85|      0|        logger_abort();                 \
  |  |   86|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (86:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
   59|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   60|      0|    }
   61|       |
   62|  9.82k|    Shared_Key_Cache *res = (Shared_Key_Cache *)mem_alloc(mem, sizeof(Shared_Key_Cache));
   63|  9.82k|    if (res == nullptr) {
  ------------------
  |  |   63|  9.82k|#define nullptr NULL
  ------------------
  |  Branch (63:9): [True: 0, False: 9.82k]
  ------------------
   64|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   65|      0|    }
   66|       |
   67|  9.82k|    res->self_secret_key = self_secret_key;
   68|  9.82k|    res->mono_time = mono_time;
   69|  9.82k|    res->mem = mem;
   70|  9.82k|    res->log = log;
   71|  9.82k|    res->keys_per_slot = keys_per_slot;
   72|       |
   73|       |    // We take one byte from the public key for each bucket and store keys_per_slot elements there
   74|  9.82k|    const size_t cache_size = 256 * keys_per_slot;
   75|  9.82k|    Shared_Key *keys = (Shared_Key *)mem_valloc(mem, cache_size, sizeof(Shared_Key));
   76|       |
   77|  9.82k|    if (keys == nullptr) {
  ------------------
  |  |   63|  9.82k|#define nullptr NULL
  ------------------
  |  Branch (77:9): [True: 0, False: 9.82k]
  ------------------
   78|      0|        mem_delete(mem, res);
   79|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   80|      0|    }
   81|       |
   82|  9.82k|    crypto_memlock(keys, cache_size * sizeof(Shared_Key));
   83|       |
   84|  9.82k|    res->keys = keys;
   85|       |
   86|  9.82k|    return res;
   87|  9.82k|}
shared_key_cache_free:
   90|  9.82k|{
   91|  9.82k|    if (cache == nullptr) {
  ------------------
  |  |   63|  9.82k|#define nullptr NULL
  ------------------
  |  Branch (91:9): [True: 0, False: 9.82k]
  ------------------
   92|      0|        return;
   93|      0|    }
   94|       |
   95|  9.82k|    const size_t cache_size = 256 * cache->keys_per_slot;
   96|       |    // Don't leave key material in memory
   97|  9.82k|    crypto_memzero(cache->keys, cache_size * sizeof(Shared_Key));
   98|  9.82k|    crypto_memunlock(cache->keys, cache_size * sizeof(Shared_Key));
   99|  9.82k|    mem_delete(cache->mem, cache->keys);
  100|  9.82k|    mem_delete(cache->mem, cache);
  101|  9.82k|}

state_load:
   15|  2.02k|{
   16|  2.02k|    if (state_load_callback == nullptr || data == nullptr) {
  ------------------
  |  |   63|  4.04k|#define nullptr NULL
  ------------------
                  if (state_load_callback == nullptr || data == nullptr) {
  ------------------
  |  |   63|  2.02k|#define nullptr NULL
  ------------------
  |  Branch (16:9): [True: 0, False: 2.02k]
  |  Branch (16:43): [True: 0, False: 2.02k]
  ------------------
   17|      0|        LOGGER_ERROR(log, "state_load() called with invalid args.");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   18|      0|        return -1;
   19|      0|    }
   20|       |
   21|  2.02k|    const uint32_t size_head = sizeof(uint32_t) * 2;
   22|       |
   23|  33.3k|    while (length >= size_head) {
  ------------------
  |  Branch (23:12): [True: 31.7k, False: 1.61k]
  ------------------
   24|  31.7k|        uint32_t length_sub;
   25|  31.7k|        lendian_bytes_to_host32(&length_sub, data);
   26|       |
   27|  31.7k|        uint32_t cookie_type;
   28|  31.7k|        lendian_bytes_to_host32(&cookie_type, data + sizeof(uint32_t));
   29|       |
   30|  31.7k|        data += size_head;
   31|  31.7k|        length -= size_head;
   32|       |
   33|  31.7k|        if (length < length_sub) {
  ------------------
  |  Branch (33:13): [True: 244, False: 31.4k]
  ------------------
   34|       |            /* file truncated */
   35|    244|            LOGGER_ERROR(log, "state file too short: %u < %u", length, length_sub);
  ------------------
  |  |   80|    244|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    244|    do {                                                                         \
  |  |  |  |   70|    244|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    488|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 244, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|    244|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|    244|        }                                                                        \
  |  |  |  |   73|    244|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 244]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   36|    244|            return -1;
   37|    244|        }
   38|       |
   39|  31.4k|        if (lendian_to_host16(cookie_type >> 16) != cookie_inner) {
  ------------------
  |  Branch (39:13): [True: 43, False: 31.4k]
  ------------------
   40|       |            /* something is not matching up in a bad way, give up */
   41|     43|            LOGGER_ERROR(log, "state file garbled: %04x != %04x", cookie_type >> 16, cookie_inner);
  ------------------
  |  |   80|     43|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     43|    do {                                                                         \
  |  |  |  |   70|     43|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     86|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 43, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     43|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     43|        }                                                                        \
  |  |  |  |   73|     43|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 43]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   42|     43|            return -1;
   43|     43|        }
   44|       |
   45|  31.4k|        const uint16_t type = lendian_to_host16(cookie_type & 0xFFFF);
   46|       |
   47|  31.4k|        switch (state_load_callback(outer, data, length_sub, type)) {
  ------------------
  |  Branch (47:17): [True: 31.4k, False: 0]
  ------------------
   48|  31.2k|            case STATE_LOAD_STATUS_CONTINUE: {
  ------------------
  |  Branch (48:13): [True: 31.2k, False: 124]
  ------------------
   49|  31.2k|                data += length_sub;
   50|  31.2k|                length -= length_sub;
   51|  31.2k|                break;
   52|      0|            }
   53|       |
   54|    118|            case STATE_LOAD_STATUS_ERROR: {
  ------------------
  |  Branch (54:13): [True: 118, False: 31.3k]
  ------------------
   55|    118|                LOGGER_ERROR(log, "Error occcured in state file (type: 0x%02x).", type);
  ------------------
  |  |   80|    118|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    118|    do {                                                                         \
  |  |  |  |   70|    118|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    236|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 118, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|    118|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|    118|        }                                                                        \
  |  |  |  |   73|    118|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 118]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   56|    118|                return -1;
   57|      0|            }
   58|       |
   59|      6|            case STATE_LOAD_STATUS_END: {
  ------------------
  |  Branch (59:13): [True: 6, False: 31.4k]
  ------------------
   60|      6|                return 0;
   61|      0|            }
   62|  31.4k|        }
   63|  31.4k|    }
   64|       |
   65|  1.61k|    if (length != 0) {
  ------------------
  |  Branch (65:9): [True: 365, False: 1.24k]
  ------------------
   66|    365|        LOGGER_ERROR(log, "unparsed data in state file of length %u", length);
  ------------------
  |  |   80|    365|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    365|    do {                                                                         \
  |  |  |  |   70|    365|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    730|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 365, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|    365|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|    365|        }                                                                        \
  |  |  |  |   73|    365|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 365]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   67|    365|        return -1;
   68|    365|    }
   69|       |
   70|  1.24k|    return 0;
   71|  1.61k|}
state_write_section_header:
   74|  11.9k|{
   75|  11.9k|    host_to_lendian_bytes32(data, len);
   76|  11.9k|    data += sizeof(uint32_t);
   77|  11.9k|    host_to_lendian_bytes32(data, (host_to_lendian16(cookie_type) << 16) | host_to_lendian16(section_type));
   78|  11.9k|    data += sizeof(uint32_t);
   79|  11.9k|    return data;
   80|  11.9k|}
lendian_to_host16:
   83|  86.8k|{
   84|       |#ifdef WORDS_BIGENDIAN
   85|       |    return (lendian << 8) | (lendian >> 8);
   86|       |#else
   87|  86.8k|    return lendian;
   88|  86.8k|#endif /* WORDS_BIGENDIAN */
   89|  86.8k|}
host_to_lendian16:
   92|  23.9k|{
   93|  23.9k|    return lendian_to_host16(host);
   94|  23.9k|}
host_to_lendian_bytes64:
   97|    152|{
   98|       |#ifdef WORDS_BIGENDIAN
   99|       |    num = ((num << 8) & 0xFF00FF00FF00FF00) | ((num >> 8) & 0xFF00FF00FF00FF);
  100|       |    num = ((num << 16) & 0xFFFF0000FFFF0000) | ((num >> 16) & 0xFFFF0000FFFF);
  101|       |    num = (num << 32) | (num >> 32);
  102|       |#endif /* WORDS_BIGENDIAN */
  103|    152|    memcpy(dest, &num, sizeof(uint64_t));
  104|    152|}
lendian_bytes_to_host64:
  107|    439|{
  108|    439|    uint64_t d;
  109|    439|    memcpy(&d, lendian, sizeof(uint64_t));
  110|       |#ifdef WORDS_BIGENDIAN
  111|       |    d = ((d << 8) & 0xFF00FF00FF00FF00) | ((d >> 8) & 0xFF00FF00FF00FF);
  112|       |    d = ((d << 16) & 0xFFFF0000FFFF0000) | ((d >> 16) & 0xFFFF0000FFFF);
  113|       |    d = (d << 32) | (d >> 32);
  114|       |#endif /* WORDS_BIGENDIAN */
  115|    439|    *dest = d;
  116|    439|}
host_to_lendian_bytes32:
  119|  29.6k|{
  120|       |#ifdef WORDS_BIGENDIAN
  121|       |    num = ((num << 8) & 0xFF00FF00) | ((num >> 8) & 0xFF00FF);
  122|       |    num = (num << 16) | (num >> 16);
  123|       |#endif /* WORDS_BIGENDIAN */
  124|  29.6k|    memcpy(dest, &num, sizeof(uint32_t));
  125|  29.6k|}
lendian_bytes_to_host32:
  128|  82.5k|{
  129|  82.5k|    uint32_t d;
  130|  82.5k|    memcpy(&d, lendian, sizeof(uint32_t));
  131|       |#ifdef WORDS_BIGENDIAN
  132|       |    d = ((d << 8) & 0xFF00FF00) | ((d >> 8) & 0xFF00FF);
  133|       |    d = (d << 16) | (d >> 16);
  134|       |#endif /* WORDS_BIGENDIAN */
  135|  82.5k|    *dest = d;
  136|  82.5k|}
host_to_lendian_bytes16:
  139|  2.96k|{
  140|       |#ifdef WORDS_BIGENDIAN
  141|       |    num = (num << 8) | (num >> 8);
  142|       |#endif /* WORDS_BIGENDIAN */
  143|  2.96k|    memcpy(dest, &num, sizeof(uint16_t));
  144|  2.96k|}
lendian_bytes_to_host16:
  147|  16.9k|{
  148|  16.9k|    uint16_t d;
  149|  16.9k|    memcpy(&d, lendian, sizeof(uint16_t));
  150|       |#ifdef WORDS_BIGENDIAN
  151|       |    d = (d << 8) | (d >> 8);
  152|       |#endif /* WORDS_BIGENDIAN */
  153|  16.9k|    *dest = d;
  154|  16.9k|}

tox_new_testing:
  979|  1.40k|{
  980|  1.40k|    if (testing == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (980:9): [True: 0, False: 1.40k]
  ------------------
  981|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  982|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  983|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  984|      0|    }
  985|       |
  986|  1.40k|    if (testing->operating_system == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (986:9): [True: 0, False: 1.40k]
  ------------------
  987|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  988|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  989|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  990|      0|    }
  991|       |
  992|  1.40k|    const Tox_System *sys = testing->operating_system;
  993|       |
  994|  1.40k|    if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  2.81k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  2.81k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (994:9): [True: 0, False: 1.40k]
  |  Branch (994:32): [True: 0, False: 1.40k]
  |  Branch (994:54): [True: 0, False: 1.40k]
  ------------------
  995|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  996|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  997|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  998|      0|    }
  999|       |
 1000|  1.40k|    SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_OK);
  ------------------
  |  |   45|  1.40k|    do {                              \
  |  |   46|  1.40k|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|  2.81k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 1.40k, False: 0]
  |  |  ------------------
  |  |   47|  1.40k|            *param = x;               \
  |  |   48|  1.40k|        }                             \
  |  |   49|  1.40k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 1.40k]
  |  |  ------------------
  ------------------
 1001|  1.40k|    return tox_new_system(options, error, sys);
 1002|  1.40k|}
tox_kill:
 1005|    981|{
 1006|    981|    if (tox == nullptr) {
  ------------------
  |  |   63|    981|#define nullptr NULL
  ------------------
  |  Branch (1006:9): [True: 0, False: 981]
  ------------------
 1007|      0|        return;
 1008|      0|    }
 1009|       |
 1010|    981|    tox_lock(tox);
 1011|    981|    LOGGER_ASSERT(tox->m->log, tox->toxav_object == nullptr, "Attempted to kill tox while toxav is still alive");
  ------------------
  |  |   89|    981|    do {                                           \
  |  |   90|    981|        if (!(cond)) {                             \
  |  |  ------------------
  |  |  |  Branch (90:13): [True: 0, False: 981]
  |  |  ------------------
  |  |   91|      0|            LOGGER_ERROR(log, "Assertion failed"); \
  |  |  ------------------
  |  |  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   92|      0|            LOGGER_FATAL(log, __VA_ARGS__);        \
  |  |  ------------------
  |  |  |  |   83|      0|    do {                                \
  |  |  |  |   84|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |   85|      0|        logger_abort();                 \
  |  |  |  |   86|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (86:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   93|      0|        }                                          \
  |  |   94|    981|    } while (0)
  |  |  ------------------
  |  |  |  Branch (94:14): [Folded, False: 981]
  |  |  ------------------
  ------------------
 1012|    981|    kill_groupchats(tox->m->conferences_object);
 1013|    981|    kill_messenger(tox->m);
 1014|    981|    logger_kill(tox->log);
 1015|    981|    mono_time_free(tox->sys.mem, tox->mono_time);
 1016|    981|    tox_unlock(tox);
 1017|       |
 1018|    981|    if (tox->mutex != nullptr) {
  ------------------
  |  |   63|    981|#define nullptr NULL
  ------------------
  |  Branch (1018:9): [True: 0, False: 981]
  ------------------
 1019|      0|        pthread_mutex_destroy(tox->mutex);
 1020|      0|        mem_delete(tox->sys.mem, tox->mutex);
 1021|      0|    }
 1022|       |
 1023|    981|    mem_delete(tox->sys.mem, tox);
 1024|    981|}
tox_get_savedata_size:
 1037|  1.96k|{
 1038|  1.96k|    assert(tox != nullptr);
  ------------------
  |  Branch (1038:5): [True: 1.96k, False: 0]
  ------------------
 1039|  1.96k|    tox_lock(tox);
 1040|  1.96k|    const size_t ret = 2 * sizeof(uint32_t)
 1041|  1.96k|                       + messenger_size(tox->m)
 1042|  1.96k|                       + conferences_size(tox->m->conferences_object)
 1043|  1.96k|                       + end_size();
 1044|  1.96k|    tox_unlock(tox);
 1045|  1.96k|    return ret;
 1046|  1.96k|}
tox_get_savedata:
 1049|    981|{
 1050|    981|    assert(tox != nullptr);
  ------------------
  |  Branch (1050:5): [True: 981, False: 0]
  ------------------
 1051|       |
 1052|    981|    if (savedata == nullptr) {
  ------------------
  |  |   63|    981|#define nullptr NULL
  ------------------
  |  Branch (1052:9): [True: 0, False: 981]
  ------------------
 1053|      0|        return;
 1054|      0|    }
 1055|       |
 1056|    981|    memzero(savedata, tox_get_savedata_size(tox));
 1057|       |
 1058|    981|    tox_lock(tox);
 1059|       |
 1060|    981|    const uint32_t size32 = sizeof(uint32_t);
 1061|       |
 1062|       |    // write cookie
 1063|    981|    memzero(savedata, size32);
 1064|    981|    savedata += size32;
 1065|    981|    host_to_lendian_bytes32(savedata, STATE_COOKIE_GLOBAL);
  ------------------
  |  |   29|    981|#define STATE_COOKIE_GLOBAL 0x15ed1b1f
  ------------------
 1066|    981|    savedata += size32;
 1067|       |
 1068|    981|    savedata = messenger_save(tox->m, savedata);
 1069|    981|    savedata = conferences_save(tox->m->conferences_object, savedata);
 1070|    981|    end_save(savedata);
 1071|       |
 1072|    981|    tox_unlock(tox);
 1073|    981|}
tox.c:tox_new_system:
  638|  1.40k|{
  639|  1.40k|    struct Tox_Options *default_options = nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  640|  1.40k|    if (options == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (640:9): [True: 0, False: 1.40k]
  ------------------
  641|      0|        Tox_Err_Options_New err;
  642|      0|        default_options = tox_options_new(&err);
  643|       |
  644|      0|        switch (err) {
  ------------------
  |  Branch (644:17): [True: 0, False: 0]
  ------------------
  645|      0|            case TOX_ERR_OPTIONS_NEW_OK: {
  ------------------
  |  Branch (645:13): [True: 0, False: 0]
  ------------------
  646|      0|                assert(default_options != nullptr);
  ------------------
  |  Branch (646:17): [True: 0, False: 0]
  ------------------
  647|      0|                break;
  648|      0|            }
  649|       |
  650|      0|            case TOX_ERR_OPTIONS_NEW_MALLOC: {
  ------------------
  |  Branch (650:13): [True: 0, False: 0]
  ------------------
  651|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  652|      0|                return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  653|      0|            }
  654|      0|        }
  655|      0|    }
  656|       |
  657|  1.40k|    const struct Tox_Options *const opts = options != nullptr ? options : default_options;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (657:44): [True: 1.40k, False: 0]
  ------------------
  658|  1.40k|    assert(opts != nullptr);
  ------------------
  |  Branch (658:5): [True: 1.40k, False: 0]
  ------------------
  659|       |
  660|  1.40k|    const Tox_System default_system = tox_default_system();
  661|       |
  662|  1.40k|    if (sys == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (662:9): [True: 0, False: 1.40k]
  ------------------
  663|      0|        sys = &default_system;
  664|      0|    }
  665|       |
  666|  1.40k|    if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  2.81k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  2.81k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (666:9): [True: 0, False: 1.40k]
  |  Branch (666:32): [True: 0, False: 1.40k]
  |  Branch (666:54): [True: 0, False: 1.40k]
  ------------------
  667|       |        // TODO(iphydf): Not quite right, but similar.
  668|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  669|      0|        tox_options_free(default_options);
  670|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  671|      0|    }
  672|       |
  673|  1.40k|    const Random *const rng = sys->rng;
  674|  1.40k|    const Network *const ns = sys->ns;
  675|  1.40k|    const Memory *const mem = sys->mem;
  676|       |
  677|  1.40k|    Messenger_Options m_options = {nullptr};
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  678|       |
  679|  1.40k|    m_options.dns_enabled = !tox_options_get_experimental_disable_dns(opts);
  680|       |
  681|  1.40k|    bool load_savedata_sk = false;
  682|  1.40k|    bool load_savedata_tox = false;
  683|       |
  684|  1.40k|    if (tox_options_get_savedata_type(opts) != TOX_SAVEDATA_TYPE_NONE) {
  ------------------
  |  Branch (684:9): [True: 1.40k, False: 0]
  ------------------
  685|  1.40k|        if (tox_options_get_savedata_data(opts) == nullptr || tox_options_get_savedata_length(opts) == 0) {
  ------------------
  |  |   63|  2.81k|#define nullptr NULL
  ------------------
  |  Branch (685:13): [True: 0, False: 1.40k]
  |  Branch (685:63): [True: 0, False: 1.40k]
  ------------------
  686|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  687|      0|            tox_options_free(default_options);
  688|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  689|      0|        }
  690|  1.40k|    }
  691|       |
  692|  1.40k|    if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_SECRET_KEY) {
  ------------------
  |  Branch (692:9): [True: 0, False: 1.40k]
  ------------------
  693|      0|        if (tox_options_get_savedata_length(opts) != TOX_SECRET_KEY_SIZE) {
  ------------------
  |  |  221|      0|#define TOX_SECRET_KEY_SIZE            32
  ------------------
  |  Branch (693:13): [True: 0, False: 0]
  ------------------
  694|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  695|      0|            tox_options_free(default_options);
  696|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  697|      0|        }
  698|       |
  699|      0|        load_savedata_sk = true;
  700|  1.40k|    } else if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_TOX_SAVE) {
  ------------------
  |  Branch (700:16): [True: 1.40k, False: 0]
  ------------------
  701|  1.40k|        if (tox_options_get_savedata_length(opts) < TOX_ENC_SAVE_MAGIC_LENGTH) {
  ------------------
  |  |   10|  1.40k|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (701:13): [True: 1, False: 1.40k]
  ------------------
  702|      1|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   45|      1|    do {                              \
  |  |   46|      1|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      2|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 1]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 1]
  |  |  ------------------
  ------------------
  703|      1|            tox_options_free(default_options);
  704|      1|            return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  705|      1|        }
  706|       |
  707|  1.40k|        if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |    9|  1.40k|#define TOX_ENC_SAVE_MAGIC_NUMBER ((const uint8_t *)"toxEsave")
  ------------------
                      if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |   10|  1.40k|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (707:13): [True: 1, False: 1.40k]
  ------------------
  708|      1|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_ENCRYPTED);
  ------------------
  |  |   45|      1|    do {                              \
  |  |   46|      1|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      2|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 1]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 1]
  |  |  ------------------
  ------------------
  709|      1|            tox_options_free(default_options);
  710|      1|            return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  711|      1|        }
  712|       |
  713|  1.40k|        load_savedata_tox = true;
  714|  1.40k|    }
  715|       |
  716|  1.40k|    m_options.ipv6enabled = tox_options_get_ipv6_enabled(opts);
  717|  1.40k|    m_options.udp_disabled = !tox_options_get_udp_enabled(opts);
  718|  1.40k|    m_options.port_range[0] = tox_options_get_start_port(opts);
  719|  1.40k|    m_options.port_range[1] = tox_options_get_end_port(opts);
  720|  1.40k|    m_options.tcp_server_port = tox_options_get_tcp_port(opts);
  721|  1.40k|    m_options.hole_punching_enabled = tox_options_get_hole_punching_enabled(opts);
  722|  1.40k|    m_options.local_discovery_enabled = tox_options_get_local_discovery_enabled(opts);
  723|  1.40k|    m_options.dht_announcements_enabled = tox_options_get_dht_announcements_enabled(opts);
  724|  1.40k|    m_options.groups_persistence_enabled = tox_options_get_experimental_groups_persistence(opts);
  725|       |
  726|  1.40k|    if (m_options.udp_disabled) {
  ------------------
  |  Branch (726:9): [True: 0, False: 1.40k]
  ------------------
  727|      0|        m_options.local_discovery_enabled = false;
  728|      0|    }
  729|       |
  730|  1.40k|    Tox *tox = (Tox *)mem_alloc(mem, sizeof(Tox));
  731|       |
  732|  1.40k|    if (tox == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (732:9): [True: 0, False: 1.40k]
  ------------------
  733|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  734|      0|        tox_options_free(default_options);
  735|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  736|      0|    }
  737|       |
  738|  1.40k|    tox->log_callback = tox_options_get_log_callback(opts);
  739|       |
  740|  1.40k|    Logger *log = logger_new(mem);
  741|       |
  742|  1.40k|    if (log == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (742:9): [True: 0, False: 1.40k]
  ------------------
  743|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  744|      0|        mem_delete(mem, tox);
  745|      0|        tox_options_free(default_options);
  746|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  747|      0|    }
  748|       |
  749|  1.40k|    tox->log = log;
  750|       |
  751|  1.40k|    m_options.log = tox->log;
  752|       |
  753|  1.40k|    logger_callback_log(tox->log, tox_log_handler, tox, tox_options_get_log_user_data(opts));
  754|       |
  755|  1.40k|    switch (tox_options_get_proxy_type(opts)) {
  756|      0|        case TOX_PROXY_TYPE_HTTP: {
  ------------------
  |  Branch (756:9): [True: 0, False: 1.40k]
  ------------------
  757|      0|            m_options.proxy_info.proxy_type = TCP_PROXY_HTTP;
  758|      0|            break;
  759|      0|        }
  760|       |
  761|      0|        case TOX_PROXY_TYPE_SOCKS5: {
  ------------------
  |  Branch (761:9): [True: 0, False: 1.40k]
  ------------------
  762|      0|            m_options.proxy_info.proxy_type = TCP_PROXY_SOCKS5;
  763|      0|            break;
  764|      0|        }
  765|       |
  766|  1.40k|        case TOX_PROXY_TYPE_NONE: {
  ------------------
  |  Branch (766:9): [True: 1.40k, False: 0]
  ------------------
  767|  1.40k|            m_options.proxy_info.proxy_type = TCP_PROXY_NONE;
  768|  1.40k|            break;
  769|      0|        }
  770|       |
  771|      0|        default: {
  ------------------
  |  Branch (771:9): [True: 0, False: 1.40k]
  ------------------
  772|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_TYPE);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  773|      0|            logger_kill(tox->log);
  774|      0|            mem_delete(mem, tox);
  775|      0|            tox_options_free(default_options);
  776|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  777|      0|        }
  778|  1.40k|    }
  779|       |
  780|  1.40k|    tox->sys = *sys;
  781|       |
  782|  1.40k|    if (m_options.proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (782:9): [True: 0, False: 1.40k]
  ------------------
  783|      0|        if (tox_options_get_proxy_port(opts) == 0) {
  ------------------
  |  Branch (783:13): [True: 0, False: 0]
  ------------------
  784|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_PORT);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  785|      0|            logger_kill(tox->log);
  786|      0|            mem_delete(mem, tox);
  787|      0|            tox_options_free(default_options);
  788|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  789|      0|        }
  790|       |
  791|      0|        ip_init(&m_options.proxy_info.ip_port.ip, m_options.ipv6enabled);
  792|       |
  793|      0|        if (m_options.ipv6enabled) {
  ------------------
  |  Branch (793:13): [True: 0, False: 0]
  ------------------
  794|      0|            m_options.proxy_info.ip_port.ip.family = net_family_unspec();
  795|      0|        }
  796|       |
  797|      0|        const char *const proxy_host = tox_options_get_proxy_host(opts);
  798|      0|        const bool dns_enabled = !tox_options_get_experimental_disable_dns(opts);
  799|       |
  800|      0|        if (proxy_host == nullptr
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (800:13): [True: 0, False: 0]
  ------------------
  801|      0|                || !addr_resolve_or_parse_ip(ns, mem, proxy_host, &m_options.proxy_info.ip_port.ip, nullptr, dns_enabled)) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (801:20): [True: 0, False: 0]
  ------------------
  802|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_HOST);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  803|       |            // TODO(irungentoo): TOX_ERR_NEW_PROXY_NOT_FOUND if domain.
  804|      0|            logger_kill(tox->log);
  805|      0|            mem_delete(mem, tox);
  806|      0|            tox_options_free(default_options);
  807|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  808|      0|        }
  809|       |
  810|      0|        m_options.proxy_info.ip_port.port = net_htons(tox_options_get_proxy_port(opts));
  811|      0|    }
  812|       |
  813|  1.40k|    Mono_Time *temp_mono_time = mono_time_new(mem, sys->mono_time_callback, sys->mono_time_user_data);
  814|       |
  815|  1.40k|    if (temp_mono_time == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (815:9): [True: 0, False: 1.40k]
  ------------------
  816|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  817|      0|        logger_kill(tox->log);
  818|      0|        mem_delete(mem, tox);
  819|      0|        tox_options_free(default_options);
  820|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  821|      0|    }
  822|  1.40k|    tox->mono_time = temp_mono_time;
  823|       |
  824|  1.40k|    if (tox_options_get_experimental_thread_safety(opts)) {
  ------------------
  |  Branch (824:9): [True: 0, False: 1.40k]
  ------------------
  825|      0|        pthread_mutex_t *mutex = (pthread_mutex_t *)mem_alloc(mem, sizeof(pthread_mutex_t));
  826|       |
  827|      0|        if (mutex == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (827:13): [True: 0, False: 0]
  ------------------
  828|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  829|      0|            mono_time_free(mem, tox->mono_time);
  830|      0|            logger_kill(tox->log);
  831|      0|            mem_delete(mem, tox);
  832|      0|            tox_options_free(default_options);
  833|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  834|      0|        }
  835|       |
  836|      0|        pthread_mutex_init(mutex, nullptr);
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  837|       |
  838|      0|        tox->mutex = mutex;
  839|  1.40k|    } else {
  840|  1.40k|        tox->mutex = nullptr;
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  841|  1.40k|    }
  842|       |
  843|  1.40k|    tox_lock(tox);
  844|       |
  845|  1.40k|    Messenger_Error m_error;
  846|  1.40k|    Messenger *temp_m = new_messenger(tox->mono_time, mem, rng, ns, &m_options, &m_error);
  847|       |
  848|  1.40k|    if (temp_m == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (848:9): [True: 0, False: 1.40k]
  ------------------
  849|      0|        switch (m_error) {
  ------------------
  |  Branch (849:17): [True: 0, False: 0]
  ------------------
  850|      0|            case MESSENGER_ERROR_PORT:
  ------------------
  |  Branch (850:13): [True: 0, False: 0]
  ------------------
  851|      0|            case MESSENGER_ERROR_TCP_SERVER: {
  ------------------
  |  Branch (851:13): [True: 0, False: 0]
  ------------------
  852|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PORT_ALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  853|      0|                break;
  854|      0|            }
  855|      0|            case MESSENGER_ERROR_OTHER:
  ------------------
  |  Branch (855:13): [True: 0, False: 0]
  ------------------
  856|      0|            case MESSENGER_ERROR_NONE: {
  ------------------
  |  Branch (856:13): [True: 0, False: 0]
  ------------------
  857|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  858|      0|                break;
  859|      0|            }
  860|      0|        }
  861|       |
  862|      0|        mono_time_free(mem, tox->mono_time);
  863|      0|        tox_unlock(tox);
  864|       |
  865|      0|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (865:13): [True: 0, False: 0]
  ------------------
  866|      0|            pthread_mutex_destroy(tox->mutex);
  867|      0|        }
  868|       |
  869|      0|        mem_delete(mem, tox->mutex);
  870|      0|        logger_kill(tox->log);
  871|      0|        mem_delete(mem, tox);
  872|      0|        tox_options_free(default_options);
  873|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  874|      0|    }
  875|  1.40k|    tox->m = temp_m;
  876|       |
  877|  1.40k|    tox->m->conferences_object = new_groupchats(tox->mono_time, mem, tox->m);
  878|       |
  879|  1.40k|    if (tox->m->conferences_object == nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (879:9): [True: 0, False: 1.40k]
  ------------------
  880|      0|        kill_messenger(tox->m);
  881|       |
  882|      0|        mono_time_free(mem, tox->mono_time);
  883|      0|        tox_unlock(tox);
  884|       |
  885|      0|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (885:13): [True: 0, False: 0]
  ------------------
  886|      0|            pthread_mutex_destroy(tox->mutex);
  887|      0|        }
  888|       |
  889|      0|        mem_delete(mem, tox->mutex);
  890|      0|        logger_kill(tox->log);
  891|      0|        mem_delete(mem, tox);
  892|       |
  893|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  894|      0|        tox_options_free(default_options);
  895|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  896|      0|    }
  897|       |
  898|  1.40k|    if (load_savedata_tox
  ------------------
  |  Branch (898:9): [True: 1.40k, False: 0]
  ------------------
  899|  1.40k|            && tox_load(tox, tox_options_get_savedata_data(opts), tox_options_get_savedata_length(opts)) == -1) {
  ------------------
  |  Branch (899:16): [True: 423, False: 981]
  ------------------
  900|    423|        kill_groupchats(tox->m->conferences_object);
  901|    423|        kill_messenger(tox->m);
  902|       |
  903|    423|        mono_time_free(mem, tox->mono_time);
  904|    423|        tox_unlock(tox);
  905|       |
  906|    423|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|    423|#define nullptr NULL
  ------------------
  |  Branch (906:13): [True: 0, False: 423]
  ------------------
  907|      0|            pthread_mutex_destroy(tox->mutex);
  908|      0|        }
  909|       |
  910|    423|        mem_delete(mem, tox->mutex);
  911|    423|        logger_kill(tox->log);
  912|    423|        mem_delete(mem, tox);
  913|       |
  914|    423|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   45|    423|    do {                              \
  |  |   46|    423|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|    846|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 423]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|    423|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 423]
  |  |  ------------------
  ------------------
  915|    423|        tox_options_free(default_options);
  916|    423|        return nullptr;
  ------------------
  |  |   63|    423|#define nullptr NULL
  ------------------
  917|    423|    }
  918|       |
  919|    981|    if (load_savedata_sk) {
  ------------------
  |  Branch (919:9): [True: 0, False: 981]
  ------------------
  920|      0|        load_secret_key(tox->m->net_crypto, tox_options_get_savedata_data(opts));
  921|      0|    }
  922|       |
  923|    981|    m_callback_namechange(tox->m, tox_friend_name_handler);
  924|    981|    m_callback_core_connection(tox->m, tox_self_connection_status_handler);
  925|    981|    m_callback_statusmessage(tox->m, tox_friend_status_message_handler);
  926|    981|    m_callback_userstatus(tox->m, tox_friend_status_handler);
  927|    981|    m_callback_connectionstatus(tox->m, tox_friend_connection_status_handler);
  928|    981|    m_callback_typingchange(tox->m, tox_friend_typing_handler);
  929|    981|    m_callback_read_receipt(tox->m, tox_friend_read_receipt_handler);
  930|    981|    m_callback_friendrequest(tox->m, tox_friend_request_handler);
  931|    981|    m_callback_friendmessage(tox->m, tox_friend_message_handler);
  932|    981|    callback_file_control(tox->m, tox_file_recv_control_handler);
  933|    981|    callback_file_reqchunk(tox->m, tox_file_chunk_request_handler);
  934|    981|    callback_file_sendrequest(tox->m, tox_file_recv_handler);
  935|    981|    callback_file_data(tox->m, tox_file_recv_chunk_handler);
  936|    981|    dht_callback_nodes_response(tox->m->dht, tox_dht_nodes_response_handler);
  937|    981|    g_callback_group_invite(tox->m->conferences_object, tox_conference_invite_handler);
  938|    981|    g_callback_group_connected(tox->m->conferences_object, tox_conference_connected_handler);
  939|    981|    g_callback_group_message(tox->m->conferences_object, tox_conference_message_handler);
  940|    981|    g_callback_group_title(tox->m->conferences_object, tox_conference_title_handler);
  941|    981|    g_callback_peer_name(tox->m->conferences_object, tox_conference_peer_name_handler);
  942|    981|    g_callback_peer_list_changed(tox->m->conferences_object, tox_conference_peer_list_changed_handler);
  943|    981|    custom_lossy_packet_registerhandler(tox->m, tox_friend_lossy_packet_handler);
  944|    981|    custom_lossless_packet_registerhandler(tox->m, tox_friend_lossless_packet_handler);
  945|       |
  946|    981|    m_callback_group_invite(tox->m, tox_group_invite_handler);
  947|    981|    gc_callback_message(tox->m, tox_group_message_handler);
  948|    981|    gc_callback_private_message(tox->m, tox_group_private_message_handler);
  949|    981|    gc_callback_custom_packet(tox->m, tox_group_custom_packet_handler);
  950|    981|    gc_callback_custom_private_packet(tox->m, tox_group_custom_private_packet_handler);
  951|    981|    gc_callback_moderation(tox->m, tox_group_moderation_handler);
  952|    981|    gc_callback_nick_change(tox->m, tox_group_peer_name_handler);
  953|    981|    gc_callback_status_change(tox->m, tox_group_peer_status_handler);
  954|    981|    gc_callback_topic_change(tox->m, tox_group_topic_handler);
  955|    981|    gc_callback_peer_limit(tox->m, tox_group_peer_limit_handler);
  956|    981|    gc_callback_privacy_state(tox->m, tox_group_privacy_state_handler);
  957|    981|    gc_callback_topic_lock(tox->m, tox_group_topic_lock_handler);
  958|    981|    gc_callback_password(tox->m, tox_group_password_handler);
  959|    981|    gc_callback_peer_join(tox->m, tox_group_peer_join_handler);
  960|    981|    gc_callback_peer_exit(tox->m, tox_group_peer_exit_handler);
  961|    981|    gc_callback_self_join(tox->m, tox_group_self_join_handler);
  962|    981|    gc_callback_rejected(tox->m, tox_group_join_fail_handler);
  963|    981|    gc_callback_voice_state(tox->m, tox_group_voice_state_handler);
  964|       |
  965|    981|    tox_unlock(tox);
  966|       |
  967|    981|    SET_ERROR_PARAMETER(error, TOX_ERR_NEW_OK);
  ------------------
  |  |   45|    981|    do {                              \
  |  |   46|    981|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|  1.96k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 981]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|    981|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 981]
  |  |  ------------------
  ------------------
  968|       |
  969|    981|    tox_options_free(default_options);
  970|    981|    return tox;
  971|  1.40k|}
tox.c:tox_log_handler:
   86|  78.0k|{
   87|  78.0k|    Tox *tox = (Tox *)context;
   88|  78.0k|    assert(tox != nullptr);
  ------------------
  |  Branch (88:5): [True: 78.0k, False: 0]
  ------------------
   89|       |
   90|  78.0k|    if (tox->log_callback != nullptr) {
  ------------------
  |  |   63|  78.0k|#define nullptr NULL
  ------------------
  |  Branch (90:9): [True: 0, False: 78.0k]
  ------------------
   91|      0|        tox->log_callback(tox, (Tox_Log_Level)level, file, line, func, message, userdata);
   92|      0|    }
   93|  78.0k|}
tox.c:tox_load:
  618|  1.40k|{
  619|  1.40k|    uint32_t data32[2];
  620|  1.40k|    const uint32_t cookie_len = sizeof(data32);
  621|       |
  622|  1.40k|    if (length < cookie_len) {
  ------------------
  |  Branch (622:9): [True: 0, False: 1.40k]
  ------------------
  623|      0|        return -1;
  624|      0|    }
  625|       |
  626|  1.40k|    memcpy(data32, data, sizeof(uint32_t));
  627|  1.40k|    lendian_bytes_to_host32(data32 + 1, data + sizeof(uint32_t));
  628|       |
  629|  1.40k|    if (data32[0] != 0 || data32[1] != STATE_COOKIE_GLOBAL) {
  ------------------
  |  |   29|  1.40k|#define STATE_COOKIE_GLOBAL 0x15ed1b1f
  ------------------
  |  Branch (629:9): [True: 1, False: 1.40k]
  |  Branch (629:27): [True: 1, False: 1.40k]
  ------------------
  630|      2|        return -1;
  631|      2|    }
  632|       |
  633|  1.40k|    return state_load(tox->m->log, state_load_callback, tox, data + cookie_len,
  634|  1.40k|                      length - cookie_len, STATE_COOKIE_TYPE);
  ------------------
  |  |   31|  1.40k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
  635|  1.40k|}
tox.c:state_load_callback:
  593|  30.8k|{
  594|  30.8k|    const Tox *tox = (const Tox *)outer;
  595|  30.8k|    State_Load_Status status = STATE_LOAD_STATUS_CONTINUE;
  596|       |
  597|  30.8k|    if (messenger_load_state_section(tox->m, data, length, type, &status)
  ------------------
  |  Branch (597:9): [True: 29.8k, False: 938]
  ------------------
  598|  30.4k|            || conferences_load_state_section(tox->m->conferences_object, data, length, type, &status)) {
  ------------------
  |  Branch (598:16): [True: 568, False: 370]
  ------------------
  599|  30.4k|        return status;
  600|  30.4k|    }
  601|       |
  602|    370|    if (type == STATE_TYPE_END) {
  ------------------
  |  Branch (602:9): [True: 7, False: 363]
  ------------------
  603|      7|        if (length != 0) {
  ------------------
  |  Branch (603:13): [True: 1, False: 6]
  ------------------
  604|      1|            return STATE_LOAD_STATUS_ERROR;
  605|      1|        }
  606|       |
  607|      6|        return STATE_LOAD_STATUS_END;
  608|      7|    }
  609|       |
  610|    363|    LOGGER_ERROR(tox->m->log, "Load state: contains unrecognized part (len %u, type %u)",
  ------------------
  |  |   80|    363|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    363|    do {                                                                         \
  |  |  |  |   70|    363|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    726|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 363, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|    363|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|    363|        }                                                                        \
  |  |  |  |   73|    363|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 363]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  611|    363|                 length, type);
  612|       |
  613|    363|    return STATE_LOAD_STATUS_CONTINUE;
  614|    370|}
tox.c:end_size:
 1027|  1.96k|{
 1028|  1.96k|    return 2 * sizeof(uint32_t);
 1029|  1.96k|}
tox.c:end_save:
 1032|    981|{
 1033|    981|    state_write_section_header(data, STATE_COOKIE_TYPE, 0, STATE_TYPE_END);
  ------------------
  |  |   31|    981|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 1034|    981|}

tox_options_get_ipv6_enabled:
   22|  1.40k|{
   23|  1.40k|    return options->ipv6_enabled;
   24|  1.40k|}
tox_options_set_ipv6_enabled:
   26|  1.40k|{
   27|  1.40k|    options->ipv6_enabled = ipv6_enabled;
   28|  1.40k|}
tox_options_get_udp_enabled:
   30|  1.40k|{
   31|  1.40k|    return options->udp_enabled;
   32|  1.40k|}
tox_options_set_udp_enabled:
   34|  1.40k|{
   35|  1.40k|    options->udp_enabled = udp_enabled;
   36|  1.40k|}
tox_options_get_proxy_type:
   38|  1.40k|{
   39|  1.40k|    return options->proxy_type;
   40|  1.40k|}
tox_options_set_proxy_type:
   42|  1.40k|{
   43|  1.40k|    options->proxy_type = proxy_type;
   44|  1.40k|}
tox_options_set_proxy_host:
   50|  2.81k|{
   51|  2.81k|    if (!options->experimental_owned_data) {
  ------------------
  |  Branch (51:9): [True: 2.81k, False: 0]
  ------------------
   52|  2.81k|        options->proxy_host = proxy_host;
   53|  2.81k|        return true;
   54|  2.81k|    }
   55|       |
   56|      0|    if (options->owned_proxy_host != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (56:9): [True: 0, False: 0]
  ------------------
   57|      0|        free(options->owned_proxy_host);
   58|      0|        options->owned_proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   59|      0|    }
   60|      0|    if (proxy_host == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (60:9): [True: 0, False: 0]
  ------------------
   61|      0|        options->proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   62|      0|        return true;
   63|      0|    }
   64|       |
   65|      0|    const size_t proxy_host_length = strlen(proxy_host) + 1;
   66|      0|    char *owned_ptr = (char *)malloc(proxy_host_length);
   67|      0|    if (owned_ptr == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (67:9): [True: 0, False: 0]
  ------------------
   68|      0|        options->proxy_host = proxy_host;
   69|      0|        options->owned_proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   70|      0|        return false;
   71|      0|    }
   72|       |
   73|      0|    memcpy(owned_ptr, proxy_host, proxy_host_length);
   74|      0|    options->proxy_host = owned_ptr;
   75|      0|    options->owned_proxy_host = owned_ptr;
   76|       |    return true;
   77|      0|}
tox_options_get_start_port:
   87|  1.40k|{
   88|  1.40k|    return options->start_port;
   89|  1.40k|}
tox_options_get_end_port:
   95|  1.40k|{
   96|  1.40k|    return options->end_port;
   97|  1.40k|}
tox_options_get_tcp_port:
  103|  1.40k|{
  104|  1.40k|    return options->tcp_port;
  105|  1.40k|}
tox_options_get_hole_punching_enabled:
  111|  1.40k|{
  112|  1.40k|    return options->hole_punching_enabled;
  113|  1.40k|}
tox_options_set_hole_punching_enabled:
  115|  1.40k|{
  116|  1.40k|    options->hole_punching_enabled = hole_punching_enabled;
  117|  1.40k|}
tox_options_get_savedata_type:
  119|  4.21k|{
  120|  4.21k|    return options->savedata_type;
  121|  4.21k|}
tox_options_set_savedata_type:
  123|  1.40k|{
  124|  1.40k|    options->savedata_type = savedata_type;
  125|  1.40k|}
tox_options_get_savedata_length:
  127|  4.21k|{
  128|  4.21k|    return options->savedata_length;
  129|  4.21k|}
tox_options_get_log_callback:
  135|  1.40k|{
  136|  1.40k|    return options->log_callback;
  137|  1.40k|}
tox_options_get_log_user_data:
  143|  1.40k|{
  144|  1.40k|    return options->log_user_data;
  145|  1.40k|}
tox_options_get_local_discovery_enabled:
  151|  1.40k|{
  152|  1.40k|    return options->local_discovery_enabled;
  153|  1.40k|}
tox_options_set_local_discovery_enabled:
  155|  1.40k|{
  156|  1.40k|    options->local_discovery_enabled = local_discovery_enabled;
  157|  1.40k|}
tox_options_get_dht_announcements_enabled:
  159|  1.40k|{
  160|  1.40k|    return options->dht_announcements_enabled;
  161|  1.40k|}
tox_options_set_dht_announcements_enabled:
  163|  1.40k|{
  164|  1.40k|    options->dht_announcements_enabled = dht_announcements_enabled;
  165|  1.40k|}
tox_options_get_experimental_thread_safety:
  167|  1.40k|{
  168|  1.40k|    return options->experimental_thread_safety;
  169|  1.40k|}
tox_options_set_experimental_thread_safety:
  172|  1.40k|{
  173|  1.40k|    options->experimental_thread_safety = experimental_thread_safety;
  174|  1.40k|}
tox_options_get_experimental_groups_persistence:
  176|  1.40k|{
  177|  1.40k|    return options->experimental_groups_persistence;
  178|  1.40k|}
tox_options_set_experimental_groups_persistence:
  181|  2.81k|{
  182|  2.81k|    options->experimental_groups_persistence = experimental_groups_persistence;
  183|  2.81k|}
tox_options_get_experimental_disable_dns:
  185|  1.40k|{
  186|  1.40k|    return options->experimental_disable_dns;
  187|  1.40k|}
tox_options_set_experimental_disable_dns:
  189|  1.40k|{
  190|  1.40k|    options->experimental_disable_dns = experimental_disable_dns;
  191|  1.40k|}
tox_options_set_experimental_owned_data:
  198|  1.40k|{
  199|  1.40k|    options->experimental_owned_data = experimental_owned_data;
  200|  1.40k|}
tox_options_get_savedata_data:
  203|  4.21k|{
  204|  4.21k|    return options->savedata_data;
  205|  4.21k|}
tox_options_set_savedata_data:
  208|  4.21k|{
  209|  4.21k|    if (!options->experimental_owned_data) {
  ------------------
  |  Branch (209:9): [True: 4.21k, False: 0]
  ------------------
  210|  4.21k|        options->savedata_data = savedata_data;
  211|  4.21k|        options->savedata_length = length;
  212|  4.21k|        return true;
  213|  4.21k|    }
  214|       |
  215|      0|    if (options->owned_savedata_data != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (215:9): [True: 0, False: 0]
  ------------------
  216|      0|        free(options->owned_savedata_data);
  217|      0|        options->owned_savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  218|      0|    }
  219|      0|    if (savedata_data == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (219:9): [True: 0, False: 0]
  ------------------
  220|      0|        options->savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  221|      0|        options->savedata_length = 0;
  222|      0|        return true;
  223|      0|    }
  224|       |
  225|      0|    uint8_t *owned_ptr = (uint8_t *)malloc(length);
  226|      0|    if (owned_ptr == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (226:9): [True: 0, False: 0]
  ------------------
  227|      0|        options->savedata_data = savedata_data;
  228|      0|        options->savedata_length = length;
  229|      0|        options->owned_savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  230|      0|        return false;
  231|      0|    }
  232|       |
  233|      0|    memcpy(owned_ptr, savedata_data, length);
  234|      0|    options->savedata_data = owned_ptr;
  235|      0|    options->savedata_length = length;
  236|      0|    options->owned_savedata_data = owned_ptr;
  237|       |    return true;
  238|      0|}
tox_options_default:
  241|  1.40k|{
  242|  1.40k|    if (options != nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (242:9): [True: 1.40k, False: 0]
  ------------------
  243|       |        // Free any owned data.
  244|  1.40k|        tox_options_set_proxy_host(options, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  245|  1.40k|        tox_options_set_savedata_data(options, nullptr, 0);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  246|       |
  247|       |        // Set the rest to default values.
  248|  1.40k|        const Tox_Options default_options = {false};
  249|  1.40k|        *options = default_options;
  250|  1.40k|        tox_options_set_ipv6_enabled(options, true);
  251|  1.40k|        tox_options_set_udp_enabled(options, true);
  252|  1.40k|        tox_options_set_proxy_type(options, TOX_PROXY_TYPE_NONE);
  253|  1.40k|        tox_options_set_hole_punching_enabled(options, true);
  254|  1.40k|        tox_options_set_local_discovery_enabled(options, true);
  255|  1.40k|        tox_options_set_dht_announcements_enabled(options, true);
  256|  1.40k|        tox_options_set_experimental_thread_safety(options, false);
  257|  1.40k|        tox_options_set_experimental_groups_persistence(options, false);
  258|  1.40k|        tox_options_set_experimental_disable_dns(options, false);
  259|       |        tox_options_set_experimental_owned_data(options, false);
  260|  1.40k|    }
  261|  1.40k|}
tox_options_new:
  284|  1.40k|{
  285|  1.40k|    Tox_Options *options = (Tox_Options *)calloc(1, sizeof(Tox_Options));
  286|       |
  287|  1.40k|    if (options != nullptr) {
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  |  Branch (287:9): [True: 1.40k, False: 0]
  ------------------
  288|  1.40k|        tox_options_default(options);
  289|  1.40k|        SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_OK);
  ------------------
  |  |   14|  1.40k|    do {                              \
  |  |   15|  1.40k|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|  2.81k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (15:13): [True: 1.40k, False: 0]
  |  |  ------------------
  |  |   16|  1.40k|            *param = x;               \
  |  |   17|  1.40k|        }                             \
  |  |   18|  1.40k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (18:14): [Folded, False: 1.40k]
  |  |  ------------------
  ------------------
  290|  1.40k|        return options;
  291|  1.40k|    }
  292|       |
  293|      0|    SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_MALLOC);
  ------------------
  |  |   14|      0|    do {                              \
  |  |   15|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (15:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   16|      0|            *param = x;               \
  |  |   17|      0|        }                             \
  |  |   18|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (18:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  294|       |    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  295|  1.40k|}
tox_options_free:
  298|  2.81k|{
  299|  2.81k|    if (options != nullptr) {
  ------------------
  |  |   63|  2.81k|#define nullptr NULL
  ------------------
  |  Branch (299:9): [True: 1.40k, False: 1.40k]
  ------------------
  300|       |        // Free any owned data.
  301|  1.40k|        tox_options_set_proxy_host(options, nullptr);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  302|       |        tox_options_set_savedata_data(options, nullptr, 0);
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
  303|  1.40k|        free(options);
  304|  1.40k|    }
  305|  2.81k|}

tox_default_system:
   40|  1.40k|{
   41|  1.40k|    const Tox_System sys = {
   42|  1.40k|        nullptr,  // mono_time_callback
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
   43|       |        nullptr,  // mono_time_user_data
  ------------------
  |  |   63|  1.40k|#define nullptr NULL
  ------------------
   44|  1.40k|        os_random(),
   45|  1.40k|        os_network(),
   46|  1.40k|        os_memory(),
   47|  1.40k|    };
   48|  1.40k|    return sys;
   49|  1.40k|}
tox_lock:
   52|  5.32k|{
   53|  5.32k|    if (tox->mutex != nullptr) {
  ------------------
  |  |   63|  5.32k|#define nullptr NULL
  ------------------
  |  Branch (53:9): [True: 0, False: 5.32k]
  ------------------
   54|      0|        pthread_mutex_lock(tox->mutex);
   55|      0|    }
   56|  5.32k|}
tox_unlock:
   59|  5.32k|{
   60|  5.32k|    if (tox->mutex != nullptr) {
  ------------------
  |  |   63|  5.32k|#define nullptr NULL
  ------------------
  |  Branch (60:9): [True: 0, False: 5.32k]
  ------------------
   61|      0|        pthread_mutex_unlock(tox->mutex);
   62|      0|    }
   63|  5.32k|}

free_uint8_t_pointer_array:
   27|  7.71k|{
   28|  7.71k|    if (ary == nullptr) {
  ------------------
  |  |   63|  7.71k|#define nullptr NULL
  ------------------
  |  Branch (28:9): [True: 7.50k, False: 215]
  ------------------
   29|  7.50k|        return;
   30|  7.50k|    }
   31|       |
   32|  3.65k|    for (size_t i = 0; i < n_items; ++i) {
  ------------------
  |  Branch (32:24): [True: 3.44k, False: 215]
  ------------------
   33|  3.44k|        if (ary[i] != nullptr) {
  ------------------
  |  |   63|  3.44k|#define nullptr NULL
  ------------------
  |  Branch (33:13): [True: 3.44k, False: 0]
  ------------------
   34|  3.44k|            mem_delete(mem, ary[i]);
   35|  3.44k|        }
   36|  3.44k|    }
   37|       |
   38|    215|    mem_delete(mem, ary);
   39|    215|}
data_checksum:
   42|    237|{
   43|    237|    uint8_t checksum[2] = {0};
   44|    237|    uint16_t check;
   45|       |
   46|  8.76k|    for (uint32_t i = 0; i < length; ++i) {
  ------------------
  |  Branch (46:26): [True: 8.53k, False: 237]
  ------------------
   47|  8.53k|        checksum[i % 2] ^= data[i];
   48|  8.53k|    }
   49|       |
   50|    237|    memcpy(&check, checksum, sizeof(check));
   51|    237|    return check;
   52|    237|}
memeq:
   79|  8.17k|{
   80|  8.17k|    return a_size == b_size && memcmp(a, b, a_size) == 0;
  ------------------
  |  Branch (80:12): [True: 7.70k, False: 478]
  |  Branch (80:32): [True: 7.70k, False: 0]
  ------------------
   81|  8.17k|}
memzero:
   99|  40.4k|{
  100|  40.4k|    if (data == nullptr || data_size == 0) {
  ------------------
  |  |   63|  80.9k|#define nullptr NULL
  ------------------
  |  Branch (100:9): [True: 0, False: 40.4k]
  |  Branch (100:28): [True: 0, False: 40.4k]
  ------------------
  101|      0|        return;
  102|      0|    }
  103|       |
  104|  40.4k|    memset(data, 0, data_size);
  105|  40.4k|}
min_u16:
  151|  1.23k|{
  152|  1.23k|    return a < b ? a : b;
  ------------------
  |  Branch (152:12): [True: 1.23k, False: 0]
  ------------------
  153|  1.23k|}
min_u32:
  155|     58|{
  156|     58|    return a < b ? a : b;
  ------------------
  |  Branch (156:12): [True: 29, False: 29]
  ------------------
  157|     58|}
jenkins_one_at_a_time_hash:
  169|    150|{
  170|    150|    uint32_t hash = 0;
  171|       |
  172|  4.95k|    for (uint32_t i = 0; i < len; ++i) {
  ------------------
  |  Branch (172:26): [True: 4.80k, False: 150]
  ------------------
  173|  4.80k|        hash += key[i];
  174|  4.80k|        hash += (uint32_t)((uint64_t)hash << 10);
  175|  4.80k|        hash ^= hash >> 6;
  176|  4.80k|    }
  177|       |
  178|    150|    hash += (uint32_t)((uint64_t)hash << 3);
  179|    150|    hash ^= hash >> 11;
  180|    150|    hash += (uint32_t)((uint64_t)hash << 15);
  181|    150|    return hash;
  182|    150|}

