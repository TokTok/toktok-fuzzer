fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Null_SystemjEXadL_ZN4$_218__invokeES3_jEEEcvPFT_T0_DpT1_EIS1_S1_JjEEEvENKUlS1_DpT_E_clIJjEEEDaS1_SG_:
   31|  3.07k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Null_SystemjEXadL_ZN4$_218__invokeES3_jEEE13static_casterIS1_EcvT_IS3_EEv:
   22|  3.07k|        {
   23|  3.07k|            return static_cast<To>(obj);
   24|  3.07k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Null_SystemjjEXadL_ZN4$_228__invokeES3_jjEEEcvPFT_T0_DpT1_EIS1_S1_JjjEEEvENKUlS1_DpT_E_clIJjjEEEDaS1_SG_:
   31|   137k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Null_SystemjjEXadL_ZN4$_228__invokeES3_jjEEE13static_casterIS1_EcvT_IS3_EEv:
   22|   137k|        {
   23|   137k|            return static_cast<To>(obj);
   24|   137k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Null_SystemS1_jEXadL_ZN4$_238__invokeES3_S1_jEEEcvPFT_T0_DpT1_EIS1_S1_JS1_jEEEvENKUlS1_DpT_E_clIJS1_jEEEDaS1_SG_:
   31|  55.8k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Null_SystemS1_jEXadL_ZN4$_238__invokeES3_S1_jEEE13static_casterIS1_EcvT_IS3_EEv:
   22|  55.8k|        {
   23|  55.8k|            return static_cast<To>(obj);
   24|  55.8k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Null_SystemPvEXadL_ZN4$_248__invokeES2_S3_EEEcvPFT_T0_DpT1_EIvS3_JS3_EEEvENKUlS3_DpT_E_clIJS3_EEEDaS3_SG_:
   31|  1.27M|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Null_SystemPvEXadL_ZN4$_248__invokeES2_S3_EEE13static_casterIS3_EcvT_IS2_EEv:
   22|  1.27M|        {
   23|  1.27M|            return static_cast<To>(obj);
   24|  1.27M|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Null_System6SocketEXadL_ZN4$_258__invokeES2_S3_EEEcvPFT_T0_DpT1_EIiPvJS3_EEEvENKUlSF_DpT_E_clIJS3_EEEDaSF_SH_:
   31|  3.15k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Null_System6SocketEXadL_ZN4$_258__invokeES2_S3_EEE13static_casterIPvEcvT_IS2_EEv:
   22|  3.15k|        {
   23|  3.15k|            return static_cast<To>(obj);
   24|  3.15k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Null_System6SocketPK12Network_AddrEXadL_ZN4$_278__invokeES2_S3_S6_EEEcvPFT_T0_DpT1_EIiPvJS3_S6_EEEvENKUlSI_DpT_E_clIJS3_S6_EEEDaSI_SK_:
   31|  3.15k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Null_System6SocketPK12Network_AddrEXadL_ZN4$_278__invokeES2_S3_S6_EEE13static_casterIPvEcvT_IS2_EEv:
   22|  3.15k|        {
   23|  3.15k|            return static_cast<To>(obj);
   24|  3.15k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPF6SocketP11Null_SystemiiiEXadL_ZN4$_358__invokeES3_iiiEEEcvPFT_T0_DpT1_EIS1_PvJiiiEEEvENKUlSF_DpT_E_clIJiiiEEEDaSF_SH_:
   31|  3.15k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPF6SocketP11Null_SystemiiiEXadL_ZN4$_358__invokeES3_iiiEEE13static_casterIPvEcvT_IS3_EEv:
   22|  3.15k|        {
   23|  3.15k|            return static_cast<To>(obj);
   24|  3.15k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Null_System6SocketbEXadL_ZN4$_368__invokeES2_S3_bEEEcvPFT_T0_DpT1_EIiPvJS3_bEEEvENKUlSF_DpT_E_clIJS3_bEEEDaSF_SH_:
   31|  3.15k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Null_System6SocketbEXadL_ZN4$_368__invokeES2_S3_bEEE13static_casterIPvEcvT_IS2_EEv:
   22|  3.15k|        {
   23|  3.15k|            return static_cast<To>(obj);
   24|  3.15k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Null_System6SocketiiPvPmEXadL_ZN4$_378__invokeES2_S3_iiS4_S5_EEEcvPFT_T0_DpT1_EIiS4_JS3_iiS4_S5_EEEvENKUlS4_DpT_E_clIJS3_iiS4_S5_EEEDaS4_SI_:
   31|  3.15k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Null_System6SocketiiPvPmEXadL_ZN4$_378__invokeES2_S3_iiS4_S5_EEE13static_casterIS4_EcvT_IS2_EEv:
   22|  3.15k|        {
   23|  3.15k|            return static_cast<To>(obj);
   24|  3.15k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Null_System6SocketiiPKvmEXadL_ZN4$_388__invokeES2_S3_iiS5_mEEEcvPFT_T0_DpT1_EIiPvJS3_iiS5_mEEEvENKUlSH_DpT_E_clIJS3_iiS5_mEEEDaSH_SJ_:
   31|  12.6k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Null_System6SocketiiPKvmEXadL_ZN4$_388__invokeES2_S3_iiS5_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|  12.6k|        {
   23|  12.6k|            return static_cast<To>(obj);
   24|  12.6k|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Null_SystemPhmEXadL_ZN4$_398__invokeES2_S3_mEEEcvPFT_T0_DpT1_EIvPvJS3_mEEEvENKUlSF_DpT_E_clIJS3_mEEEDaSF_SH_:
   31|  45.4k|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Null_SystemPhmEXadL_ZN4$_398__invokeES2_S3_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|  45.4k|        {
   23|  45.4k|            return static_cast<To>(obj);
   24|  45.4k|        }

_ZN6SystemC2ENSt3__110unique_ptrI10Tox_SystemNS0_14default_deleteIS2_EEEENS1_I6MemoryNS3_IS6_EEEENS1_I7NetworkNS3_IS9_EEEENS1_I6RandomNS3_ISC_EEEE:
   38|  3.15k|    : sys(std::move(in_sys))
   39|  3.15k|    , mem(std::move(in_mem))
   40|  3.15k|    , ns(std::move(in_ns))
   41|  3.15k|    , rng(std::move(in_rng))
   42|  3.15k|{
   43|  3.15k|}
_ZN6SystemD2Ev:
   46|  3.15k|System::~System() { }
_ZN11Null_SystemC2Ev:
  321|  3.15k|    : System{
  322|  3.15k|        std::make_unique<Tox_System>(),
  323|  3.15k|        std::make_unique<Memory>(Memory{&null_memory_funcs, this}),
  324|  3.15k|        std::make_unique<Network>(Network{&null_network_funcs, this}),
  325|  3.15k|        std::make_unique<Random>(Random{&null_random_funcs, this}),
  326|  3.15k|    }
  327|  3.15k|{
  328|  3.15k|    sys->mono_time_callback = [](void *self) { return static_cast<Null_System *>(self)->clock; };
  329|  3.15k|    sys->mono_time_user_data = this;
  330|  3.15k|    sys->mem = mem.get();
  331|  3.15k|    sys->ns = ns.get();
  332|  3.15k|    sys->rng = rng.get();
  333|  3.15k|}
fuzz_support.cc:_ZNK4$_21clEP11Null_Systemj:
  249|  3.07k|    ![](Null_System *self, uint32_t size) { return std::malloc(size); },
fuzz_support.cc:_ZNK4$_22clEP11Null_Systemjj:
  251|   137k|    ![](Null_System *self, uint32_t nmemb, uint32_t size) { return std::calloc(nmemb, size); },
fuzz_support.cc:_ZNK4$_23clEP11Null_SystemPvj:
  253|  55.8k|    ![](Null_System *self, void *ptr, uint32_t size) { return std::realloc(ptr, size); },
fuzz_support.cc:_ZNK4$_24clEP11Null_SystemPv:
  255|  1.27M|    ![](Null_System *self, void *ptr) { std::free(ptr); },
fuzz_support.cc:_ZNK4$_25clEP11Null_System6Socket:
  259|  3.15k|    /* .close = */ ![](Null_System *self, Socket sock) { return 0; },
fuzz_support.cc:_ZNK4$_27clEP11Null_System6SocketPK12Network_Addr:
  261|  3.15k|    /* .bind = */ ![](Null_System *self, Socket sock, const Network_Addr *addr) { return 0; },
fuzz_support.cc:_ZNK4$_35clEP11Null_Systemiii:
  287|  3.15k|    /* .socket = */ ![](Null_System *self, int domain, int type, int proto) { return Socket{42}; },
fuzz_support.cc:_ZNK4$_36clEP11Null_System6Socketb:
  288|  3.15k|    /* .socket_nonblock = */ ![](Null_System *self, Socket sock, bool nonblock) { return 0; },
fuzz_support.cc:_ZNK4$_37clEP11Null_System6SocketiiPvPm:
  290|  3.15k|    ![](Null_System *self, Socket sock, int level, int optname, void *optval, size_t *optlen) {
  291|  3.15k|        std::memset(optval, 0, *optlen);
  292|  3.15k|        return 0;
  293|  3.15k|    },
fuzz_support.cc:_ZNK4$_38clEP11Null_System6SocketiiPKvm:
  295|  12.6k|    ![](Null_System *self, Socket sock, int level, int optname, const void *optval, size_t optlen) {
  296|  12.6k|        return 0;
  297|  12.6k|    },
fuzz_support.cc:_ZNK4$_39clEP11Null_SystemPhm:
  309|  45.4k|    ![](Null_System *self, uint8_t *bytes, size_t length) {
  310|  1.24M|        for (size_t i = 0; i < length; ++i) {
  ------------------
  |  Branch (310:28): [True: 1.19M, False: 45.4k]
  ------------------
  311|  1.19M|            bytes[i] = simple_rng(self->seed) & 0xff;
  312|  1.19M|        }
  313|  45.4k|    },
fuzz_support.cc:_ZL10simple_rngRm:
  301|  1.19M|{
  302|       |    // https://nuclear.llnl.gov/CNP/rng/rngman/node4.html
  303|  1.19M|    seed = 2862933555777941757LL * seed + 3037000493LL;
  304|  1.19M|    return seed;
  305|  1.19M|}
fuzz_support.cc:_ZZN11Null_SystemC1EvENK3$_0clEPv:
  328|  3.15k|    sys->mono_time_callback = [](void *self) { return static_cast<Null_System *>(self)->clock; };

_ZN9Fuzz_DataC2EPKhm:
   32|  3.15k|        : data_(input_data)
   33|  3.15k|        , base_(input_data)
   34|  3.15k|        , size_(input_size)
   35|  3.15k|    {
   36|  3.15k|    }
_ZNK9Fuzz_Data4sizeEv:
   69|  6.30k|    std::size_t size() const { return size_; }
_ZN9Fuzz_Data7consumeEPKcm:
   75|  3.15k|    {
   76|  3.15k|        const uint8_t *val = data_;
   77|  3.15k|        if (FUZZ_DEBUG) {
  ------------------
  |  Branch (77:13): [Folded - Ignored]
  ------------------
   78|      0|            if (pos() == TRACE_TRAP) {
  ------------------
  |  Branch (78:17): [True: 0, False: 0]
  ------------------
   79|      0|                __asm__("int $3");
   80|      0|            }
   81|      0|            if (count == 1) {
  ------------------
  |  Branch (81:17): [True: 0, False: 0]
  ------------------
   82|      0|                std::printf("consume@%zu(%s): %d (0x%02x)\n", pos(), func, val[0], val[0]);
   83|      0|            } else if (count != 0) {
  ------------------
  |  Branch (83:24): [True: 0, False: 0]
  ------------------
   84|      0|                std::printf("consume@%zu(%s): %02x..%02x[%zu]\n", pos(), func, val[0],
   85|      0|                    val[count - 1], count);
   86|      0|            }
   87|      0|        }
   88|  3.15k|        data_ += count;
   89|  3.15k|        size_ -= count;
   90|  3.15k|        return val;
   91|  3.15k|    }

LLVMFuzzerTestOneInput:
   51|  3.15k|{
   52|  3.15k|    Fuzz_Data input{data, size};
   53|  3.15k|    TestSaveDataLoading(input);
   54|  3.15k|    return 0;  // Non-zero return values are reserved for future use.
   55|  3.15k|}
toxsave_fuzz_test.cc:_ZN12_GLOBAL__N_119TestSaveDataLoadingER9Fuzz_Data:
   12|  3.15k|{
   13|  3.15k|    Tox_Err_Options_New error_options;
   14|       |
   15|  3.15k|    struct Tox_Options *tox_options = tox_options_new(&error_options);
   16|       |
   17|  3.15k|    assert(tox_options != nullptr);
   18|  3.15k|    assert(error_options == TOX_ERR_OPTIONS_NEW_OK);
   19|       |
   20|  3.15k|    const size_t savedata_size = input.size();
   21|  3.15k|    CONSUME_OR_RETURN(const uint8_t *savedata, input, savedata_size);
  ------------------
  |  |  139|  3.15k|    if (INPUT.size() < SIZE) {               \
  |  |  ------------------
  |  |  |  Branch (139:9): [True: 0, False: 3.15k]
  |  |  ------------------
  |  |  140|      0|        return;                              \
  |  |  141|      0|    }                                        \
  |  |  142|  3.15k|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   22|       |
   23|  3.15k|    tox_options_set_experimental_groups_persistence(tox_options, true);
   24|       |
   25|       |    // pass test data to Tox
   26|  3.15k|    tox_options_set_savedata_data(tox_options, savedata, savedata_size);
   27|  3.15k|    tox_options_set_savedata_type(tox_options, TOX_SAVEDATA_TYPE_TOX_SAVE);
   28|       |
   29|  3.15k|    Tox_Options_Testing tox_options_testing;
   30|  3.15k|    Null_System sys;
   31|  3.15k|    tox_options_testing.operating_system = sys.sys.get();
   32|       |
   33|  3.15k|    Tox *tox = tox_new_testing(tox_options, nullptr, &tox_options_testing, nullptr);
   34|  3.15k|    tox_options_free(tox_options);
   35|  3.15k|    if (tox == nullptr) {
  ------------------
  |  Branch (35:9): [True: 2.53k, False: 615]
  ------------------
   36|       |        // Tox save was invalid, we're finished here
   37|  2.53k|        return;
   38|  2.53k|    }
   39|       |
   40|       |    // verify that the file can be saved again
   41|    615|    std::vector<uint8_t> new_savedata(tox_get_savedata_size(tox));
   42|    615|    tox_get_savedata(tox, new_savedata.data());
   43|       |
   44|    615|    tox_kill(tox);
   45|    615|}

cmp_init:
  837|  32.0k|                                         cmp_writer *write) {
  838|  32.0k|  ctx->error = CMP_ERROR_NONE;
  839|  32.0k|  ctx->buf = buf;
  840|  32.0k|  ctx->read = read;
  841|  32.0k|  ctx->skip = skip;
  842|  32.0k|  ctx->write = write;
  843|  32.0k|}
cmp_write_pfix:
  859|  1.00k|bool cmp_write_pfix(cmp_ctx_t *ctx, uint8_t c) {
  860|  1.00k|  if (c <= 0x7F)
  ------------------
  |  Branch (860:7): [True: 1.00k, False: 0]
  ------------------
  861|  1.00k|    return write_fixed_value(ctx, c);
  862|       |
  863|      0|  ctx->error = CMP_ERROR_INPUT_VALUE_TOO_LARGE;
  864|      0|  return false;
  865|  1.00k|}
cmp_write_u8:
  938|     16|bool cmp_write_u8(cmp_ctx_t *ctx, uint8_t c) {
  939|     16|  if (!write_type_marker(ctx, U8_MARKER))
  ------------------
  |  Branch (939:7): [True: 0, False: 16]
  ------------------
  940|      0|    return false;
  941|       |
  942|     16|  return ctx->write(ctx, &c, sizeof(uint8_t)) == sizeof(uint8_t);
  943|     16|}
cmp_write_u16:
  945|    116|bool cmp_write_u16(cmp_ctx_t *ctx, uint16_t s) {
  946|    116|  if (!write_type_marker(ctx, U16_MARKER))
  ------------------
  |  Branch (946:7): [True: 0, False: 116]
  ------------------
  947|      0|    return false;
  948|       |
  949|    116|  s = be16(s);
  950|       |
  951|    116|  return ctx->write(ctx, &s, sizeof(uint16_t)) == sizeof(uint16_t);
  952|    116|}
cmp_write_uinteger:
  972|  1.14k|bool cmp_write_uinteger(cmp_ctx_t *ctx, uint64_t u) {
  973|  1.14k|  if (u <= 0x7F)
  ------------------
  |  Branch (973:7): [True: 1.00k, False: 132]
  ------------------
  974|  1.00k|    return cmp_write_pfix(ctx, (uint8_t)u);
  975|    132|  if (u <= 0xFF)
  ------------------
  |  Branch (975:7): [True: 16, False: 116]
  ------------------
  976|     16|    return cmp_write_u8(ctx, (uint8_t)u);
  977|    116|  if (u <= 0xFFFF)
  ------------------
  |  Branch (977:7): [True: 116, False: 0]
  ------------------
  978|    116|    return cmp_write_u16(ctx, (uint16_t)u);
  979|      0|  if (u <= 0xFFFFFFFF)
  ------------------
  |  Branch (979:7): [True: 0, False: 0]
  ------------------
  980|      0|    return cmp_write_u32(ctx, (uint32_t)u);
  981|       |
  982|      0|  return cmp_write_u64(ctx, u);
  983|      0|}
cmp_write_nil:
 1041|      4|bool cmp_write_nil(cmp_ctx_t *ctx) {
 1042|      4|  return write_type_marker(ctx, NIL_MARKER);
 1043|      4|}
cmp_write_false:
 1049|     76|bool cmp_write_false(cmp_ctx_t *ctx) {
 1050|     76|  return write_type_marker(ctx, FALSE_MARKER);
 1051|     76|}
cmp_write_bool:
 1053|     76|bool cmp_write_bool(cmp_ctx_t *ctx, bool b) {
 1054|     76|  if (b)
  ------------------
  |  Branch (1054:7): [True: 0, False: 76]
  ------------------
 1055|      0|    return cmp_write_true(ctx);
 1056|       |
 1057|     76|  return cmp_write_false(ctx);
 1058|     76|}
cmp_write_bin8_marker:
 1205|  1.02k|bool cmp_write_bin8_marker(cmp_ctx_t *ctx, uint8_t size) {
 1206|  1.02k|  if (!write_type_marker(ctx, BIN8_MARKER))
  ------------------
  |  Branch (1206:7): [True: 0, False: 1.02k]
  ------------------
 1207|      0|    return false;
 1208|       |
 1209|  1.02k|  if (ctx->write(ctx, &size, sizeof(uint8_t)) == sizeof(uint8_t))
  ------------------
  |  Branch (1209:7): [True: 1.02k, False: 0]
  ------------------
 1210|  1.02k|    return true;
 1211|       |
 1212|      0|  ctx->error = CMP_ERROR_LENGTH_WRITING;
 1213|      0|  return false;
 1214|  1.02k|}
cmp_write_bin8:
 1216|  1.02k|bool cmp_write_bin8(cmp_ctx_t *ctx, const void *data, uint8_t size) {
 1217|  1.02k|  if (!cmp_write_bin8_marker(ctx, size))
  ------------------
  |  Branch (1217:7): [True: 0, False: 1.02k]
  ------------------
 1218|      0|    return false;
 1219|       |
 1220|  1.02k|  if (size == 0)
  ------------------
  |  Branch (1220:7): [True: 76, False: 944]
  ------------------
 1221|     76|    return true;
 1222|       |
 1223|    944|  if (ctx->write(ctx, data, size) == size)
  ------------------
  |  Branch (1223:7): [True: 944, False: 0]
  ------------------
 1224|    944|    return true;
 1225|       |
 1226|      0|  ctx->error = CMP_ERROR_DATA_WRITING;
 1227|      0|  return false;
 1228|    944|}
cmp_write_bin16_marker:
 1230|    116|bool cmp_write_bin16_marker(cmp_ctx_t *ctx, uint16_t size) {
 1231|    116|  if (!write_type_marker(ctx, BIN16_MARKER))
  ------------------
  |  Branch (1231:7): [True: 0, False: 116]
  ------------------
 1232|      0|    return false;
 1233|       |
 1234|    116|  size = be16(size);
 1235|       |
 1236|    116|  if (ctx->write(ctx, &size, sizeof(uint16_t)) == sizeof(uint16_t))
  ------------------
  |  Branch (1236:7): [True: 116, False: 0]
  ------------------
 1237|    116|    return true;
 1238|       |
 1239|      0|  ctx->error = CMP_ERROR_LENGTH_WRITING;
 1240|      0|  return false;
 1241|    116|}
cmp_write_bin16:
 1243|    116|bool cmp_write_bin16(cmp_ctx_t *ctx, const void *data, uint16_t size) {
 1244|    116|  if (!cmp_write_bin16_marker(ctx, size))
  ------------------
  |  Branch (1244:7): [True: 0, False: 116]
  ------------------
 1245|      0|    return false;
 1246|       |
 1247|    116|  if (size == 0)
  ------------------
  |  Branch (1247:7): [True: 0, False: 116]
  ------------------
 1248|      0|    return true;
 1249|       |
 1250|    116|  if (ctx->write(ctx, data, size) == size)
  ------------------
  |  Branch (1250:7): [True: 116, False: 0]
  ------------------
 1251|    116|    return true;
 1252|       |
 1253|      0|  ctx->error = CMP_ERROR_DATA_WRITING;
 1254|      0|  return false;
 1255|    116|}
cmp_write_bin:
 1293|  1.13k|bool cmp_write_bin(cmp_ctx_t *ctx, const void *data, uint32_t size) {
 1294|  1.13k|  if (size <= 0xFF)
  ------------------
  |  Branch (1294:7): [True: 1.02k, False: 116]
  ------------------
 1295|  1.02k|    return cmp_write_bin8(ctx, data, (uint8_t)size);
 1296|    116|  if (size <= 0xFFFF)
  ------------------
  |  Branch (1296:7): [True: 116, False: 0]
  ------------------
 1297|    116|    return cmp_write_bin16(ctx, data, (uint16_t)size);
 1298|       |
 1299|      0|  return cmp_write_bin32(ctx, data, size);
 1300|    116|}
cmp_write_fixarray:
 1302|  1.94k|bool cmp_write_fixarray(cmp_ctx_t *ctx, uint8_t size) {
 1303|  1.94k|  if (size <= FIXARRAY_SIZE)
  ------------------
  |  Branch (1303:7): [True: 1.94k, False: 0]
  ------------------
 1304|  1.94k|    return write_fixed_value(ctx, FIXARRAY_MARKER | size);
 1305|       |
 1306|      0|  ctx->error = CMP_ERROR_INPUT_VALUE_TOO_LARGE;
 1307|      0|  return false;
 1308|  1.94k|}
cmp_write_array:
 1336|  1.94k|bool cmp_write_array(cmp_ctx_t *ctx, uint32_t size) {
 1337|  1.94k|  if (size <= FIXARRAY_SIZE)
  ------------------
  |  Branch (1337:7): [True: 1.94k, False: 0]
  ------------------
 1338|  1.94k|    return cmp_write_fixarray(ctx, (uint8_t)size);
 1339|      0|  if (size <= 0xFFFF)
  ------------------
  |  Branch (1339:7): [True: 0, False: 0]
  ------------------
 1340|      0|    return cmp_write_array16(ctx, (uint16_t)size);
 1341|       |
 1342|      0|  return cmp_write_array32(ctx, size);
 1343|      0|}
cmp_read_uchar:
 2144|  13.9k|bool cmp_read_uchar(cmp_ctx_t *ctx, uint8_t *c) {
 2145|  13.9k|  cmp_object_t obj;
 2146|       |
 2147|  13.9k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2147:7): [True: 215, False: 13.7k]
  ------------------
 2148|    215|    return false;
 2149|       |
 2150|  13.7k|  switch (obj.type) {
 2151|  7.02k|    case CMP_TYPE_POSITIVE_FIXNUM:
  ------------------
  |  Branch (2151:5): [True: 7.02k, False: 6.71k]
  ------------------
 2152|  13.0k|    case CMP_TYPE_UINT8: {
  ------------------
  |  Branch (2152:5): [True: 6.04k, False: 7.68k]
  ------------------
 2153|  13.0k|      *c = obj.as.u8;
 2154|  13.0k|      return true;
 2155|  7.02k|    }
 2156|    160|    case CMP_TYPE_NEGATIVE_FIXNUM:
  ------------------
  |  Branch (2156:5): [True: 160, False: 13.5k]
  ------------------
 2157|    249|    case CMP_TYPE_SINT8: {
  ------------------
  |  Branch (2157:5): [True: 89, False: 13.6k]
  ------------------
 2158|    249|      if (obj.as.s8 >= 0) {
  ------------------
  |  Branch (2158:11): [True: 89, False: 160]
  ------------------
 2159|     89|        *c = (uint8_t)obj.as.s8;
 2160|     89|        return true;
 2161|     89|      }
 2162|    160|      break;
 2163|    249|    }
 2164|    418|    default:
  ------------------
  |  Branch (2164:5): [True: 418, False: 13.3k]
  ------------------
 2165|    418|      break;
 2166|  13.7k|  }
 2167|       |
 2168|    578|  ctx->error = CMP_ERROR_INVALID_TYPE;
 2169|    578|  return false;
 2170|  13.7k|}
cmp_read_ushort:
 2172|  29.9k|bool cmp_read_ushort(cmp_ctx_t *ctx, uint16_t *s) {
 2173|  29.9k|  cmp_object_t obj;
 2174|       |
 2175|  29.9k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2175:7): [True: 2.25k, False: 27.6k]
  ------------------
 2176|  2.25k|    return false;
 2177|       |
 2178|  27.6k|  switch (obj.type) {
 2179|  9.53k|    case CMP_TYPE_POSITIVE_FIXNUM:
  ------------------
  |  Branch (2179:5): [True: 9.53k, False: 18.1k]
  ------------------
 2180|  21.4k|    case CMP_TYPE_UINT8: {
  ------------------
  |  Branch (2180:5): [True: 11.8k, False: 15.7k]
  ------------------
 2181|  21.4k|      *s = obj.as.u8;
 2182|  21.4k|      return true;
 2183|  9.53k|    }
 2184|    356|    case CMP_TYPE_UINT16: {
  ------------------
  |  Branch (2184:5): [True: 356, False: 27.3k]
  ------------------
 2185|    356|      *s = obj.as.u16;
 2186|    356|      return true;
 2187|  9.53k|    }
 2188|    213|    case CMP_TYPE_NEGATIVE_FIXNUM:
  ------------------
  |  Branch (2188:5): [True: 213, False: 27.4k]
  ------------------
 2189|    226|    case CMP_TYPE_SINT8: {
  ------------------
  |  Branch (2189:5): [True: 13, False: 27.6k]
  ------------------
 2190|    226|      if (obj.as.s8 >= 0) {
  ------------------
  |  Branch (2190:11): [True: 13, False: 213]
  ------------------
 2191|     13|        *s = (uint8_t)obj.as.s8;
 2192|     13|        return true;
 2193|     13|      }
 2194|    213|      break;
 2195|    226|    }
 2196|    213|    case CMP_TYPE_SINT16: {
  ------------------
  |  Branch (2196:5): [True: 26, False: 27.6k]
  ------------------
 2197|     26|      if (obj.as.s16 >= 0) {
  ------------------
  |  Branch (2197:11): [True: 19, False: 7]
  ------------------
 2198|     19|        *s = (uint16_t)obj.as.s16;
 2199|     19|        return true;
 2200|     19|      }
 2201|      7|      break;
 2202|     26|    }
 2203|  5.65k|    default:
  ------------------
  |  Branch (2203:5): [True: 5.65k, False: 22.0k]
  ------------------
 2204|  5.65k|      break;
 2205|  27.6k|  }
 2206|       |
 2207|  5.87k|  ctx->error = CMP_ERROR_INVALID_TYPE;
 2208|  5.87k|  return false;
 2209|  27.6k|}
cmp_read_uint:
 2211|  8.31k|bool cmp_read_uint(cmp_ctx_t *ctx, uint32_t *i) {
 2212|  8.31k|  cmp_object_t obj;
 2213|       |
 2214|  8.31k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2214:7): [True: 2.41k, False: 5.90k]
  ------------------
 2215|  2.41k|    return false;
 2216|       |
 2217|  5.90k|  switch (obj.type) {
 2218|  5.27k|    case CMP_TYPE_POSITIVE_FIXNUM:
  ------------------
  |  Branch (2218:5): [True: 5.27k, False: 631]
  ------------------
 2219|  5.31k|    case CMP_TYPE_UINT8: {
  ------------------
  |  Branch (2219:5): [True: 43, False: 5.85k]
  ------------------
 2220|  5.31k|      *i = obj.as.u8;
 2221|  5.31k|      return true;
 2222|  5.27k|    }
 2223|     31|    case CMP_TYPE_UINT16: {
  ------------------
  |  Branch (2223:5): [True: 31, False: 5.87k]
  ------------------
 2224|     31|      *i = obj.as.u16;
 2225|     31|      return true;
 2226|  5.27k|    }
 2227|     89|    case CMP_TYPE_UINT32: {
  ------------------
  |  Branch (2227:5): [True: 89, False: 5.81k]
  ------------------
 2228|     89|      *i = obj.as.u32;
 2229|     89|      return true;
 2230|  5.27k|    }
 2231|     77|    case CMP_TYPE_NEGATIVE_FIXNUM:
  ------------------
  |  Branch (2231:5): [True: 77, False: 5.82k]
  ------------------
 2232|     83|    case CMP_TYPE_SINT8: {
  ------------------
  |  Branch (2232:5): [True: 6, False: 5.89k]
  ------------------
 2233|     83|      if (obj.as.s8 >= 0) {
  ------------------
  |  Branch (2233:11): [True: 6, False: 77]
  ------------------
 2234|      6|        *i = (uint8_t)obj.as.s8;
 2235|      6|        return true;
 2236|      6|      }
 2237|     77|      break;
 2238|     83|    }
 2239|     77|    case CMP_TYPE_SINT16: {
  ------------------
  |  Branch (2239:5): [True: 17, False: 5.88k]
  ------------------
 2240|     17|      if (obj.as.s16 >= 0) {
  ------------------
  |  Branch (2240:11): [True: 8, False: 9]
  ------------------
 2241|      8|        *i = (uint16_t)obj.as.s16;
 2242|      8|        return true;
 2243|      8|      }
 2244|      9|      break;
 2245|     17|    }
 2246|     79|    case CMP_TYPE_SINT32: {
  ------------------
  |  Branch (2246:5): [True: 79, False: 5.82k]
  ------------------
 2247|     79|      if (obj.as.s32 >= 0) {
  ------------------
  |  Branch (2247:11): [True: 41, False: 38]
  ------------------
 2248|     41|        *i = (uint32_t)obj.as.s32;
 2249|     41|        return true;
 2250|     41|      }
 2251|     38|      break;
 2252|     79|    }
 2253|    289|    default:
  ------------------
  |  Branch (2253:5): [True: 289, False: 5.61k]
  ------------------
 2254|    289|      break;
 2255|  5.90k|  }
 2256|       |
 2257|    413|  ctx->error = CMP_ERROR_INVALID_TYPE;
 2258|    413|  return false;
 2259|  5.90k|}
cmp_read_nil:
 2382|     32|bool cmp_read_nil(cmp_ctx_t *ctx) {
 2383|     32|  cmp_object_t obj;
 2384|       |
 2385|     32|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2385:7): [True: 0, False: 32]
  ------------------
 2386|      0|    return false;
 2387|       |
 2388|     32|  if (obj.type == CMP_TYPE_NIL)
  ------------------
  |  Branch (2388:7): [True: 20, False: 12]
  ------------------
 2389|     20|    return true;
 2390|       |
 2391|     12|  ctx->error = CMP_ERROR_INVALID_TYPE;
 2392|     12|  return false;
 2393|     32|}
cmp_read_bool:
 2395|  20.5k|bool cmp_read_bool(cmp_ctx_t *ctx, bool *b) {
 2396|  20.5k|  cmp_object_t obj;
 2397|       |
 2398|  20.5k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2398:7): [True: 234, False: 20.2k]
  ------------------
 2399|    234|    return false;
 2400|       |
 2401|  20.2k|  if (obj.type != CMP_TYPE_BOOLEAN) {
  ------------------
  |  Branch (2401:7): [True: 7.38k, False: 12.9k]
  ------------------
 2402|  7.38k|    ctx->error = CMP_ERROR_INVALID_TYPE;
 2403|  7.38k|    return false;
 2404|  7.38k|  }
 2405|       |
 2406|  12.9k|  if (obj.as.boolean) {
  ------------------
  |  Branch (2406:7): [True: 112, False: 12.8k]
  ------------------
 2407|    112|    *b = true;
 2408|  12.8k|  } else {
 2409|  12.8k|    *b = false;
 2410|  12.8k|  }
 2411|       |
 2412|  12.9k|  return true;
 2413|  20.2k|}
cmp_read_bin_size:
 2479|  2.17k|bool cmp_read_bin_size(cmp_ctx_t *ctx, uint32_t *size) {
 2480|  2.17k|  cmp_object_t obj;
 2481|       |
 2482|  2.17k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2482:7): [True: 16, False: 2.16k]
  ------------------
 2483|     16|    return false;
 2484|       |
 2485|  2.16k|  switch (obj.type) {
 2486|  1.89k|    case CMP_TYPE_BIN8:
  ------------------
  |  Branch (2486:5): [True: 1.89k, False: 270]
  ------------------
 2487|  2.05k|    case CMP_TYPE_BIN16:
  ------------------
  |  Branch (2487:5): [True: 163, False: 2.00k]
  ------------------
 2488|  2.05k|    case CMP_TYPE_BIN32: {
  ------------------
  |  Branch (2488:5): [True: 1, False: 2.16k]
  ------------------
 2489|  2.05k|      *size = obj.as.bin_size;
 2490|  2.05k|      return true;
 2491|  2.05k|    }
 2492|    106|    default: {
  ------------------
  |  Branch (2492:5): [True: 106, False: 2.05k]
  ------------------
 2493|    106|      ctx->error = CMP_ERROR_INVALID_TYPE;
 2494|    106|      return false;
 2495|  2.05k|    }
 2496|  2.16k|  }
 2497|  2.16k|}
cmp_read_array:
 2519|  74.7k|bool cmp_read_array(cmp_ctx_t *ctx, uint32_t *size) {
 2520|  74.7k|  cmp_object_t obj;
 2521|       |
 2522|  74.7k|  if (!cmp_read_object(ctx, &obj))
  ------------------
  |  Branch (2522:7): [True: 311, False: 74.4k]
  ------------------
 2523|    311|    return false;
 2524|       |
 2525|  74.4k|  switch (obj.type) {
 2526|  68.5k|    case CMP_TYPE_FIXARRAY:
  ------------------
  |  Branch (2526:5): [True: 68.5k, False: 5.80k]
  ------------------
 2527|  68.6k|    case CMP_TYPE_ARRAY16:
  ------------------
  |  Branch (2527:5): [True: 16, False: 74.3k]
  ------------------
 2528|  68.6k|    case CMP_TYPE_ARRAY32: {
  ------------------
  |  Branch (2528:5): [True: 4, False: 74.3k]
  ------------------
 2529|  68.6k|      *size = obj.as.array_size;
 2530|  68.6k|      return true;
 2531|  68.6k|    }
 2532|  5.78k|    default: {
  ------------------
  |  Branch (2532:5): [True: 5.78k, False: 68.6k]
  ------------------
 2533|  5.78k|      ctx->error = CMP_ERROR_INVALID_TYPE;
 2534|  5.78k|      return false;
 2535|  68.6k|    }
 2536|  74.4k|  }
 2537|  74.4k|}
cmp_read_object:
 2810|   149k|bool cmp_read_object(cmp_ctx_t *ctx, cmp_object_t *obj) {
 2811|   149k|  uint8_t type_marker = 0;
 2812|       |
 2813|   149k|  if (!read_type_marker(ctx, &type_marker))
  ------------------
  |  Branch (2813:7): [True: 2.41k, False: 147k]
  ------------------
 2814|  2.41k|    return false;
 2815|       |
 2816|   147k|  if (!type_marker_to_cmp_type(type_marker, &obj->type)) {
  ------------------
  |  Branch (2816:7): [True: 116, False: 147k]
  ------------------
 2817|    116|    ctx->error = CMP_ERROR_INVALID_TYPE;
 2818|    116|    return false;
 2819|    116|  }
 2820|       |
 2821|   147k|  return read_obj_data(ctx, type_marker, obj);
 2822|   147k|}
cmp.c:write_fixed_value:
  245|  2.95k|static bool write_fixed_value(cmp_ctx_t *ctx, uint8_t value) {
  246|  2.95k|  if (write_byte(ctx, value))
  ------------------
  |  Branch (246:7): [True: 2.95k, False: 0]
  ------------------
  247|  2.95k|    return true;
  248|       |
  249|      0|  ctx->error = CMP_ERROR_FIXED_VALUE_WRITING;
  250|      0|  return false;
  251|  2.95k|}
cmp.c:write_byte:
  207|  4.30k|static bool write_byte(cmp_ctx_t *ctx, uint8_t x) {
  208|  4.30k|  return ctx->write(ctx, &x, sizeof(uint8_t)) == sizeof(uint8_t);
  209|  4.30k|}
cmp.c:write_type_marker:
  237|  1.34k|static bool write_type_marker(cmp_ctx_t *ctx, uint8_t marker) {
  238|  1.34k|  if (write_byte(ctx, marker))
  ------------------
  |  Branch (238:7): [True: 1.34k, False: 0]
  ------------------
  239|  1.34k|    return true;
  240|       |
  241|      0|  ctx->error = CMP_ERROR_TYPE_MARKER_WRITING;
  242|      0|  return false;
  243|  1.34k|}
cmp.c:sbe16:
  127|     87|static int16_t sbe16(int16_t x) {
  128|     87|  return (int16_t)be16((uint16_t)x);
  129|     87|}
cmp.c:sbe32:
  138|    118|static int32_t sbe32(int32_t x) {
  139|    118|  return (int32_t)be32((uint32_t)x);
  140|    118|}
cmp.c:sbe64:
  149|     36|static int64_t sbe64(int64_t x) {
  150|     36|  return (int64_t)be64((uint64_t)x);
  151|     36|}
cmp.c:be16:
  119|  24.2k|static uint16_t be16(uint16_t x) {
  120|  24.2k|  if (!is_bigendian())
  ------------------
  |  Branch (120:7): [True: 24.2k, False: 0]
  ------------------
  121|  24.2k|    return ((x >> 8) & 0x00ff)
  122|  24.2k|         | ((x << 8) & 0xff00);
  123|       |
  124|      0|  return x;
  125|  24.2k|}
cmp.c:is_bigendian:
  109|  35.8k|static bool is_bigendian(void) {
  110|       |#ifdef WORDS_BIGENDIAN
  111|       |  return WORDS_BIGENDIAN;
  112|       |#else
  113|  35.8k|  const int32_t i_ = 1;
  114|  35.8k|  const char *i_bytes = (const char *)&i_;
  115|  35.8k|  return *i_bytes == 0;
  116|  35.8k|#endif /* WORDS_BIGENDIAN */
  117|  35.8k|}
cmp.c:be32:
  131|  11.4k|static uint32_t be32(uint32_t x) {
  132|  11.4k|  if (!is_bigendian())
  ------------------
  |  Branch (132:7): [True: 11.4k, False: 0]
  ------------------
  133|  11.4k|    return ((uint32_t)be16((uint16_t)(x & 0xffff)) << 16) | (uint32_t)be16((uint16_t)(x >> 16));
  134|       |
  135|      0|  return x;
  136|  11.4k|}
cmp.c:be64:
  142|    131|static uint64_t be64(uint64_t x) {
  143|    131|  if (!is_bigendian())
  ------------------
  |  Branch (143:7): [True: 131, False: 0]
  ------------------
  144|    131|    return ((uint64_t)be32((uint32_t)(x & 0xffffffff)) << 32) | (uint64_t)be32((uint32_t)(x >> 32));
  145|       |
  146|      0|  return x;
  147|    131|}
cmp.c:read_type_marker:
  228|   149k|static bool read_type_marker(cmp_ctx_t *ctx, uint8_t *marker) {
  229|   149k|  if (read_byte(ctx, marker)) {
  ------------------
  |  Branch (229:7): [True: 147k, False: 2.41k]
  ------------------
  230|   147k|    return true;
  231|   147k|  }
  232|       |
  233|  2.41k|  ctx->error = CMP_ERROR_TYPE_MARKER_READING;
  234|  2.41k|  return false;
  235|   149k|}
cmp.c:read_byte:
  203|   149k|static bool read_byte(cmp_ctx_t *ctx, uint8_t *x) {
  204|   149k|  return ctx->read(ctx, x, sizeof(uint8_t));
  205|   149k|}
cmp.c:type_marker_to_cmp_type:
  253|   147k|static bool type_marker_to_cmp_type(uint8_t type_marker, uint8_t *cmp_type) {
  254|   147k|  if (type_marker <= 0x7F) {
  ------------------
  |  Branch (254:7): [True: 27.7k, False: 119k]
  ------------------
  255|  27.7k|    *cmp_type = CMP_TYPE_POSITIVE_FIXNUM;
  256|  27.7k|    return true;
  257|  27.7k|  }
  258|       |
  259|   119k|  if (type_marker <= 0x8F) {
  ------------------
  |  Branch (259:7): [True: 236, False: 119k]
  ------------------
  260|    236|    *cmp_type = CMP_TYPE_FIXMAP;
  261|    236|    return true;
  262|    236|  }
  263|       |
  264|   119k|  if (type_marker <= 0x9F) {
  ------------------
  |  Branch (264:7): [True: 68.7k, False: 50.4k]
  ------------------
  265|  68.7k|    *cmp_type = CMP_TYPE_FIXARRAY;
  266|  68.7k|    return true;
  267|  68.7k|  }
  268|       |
  269|  50.4k|  if (type_marker <= 0xBF) {
  ------------------
  |  Branch (269:7): [True: 283, False: 50.1k]
  ------------------
  270|    283|    *cmp_type = CMP_TYPE_FIXSTR;
  271|    283|    return true;
  272|    283|  }
  273|       |
  274|  50.1k|  if (type_marker >= 0xE0) {
  ------------------
  |  Branch (274:7): [True: 634, False: 49.5k]
  ------------------
  275|    634|    *cmp_type = CMP_TYPE_NEGATIVE_FIXNUM;
  276|    634|    return true;
  277|    634|  }
  278|       |
  279|  49.5k|  switch (type_marker) {
  280|    150|    case NIL_MARKER: {
  ------------------
  |  Branch (280:5): [True: 150, False: 49.4k]
  ------------------
  281|    150|      *cmp_type = CMP_TYPE_NIL;
  282|    150|      return true;
  283|      0|    }
  284|  12.9k|    case FALSE_MARKER: {
  ------------------
  |  Branch (284:5): [True: 12.9k, False: 36.5k]
  ------------------
  285|  12.9k|      *cmp_type = CMP_TYPE_BOOLEAN;
  286|  12.9k|      return true;
  287|      0|    }
  288|    238|    case TRUE_MARKER: {
  ------------------
  |  Branch (288:5): [True: 238, False: 49.3k]
  ------------------
  289|    238|      *cmp_type = CMP_TYPE_BOOLEAN;
  290|    238|      return true;
  291|      0|    }
  292|  2.00k|    case BIN8_MARKER: {
  ------------------
  |  Branch (292:5): [True: 2.00k, False: 47.5k]
  ------------------
  293|  2.00k|      *cmp_type = CMP_TYPE_BIN8;
  294|  2.00k|      return true;
  295|      0|    }
  296|    206|    case BIN16_MARKER: {
  ------------------
  |  Branch (296:5): [True: 206, False: 49.3k]
  ------------------
  297|    206|      *cmp_type = CMP_TYPE_BIN16;
  298|    206|      return true;
  299|      0|    }
  300|  12.7k|    case BIN32_MARKER: {
  ------------------
  |  Branch (300:5): [True: 12.7k, False: 36.7k]
  ------------------
  301|  12.7k|      *cmp_type = CMP_TYPE_BIN32;
  302|  12.7k|      return true;
  303|      0|    }
  304|    108|    case EXT8_MARKER: {
  ------------------
  |  Branch (304:5): [True: 108, False: 49.4k]
  ------------------
  305|    108|      *cmp_type = CMP_TYPE_EXT8;
  306|    108|      return true;
  307|      0|    }
  308|     58|    case EXT16_MARKER: {
  ------------------
  |  Branch (308:5): [True: 58, False: 49.4k]
  ------------------
  309|     58|      *cmp_type = CMP_TYPE_EXT16;
  310|     58|      return true;
  311|      0|    }
  312|    106|    case EXT32_MARKER: {
  ------------------
  |  Branch (312:5): [True: 106, False: 49.4k]
  ------------------
  313|    106|      *cmp_type = CMP_TYPE_EXT32;
  314|    106|      return true;
  315|      0|    }
  316|    178|    case FLOAT_MARKER: {
  ------------------
  |  Branch (316:5): [True: 178, False: 49.3k]
  ------------------
  317|    178|      *cmp_type = CMP_TYPE_FLOAT;
  318|    178|      return true;
  319|      0|    }
  320|    128|    case DOUBLE_MARKER: {
  ------------------
  |  Branch (320:5): [True: 128, False: 49.4k]
  ------------------
  321|    128|      *cmp_type = CMP_TYPE_DOUBLE;
  322|    128|      return true;
  323|      0|    }
  324|  18.1k|    case U8_MARKER: {
  ------------------
  |  Branch (324:5): [True: 18.1k, False: 31.4k]
  ------------------
  325|  18.1k|      *cmp_type = CMP_TYPE_UINT8;
  326|  18.1k|      return true;
  327|      0|    }
  328|    455|    case U16_MARKER: {
  ------------------
  |  Branch (328:5): [True: 455, False: 49.1k]
  ------------------
  329|    455|      *cmp_type = CMP_TYPE_UINT16;
  330|    455|      return true;
  331|      0|    }
  332|    450|    case U32_MARKER: {
  ------------------
  |  Branch (332:5): [True: 450, False: 49.1k]
  ------------------
  333|    450|      *cmp_type = CMP_TYPE_UINT32;
  334|    450|      return true;
  335|      0|    }
  336|    127|    case U64_MARKER: {
  ------------------
  |  Branch (336:5): [True: 127, False: 49.4k]
  ------------------
  337|    127|      *cmp_type = CMP_TYPE_UINT64;
  338|    127|      return true;
  339|      0|    }
  340|    125|    case S8_MARKER: {
  ------------------
  |  Branch (340:5): [True: 125, False: 49.4k]
  ------------------
  341|    125|      *cmp_type = CMP_TYPE_SINT8;
  342|    125|      return true;
  343|      0|    }
  344|     90|    case S16_MARKER: {
  ------------------
  |  Branch (344:5): [True: 90, False: 49.4k]
  ------------------
  345|     90|      *cmp_type = CMP_TYPE_SINT16;
  346|     90|      return true;
  347|      0|    }
  348|    121|    case S32_MARKER: {
  ------------------
  |  Branch (348:5): [True: 121, False: 49.4k]
  ------------------
  349|    121|      *cmp_type = CMP_TYPE_SINT32;
  350|    121|      return true;
  351|      0|    }
  352|     42|    case S64_MARKER: {
  ------------------
  |  Branch (352:5): [True: 42, False: 49.5k]
  ------------------
  353|     42|      *cmp_type = CMP_TYPE_SINT64;
  354|     42|      return true;
  355|      0|    }
  356|     90|    case FIXEXT1_MARKER: {
  ------------------
  |  Branch (356:5): [True: 90, False: 49.4k]
  ------------------
  357|     90|      *cmp_type = CMP_TYPE_FIXEXT1;
  358|     90|      return true;
  359|      0|    }
  360|     33|    case FIXEXT2_MARKER: {
  ------------------
  |  Branch (360:5): [True: 33, False: 49.5k]
  ------------------
  361|     33|      *cmp_type = CMP_TYPE_FIXEXT2;
  362|     33|      return true;
  363|      0|    }
  364|     64|    case FIXEXT4_MARKER: {
  ------------------
  |  Branch (364:5): [True: 64, False: 49.4k]
  ------------------
  365|     64|      *cmp_type = CMP_TYPE_FIXEXT4;
  366|     64|      return true;
  367|      0|    }
  368|     65|    case FIXEXT8_MARKER: {
  ------------------
  |  Branch (368:5): [True: 65, False: 49.4k]
  ------------------
  369|     65|      *cmp_type = CMP_TYPE_FIXEXT8;
  370|     65|      return true;
  371|      0|    }
  372|    215|    case FIXEXT16_MARKER: {
  ------------------
  |  Branch (372:5): [True: 215, False: 49.3k]
  ------------------
  373|    215|      *cmp_type = CMP_TYPE_FIXEXT16;
  374|    215|      return true;
  375|      0|    }
  376|     54|    case STR8_MARKER: {
  ------------------
  |  Branch (376:5): [True: 54, False: 49.5k]
  ------------------
  377|     54|      *cmp_type = CMP_TYPE_STR8;
  378|     54|      return true;
  379|      0|    }
  380|     73|    case STR16_MARKER: {
  ------------------
  |  Branch (380:5): [True: 73, False: 49.4k]
  ------------------
  381|     73|      *cmp_type = CMP_TYPE_STR16;
  382|     73|      return true;
  383|      0|    }
  384|     42|    case STR32_MARKER: {
  ------------------
  |  Branch (384:5): [True: 42, False: 49.5k]
  ------------------
  385|     42|      *cmp_type = CMP_TYPE_STR32;
  386|     42|      return true;
  387|      0|    }
  388|    157|    case ARRAY16_MARKER: {
  ------------------
  |  Branch (388:5): [True: 157, False: 49.4k]
  ------------------
  389|    157|      *cmp_type = CMP_TYPE_ARRAY16;
  390|    157|      return true;
  391|      0|    }
  392|     55|    case ARRAY32_MARKER: {
  ------------------
  |  Branch (392:5): [True: 55, False: 49.5k]
  ------------------
  393|     55|      *cmp_type = CMP_TYPE_ARRAY32;
  394|     55|      return true;
  395|      0|    }
  396|     93|    case MAP16_MARKER: {
  ------------------
  |  Branch (396:5): [True: 93, False: 49.4k]
  ------------------
  397|     93|      *cmp_type = CMP_TYPE_MAP16;
  398|     93|      return true;
  399|      0|    }
  400|     75|    case MAP32_MARKER: {
  ------------------
  |  Branch (400:5): [True: 75, False: 49.4k]
  ------------------
  401|     75|      *cmp_type = CMP_TYPE_MAP32;
  402|     75|      return true;
  403|      0|    }
  404|    116|    default: {
  ------------------
  |  Branch (404:5): [True: 116, False: 49.4k]
  ------------------
  405|    116|      return false;
  406|      0|    }
  407|  49.5k|  }
  408|  49.5k|}
cmp.c:read_obj_data:
  618|   147k|                                          cmp_object_t *obj) {
  619|   147k|  switch (obj->type) {
  620|  27.7k|    case CMP_TYPE_POSITIVE_FIXNUM: {
  ------------------
  |  Branch (620:5): [True: 27.7k, False: 119k]
  ------------------
  621|  27.7k|      obj->as.u8 = type_marker;
  622|  27.7k|      return true;
  623|      0|    }
  624|    634|    case CMP_TYPE_NEGATIVE_FIXNUM: {
  ------------------
  |  Branch (624:5): [True: 634, False: 146k]
  ------------------
  625|    634|      obj->as.s8 = (int8_t)type_marker;
  626|    634|      return true;
  627|      0|    }
  628|    150|    case CMP_TYPE_NIL: {
  ------------------
  |  Branch (628:5): [True: 150, False: 146k]
  ------------------
  629|    150|      obj->as.u8 = 0;
  630|    150|      return true;
  631|      0|    }
  632|  13.2k|    case CMP_TYPE_BOOLEAN: {
  ------------------
  |  Branch (632:5): [True: 13.2k, False: 133k]
  ------------------
  633|  13.2k|      switch (type_marker) {
  634|    238|        case TRUE_MARKER: {
  ------------------
  |  Branch (634:9): [True: 238, False: 12.9k]
  ------------------
  635|    238|          obj->as.boolean = true;
  636|    238|          return true;
  637|      0|        }
  638|  12.9k|        case FALSE_MARKER: {
  ------------------
  |  Branch (638:9): [True: 12.9k, False: 238]
  ------------------
  639|  12.9k|          obj->as.boolean = false;
  640|  12.9k|          return true;
  641|      0|        }
  642|      0|        default:
  ------------------
  |  Branch (642:9): [True: 0, False: 13.2k]
  ------------------
  643|      0|          break;
  644|  13.2k|      }
  645|      0|      ctx->error = CMP_ERROR_INTERNAL;
  646|      0|      return false;
  647|  13.2k|    }
  648|  18.1k|    case CMP_TYPE_UINT8: {
  ------------------
  |  Branch (648:5): [True: 18.1k, False: 129k]
  ------------------
  649|  18.1k|      if (!ctx->read(ctx, &obj->as.u8, sizeof(uint8_t))) {
  ------------------
  |  Branch (649:11): [True: 1, False: 18.1k]
  ------------------
  650|      1|        ctx->error = CMP_ERROR_DATA_READING;
  651|      1|        return false;
  652|      1|      }
  653|  18.1k|      return true;
  654|  18.1k|    }
  655|    455|    case CMP_TYPE_UINT16: {
  ------------------
  |  Branch (655:5): [True: 455, False: 146k]
  ------------------
  656|    455|      if (!ctx->read(ctx, &obj->as.u16, sizeof(uint16_t))) {
  ------------------
  |  Branch (656:11): [True: 31, False: 424]
  ------------------
  657|     31|        ctx->error = CMP_ERROR_DATA_READING;
  658|     31|        return false;
  659|     31|      }
  660|    424|      obj->as.u16 = be16(obj->as.u16);
  661|    424|      return true;
  662|    455|    }
  663|    450|    case CMP_TYPE_UINT32: {
  ------------------
  |  Branch (663:5): [True: 450, False: 146k]
  ------------------
  664|    450|      if (!ctx->read(ctx, &obj->as.u32, sizeof(uint32_t))) {
  ------------------
  |  Branch (664:11): [True: 137, False: 313]
  ------------------
  665|    137|        ctx->error = CMP_ERROR_DATA_READING;
  666|    137|        return false;
  667|    137|      }
  668|    313|      obj->as.u32 = be32(obj->as.u32);
  669|    313|      return true;
  670|    450|    }
  671|    127|    case CMP_TYPE_UINT64: {
  ------------------
  |  Branch (671:5): [True: 127, False: 146k]
  ------------------
  672|    127|      if (!ctx->read(ctx, &obj->as.u64, sizeof(uint64_t))) {
  ------------------
  |  Branch (672:11): [True: 32, False: 95]
  ------------------
  673|     32|        ctx->error = CMP_ERROR_DATA_READING;
  674|     32|        return false;
  675|     32|      }
  676|     95|      obj->as.u64 = be64(obj->as.u64);
  677|     95|      return true;
  678|    127|    }
  679|    125|    case CMP_TYPE_SINT8: {
  ------------------
  |  Branch (679:5): [True: 125, False: 146k]
  ------------------
  680|    125|      if (!ctx->read(ctx, &obj->as.s8, sizeof(int8_t))) {
  ------------------
  |  Branch (680:11): [True: 2, False: 123]
  ------------------
  681|      2|        ctx->error = CMP_ERROR_DATA_READING;
  682|      2|        return false;
  683|      2|      }
  684|    123|      return true;
  685|    125|    }
  686|     90|    case CMP_TYPE_SINT16: {
  ------------------
  |  Branch (686:5): [True: 90, False: 147k]
  ------------------
  687|     90|      if (!ctx->read(ctx, &obj->as.s16, sizeof(int16_t))) {
  ------------------
  |  Branch (687:11): [True: 3, False: 87]
  ------------------
  688|      3|        ctx->error = CMP_ERROR_DATA_READING;
  689|      3|        return false;
  690|      3|      }
  691|     87|      obj->as.s16 = sbe16(obj->as.s16);
  692|     87|      return true;
  693|     90|    }
  694|    121|    case CMP_TYPE_SINT32: {
  ------------------
  |  Branch (694:5): [True: 121, False: 146k]
  ------------------
  695|    121|      if (!ctx->read(ctx, &obj->as.s32, sizeof(int32_t))) {
  ------------------
  |  Branch (695:11): [True: 3, False: 118]
  ------------------
  696|      3|        ctx->error = CMP_ERROR_DATA_READING;
  697|      3|        return false;
  698|      3|      }
  699|    118|      obj->as.s32 = sbe32(obj->as.s32);
  700|    118|      return true;
  701|    121|    }
  702|     42|    case CMP_TYPE_SINT64: {
  ------------------
  |  Branch (702:5): [True: 42, False: 147k]
  ------------------
  703|     42|      if (!ctx->read(ctx, &obj->as.s64, sizeof(int64_t))) {
  ------------------
  |  Branch (703:11): [True: 6, False: 36]
  ------------------
  704|      6|        ctx->error = CMP_ERROR_DATA_READING;
  705|      6|        return false;
  706|      6|      }
  707|     36|      obj->as.s64 = sbe64(obj->as.s64);
  708|     36|      return true;
  709|     42|    }
  710|    178|    case CMP_TYPE_FLOAT: {
  ------------------
  |  Branch (710:5): [True: 178, False: 146k]
  ------------------
  711|       |#ifndef CMP_NO_FLOAT
  712|       |      char bytes[4];
  713|       |
  714|       |      if (!ctx->read(ctx, bytes, 4)) {
  715|       |        ctx->error = CMP_ERROR_DATA_READING;
  716|       |        return false;
  717|       |      }
  718|       |      obj->as.flt = decode_befloat(bytes);
  719|       |      return true;
  720|       |#else /* CMP_NO_FLOAT */
  721|    178|      ctx->error = CMP_ERROR_DISABLED_FLOATING_POINT;
  722|    178|      return false;
  723|     42|#endif /* CMP_NO_FLOAT */
  724|     42|    }
  725|    128|    case CMP_TYPE_DOUBLE: {
  ------------------
  |  Branch (725:5): [True: 128, False: 146k]
  ------------------
  726|       |#ifndef CMP_NO_FLOAT
  727|       |      char bytes[8];
  728|       |
  729|       |      if (!ctx->read(ctx, bytes, 8)) {
  730|       |        ctx->error = CMP_ERROR_DATA_READING;
  731|       |        return false;
  732|       |      }
  733|       |      obj->as.dbl = decode_bedouble(bytes);
  734|       |      return true;
  735|       |#else /* CMP_NO_FLOAT */
  736|    128|      ctx->error = CMP_ERROR_DISABLED_FLOATING_POINT;
  737|    128|      return false;
  738|     42|#endif /* CMP_NO_FLOAT */
  739|     42|    }
  740|  2.00k|    case CMP_TYPE_BIN8:
  ------------------
  |  Branch (740:5): [True: 2.00k, False: 145k]
  ------------------
  741|  2.21k|    case CMP_TYPE_BIN16:
  ------------------
  |  Branch (741:5): [True: 206, False: 146k]
  ------------------
  742|  14.9k|    case CMP_TYPE_BIN32:
  ------------------
  |  Branch (742:5): [True: 12.7k, False: 134k]
  ------------------
  743|  14.9k|      return read_type_size(ctx, type_marker, obj->type, &obj->as.bin_size);
  744|    283|    case CMP_TYPE_FIXSTR:
  ------------------
  |  Branch (744:5): [True: 283, False: 146k]
  ------------------
  745|    337|    case CMP_TYPE_STR8:
  ------------------
  |  Branch (745:5): [True: 54, False: 147k]
  ------------------
  746|    410|    case CMP_TYPE_STR16:
  ------------------
  |  Branch (746:5): [True: 73, False: 147k]
  ------------------
  747|    452|    case CMP_TYPE_STR32:
  ------------------
  |  Branch (747:5): [True: 42, False: 147k]
  ------------------
  748|    452|      return read_type_size(ctx, type_marker, obj->type, &obj->as.str_size);
  749|  68.7k|    case CMP_TYPE_FIXARRAY:
  ------------------
  |  Branch (749:5): [True: 68.7k, False: 78.3k]
  ------------------
  750|  68.9k|    case CMP_TYPE_ARRAY16:
  ------------------
  |  Branch (750:5): [True: 157, False: 146k]
  ------------------
  751|  68.9k|    case CMP_TYPE_ARRAY32:
  ------------------
  |  Branch (751:5): [True: 55, False: 147k]
  ------------------
  752|  68.9k|      return read_type_size(ctx, type_marker, obj->type, &obj->as.array_size);
  753|    236|    case CMP_TYPE_FIXMAP:
  ------------------
  |  Branch (753:5): [True: 236, False: 146k]
  ------------------
  754|    329|    case CMP_TYPE_MAP16:
  ------------------
  |  Branch (754:5): [True: 93, False: 147k]
  ------------------
  755|    404|    case CMP_TYPE_MAP32:
  ------------------
  |  Branch (755:5): [True: 75, False: 147k]
  ------------------
  756|    404|      return read_type_size(ctx, type_marker, obj->type, &obj->as.map_size);
  757|     90|    case CMP_TYPE_FIXEXT1: {
  ------------------
  |  Branch (757:5): [True: 90, False: 147k]
  ------------------
  758|     90|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (758:11): [True: 3, False: 87]
  ------------------
  759|      3|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  760|      3|        return false;
  761|      3|      }
  762|     87|      obj->as.ext.size = 1;
  763|     87|      return true;
  764|     90|    }
  765|     33|    case CMP_TYPE_FIXEXT2: {
  ------------------
  |  Branch (765:5): [True: 33, False: 147k]
  ------------------
  766|     33|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (766:11): [True: 2, False: 31]
  ------------------
  767|      2|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  768|      2|        return false;
  769|      2|      }
  770|     31|      obj->as.ext.size = 2;
  771|     31|      return true;
  772|     33|    }
  773|     64|    case CMP_TYPE_FIXEXT4: {
  ------------------
  |  Branch (773:5): [True: 64, False: 147k]
  ------------------
  774|     64|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (774:11): [True: 23, False: 41]
  ------------------
  775|     23|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  776|     23|        return false;
  777|     23|      }
  778|     41|      obj->as.ext.size = 4;
  779|     41|      return true;
  780|     64|    }
  781|     65|    case CMP_TYPE_FIXEXT8: {
  ------------------
  |  Branch (781:5): [True: 65, False: 147k]
  ------------------
  782|     65|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (782:11): [True: 3, False: 62]
  ------------------
  783|      3|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  784|      3|        return false;
  785|      3|      }
  786|     62|      obj->as.ext.size = 8;
  787|     62|      return true;
  788|     65|    }
  789|    215|    case CMP_TYPE_FIXEXT16: {
  ------------------
  |  Branch (789:5): [True: 215, False: 146k]
  ------------------
  790|    215|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (790:11): [True: 2, False: 213]
  ------------------
  791|      2|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  792|      2|        return false;
  793|      2|      }
  794|    213|      obj->as.ext.size = 16;
  795|    213|      return true;
  796|    215|    }
  797|    108|    case CMP_TYPE_EXT8: {
  ------------------
  |  Branch (797:5): [True: 108, False: 147k]
  ------------------
  798|    108|      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
  ------------------
  |  Branch (798:11): [True: 3, False: 105]
  ------------------
  799|      3|        return false;
  800|      3|      }
  801|    105|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (801:11): [True: 4, False: 101]
  ------------------
  802|      4|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  803|      4|        return false;
  804|      4|      }
  805|    101|      return true;
  806|    105|    }
  807|     58|    case CMP_TYPE_EXT16: {
  ------------------
  |  Branch (807:5): [True: 58, False: 147k]
  ------------------
  808|     58|      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
  ------------------
  |  Branch (808:11): [True: 21, False: 37]
  ------------------
  809|     21|        return false;
  810|     21|      }
  811|     37|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (811:11): [True: 6, False: 31]
  ------------------
  812|      6|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  813|      6|        return false;
  814|      6|      }
  815|     31|      return true;
  816|     37|    }
  817|    106|    case CMP_TYPE_EXT32: {
  ------------------
  |  Branch (817:5): [True: 106, False: 147k]
  ------------------
  818|    106|      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
  ------------------
  |  Branch (818:11): [True: 35, False: 71]
  ------------------
  819|     35|        return false;
  820|     35|      }
  821|     71|      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
  ------------------
  |  Branch (821:11): [True: 1, False: 70]
  ------------------
  822|      1|        ctx->error = CMP_ERROR_EXT_TYPE_READING;
  823|      1|        return false;
  824|      1|      }
  825|     70|      return true;
  826|     71|    }
  827|      0|    default:
  ------------------
  |  Branch (827:5): [True: 0, False: 147k]
  ------------------
  828|      0|      break;
  829|   147k|  }
  830|       |
  831|      0|  ctx->error = CMP_ERROR_INVALID_TYPE;
  832|      0|  return false;
  833|   147k|}
cmp.c:read_type_size:
  412|  85.0k|                                           uint32_t *size) {
  413|  85.0k|  uint8_t u8temp = 0;
  414|  85.0k|  uint16_t u16temp = 0;
  415|  85.0k|  uint32_t u32temp = 0;
  416|       |
  417|  85.0k|  switch (cmp_type) {
  418|      0|    case CMP_TYPE_POSITIVE_FIXNUM: {
  ------------------
  |  Branch (418:5): [True: 0, False: 85.0k]
  ------------------
  419|      0|      *size = 0;
  420|      0|      return true;
  421|      0|    }
  422|    236|    case CMP_TYPE_FIXMAP: {
  ------------------
  |  Branch (422:5): [True: 236, False: 84.8k]
  ------------------
  423|    236|      *size = type_marker & FIXMAP_SIZE;
  424|    236|      return true;
  425|      0|    }
  426|  68.7k|    case CMP_TYPE_FIXARRAY: {
  ------------------
  |  Branch (426:5): [True: 68.7k, False: 16.3k]
  ------------------
  427|  68.7k|      *size = type_marker & FIXARRAY_SIZE;
  428|  68.7k|      return true;
  429|      0|    }
  430|    283|    case CMP_TYPE_FIXSTR: {
  ------------------
  |  Branch (430:5): [True: 283, False: 84.8k]
  ------------------
  431|    283|      *size = type_marker & FIXSTR_SIZE;
  432|    283|      return true;
  433|      0|    }
  434|      0|    case CMP_TYPE_NIL: {
  ------------------
  |  Branch (434:5): [True: 0, False: 85.0k]
  ------------------
  435|      0|      *size = 0;
  436|      0|      return true;
  437|      0|    }
  438|      0|    case CMP_TYPE_BOOLEAN: {
  ------------------
  |  Branch (438:5): [True: 0, False: 85.0k]
  ------------------
  439|      0|      *size = 0;
  440|      0|      return true;
  441|      0|    }
  442|  2.00k|    case CMP_TYPE_BIN8: {
  ------------------
  |  Branch (442:5): [True: 2.00k, False: 83.0k]
  ------------------
  443|  2.00k|      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
  ------------------
  |  Branch (443:11): [True: 2, False: 2.00k]
  ------------------
  444|      2|        ctx->error = CMP_ERROR_LENGTH_READING;
  445|      2|        return false;
  446|      2|      }
  447|  2.00k|      *size = u8temp;
  448|  2.00k|      return true;
  449|  2.00k|    }
  450|    206|    case CMP_TYPE_BIN16: {
  ------------------
  |  Branch (450:5): [True: 206, False: 84.8k]
  ------------------
  451|    206|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (451:11): [True: 1, False: 205]
  ------------------
  452|      1|        ctx->error = CMP_ERROR_LENGTH_READING;
  453|      1|        return false;
  454|      1|      }
  455|    205|      *size = be16(u16temp);
  456|    205|      return true;
  457|    206|    }
  458|  12.7k|    case CMP_TYPE_BIN32: {
  ------------------
  |  Branch (458:5): [True: 12.7k, False: 72.3k]
  ------------------
  459|  12.7k|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (459:11): [True: 2.18k, False: 10.5k]
  ------------------
  460|  2.18k|        ctx->error = CMP_ERROR_LENGTH_READING;
  461|  2.18k|        return false;
  462|  2.18k|      }
  463|  10.5k|      *size = be32(u32temp);
  464|  10.5k|      return true;
  465|  12.7k|    }
  466|    108|    case CMP_TYPE_EXT8: {
  ------------------
  |  Branch (466:5): [True: 108, False: 84.9k]
  ------------------
  467|    108|      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
  ------------------
  |  Branch (467:11): [True: 3, False: 105]
  ------------------
  468|      3|        ctx->error = CMP_ERROR_LENGTH_READING;
  469|      3|        return false;
  470|      3|      }
  471|    105|      *size = u8temp;
  472|    105|      return true;
  473|    108|    }
  474|     58|    case CMP_TYPE_EXT16: {
  ------------------
  |  Branch (474:5): [True: 58, False: 85.0k]
  ------------------
  475|     58|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (475:11): [True: 21, False: 37]
  ------------------
  476|     21|        ctx->error = CMP_ERROR_LENGTH_READING;
  477|     21|        return false;
  478|     21|      }
  479|     37|      *size = be16(u16temp);
  480|     37|      return true;
  481|     58|    }
  482|    106|    case CMP_TYPE_EXT32: {
  ------------------
  |  Branch (482:5): [True: 106, False: 84.9k]
  ------------------
  483|    106|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (483:11): [True: 35, False: 71]
  ------------------
  484|     35|        ctx->error = CMP_ERROR_LENGTH_READING;
  485|     35|        return false;
  486|     35|      }
  487|     71|      *size = be32(u32temp);
  488|     71|      return true;
  489|    106|    }
  490|      0|    case CMP_TYPE_FLOAT: {
  ------------------
  |  Branch (490:5): [True: 0, False: 85.0k]
  ------------------
  491|      0|      *size = 4;
  492|      0|      return true;
  493|    106|    }
  494|      0|    case CMP_TYPE_DOUBLE: {
  ------------------
  |  Branch (494:5): [True: 0, False: 85.0k]
  ------------------
  495|      0|      *size = 8;
  496|      0|      return true;
  497|    106|    }
  498|      0|    case CMP_TYPE_UINT8: {
  ------------------
  |  Branch (498:5): [True: 0, False: 85.0k]
  ------------------
  499|      0|      *size = 1;
  500|      0|      return true;
  501|    106|    }
  502|      0|    case CMP_TYPE_UINT16: {
  ------------------
  |  Branch (502:5): [True: 0, False: 85.0k]
  ------------------
  503|      0|      *size = 2;
  504|      0|      return true;
  505|    106|    }
  506|      0|    case CMP_TYPE_UINT32: {
  ------------------
  |  Branch (506:5): [True: 0, False: 85.0k]
  ------------------
  507|      0|      *size = 4;
  508|      0|      return true;
  509|    106|    }
  510|      0|    case CMP_TYPE_UINT64: {
  ------------------
  |  Branch (510:5): [True: 0, False: 85.0k]
  ------------------
  511|      0|      *size = 8;
  512|      0|      return true;
  513|    106|    }
  514|      0|    case CMP_TYPE_SINT8: {
  ------------------
  |  Branch (514:5): [True: 0, False: 85.0k]
  ------------------
  515|      0|      *size = 1;
  516|      0|      return true;
  517|    106|    }
  518|      0|    case CMP_TYPE_SINT16: {
  ------------------
  |  Branch (518:5): [True: 0, False: 85.0k]
  ------------------
  519|      0|      *size = 2;
  520|      0|      return true;
  521|    106|    }
  522|      0|    case CMP_TYPE_SINT32: {
  ------------------
  |  Branch (522:5): [True: 0, False: 85.0k]
  ------------------
  523|      0|      *size = 4;
  524|      0|      return true;
  525|    106|    }
  526|      0|    case CMP_TYPE_SINT64: {
  ------------------
  |  Branch (526:5): [True: 0, False: 85.0k]
  ------------------
  527|      0|      *size = 8;
  528|      0|      return true;
  529|    106|    }
  530|      0|    case CMP_TYPE_FIXEXT1: {
  ------------------
  |  Branch (530:5): [True: 0, False: 85.0k]
  ------------------
  531|      0|      *size = 1;
  532|      0|      return true;
  533|    106|    }
  534|      0|    case CMP_TYPE_FIXEXT2: {
  ------------------
  |  Branch (534:5): [True: 0, False: 85.0k]
  ------------------
  535|      0|      *size = 2;
  536|      0|      return true;
  537|    106|    }
  538|      0|    case CMP_TYPE_FIXEXT4: {
  ------------------
  |  Branch (538:5): [True: 0, False: 85.0k]
  ------------------
  539|      0|      *size = 4;
  540|      0|      return true;
  541|    106|    }
  542|      0|    case CMP_TYPE_FIXEXT8: {
  ------------------
  |  Branch (542:5): [True: 0, False: 85.0k]
  ------------------
  543|      0|      *size = 8;
  544|      0|      return true;
  545|    106|    }
  546|      0|    case CMP_TYPE_FIXEXT16: {
  ------------------
  |  Branch (546:5): [True: 0, False: 85.0k]
  ------------------
  547|      0|      *size = 16;
  548|      0|      return true;
  549|    106|    }
  550|     54|    case CMP_TYPE_STR8: {
  ------------------
  |  Branch (550:5): [True: 54, False: 85.0k]
  ------------------
  551|     54|      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
  ------------------
  |  Branch (551:11): [True: 3, False: 51]
  ------------------
  552|      3|        ctx->error = CMP_ERROR_DATA_READING;
  553|      3|        return false;
  554|      3|      }
  555|     51|      *size = u8temp;
  556|     51|      return true;
  557|     54|    }
  558|     73|    case CMP_TYPE_STR16: {
  ------------------
  |  Branch (558:5): [True: 73, False: 85.0k]
  ------------------
  559|     73|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (559:11): [True: 1, False: 72]
  ------------------
  560|      1|        ctx->error = CMP_ERROR_DATA_READING;
  561|      1|        return false;
  562|      1|      }
  563|     72|      *size = be16(u16temp);
  564|     72|      return true;
  565|     73|    }
  566|     42|    case CMP_TYPE_STR32: {
  ------------------
  |  Branch (566:5): [True: 42, False: 85.0k]
  ------------------
  567|     42|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (567:11): [True: 3, False: 39]
  ------------------
  568|      3|        ctx->error = CMP_ERROR_DATA_READING;
  569|      3|        return false;
  570|      3|      }
  571|     39|      *size = be32(u32temp);
  572|     39|      return true;
  573|     42|    }
  574|    157|    case CMP_TYPE_ARRAY16: {
  ------------------
  |  Branch (574:5): [True: 157, False: 84.9k]
  ------------------
  575|    157|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (575:11): [True: 75, False: 82]
  ------------------
  576|     75|        ctx->error = CMP_ERROR_DATA_READING;
  577|     75|        return false;
  578|     75|      }
  579|     82|      *size = be16(u16temp);
  580|     82|      return true;
  581|    157|    }
  582|     55|    case CMP_TYPE_ARRAY32: {
  ------------------
  |  Branch (582:5): [True: 55, False: 85.0k]
  ------------------
  583|     55|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (583:11): [True: 8, False: 47]
  ------------------
  584|      8|        ctx->error = CMP_ERROR_DATA_READING;
  585|      8|        return false;
  586|      8|      }
  587|     47|      *size = be32(u32temp);
  588|     47|      return true;
  589|     55|    }
  590|     93|    case CMP_TYPE_MAP16: {
  ------------------
  |  Branch (590:5): [True: 93, False: 84.9k]
  ------------------
  591|     93|      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
  ------------------
  |  Branch (591:11): [True: 3, False: 90]
  ------------------
  592|      3|        ctx->error = CMP_ERROR_DATA_READING;
  593|      3|        return false;
  594|      3|      }
  595|     90|      *size = be16(u16temp);
  596|     90|      return true;
  597|     93|    }
  598|     75|    case CMP_TYPE_MAP32: {
  ------------------
  |  Branch (598:5): [True: 75, False: 85.0k]
  ------------------
  599|     75|      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
  ------------------
  |  Branch (599:11): [True: 11, False: 64]
  ------------------
  600|     11|        ctx->error = CMP_ERROR_DATA_READING;
  601|     11|        return false;
  602|     11|      }
  603|     64|      *size = be32(u32temp);
  604|     64|      return true;
  605|     75|    }
  606|      0|    case CMP_TYPE_NEGATIVE_FIXNUM: {
  ------------------
  |  Branch (606:5): [True: 0, False: 85.0k]
  ------------------
  607|      0|      *size = 0;
  608|      0|      return true;
  609|     75|    }
  610|      0|    default: {
  ------------------
  |  Branch (610:5): [True: 0, False: 85.0k]
  ------------------
  611|      0|      ctx->error = CMP_ERROR_INVALID_TYPE;
  612|      0|      return false;
  613|     75|    }
  614|  85.0k|  }
  615|  85.0k|}

dht_get_self_public_key:
  147|  7.46k|{
  148|  7.46k|    return dht->self_public_key;
  149|  7.46k|}
dht_get_self_secret_key:
  151|  12.6k|{
  152|  12.6k|    return dht->self_secret_key;
  153|  12.6k|}
dht_get_net:
  165|  53.5k|{
  166|  53.5k|    return dht->net;
  167|  53.5k|}
id_closest:
  221|     70|{
  222|  2.31k|    for (size_t i = 0; i < CRYPTO_PUBLIC_KEY_SIZE; ++i) {
  ------------------
  |  |   43|  2.31k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (222:24): [True: 2.24k, False: 70]
  ------------------
  223|  2.24k|        const uint8_t distance1 = pk[i] ^ pk1[i];
  224|  2.24k|        const uint8_t distance2 = pk[i] ^ pk2[i];
  225|       |
  226|  2.24k|        if (distance1 < distance2) {
  ------------------
  |  Branch (226:13): [True: 0, False: 2.24k]
  ------------------
  227|      0|            return 1;
  228|      0|        }
  229|       |
  230|  2.24k|        if (distance1 > distance2) {
  ------------------
  |  Branch (230:13): [True: 0, False: 2.24k]
  ------------------
  231|      0|            return 2;
  232|      0|        }
  233|  2.24k|    }
  234|       |
  235|     70|    return 0;
  236|     70|}
packed_node_size:
  355|  7.38k|{
  356|  7.38k|    if (net_family_is_ipv4(ip_family) || net_family_is_tcp_ipv4(ip_family)) {
  ------------------
  |  Branch (356:9): [True: 1.84k, False: 5.53k]
  |  Branch (356:42): [True: 0, False: 5.53k]
  ------------------
  357|  1.84k|        return PACKED_NODE_SIZE_IP4;
  ------------------
  |  |   71|  1.84k|#define PACKED_NODE_SIZE_IP4 (1 + SIZE_IP4 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |  185|  1.84k|#define SIZE_IP4 4
  |  |  ------------------
  |  |               #define PACKED_NODE_SIZE_IP4 (1 + SIZE_IP4 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   43|  1.84k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  358|  1.84k|    }
  359|       |
  360|  5.53k|    if (net_family_is_ipv6(ip_family) || net_family_is_tcp_ipv6(ip_family)) {
  ------------------
  |  Branch (360:9): [True: 1.84k, False: 3.69k]
  |  Branch (360:42): [True: 3.69k, False: 0]
  ------------------
  361|  5.53k|        return PACKED_NODE_SIZE_IP6;
  ------------------
  |  |   72|  5.53k|#define PACKED_NODE_SIZE_IP6 (1 + SIZE_IP6 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |  186|  5.53k|#define SIZE_IP6 16
  |  |  ------------------
  |  |               #define PACKED_NODE_SIZE_IP6 (1 + SIZE_IP6 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
  |  |  ------------------
  |  |  |  |   43|  5.53k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  362|  5.53k|    }
  363|       |
  364|      0|    return -1;
  365|  5.53k|}
pack_nodes:
  416|  2.17k|{
  417|  2.17k|    const uint32_t size = bin_pack_obj_array_b_size(bin_pack_node_handler, nodes, number, logger);
  418|  2.17k|    if (!bin_pack_obj_array_b(bin_pack_node_handler, nodes, number, logger, data, length)) {
  ------------------
  |  Branch (418:9): [True: 0, False: 2.17k]
  ------------------
  419|      0|        return -1;
  420|      0|    }
  421|  2.17k|    return size;
  422|  2.17k|}
unpack_nodes:
  426|  2.38k|{
  427|  2.38k|    uint32_t num = 0;
  428|  2.38k|    uint32_t len_processed = 0;
  429|       |
  430|  21.6k|    while (num < max_num_nodes && len_processed < length) {
  ------------------
  |  Branch (430:12): [True: 21.0k, False: 643]
  |  Branch (430:35): [True: 20.2k, False: 708]
  ------------------
  431|  20.2k|        const int ipp_size = unpack_ip_port(&nodes[num].ip_port, data + len_processed, length - len_processed, tcp_enabled);
  432|       |
  433|  20.2k|        if (ipp_size == -1) {
  ------------------
  |  Branch (433:13): [True: 913, False: 19.3k]
  ------------------
  434|    913|            break;
  435|    913|        }
  436|       |
  437|  19.3k|        len_processed += ipp_size;
  438|       |
  439|  19.3k|        if (len_processed + CRYPTO_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |   43|  19.3k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (439:13): [True: 119, False: 19.2k]
  ------------------
  440|    119|            return -1;
  441|    119|        }
  442|       |
  443|  19.2k|        memcpy(nodes[num].public_key, data + len_processed, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|  19.2k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  444|  19.2k|        len_processed += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   43|  19.2k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  445|  19.2k|        ++num;
  446|       |
  447|  19.2k|#ifndef NDEBUG
  448|  19.2k|        const uint32_t increment = ipp_size + CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   43|  19.2k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  449|  19.2k|        assert(increment == PACKED_NODE_SIZE_IP4 || increment == PACKED_NODE_SIZE_IP6);
  450|  19.2k|#endif /* NDEBUG */
  451|  19.2k|    }
  452|       |
  453|  2.26k|    if (num == 0 && max_num_nodes > 0 && length > 0) {
  ------------------
  |  Branch (453:9): [True: 392, False: 1.87k]
  |  Branch (453:21): [True: 392, False: 0]
  |  Branch (453:42): [True: 391, False: 1]
  ------------------
  454|    391|        return -1;
  455|    391|    }
  456|       |
  457|  1.87k|    if (processed_data_len != nullptr) {
  ------------------
  |  |   63|  1.87k|#define nullptr NULL
  ------------------
  |  Branch (457:9): [True: 245, False: 1.62k]
  ------------------
  458|    245|        *processed_data_len = len_processed;
  459|    245|    }
  460|       |
  461|  1.87k|    return num;
  462|  2.26k|}
get_close_nodes:
  755|  6.30k|{
  756|  6.30k|    return get_somewhat_close_nodes(
  757|  6.30k|               dht->cur_time, public_key, nodes_list,
  758|  6.30k|               sa_family, dht->close_clientlist,
  759|  6.30k|               dht->friends_list, dht->num_friends,
  760|  6.30k|               is_lan, want_announce);
  761|  6.30k|}
dht_addfriend:
 1630|  6.30k|{
 1631|  6.30k|    const uint32_t friend_num = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);
 1632|       |
 1633|  6.30k|    if (friend_num != UINT32_MAX) { /* Is friend already in DHT? */
  ------------------
  |  Branch (1633:9): [True: 0, False: 6.30k]
  ------------------
 1634|      0|        DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
 1635|      0|        const uint32_t tmp_lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1636|       |
 1637|      0|        if (tmp_lock_token == 0) {
  ------------------
  |  Branch (1637:13): [True: 0, False: 0]
  ------------------
 1638|      0|            return -1;
 1639|      0|        }
 1640|       |
 1641|      0|        return 0;
 1642|      0|    }
 1643|       |
 1644|  6.30k|    DHT_Friend *const temp = (DHT_Friend *)mem_vrealloc(dht->mem, dht->friends_list, dht->num_friends + 1, sizeof(DHT_Friend));
 1645|       |
 1646|  6.30k|    if (temp == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
  |  Branch (1646:9): [True: 0, False: 6.30k]
  ------------------
 1647|      0|        return -1;
 1648|      0|    }
 1649|       |
 1650|  6.30k|    dht->friends_list = temp;
 1651|  6.30k|    DHT_Friend *const dht_friend = &dht->friends_list[dht->num_friends];
 1652|  6.30k|    *dht_friend = empty_dht_friend;
 1653|  6.30k|    memcpy(dht_friend->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|  6.30k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1654|       |
 1655|  6.30k|    dht_friend->nat.nat_ping_id = random_u64(dht->rng);
 1656|  6.30k|    ++dht->num_friends;
 1657|       |
 1658|  6.30k|    *lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1659|  6.30k|    assert(*lock_token != 0); // Friend was newly allocated
 1660|       |
 1661|  6.30k|    dht_friend->num_to_bootstrap = get_close_nodes(dht, dht_friend->public_key, dht_friend->to_bootstrap, net_family_unspec(),
 1662|  6.30k|                                   true, false);
 1663|       |
 1664|  6.30k|    return 0;
 1665|  6.30k|}
cryptopacket_registerhandler:
 2488|  12.6k|{
 2489|  12.6k|    dht->cryptopackethandlers[byte].function = cb;
 2490|  12.6k|    dht->cryptopackethandlers[byte].object = object;
 2491|  12.6k|}
dht_callback_nodes_response:
 2538|    615|{
 2539|    615|    dht->nodes_response_callback = function;
 2540|    615|}
new_dht:
 2569|  3.15k|{
 2570|  3.15k|    if (net == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2570:9): [True: 0, False: 3.15k]
  ------------------
 2571|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2572|      0|    }
 2573|       |
 2574|  3.15k|    DHT *const dht = (DHT *)mem_alloc(mem, sizeof(DHT));
 2575|       |
 2576|  3.15k|    if (dht == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2576:9): [True: 0, False: 3.15k]
  ------------------
 2577|      0|        LOGGER_ERROR(log, "failed to allocate DHT struct (%ld bytes)", (unsigned long)sizeof(DHT));
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2578|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2579|      0|    }
 2580|       |
 2581|  3.15k|    dht->ns = ns;
 2582|  3.15k|    dht->mono_time = mono_time;
 2583|  3.15k|    dht->cur_time = mono_time_get(mono_time);
 2584|  3.15k|    dht->log = log;
 2585|  3.15k|    dht->net = net;
 2586|  3.15k|    dht->rng = rng;
 2587|  3.15k|    dht->mem = mem;
 2588|       |
 2589|  3.15k|    dht->hole_punching_enabled = hole_punching_enabled;
 2590|  3.15k|    dht->lan_discovery_enabled = lan_discovery_enabled;
 2591|       |
 2592|  3.15k|    dht->ping = ping_new(mem, mono_time, rng, dht);
 2593|       |
 2594|  3.15k|    if (dht->ping == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2594:9): [True: 0, False: 3.15k]
  ------------------
 2595|      0|        LOGGER_ERROR(log, "failed to initialise ping");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2596|      0|        kill_dht(dht);
 2597|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2598|      0|    }
 2599|       |
 2600|  3.15k|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, &handle_nodes_request, dht);
 2601|  3.15k|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, &handle_nodes_response, dht);
 2602|  3.15k|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, &cryptopacket_handle, dht);
 2603|  3.15k|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, &handle_lan_discovery, dht);
 2604|  3.15k|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, &handle_nat_ping, dht);
  ------------------
  |  |   68|  3.15k|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
 2605|       |
 2606|  3.15k|#ifdef CHECK_ANNOUNCE_NODE
 2607|  3.15k|    networking_registerhandler(dht->net, NET_PACKET_DATA_SEARCH_RESPONSE, &handle_data_search_response, dht);
 2608|  3.15k|#endif /* CHECK_ANNOUNCE_NODE */
 2609|       |
 2610|  3.15k|    crypto_new_keypair(rng, dht->self_public_key, dht->self_secret_key);
 2611|       |
 2612|  3.15k|    dht->shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   57|  3.15k|#define KEYS_TIMEOUT 600
  ------------------
                  dht->shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|  3.15k|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2613|  3.15k|    dht->shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   57|  3.15k|#define KEYS_TIMEOUT 600
  ------------------
                  dht->shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|  3.15k|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2614|       |
 2615|  3.15k|    if (dht->shared_keys_recv == nullptr || dht->shared_keys_sent == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                  if (dht->shared_keys_recv == nullptr || dht->shared_keys_sent == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2615:9): [True: 0, False: 3.15k]
  |  Branch (2615:45): [True: 0, False: 3.15k]
  ------------------
 2616|      0|        LOGGER_ERROR(log, "failed to initialise shared key cache");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2617|      0|        kill_dht(dht);
 2618|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2619|      0|    }
 2620|       |
 2621|  3.15k|    dht->dht_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   46|  3.15k|#define DHT_PING_ARRAY_SIZE 512
  ------------------
                  dht->dht_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   43|  3.15k|#define PING_TIMEOUT 5
  ------------------
 2622|       |
 2623|  3.15k|    if (dht->dht_ping_array == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2623:9): [True: 0, False: 3.15k]
  ------------------
 2624|      0|        LOGGER_ERROR(log, "failed to initialise ping array");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2625|      0|        kill_dht(dht);
 2626|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2627|      0|    }
 2628|       |
 2629|  9.45k|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
  ------------------
  |  |   61|  9.45k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2629:26): [True: 6.30k, False: 3.15k]
  ------------------
 2630|  6.30k|        uint8_t random_public_key_bytes[CRYPTO_PUBLIC_KEY_SIZE];
 2631|  6.30k|        uint8_t random_secret_key_bytes[CRYPTO_SECRET_KEY_SIZE];
 2632|       |
 2633|  6.30k|        crypto_new_keypair(rng, random_public_key_bytes, random_secret_key_bytes);
 2634|       |
 2635|  6.30k|        uint32_t token; // We don't intend to delete these ever, but need to pass the token
 2636|  6.30k|        if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                      if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
  |  Branch (2636:13): [True: 0, False: 6.30k]
  ------------------
 2637|      0|            LOGGER_ERROR(log, "failed to add initial random seed DHT friends");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2638|      0|            kill_dht(dht);
 2639|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2640|      0|        }
 2641|  6.30k|    }
 2642|       |
 2643|  3.15k|    if (dht->num_friends != DHT_FAKE_FRIEND_NUMBER) {
  ------------------
  |  |   61|  3.15k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2643:9): [True: 0, False: 3.15k]
  ------------------
 2644|      0|        LOGGER_ERROR(log, "the RNG provided seems to be broken: it generated the same keypair twice");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2645|      0|        kill_dht(dht);
 2646|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2647|      0|    }
 2648|       |
 2649|  3.15k|    return dht;
 2650|  3.15k|}
kill_dht:
 2674|  3.15k|{
 2675|  3.15k|    if (dht == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2675:9): [True: 0, False: 3.15k]
  ------------------
 2676|      0|        return;
 2677|      0|    }
 2678|       |
 2679|  3.15k|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2680|  3.15k|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2681|  3.15k|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2682|  3.15k|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2683|  3.15k|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   68|  3.15k|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2684|       |
 2685|  3.15k|    shared_key_cache_free(dht->shared_keys_recv);
 2686|  3.15k|    shared_key_cache_free(dht->shared_keys_sent);
 2687|  3.15k|    ping_array_kill(dht->dht_ping_array);
 2688|  3.15k|    ping_kill(dht->mem, dht->ping);
 2689|  3.15k|    mem_delete(dht->mem, dht->friends_list);
 2690|  3.15k|    mem_delete(dht->mem, dht->loaded_nodes_list);
 2691|  3.15k|    crypto_memzero(dht->self_secret_key, sizeof(dht->self_secret_key));
 2692|  3.15k|    mem_delete(dht->mem, dht);
 2693|  3.15k|}
dht_size:
 2706|  1.84k|{
 2707|  1.84k|    uint32_t numv4 = 0;
 2708|  1.84k|    uint32_t numv6 = 0;
 2709|       |
 2710|  9.71k|    for (uint32_t i = 0; i < dht->loaded_num_nodes; ++i) {
  ------------------
  |  Branch (2710:26): [True: 7.86k, False: 1.84k]
  ------------------
 2711|  7.86k|        numv4 += net_family_is_ipv4(dht->loaded_nodes_list[i].ip_port.ip.family) ? 1 : 0;
  ------------------
  |  Branch (2711:18): [True: 7.33k, False: 534]
  ------------------
 2712|  7.86k|        numv6 += net_family_is_ipv6(dht->loaded_nodes_list[i].ip_port.ip.family) ? 1 : 0;
  ------------------
  |  Branch (2712:18): [True: 534, False: 7.33k]
  ------------------
 2713|  7.86k|    }
 2714|       |
 2715|  1.89M|    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
  ------------------
  |  |   35|  1.89M|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   32|  1.89M|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   31|  1.89M|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   29|  1.89M|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2715:26): [True: 1.88M, False: 1.84k]
  ------------------
 2716|  1.88M|        numv4 += dht->close_clientlist[i].assoc4.timestamp != 0 ? 1 : 0;
  ------------------
  |  Branch (2716:18): [True: 0, False: 1.88M]
  ------------------
 2717|  1.88M|        numv6 += dht->close_clientlist[i].assoc6.timestamp != 0 ? 1 : 0;
  ------------------
  |  Branch (2717:18): [True: 0, False: 1.88M]
  ------------------
 2718|  1.88M|    }
 2719|       |
 2720|  5.53k|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER && i < dht->num_friends; ++i) {
  ------------------
  |  |   61|  11.0k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2720:26): [True: 3.69k, False: 1.84k]
  |  Branch (2720:56): [True: 3.69k, False: 0]
  ------------------
 2721|  3.69k|        const DHT_Friend *const fr = &dht->friends_list[i];
 2722|       |
 2723|  33.2k|        for (uint32_t j = 0; j < MAX_FRIEND_CLIENTS; ++j) {
  ------------------
  |  |   29|  33.2k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  |  Branch (2723:30): [True: 29.5k, False: 3.69k]
  ------------------
 2724|  29.5k|            numv4 += fr->client_list[j].assoc4.timestamp != 0 ? 1 : 0;
  ------------------
  |  Branch (2724:22): [True: 0, False: 29.5k]
  ------------------
 2725|  29.5k|            numv6 += fr->client_list[j].assoc6.timestamp != 0 ? 1 : 0;
  ------------------
  |  Branch (2725:22): [True: 0, False: 29.5k]
  ------------------
 2726|  29.5k|        }
 2727|  3.69k|    }
 2728|       |
 2729|  1.84k|    const uint32_t size32 = sizeof(uint32_t);
 2730|  1.84k|    const uint32_t sizesubhead = size32 * 2;
 2731|       |
 2732|  1.84k|    return size32 + sizesubhead + packed_node_size(net_family_ipv4()) * numv4 + packed_node_size(net_family_ipv6()) * numv6;
 2733|  1.84k|}
dht_save:
 2737|    615|{
 2738|    615|    host_to_lendian_bytes32(data, DHT_STATE_COOKIE_GLOBAL);
  ------------------
  |  | 2697|    615|#define DHT_STATE_COOKIE_GLOBAL 0x159000d
  ------------------
 2739|    615|    data += sizeof(uint32_t);
 2740|       |
 2741|    615|    uint8_t *const old_data = data;
 2742|       |
 2743|       |    /* get right offset. we write the actual header later. */
 2744|    615|    data = state_write_section_header(data, DHT_STATE_COOKIE_TYPE, 0, 0);
  ------------------
  |  | 2699|    615|#define DHT_STATE_COOKIE_TYPE      0x11ce
  ------------------
 2745|       |
 2746|    615|    Node_format *clients = (Node_format *)mem_valloc(dht->mem, MAX_SAVED_DHT_NODES, sizeof(Node_format));
  ------------------
  |  | 2702|    615|#define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   61|    615|#define DHT_FAKE_FRIEND_NUMBER 2
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   29|    615|#define MAX_FRIEND_CLIENTS 8
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   35|    615|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   32|    615|#define LCLIENT_LENGTH 128
  |  |  |  |  ------------------
  |  |  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   31|    615|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   29|    615|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2747|       |
 2748|    615|    if (clients == nullptr) {
  ------------------
  |  |   63|    615|#define nullptr NULL
  ------------------
  |  Branch (2748:9): [True: 0, False: 615]
  ------------------
 2749|      0|        LOGGER_ERROR(dht->log, "could not allocate %u nodes", MAX_SAVED_DHT_NODES);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2750|      0|        return;
 2751|      0|    }
 2752|       |
 2753|    615|    uint32_t num = 0;
 2754|       |
 2755|    615|    if (dht->loaded_num_nodes > 0) {
  ------------------
  |  Branch (2755:9): [True: 89, False: 526]
  ------------------
 2756|     89|        memcpy(clients, dht->loaded_nodes_list, sizeof(Node_format) * dht->loaded_num_nodes);
 2757|     89|        num += dht->loaded_num_nodes;
 2758|     89|    }
 2759|       |
 2760|   630k|    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
  ------------------
  |  |   35|   630k|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   32|   630k|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   31|   630k|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   29|   630k|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2760:26): [True: 629k, False: 615]
  ------------------
 2761|   629k|        if (dht->close_clientlist[i].assoc4.timestamp != 0) {
  ------------------
  |  Branch (2761:13): [True: 0, False: 629k]
  ------------------
 2762|      0|            memcpy(clients[num].public_key, dht->close_clientlist[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2763|      0|            clients[num].ip_port = dht->close_clientlist[i].assoc4.ip_port;
 2764|      0|            ++num;
 2765|      0|        }
 2766|       |
 2767|   629k|        if (dht->close_clientlist[i].assoc6.timestamp != 0) {
  ------------------
  |  Branch (2767:13): [True: 0, False: 629k]
  ------------------
 2768|      0|            memcpy(clients[num].public_key, dht->close_clientlist[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2769|      0|            clients[num].ip_port = dht->close_clientlist[i].assoc6.ip_port;
 2770|      0|            ++num;
 2771|      0|        }
 2772|   629k|    }
 2773|       |
 2774|  1.84k|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER && i < dht->num_friends; ++i) {
  ------------------
  |  |   61|  3.69k|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2774:26): [True: 1.23k, False: 615]
  |  Branch (2774:56): [True: 1.23k, False: 0]
  ------------------
 2775|  1.23k|        const DHT_Friend *const fr = &dht->friends_list[i];
 2776|       |
 2777|  11.0k|        for (uint32_t j = 0; j < MAX_FRIEND_CLIENTS; ++j) {
  ------------------
  |  |   29|  11.0k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  |  Branch (2777:30): [True: 9.84k, False: 1.23k]
  ------------------
 2778|  9.84k|            if (fr->client_list[j].assoc4.timestamp != 0) {
  ------------------
  |  Branch (2778:17): [True: 0, False: 9.84k]
  ------------------
 2779|      0|                memcpy(clients[num].public_key, fr->client_list[j].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2780|      0|                clients[num].ip_port = fr->client_list[j].assoc4.ip_port;
 2781|      0|                ++num;
 2782|      0|            }
 2783|       |
 2784|  9.84k|            if (fr->client_list[j].assoc6.timestamp != 0) {
  ------------------
  |  Branch (2784:17): [True: 0, False: 9.84k]
  ------------------
 2785|      0|                memcpy(clients[num].public_key, fr->client_list[j].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2786|      0|                clients[num].ip_port = fr->client_list[j].assoc6.ip_port;
 2787|      0|                ++num;
 2788|      0|            }
 2789|  9.84k|        }
 2790|  1.23k|    }
 2791|       |
 2792|    615|    state_write_section_header(
 2793|    615|        old_data, DHT_STATE_COOKIE_TYPE, pack_nodes(dht->log, data, sizeof(Node_format) * num, clients, num),
  ------------------
  |  | 2699|    615|#define DHT_STATE_COOKIE_TYPE      0x11ce
  ------------------
 2794|    615|        DHT_STATE_TYPE_NODES);
  ------------------
  |  | 2700|    615|#define DHT_STATE_TYPE_NODES       4
  ------------------
 2795|       |
 2796|    615|    mem_delete(dht->mem, clients);
 2797|    615|}
dht_load:
 2876|    851|{
 2877|    851|    const uint32_t cookie_len = sizeof(uint32_t);
 2878|       |
 2879|    851|    if (length > cookie_len) {
  ------------------
  |  Branch (2879:9): [True: 759, False: 92]
  ------------------
 2880|    759|        uint32_t data32;
 2881|    759|        lendian_bytes_to_host32(&data32, data);
 2882|       |
 2883|    759|        if (data32 == DHT_STATE_COOKIE_GLOBAL) {
  ------------------
  |  | 2697|    759|#define DHT_STATE_COOKIE_GLOBAL 0x159000d
  ------------------
  |  Branch (2883:13): [True: 741, False: 18]
  ------------------
 2884|    741|            return state_load(dht->log, dht_load_state_callback, dht, data + cookie_len,
 2885|    741|                              length - cookie_len, DHT_STATE_COOKIE_TYPE);
  ------------------
  |  | 2699|    741|#define DHT_STATE_COOKIE_TYPE      0x11ce
  ------------------
 2886|    741|        }
 2887|    759|    }
 2888|       |
 2889|    110|    return -1;
 2890|    851|}
DHT.c:bin_pack_node_handler:
  409|  7.01k|{
  410|  7.01k|    const Node_format *nodes = (const Node_format *)arr;
  411|  7.01k|    return bin_pack_ip_port(bp, logger, &nodes[index].ip_port)
  ------------------
  |  Branch (411:12): [True: 7.01k, False: 0]
  ------------------
  412|  7.01k|           && bin_pack_bin_b(bp, nodes[index].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|  7.01k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (412:15): [True: 7.01k, False: 0]
  ------------------
  413|  7.01k|}
DHT.c:get_somewhat_close_nodes:
  726|  6.30k|{
  727|  31.5k|    for (uint16_t i = 0; i < MAX_SENT_NODES; ++i) {
  ------------------
  |  |   40|  31.5k|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (727:26): [True: 25.2k, False: 6.30k]
  ------------------
  728|  25.2k|        nodes_list[i] = empty_node_format;
  729|  25.2k|    }
  730|       |
  731|  6.30k|    uint32_t num_nodes = 0;
  732|  6.30k|    get_close_nodes_inner(
  733|  6.30k|        cur_time, public_key,
  734|  6.30k|        nodes_list, &num_nodes,
  735|  6.30k|        sa_family, close_clientlist, LCLIENT_LIST,
  ------------------
  |  |   35|  6.30k|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   32|  6.30k|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   31|  6.30k|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   29|  6.30k|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  736|  6.30k|        is_lan, want_announce);
  737|       |
  738|  15.7k|    for (uint16_t i = 0; i < friends_list_size; ++i) {
  ------------------
  |  Branch (738:26): [True: 9.45k, False: 6.30k]
  ------------------
  739|  9.45k|        const DHT_Friend *dht_friend = &friends_list[i];
  740|       |
  741|  9.45k|        get_close_nodes_inner(
  742|  9.45k|            cur_time, public_key,
  743|  9.45k|            nodes_list, &num_nodes,
  744|  9.45k|            sa_family, dht_friend->client_list, MAX_FRIEND_CLIENTS,
  ------------------
  |  |   29|  9.45k|#define MAX_FRIEND_CLIENTS 8
  ------------------
  745|  9.45k|            is_lan, want_announce);
  746|  9.45k|    }
  747|       |
  748|  6.30k|    return num_nodes;
  749|  6.30k|}
DHT.c:get_close_nodes_inner:
  655|  15.7k|{
  656|  15.7k|    if (!net_family_is_ipv4(sa_family) && !net_family_is_ipv6(sa_family) && !net_family_is_unspec(sa_family)) {
  ------------------
  |  Branch (656:9): [True: 15.7k, False: 0]
  |  Branch (656:43): [True: 15.7k, False: 0]
  |  Branch (656:77): [True: 0, False: 15.7k]
  ------------------
  657|      0|        return;
  658|      0|    }
  659|       |
  660|  15.7k|    uint32_t num_nodes = *num_nodes_ptr;
  661|       |
  662|  6.54M|    for (uint32_t i = 0; i < client_list_length; ++i) {
  ------------------
  |  Branch (662:26): [True: 6.52M, False: 15.7k]
  ------------------
  663|  6.52M|        const Client_data *const client = &client_list[i];
  664|       |
  665|       |        /* node already in list? */
  666|  6.52M|        if (index_of_node_pk(nodes_list, MAX_SENT_NODES, client->public_key) != UINT32_MAX) {
  ------------------
  |  |   40|  6.52M|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (666:13): [True: 6.52M, False: 0]
  ------------------
  667|  6.52M|            continue;
  668|  6.52M|        }
  669|       |
  670|      0|        const IPPTsPng *ipptp;
  671|       |
  672|      0|        if (net_family_is_ipv4(sa_family)) {
  ------------------
  |  Branch (672:13): [True: 0, False: 0]
  ------------------
  673|      0|            ipptp = &client->assoc4;
  674|      0|        } else if (net_family_is_ipv6(sa_family)) {
  ------------------
  |  Branch (674:20): [True: 0, False: 0]
  ------------------
  675|      0|            ipptp = &client->assoc6;
  676|      0|        } else if (client->assoc4.timestamp >= client->assoc6.timestamp) {
  ------------------
  |  Branch (676:20): [True: 0, False: 0]
  ------------------
  677|      0|            ipptp = &client->assoc4;
  678|      0|        } else {
  679|      0|            ipptp = &client->assoc6;
  680|      0|        }
  681|       |
  682|       |        /* node not in a good condition? */
  683|      0|        if (assoc_timeout(cur_time, ipptp)) {
  ------------------
  |  Branch (683:13): [True: 0, False: 0]
  ------------------
  684|      0|            continue;
  685|      0|        }
  686|       |
  687|       |        /* don't send LAN ips to non LAN peers */
  688|      0|        if (ip_is_lan(&ipptp->ip_port.ip) && !is_lan) {
  ------------------
  |  Branch (688:13): [True: 0, False: 0]
  |  Branch (688:46): [True: 0, False: 0]
  ------------------
  689|      0|            continue;
  690|      0|        }
  691|       |
  692|      0|#ifdef CHECK_ANNOUNCE_NODE
  693|       |
  694|      0|        if (want_announce && !client->announce_node) {
  ------------------
  |  Branch (694:13): [True: 0, False: 0]
  |  Branch (694:30): [True: 0, False: 0]
  ------------------
  695|      0|            continue;
  696|      0|        }
  697|       |
  698|      0|#endif /* CHECK_ANNOUNCE_NODE */
  699|       |
  700|      0|        if (num_nodes < MAX_SENT_NODES) {
  ------------------
  |  |   40|      0|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (700:13): [True: 0, False: 0]
  ------------------
  701|      0|            memcpy(nodes_list[num_nodes].public_key, client->public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  702|      0|            nodes_list[num_nodes].ip_port = ipptp->ip_port;
  703|      0|            ++num_nodes;
  704|      0|        } else {
  705|       |            // TODO(zugz): this could be made significantly more efficient by
  706|       |            // using a version of add_to_list which works with a sorted list.
  707|      0|            add_to_list(nodes_list, MAX_SENT_NODES, client->public_key, &ipptp->ip_port, public_key);
  ------------------
  |  |   40|      0|#define MAX_SENT_NODES 4
  ------------------
  708|      0|        }
  709|      0|    }
  710|       |
  711|  15.7k|    *num_nodes_ptr = num_nodes;
  712|  15.7k|}
DHT.c:index_of_node_pk:
  498|  6.52M|{
  499|  6.52M|    assert(size == 0 || array != nullptr);
  500|       |
  501|  6.52M|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (501:26): [True: 6.52M, False: 0]
  ------------------
  502|  6.52M|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (502:13): [True: 6.52M, False: 0]
  ------------------
  503|  6.52M|            return i;
  504|  6.52M|        }
  505|  6.52M|    }
  506|       |
  507|      0|    return UINT32_MAX;
  508|  6.52M|}
DHT.c:index_of_friend_pk:
  484|  6.30k|{
  485|  6.30k|    assert(size == 0 || array != nullptr);
  486|       |
  487|  9.45k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (487:26): [True: 3.15k, False: 6.30k]
  ------------------
  488|  3.15k|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (488:13): [True: 0, False: 3.15k]
  ------------------
  489|      0|            return i;
  490|      0|        }
  491|  3.15k|    }
  492|       |
  493|  6.30k|    return UINT32_MAX;
  494|  6.30k|}
DHT.c:dht_friend_lock:
 1575|  6.30k|{
 1576|       |    // find first free slot
 1577|  6.30k|    uint8_t lock_num;
 1578|  6.30k|    uint32_t lock_token = 0;
 1579|  6.30k|    for (lock_num = 0; lock_num < DHT_FRIEND_MAX_LOCKS; ++lock_num) {
  ------------------
  |  |   53|  6.30k|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1579:24): [True: 6.30k, False: 0]
  ------------------
 1580|  6.30k|        lock_token = UINT32_C(1) << lock_num;
 1581|  6.30k|        if ((dht_friend->lock_flags & lock_token) == 0) {
  ------------------
  |  Branch (1581:13): [True: 6.30k, False: 0]
  ------------------
 1582|  6.30k|            break;
 1583|  6.30k|        }
 1584|  6.30k|    }
 1585|       |
 1586|       |    // One of the conditions would be enough, but static analyzers don't get that
 1587|  6.30k|    if (lock_token == 0 || lock_num == DHT_FRIEND_MAX_LOCKS) {
  ------------------
  |  |   53|  6.30k|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1587:9): [True: 0, False: 6.30k]
  |  Branch (1587:28): [True: 0, False: 6.30k]
  ------------------
 1588|      0|        return 0;
 1589|      0|    }
 1590|       |
 1591|       |    // Claim that slot
 1592|  6.30k|    dht_friend->lock_flags |= lock_token;
 1593|       |
 1594|  6.30k|    dht_friend->callbacks[lock_num].ip_callback = ip_callback;
 1595|  6.30k|    dht_friend->callbacks[lock_num].data = data;
 1596|  6.30k|    dht_friend->callbacks[lock_num].number = number;
 1597|       |
 1598|  6.30k|    return lock_token;
 1599|  6.30k|}
DHT.c:dht_load_state_callback:
 2831|    727|{
 2832|    727|    DHT *dht = (DHT *)outer;
 2833|       |
 2834|    727|    switch (type) {
 2835|    661|        case DHT_STATE_TYPE_NODES: {
  ------------------
  |  | 2700|    661|#define DHT_STATE_TYPE_NODES       4
  ------------------
  |  Branch (2835:9): [True: 661, False: 66]
  ------------------
 2836|    661|            if (length == 0) {
  ------------------
  |  Branch (2836:17): [True: 10, False: 651]
  ------------------
 2837|     10|                break;
 2838|     10|            }
 2839|       |
 2840|    651|            mem_delete(dht->mem, dht->loaded_nodes_list);
 2841|       |
 2842|       |            // Copy to loaded_clients_list
 2843|    651|            Node_format *nodes = (Node_format *)mem_valloc(dht->mem, MAX_SAVED_DHT_NODES, sizeof(Node_format));
  ------------------
  |  | 2702|    651|#define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   61|    651|#define DHT_FAKE_FRIEND_NUMBER 2
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   29|    651|#define MAX_FRIEND_CLIENTS 8
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   35|    651|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   32|    651|#define LCLIENT_LENGTH 128
  |  |  |  |  ------------------
  |  |  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   31|    651|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   29|    651|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2844|       |
 2845|    651|            if (nodes == nullptr) {
  ------------------
  |  |   63|    651|#define nullptr NULL
  ------------------
  |  Branch (2845:17): [True: 0, False: 651]
  ------------------
 2846|      0|                LOGGER_ERROR(dht->log, "could not allocate %u nodes", MAX_SAVED_DHT_NODES);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2847|      0|                dht->loaded_num_nodes = 0;
 2848|      0|                break;
 2849|      0|            }
 2850|       |
 2851|    651|            const int num = unpack_nodes(nodes, MAX_SAVED_DHT_NODES, nullptr, data, length, false);
  ------------------
  |  | 2702|    651|#define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   61|    651|#define DHT_FAKE_FRIEND_NUMBER 2
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   29|    651|#define MAX_FRIEND_CLIENTS 8
  |  |  ------------------
  |  |               #define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)
  |  |  ------------------
  |  |  |  |   35|    651|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   32|    651|#define LCLIENT_LENGTH 128
  |  |  |  |  ------------------
  |  |  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  |  |  ------------------
  |  |  |  |  |  |   31|    651|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   29|    651|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                          const int num = unpack_nodes(nodes, MAX_SAVED_DHT_NODES, nullptr, data, length, false);
  ------------------
  |  |   63|    651|#define nullptr NULL
  ------------------
 2852|       |
 2853|    651|            if (num < 0) {
  ------------------
  |  Branch (2853:17): [True: 63, False: 588]
  ------------------
 2854|       |                // Unpack error happened, we ignore it.
 2855|     63|                dht->loaded_num_nodes = 0;
 2856|    588|            } else {
 2857|    588|                dht->loaded_num_nodes = num;
 2858|    588|            }
 2859|       |
 2860|    651|            dht->loaded_nodes_list = nodes;
 2861|       |
 2862|    651|            break;
 2863|    651|        }
 2864|       |
 2865|     66|        default: {
  ------------------
  |  Branch (2865:9): [True: 66, False: 661]
  ------------------
 2866|     66|            LOGGER_ERROR(dht->log, "Load state (DHT): contains unrecognized part (len %u, type %u)",
  ------------------
  |  |   87|     66|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     66|    do {                                                                         \
  |  |  |  |   77|     66|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    132|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     66|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     66|        }                                                                        \
  |  |  |  |   80|     66|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2867|     66|                         length, type);
 2868|     66|            break;
 2869|    651|        }
 2870|    727|    }
 2871|       |
 2872|    727|    return STATE_LOAD_STATUS_CONTINUE;
 2873|    727|}

lan_discovery_init:
  413|  3.15k|{
  414|  3.15k|    return fetch_broadcast_info(mem, ns);
  415|  3.15k|}
lan_discovery_kill:
  418|  3.15k|{
  419|  3.15k|    if (broadcast == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (419:9): [True: 0, False: 3.15k]
  ------------------
  420|      0|        return;
  421|      0|    }
  422|       |
  423|  3.15k|    mem_delete(broadcast->mem, broadcast);
  424|  3.15k|}
LAN_discovery.c:fetch_broadcast_info:
  227|  3.15k|{
  228|  3.15k|    Broadcast_Info *broadcast = (Broadcast_Info *)mem_alloc(mem, sizeof(Broadcast_Info));
  229|       |
  230|  3.15k|    if (broadcast == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (230:9): [True: 0, False: 3.15k]
  ------------------
  231|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  232|      0|    }
  233|       |
  234|  3.15k|    broadcast->mem = mem;
  235|       |
  236|  3.15k|    return broadcast;
  237|  3.15k|}

getfriend_id:
   86|  5.66k|{
   87|  6.87k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (87:26): [True: 1.38k, False: 5.48k]
  ------------------
   88|  1.38k|        if (m->friendlist[i].status > 0 && pk_equal(real_pk, m->friendlist[i].real_pk)) {
  ------------------
  |  Branch (88:13): [True: 1.38k, False: 0]
  |  Branch (88:44): [True: 174, False: 1.21k]
  ------------------
   89|    174|            return i;
   90|    174|        }
   91|  1.38k|    }
   92|       |
   93|  5.48k|    return -1;
   94|  5.66k|}
m_addfriend:
  249|    132|{
  250|    132|    if (length > MAX_FRIEND_REQUEST_DATA_SIZE) {
  ------------------
  |  |   19|    132|#define MAX_FRIEND_REQUEST_DATA_SIZE (ONION_CLIENT_MAX_DATA_SIZE - 100)
  |  |  ------------------
  |  |  |  |  188|    132|#define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   42|    132|#define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   52|    132|#define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   41|    132|#define ONION_MAX_PACKET_SIZE 1400
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   50|    132|#define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   69|    132|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   47|    132|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   43|    132|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  189|    132|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  187|    132|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  186|    132|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  188|    132|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   64|    132|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   41|    132|#define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   43|    132|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   69|    132|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   43|    132|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   64|    132|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  185|    132|#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   43|    132|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|    132|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (250:9): [True: 13, False: 119]
  ------------------
  251|     13|        return FAERR_TOOLONG;
  252|     13|    }
  253|       |
  254|    119|    uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
  255|    119|    pk_copy(real_pk, address);
  256|       |
  257|    119|    if (!public_key_valid(real_pk)) {
  ------------------
  |  Branch (257:9): [True: 10, False: 109]
  ------------------
  258|     10|        return FAERR_BADCHECKSUM;
  259|     10|    }
  260|       |
  261|    109|    uint16_t check;
  262|    109|    const uint16_t checksum = data_checksum(address, FRIEND_ADDRESS_SIZE - sizeof(checksum));
  ------------------
  |  |   42|    109|#define FRIEND_ADDRESS_SIZE (CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t) + sizeof(uint16_t))
  |  |  ------------------
  |  |  |  |   43|    109|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  263|    109|    memcpy(&check, address + CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t), sizeof(check));
  ------------------
  |  |   43|    109|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  264|       |
  265|    109|    if (check != checksum) {
  ------------------
  |  Branch (265:9): [True: 0, False: 109]
  ------------------
  266|      0|        return FAERR_BADCHECKSUM;
  267|      0|    }
  268|       |
  269|    109|    if (length < 1) {
  ------------------
  |  Branch (269:9): [True: 10, False: 99]
  ------------------
  270|     10|        return FAERR_NOMESSAGE;
  271|     10|    }
  272|       |
  273|     99|    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (273:9): [True: 10, False: 89]
  ------------------
  274|     10|        return FAERR_OWNKEY;
  275|     10|    }
  276|       |
  277|     89|    const int32_t friend_id = getfriend_id(m, real_pk);
  278|       |
  279|     89|    if (friend_id != -1) {
  ------------------
  |  Branch (279:9): [True: 51, False: 38]
  ------------------
  280|     51|        if (m->friendlist[friend_id].status >= FRIEND_CONFIRMED) {
  ------------------
  |  Branch (280:13): [True: 15, False: 36]
  ------------------
  281|     15|            return FAERR_ALREADYSENT;
  282|     15|        }
  283|       |
  284|     36|        uint32_t nospam;
  285|     36|        memcpy(&nospam, address + CRYPTO_PUBLIC_KEY_SIZE, sizeof(nospam));
  ------------------
  |  |   43|     36|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  286|       |
  287|     36|        if (m->friendlist[friend_id].friendrequest_nospam == nospam) {
  ------------------
  |  Branch (287:13): [True: 19, False: 17]
  ------------------
  288|     19|            return FAERR_ALREADYSENT;
  289|     19|        }
  290|       |
  291|     17|        m->friendlist[friend_id].friendrequest_nospam = nospam;
  292|     17|        return FAERR_SETNEWNOSPAM;
  293|     36|    }
  294|       |
  295|     38|    const int32_t ret = init_new_friend(m, real_pk, FRIEND_ADDED);
  296|       |
  297|     38|    if (ret < 0) {
  ------------------
  |  Branch (297:9): [True: 0, False: 38]
  ------------------
  298|      0|        return ret;
  299|      0|    }
  300|       |
  301|     38|    m->friendlist[ret].friendrequest_timeout = FRIENDREQUEST_TIMEOUT;
  ------------------
  |  |  123|     38|#define FRIENDREQUEST_TIMEOUT 5
  ------------------
  302|     38|    memcpy(m->friendlist[ret].info, data, length);
  303|     38|    m->friendlist[ret].info_size = length;
  304|     38|    memcpy(&m->friendlist[ret].friendrequest_nospam, address + CRYPTO_PUBLIC_KEY_SIZE, sizeof(uint32_t));
  ------------------
  |  |   43|     38|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  305|       |
  306|     38|    return ret;
  307|     38|}
m_addfriend_norequest:
  310|    585|{
  311|    585|    if (!public_key_valid(real_pk)) {
  ------------------
  |  Branch (311:9): [True: 48, False: 537]
  ------------------
  312|     48|        return FAERR_BADCHECKSUM;
  313|     48|    }
  314|       |
  315|    537|    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (315:9): [True: 10, False: 527]
  ------------------
  316|     10|        return FAERR_OWNKEY;
  317|     10|    }
  318|       |
  319|    527|    return m_add_friend_contact_norequest(m, real_pk);
  320|    537|}
m_create_group_connection:
  384|     64|{
  385|     64|    random_bytes(m->rng, chat->m_group_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|     64|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  386|     64|    const int friendcon_id = new_friend_connection(m->fr_c, chat->m_group_public_key);
  387|       |
  388|     64|    if (friendcon_id == -1) {
  ------------------
  |  Branch (388:9): [True: 0, False: 64]
  ------------------
  389|      0|        return false;
  390|      0|    }
  391|       |
  392|     64|    const Friend_Conn *connection = get_conn(m->fr_c, friendcon_id);
  393|       |
  394|     64|    if (connection == nullptr) {
  ------------------
  |  |   63|     64|#define nullptr NULL
  ------------------
  |  Branch (394:9): [True: 0, False: 64]
  ------------------
  395|      0|        return false;
  396|      0|    }
  397|       |
  398|     64|    chat->friend_connection_id = friendcon_id;
  399|       |
  400|     64|    if (friend_con_connected(m->fr_c, friendcon_id) == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (400:9): [True: 0, False: 64]
  ------------------
  401|      0|        send_online_packet(m, friendcon_id);
  402|      0|    }
  403|       |
  404|     64|    const int onion_friend_number = friend_conn_get_onion_friendnum(connection);
  405|     64|    Onion_Friend *onion_friend = onion_get_friend(m->onion_c, (uint16_t)onion_friend_number);
  406|       |
  407|     64|    onion_friend_set_gc_public_key(onion_friend, get_chat_id(&chat->chat_public_key));
  408|     64|    onion_friend_set_gc_data(onion_friend, nullptr, 0);
  ------------------
  |  |   63|     64|#define nullptr NULL
  ------------------
  409|       |
  410|     64|    return true;
  411|     64|}
m_kill_group_connection:
  417|     64|{
  418|     64|    remove_request_received(m->fr, chat->m_group_public_key);
  419|       |
  420|     64|    friend_connection_callbacks(m->fr_c, chat->friend_connection_id, MESSENGER_CALLBACK_INDEX, nullptr,
  ------------------
  |  |   24|     64|#define MESSENGER_CALLBACK_INDEX 0
  ------------------
                  friend_connection_callbacks(m->fr_c, chat->friend_connection_id, MESSENGER_CALLBACK_INDEX, nullptr,
  ------------------
  |  |   63|     64|#define nullptr NULL
  ------------------
  421|     64|                                nullptr, nullptr, nullptr, 0);
  ------------------
  |  |   63|     64|#define nullptr NULL
  ------------------
                                              nullptr, nullptr, nullptr, 0);
  ------------------
  |  |   63|     64|#define nullptr NULL
  ------------------
                                              nullptr, nullptr, nullptr, 0);
  ------------------
  |  |   63|     64|#define nullptr NULL
  ------------------
  422|       |
  423|     64|    if (friend_con_connected(m->fr_c, chat->friend_connection_id) == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (423:9): [True: 0, False: 64]
  ------------------
  424|      0|        send_offline_packet(m, chat->friend_connection_id);
  425|      0|    }
  426|       |
  427|     64|    kill_friend_connection(m->fr_c, chat->friend_connection_id);
  428|     64|}
m_friend_exists:
  546|  1.50k|{
  547|  1.50k|    return (unsigned int)friendnumber < m->numfriends && m->friendlist[friendnumber].status != 0;
  ------------------
  |  Branch (547:12): [True: 1.50k, False: 0]
  |  Branch (547:58): [True: 1.50k, False: 0]
  ------------------
  548|  1.50k|}
setfriendname:
  653|    488|{
  654|    488|    if (!m_friend_exists(m, friendnumber)) {
  ------------------
  |  Branch (654:9): [True: 0, False: 488]
  ------------------
  655|      0|        return -1;
  656|      0|    }
  657|       |
  658|    488|    if (length > MAX_NAME_LENGTH || length == 0) {
  ------------------
  |  |   34|    976|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (658:9): [True: 108, False: 380]
  |  Branch (658:37): [True: 84, False: 296]
  ------------------
  659|    192|        return -1;
  660|    192|    }
  661|       |
  662|    296|    m->friendlist[friendnumber].name_length = length;
  663|    296|    memcpy(m->friendlist[friendnumber].name, name, length);
  664|    296|    return 0;
  665|    488|}
setname:
  677|    511|{
  678|    511|    if (length > MAX_NAME_LENGTH) {
  ------------------
  |  |   34|    511|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (678:9): [True: 0, False: 511]
  ------------------
  679|      0|        return -1;
  680|      0|    }
  681|       |
  682|    511|    if (m->name_length == length && (length == 0 || memcmp(name, m->name, length) == 0)) {
  ------------------
  |  Branch (682:9): [True: 319, False: 192]
  |  Branch (682:38): [True: 0, False: 319]
  |  Branch (682:53): [True: 79, False: 240]
  ------------------
  683|     79|        return 0;
  684|     79|    }
  685|       |
  686|    432|    if (length > 0) {
  ------------------
  |  Branch (686:9): [True: 432, False: 0]
  ------------------
  687|    432|        memcpy(m->name, name, length);
  688|    432|    }
  689|       |
  690|    432|    m->name_length = length;
  691|       |
  692|  1.17k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (692:26): [True: 745, False: 432]
  ------------------
  693|    745|        m->friendlist[i].name_sent = false;
  694|    745|    }
  695|       |
  696|    432|    return 0;
  697|    511|}
m_set_statusmessage:
  751|    873|{
  752|    873|    if (length > MAX_STATUSMESSAGE_LENGTH) {
  ------------------
  |  |   36|    873|#define MAX_STATUSMESSAGE_LENGTH 1007
  ------------------
  |  Branch (752:9): [True: 0, False: 873]
  ------------------
  753|      0|        return -1;
  754|      0|    }
  755|       |
  756|    873|    if (m->statusmessage_length == length && (length == 0 || memcmp(m->statusmessage, status, length) == 0)) {
  ------------------
  |  Branch (756:9): [True: 616, False: 257]
  |  Branch (756:47): [True: 0, False: 616]
  |  Branch (756:62): [True: 138, False: 478]
  ------------------
  757|    138|        return 0;
  758|    138|    }
  759|       |
  760|    735|    if (length > 0) {
  ------------------
  |  Branch (760:9): [True: 735, False: 0]
  ------------------
  761|    735|        memcpy(m->statusmessage, status, length);
  762|    735|    }
  763|       |
  764|    735|    m->statusmessage_length = length;
  765|       |
  766|  1.82k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (766:26): [True: 1.09k, False: 735]
  ------------------
  767|  1.09k|        m->friendlist[i].statusmessage_sent = false;
  768|  1.09k|    }
  769|       |
  770|    735|    return 0;
  771|    873|}
m_set_userstatus:
  805|    619|{
  806|    619|    if (status >= USERSTATUS_INVALID) {
  ------------------
  |  Branch (806:9): [True: 265, False: 354]
  ------------------
  807|    265|        return -1;
  808|    265|    }
  809|       |
  810|    354|    if (m->userstatus == status) {
  ------------------
  |  Branch (810:9): [True: 183, False: 171]
  ------------------
  811|    183|        return 0;
  812|    183|    }
  813|       |
  814|    171|    userstatus_from_int(status, &m->userstatus);
  815|       |
  816|    359|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (816:26): [True: 188, False: 171]
  ------------------
  817|    188|        m->friendlist[i].userstatus_sent = false;
  818|    188|    }
  819|       |
  820|    171|    return 0;
  821|    354|}
m_callback_friendrequest:
  981|    615|{
  982|    615|    m->friend_request = function;
  983|    615|}
m_callback_friendmessage:
  987|    615|{
  988|    615|    m->friend_message = function;
  989|    615|}
m_callback_namechange:
  992|    615|{
  993|    615|    m->friend_namechange = function;
  994|    615|}
m_callback_statusmessage:
  997|    615|{
  998|    615|    m->friend_statusmessagechange = function;
  999|    615|}
m_callback_userstatus:
 1002|    615|{
 1003|    615|    m->friend_userstatuschange = function;
 1004|    615|}
m_callback_typingchange:
 1007|    615|{
 1008|    615|    m->friend_typingchange = function;
 1009|    615|}
m_callback_read_receipt:
 1012|    615|{
 1013|    615|    m->read_receipt = function;
 1014|    615|}
m_callback_connectionstatus:
 1017|    615|{
 1018|    615|    m->friend_connectionstatuschange = function;
 1019|    615|}
m_callback_core_connection:
 1022|    615|{
 1023|    615|    m->core_connection_change = function;
 1024|    615|}
m_callback_conference_invite:
 1087|  6.30k|{
 1088|  6.30k|    m->conference_invite = function;
 1089|  6.30k|}
m_callback_group_invite:
 1093|    615|{
 1094|    615|    m->group_invite = function;
 1095|    615|}
callback_file_sendrequest:
 1120|    615|{
 1121|    615|    m->file_sendrequest = function;
 1122|    615|}
callback_file_control:
 1126|    615|{
 1127|    615|    m->file_filecontrol = function;
 1128|    615|}
callback_file_data:
 1132|    615|{
 1133|    615|    m->file_filedata = function;
 1134|    615|}
callback_file_reqchunk:
 1138|    615|{
 1139|    615|    m->file_reqchunk = function;
 1140|    615|}
custom_lossy_packet_registerhandler:
 1859|    615|{
 1860|    615|    m->lossy_packethandler = lossy_packethandler;
 1861|    615|}
custom_lossless_packet_registerhandler:
 1914|    615|{
 1915|    615|    m->lossless_packethandler = lossless_packethandler;
 1916|    615|}
m_register_state_plugin:
 2860|  28.3k|{
 2861|  28.3k|    const uint32_t new_length = m->options.state_plugins_length + 1;
 2862|  28.3k|    Messenger_State_Plugin *temp = (Messenger_State_Plugin *)mem_vrealloc(
 2863|  28.3k|                                       m->mem, m->options.state_plugins, new_length, sizeof(Messenger_State_Plugin));
 2864|       |
 2865|  28.3k|    if (temp == nullptr) {
  ------------------
  |  |   63|  28.3k|#define nullptr NULL
  ------------------
  |  Branch (2865:9): [True: 0, False: 28.3k]
  ------------------
 2866|      0|        return false;
 2867|      0|    }
 2868|       |
 2869|  28.3k|    m->options.state_plugins = temp;
 2870|  28.3k|    m->options.state_plugins_length = new_length;
 2871|       |
 2872|  28.3k|    const uint8_t index = m->options.state_plugins_length - 1;
 2873|  28.3k|    m->options.state_plugins[index].type = type;
 2874|  28.3k|    m->options.state_plugins[index].size = size_callback;
 2875|  28.3k|    m->options.state_plugins[index].load = load_callback;
 2876|  28.3k|    m->options.state_plugins[index].save = save_callback;
 2877|       |
 2878|  28.3k|    return true;
 2879|  28.3k|}
messenger_size:
 2899|  1.23k|{
 2900|  1.23k|    return m_state_plugins_size(m);
 2901|  1.23k|}
messenger_save:
 2905|    615|{
 2906|  6.15k|    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
  ------------------
  |  Branch (2906:25): [True: 5.53k, False: 615]
  ------------------
 2907|  5.53k|        const Messenger_State_Plugin plugin = m->options.state_plugins[i];
 2908|  5.53k|        data = plugin.save(m, data);
 2909|  5.53k|    }
 2910|       |
 2911|    615|    return data;
 2912|    615|}
messenger_load_state_section:
 3376|  33.7k|{
 3377|   227k|    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
  ------------------
  |  Branch (3377:25): [True: 225k, False: 1.79k]
  ------------------
 3378|   225k|        const Messenger_State_Plugin *const plugin = &m->options.state_plugins[i];
 3379|       |
 3380|   225k|        if (plugin->type == type) {
  ------------------
  |  Branch (3380:13): [True: 31.9k, False: 193k]
  ------------------
 3381|  31.9k|            *status = plugin->load(m, data, length);
 3382|  31.9k|            return true;
 3383|  31.9k|        }
 3384|   225k|    }
 3385|       |
 3386|  1.79k|    return false;
 3387|  33.7k|}
count_friendlist:
 3395|  1.84k|{
 3396|  1.84k|    uint32_t ret = 0;
 3397|       |
 3398|  2.22k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (3398:26): [True: 384, False: 1.84k]
  ------------------
 3399|    384|        if (m->friendlist[i].status > 0) {
  ------------------
  |  Branch (3399:13): [True: 384, False: 0]
  ------------------
 3400|    384|            ++ret;
 3401|    384|        }
 3402|    384|    }
 3403|       |
 3404|  1.84k|    return ret;
 3405|  1.84k|}
new_messenger:
 3458|  3.15k|{
 3459|  3.15k|    if (options == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3459:9): [True: 0, False: 3.15k]
  ------------------
 3460|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3461|      0|    }
 3462|       |
 3463|  3.15k|    if (error != nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3463:9): [True: 3.15k, False: 0]
  ------------------
 3464|  3.15k|        *error = MESSENGER_ERROR_OTHER;
 3465|  3.15k|    }
 3466|       |
 3467|  3.15k|    Messenger *m = (Messenger *)mem_alloc(mem, sizeof(Messenger));
 3468|       |
 3469|  3.15k|    if (m == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3469:9): [True: 0, False: 3.15k]
  ------------------
 3470|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3471|      0|    }
 3472|       |
 3473|  3.15k|    m->mono_time = mono_time;
 3474|  3.15k|    m->mem = mem;
 3475|  3.15k|    m->rng = rng;
 3476|  3.15k|    m->ns = ns;
 3477|       |
 3478|  3.15k|    m->fr = friendreq_new(mem);
 3479|       |
 3480|  3.15k|    if (m->fr == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3480:9): [True: 0, False: 3.15k]
  ------------------
 3481|      0|        mem_delete(mem, m);
 3482|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3483|      0|    }
 3484|       |
 3485|  3.15k|    m->log = logger_new(mem);
 3486|       |
 3487|  3.15k|    if (m->log == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3487:9): [True: 0, False: 3.15k]
  ------------------
 3488|      0|        friendreq_kill(m->fr);
 3489|      0|        mem_delete(mem, m);
 3490|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3491|      0|    }
 3492|       |
 3493|  3.15k|    logger_callback_log(m->log, options->log_callback, options->log_context, options->log_user_data);
 3494|       |
 3495|  3.15k|    unsigned int net_err = 0;
 3496|       |
 3497|  3.15k|    if (!options->udp_disabled && options->proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (3497:9): [True: 3.15k, False: 0]
  |  Branch (3497:35): [True: 0, False: 3.15k]
  ------------------
 3498|       |        // We don't currently support UDP over proxy.
 3499|      0|        LOGGER_INFO(m->log, "UDP enabled and proxy set: disabling UDP");
  ------------------
  |  |   85|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3500|      0|        options->udp_disabled = true;
 3501|      0|    }
 3502|       |
 3503|  3.15k|    if (options->udp_disabled) {
  ------------------
  |  Branch (3503:9): [True: 0, False: 3.15k]
  ------------------
 3504|      0|        m->net = new_networking_no_udp(m->log, m->mem, m->ns);
 3505|  3.15k|    } else {
 3506|  3.15k|        IP ip;
 3507|  3.15k|        ip_init(&ip, options->ipv6enabled);
 3508|  3.15k|        m->net = new_networking_ex(m->log, m->mem, m->ns, &ip, options->port_range[0], options->port_range[1], &net_err);
 3509|  3.15k|    }
 3510|       |
 3511|  3.15k|    if (m->net == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3511:9): [True: 0, False: 3.15k]
  ------------------
 3512|      0|        friendreq_kill(m->fr);
 3513|       |
 3514|      0|        if (error != nullptr && net_err == 1) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3514:13): [True: 0, False: 0]
  |  Branch (3514:33): [True: 0, False: 0]
  ------------------
 3515|      0|            LOGGER_WARNING(m->log, "network initialisation failed (no ports available)");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3516|      0|            *error = MESSENGER_ERROR_PORT;
 3517|      0|        }
 3518|       |
 3519|      0|        logger_kill(m->log);
 3520|      0|        mem_delete(mem, m);
 3521|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3522|      0|    }
 3523|       |
 3524|  3.15k|    m->dht = new_dht(m->log, m->mem, m->rng, m->ns, m->mono_time, m->net, options->hole_punching_enabled, options->local_discovery_enabled);
 3525|       |
 3526|  3.15k|    if (m->dht == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3526:9): [True: 0, False: 3.15k]
  ------------------
 3527|      0|        kill_networking(m->net);
 3528|      0|        friendreq_kill(m->fr);
 3529|      0|        logger_kill(m->log);
 3530|      0|        mem_delete(mem, m);
 3531|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3532|      0|    }
 3533|       |
 3534|  3.15k|    m->net_crypto = new_net_crypto(m->log, m->mem, m->rng, m->ns, m->mono_time, m->dht, &options->proxy_info);
 3535|       |
 3536|  3.15k|    if (m->net_crypto == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3536:9): [True: 0, False: 3.15k]
  ------------------
 3537|      0|        LOGGER_WARNING(m->log, "net_crypto initialisation failed");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3538|       |
 3539|      0|        kill_dht(m->dht);
 3540|      0|        kill_networking(m->net);
 3541|      0|        friendreq_kill(m->fr);
 3542|      0|        logger_kill(m->log);
 3543|      0|        mem_delete(mem, m);
 3544|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3545|      0|    }
 3546|       |
 3547|  3.15k|    m->group_announce = new_gca_list(m->mem);
 3548|       |
 3549|  3.15k|    if (m->group_announce == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3549:9): [True: 0, False: 3.15k]
  ------------------
 3550|      0|        LOGGER_WARNING(m->log, "DHT group chats initialisation failed");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3551|       |
 3552|      0|        kill_net_crypto(m->net_crypto);
 3553|      0|        kill_dht(m->dht);
 3554|      0|        kill_networking(m->net);
 3555|      0|        friendreq_kill(m->fr);
 3556|      0|        logger_kill(m->log);
 3557|      0|        mem_delete(mem, m);
 3558|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3559|      0|    }
 3560|       |
 3561|  3.15k|    if (options->dht_announcements_enabled) {
  ------------------
  |  Branch (3561:9): [True: 3.15k, False: 0]
  ------------------
 3562|  3.15k|        m->forwarding = new_forwarding(m->log, m->mem, m->rng, m->mono_time, m->dht);
 3563|  3.15k|        if (m->forwarding != nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3563:13): [True: 3.15k, False: 0]
  ------------------
 3564|  3.15k|            m->announce = new_announcements(m->log, m->mem, m->rng, m->mono_time, m->forwarding);
 3565|  3.15k|        } else {
 3566|      0|            m->announce = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3567|      0|        }
 3568|  3.15k|    } else {
 3569|      0|        m->forwarding = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3570|      0|        m->announce = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3571|      0|    }
 3572|       |
 3573|  3.15k|    m->onion = new_onion(m->log, m->mem, m->mono_time, m->rng, m->dht);
 3574|  3.15k|    m->onion_a = new_onion_announce(m->log, m->mem, m->rng, m->mono_time, m->dht);
 3575|  3.15k|    m->onion_c = new_onion_client(m->log, m->mem, m->rng, m->mono_time, m->net_crypto);
 3576|  3.15k|    if (m->onion_c != nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3576:9): [True: 3.15k, False: 0]
  ------------------
 3577|  3.15k|        m->fr_c = new_friend_connections(m->log, m->mem, m->mono_time, m->ns, m->onion_c, options->local_discovery_enabled);
 3578|  3.15k|    }
 3579|       |
 3580|  3.15k|    if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                  if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3580:10): [True: 3.15k, False: 0]
  |  Branch (3580:49): [True: 0, False: 3.15k]
  |  Branch (3580:77): [True: 0, False: 3.15k]
  ------------------
 3581|  3.15k|            m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3581:13): [True: 0, False: 3.15k]
  |  Branch (3581:36): [True: 0, False: 3.15k]
  |  Branch (3581:61): [True: 0, False: 3.15k]
  |  Branch (3581:86): [True: 0, False: 3.15k]
  ------------------
 3582|      0|        LOGGER_WARNING(m->log, "onion initialisation failed");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3583|       |
 3584|      0|        kill_onion(m->onion);
 3585|      0|        kill_onion_announce(m->onion_a);
 3586|      0|        kill_onion_client(m->onion_c);
 3587|      0|        kill_gca(m->group_announce);
 3588|      0|        kill_friend_connections(m->fr_c);
 3589|      0|        kill_announcements(m->announce);
 3590|      0|        kill_forwarding(m->forwarding);
 3591|      0|        kill_net_crypto(m->net_crypto);
 3592|      0|        kill_dht(m->dht);
 3593|      0|        kill_networking(m->net);
 3594|      0|        friendreq_kill(m->fr);
 3595|      0|        logger_kill(m->log);
 3596|      0|        mem_delete(mem, m);
 3597|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3598|      0|    }
 3599|       |
 3600|  3.15k|    gca_onion_init(m->group_announce, m->onion_a);
 3601|       |
 3602|  3.15k|    m->group_handler = new_dht_groupchats(m);
 3603|       |
 3604|  3.15k|    if (m->group_handler == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3604:9): [True: 0, False: 3.15k]
  ------------------
 3605|      0|        LOGGER_WARNING(m->log, "conferences initialisation failed");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3606|       |
 3607|      0|        kill_onion(m->onion);
 3608|      0|        kill_onion_announce(m->onion_a);
 3609|      0|        kill_onion_client(m->onion_c);
 3610|      0|        kill_gca(m->group_announce);
 3611|      0|        kill_friend_connections(m->fr_c);
 3612|      0|        kill_announcements(m->announce);
 3613|      0|        kill_forwarding(m->forwarding);
 3614|      0|        kill_net_crypto(m->net_crypto);
 3615|      0|        kill_dht(m->dht);
 3616|      0|        kill_networking(m->net);
 3617|      0|        friendreq_kill(m->fr);
 3618|      0|        logger_kill(m->log);
 3619|      0|        mem_delete(mem, m);
 3620|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3621|      0|    }
 3622|       |
 3623|  3.15k|    if (options->tcp_server_port != 0) {
  ------------------
  |  Branch (3623:9): [True: 0, False: 3.15k]
  ------------------
 3624|      0|        m->tcp_server = new_tcp_server(m->log, m->mem, m->rng, m->ns, options->ipv6enabled, 1,
 3625|      0|                                       &options->tcp_server_port, dht_get_self_secret_key(m->dht),
 3626|      0|                                       m->onion, m->forwarding);
 3627|       |
 3628|      0|        if (m->tcp_server == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3628:13): [True: 0, False: 0]
  ------------------
 3629|      0|            LOGGER_WARNING(m->log, "TCP server initialisation failed");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3630|       |
 3631|      0|            kill_onion(m->onion);
 3632|      0|            kill_onion_announce(m->onion_a);
 3633|      0|            kill_dht_groupchats(m->group_handler);
 3634|      0|            kill_friend_connections(m->fr_c);
 3635|      0|            kill_onion_client(m->onion_c);
 3636|      0|            kill_gca(m->group_announce);
 3637|      0|            kill_announcements(m->announce);
 3638|      0|            kill_forwarding(m->forwarding);
 3639|      0|            kill_net_crypto(m->net_crypto);
 3640|      0|            kill_dht(m->dht);
 3641|      0|            kill_networking(m->net);
 3642|      0|            friendreq_kill(m->fr);
 3643|      0|            logger_kill(m->log);
 3644|      0|            mem_delete(mem, m);
 3645|       |
 3646|      0|            if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3646:17): [True: 0, False: 0]
  ------------------
 3647|      0|                *error = MESSENGER_ERROR_TCP_SERVER;
 3648|      0|            }
 3649|       |
 3650|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3651|      0|        }
 3652|      0|    }
 3653|       |
 3654|  3.15k|    m->options = *options;
 3655|  3.15k|    friendreq_init(m->fr, m->fr_c);
 3656|  3.15k|    set_nospam(m->fr, random_u32(m->rng));
 3657|  3.15k|    set_filter_function(m->fr, &friend_already_added, m);
 3658|       |
 3659|  3.15k|    m->lastdump = 0;
 3660|  3.15k|    m->is_receiving_file = 0;
 3661|       |
 3662|  3.15k|    m_register_default_plugins(m);
 3663|  3.15k|    callback_friendrequest(m->fr, m_handle_friend_request, m);
 3664|       |
 3665|  3.15k|    if (error != nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3665:9): [True: 3.15k, False: 0]
  ------------------
 3666|  3.15k|        *error = MESSENGER_ERROR_NONE;
 3667|  3.15k|    }
 3668|       |
 3669|  3.15k|    return m;
 3670|  3.15k|}
kill_messenger:
 3677|  3.15k|{
 3678|  3.15k|    if (m == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3678:9): [True: 0, False: 3.15k]
  ------------------
 3679|      0|        return;
 3680|      0|    }
 3681|       |
 3682|  3.15k|    if (m->tcp_server != nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3682:9): [True: 0, False: 3.15k]
  ------------------
 3683|      0|        kill_tcp_server(m->tcp_server);
 3684|      0|    }
 3685|       |
 3686|  3.15k|    kill_onion(m->onion);
 3687|  3.15k|    kill_onion_announce(m->onion_a);
 3688|  3.15k|    kill_dht_groupchats(m->group_handler);
 3689|  3.15k|    kill_friend_connections(m->fr_c);
 3690|  3.15k|    kill_onion_client(m->onion_c);
 3691|  3.15k|    kill_gca(m->group_announce);
 3692|  3.15k|    kill_announcements(m->announce);
 3693|  3.15k|    kill_forwarding(m->forwarding);
 3694|  3.15k|    kill_net_crypto(m->net_crypto);
 3695|  3.15k|    kill_dht(m->dht);
 3696|  3.15k|    kill_networking(m->net);
 3697|       |
 3698|  3.67k|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (3698:26): [True: 526, False: 3.15k]
  ------------------
 3699|    526|        clear_receipts(m, i);
 3700|    526|    }
 3701|       |
 3702|  3.15k|    mem_delete(m->mem, m->friendlist);
 3703|  3.15k|    friendreq_kill(m->fr);
 3704|       |
 3705|  3.15k|    mem_delete(m->mem, m->options.state_plugins);
 3706|  3.15k|    logger_kill(m->log);
 3707|  3.15k|    mem_delete(m->mem, m);
 3708|  3.15k|}
Messenger.c:init_new_friend:
  165|    526|{
  166|    526|    if (m->numfriends == UINT32_MAX) {
  ------------------
  |  Branch (166:9): [True: 0, False: 526]
  ------------------
  167|      0|        LOGGER_ERROR(m->log, "Friend list full: we have more than 4 billion friends");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  168|       |        /* This is technically incorrect, but close enough. */
  169|      0|        return FAERR_NOMEM;
  170|      0|    }
  171|       |
  172|       |    /* Resize the friend list if necessary. */
  173|    526|    if (realloc_friendlist(m, m->numfriends + 1) != 0) {
  ------------------
  |  Branch (173:9): [True: 0, False: 526]
  ------------------
  174|      0|        return FAERR_NOMEM;
  175|      0|    }
  176|       |
  177|    526|    m->friendlist[m->numfriends] = empty_friend;
  178|       |
  179|    526|    const int friendcon_id = new_friend_connection(m->fr_c, real_pk);
  180|       |
  181|    526|    if (friendcon_id == -1) {
  ------------------
  |  Branch (181:9): [True: 0, False: 526]
  ------------------
  182|      0|        return FAERR_NOMEM;
  183|      0|    }
  184|       |
  185|  1.16k|    for (uint32_t i = 0; i <= m->numfriends; ++i) {
  ------------------
  |  Branch (185:26): [True: 1.16k, False: 0]
  ------------------
  186|  1.16k|        if (m->friendlist[i].status == NOFRIEND) {
  ------------------
  |  Branch (186:13): [True: 526, False: 642]
  ------------------
  187|    526|            m->friendlist[i].status = status;
  188|    526|            m->friendlist[i].friendcon_id = friendcon_id;
  189|    526|            m->friendlist[i].friendrequest_lastsent = 0;
  190|    526|            pk_copy(m->friendlist[i].real_pk, real_pk);
  191|    526|            m->friendlist[i].statusmessage_length = 0;
  192|    526|            m->friendlist[i].userstatus = USERSTATUS_NONE;
  193|    526|            m->friendlist[i].is_typing = false;
  194|    526|            m->friendlist[i].message_id = 0;
  195|    526|            friend_connection_callbacks(m->fr_c, friendcon_id, MESSENGER_CALLBACK_INDEX, &m_handle_status, &m_handle_packet,
  ------------------
  |  |   24|    526|#define MESSENGER_CALLBACK_INDEX 0
  ------------------
  196|    526|                                        &m_handle_lossy_packet, m, i);
  197|       |
  198|    526|            if (m->numfriends == i) {
  ------------------
  |  Branch (198:17): [True: 526, False: 0]
  ------------------
  199|    526|                ++m->numfriends;
  200|    526|            }
  201|       |
  202|    526|            if (friend_con_connected(m->fr_c, friendcon_id) == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (202:17): [True: 0, False: 526]
  ------------------
  203|      0|                send_online_packet(m, friendcon_id);
  204|      0|            }
  205|       |
  206|    526|            return i;
  207|    526|        }
  208|  1.16k|    }
  209|       |
  210|      0|    return FAERR_NOMEM;
  211|    526|}
Messenger.c:set_friend_statusmessage:
  950|    488|{
  951|    488|    if (!m_friend_exists(m, friendnumber)) {
  ------------------
  |  Branch (951:9): [True: 0, False: 488]
  ------------------
  952|      0|        return -1;
  953|      0|    }
  954|       |
  955|    488|    if (length > MAX_STATUSMESSAGE_LENGTH) {
  ------------------
  |  |   36|    488|#define MAX_STATUSMESSAGE_LENGTH 1007
  ------------------
  |  Branch (955:9): [True: 166, False: 322]
  ------------------
  956|    166|        return -1;
  957|    166|    }
  958|       |
  959|    322|    if (length > 0) {
  ------------------
  |  Branch (959:9): [True: 259, False: 63]
  ------------------
  960|    259|        memcpy(m->friendlist[friendnumber].statusmessage, status, length);
  961|    259|    }
  962|       |
  963|    322|    m->friendlist[friendnumber].statusmessage_length = length;
  964|    322|    return 0;
  965|    488|}
Messenger.c:set_friend_userstatus:
  969|    488|{
  970|    488|    userstatus_from_int(status, &m->friendlist[friendnumber].userstatus);
  971|    488|}
Messenger.c:m_add_friend_contact_norequest:
  215|    527|{
  216|    527|    if (getfriend_id(m, real_pk) != -1) {
  ------------------
  |  Branch (216:9): [True: 39, False: 488]
  ------------------
  217|     39|        return FAERR_ALREADYSENT;
  218|     39|    }
  219|       |
  220|    488|    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (220:9): [True: 0, False: 488]
  ------------------
  221|      0|        return FAERR_OWNKEY;
  222|      0|    }
  223|       |
  224|    488|    return init_new_friend(m, real_pk, FRIEND_CONFIRMED);
  225|    488|}
Messenger.c:clear_receipts:
  324|    526|{
  325|    526|    if (!m_friend_exists(m, friendnumber)) {
  ------------------
  |  Branch (325:9): [True: 0, False: 526]
  ------------------
  326|      0|        return -1;
  327|      0|    }
  328|       |
  329|    526|    struct Receipts *receipts = m->friendlist[friendnumber].receipts_start;
  330|       |
  331|    526|    while (receipts != nullptr) {
  ------------------
  |  |   63|    526|#define nullptr NULL
  ------------------
  |  Branch (331:12): [True: 0, False: 526]
  ------------------
  332|      0|        struct Receipts *temp_r = receipts->next;
  333|      0|        mem_delete(m->mem, receipts);
  334|      0|        receipts = temp_r;
  335|      0|    }
  336|       |
  337|    526|    m->friendlist[friendnumber].receipts_start = nullptr;
  ------------------
  |  |   63|    526|#define nullptr NULL
  ------------------
  338|    526|    m->friendlist[friendnumber].receipts_end = nullptr;
  ------------------
  |  |   63|    526|#define nullptr NULL
  ------------------
  339|    526|    return 0;
  340|    526|}
Messenger.c:realloc_friendlist:
   65|    526|{
   66|    526|    if (num == 0) {
  ------------------
  |  Branch (66:9): [True: 0, False: 526]
  ------------------
   67|      0|        mem_delete(m->mem, m->friendlist);
   68|      0|        m->friendlist = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   69|      0|        return 0;
   70|      0|    }
   71|       |
   72|    526|    Friend *newfriendlist = (Friend *)mem_vrealloc(m->mem, m->friendlist, num, sizeof(Friend));
   73|       |
   74|    526|    if (newfriendlist == nullptr) {
  ------------------
  |  |   63|    526|#define nullptr NULL
  ------------------
  |  Branch (74:9): [True: 0, False: 526]
  ------------------
   75|      0|        return -1;
   76|      0|    }
   77|       |
   78|    526|    m->friendlist = newfriendlist;
   79|    526|    return 0;
   80|    526|}
Messenger.c:userstatus_from_int:
  775|    659|{
  776|    659|    switch (status) {
  777|    302|        case USERSTATUS_NONE: {
  ------------------
  |  Branch (777:9): [True: 302, False: 357]
  ------------------
  778|    302|            *out_enum = USERSTATUS_NONE;
  779|    302|            return true;
  780|      0|        }
  781|       |
  782|    105|        case USERSTATUS_AWAY: {
  ------------------
  |  Branch (782:9): [True: 105, False: 554]
  ------------------
  783|    105|            *out_enum = USERSTATUS_AWAY;
  784|    105|            return true;
  785|      0|        }
  786|       |
  787|     89|        case USERSTATUS_BUSY: {
  ------------------
  |  Branch (787:9): [True: 89, False: 570]
  ------------------
  788|     89|            *out_enum = USERSTATUS_BUSY;
  789|     89|            return true;
  790|      0|        }
  791|       |
  792|      0|        case USERSTATUS_INVALID: {
  ------------------
  |  Branch (792:9): [True: 0, False: 659]
  ------------------
  793|      0|            *out_enum = USERSTATUS_INVALID;
  794|      0|            return true;
  795|      0|        }
  796|       |
  797|    163|        default: {
  ------------------
  |  Branch (797:9): [True: 163, False: 496]
  ------------------
  798|    163|            *out_enum = USERSTATUS_INVALID;
  799|    163|            return false;
  800|      0|        }
  801|    659|    }
  802|    659|}
Messenger.c:m_state_plugins_size:
 2837|  1.23k|{
 2838|  1.23k|    const uint32_t size32 = sizeof(uint32_t);
 2839|  1.23k|    const uint32_t sizesubhead = size32 * 2;
 2840|       |
 2841|  1.23k|    uint32_t size = 0;
 2842|       |
 2843|  1.23k|    for (const Messenger_State_Plugin *plugin = m->options.state_plugins;
 2844|  12.3k|            plugin != m->options.state_plugins + m->options.state_plugins_length;
  ------------------
  |  Branch (2844:13): [True: 11.0k, False: 1.23k]
  ------------------
 2845|  11.0k|            ++plugin) {
 2846|  11.0k|        size += sizesubhead + plugin->size(m);
 2847|  11.0k|    }
 2848|       |
 2849|  1.23k|    return size;
 2850|  1.23k|}
Messenger.c:m_register_default_plugins:
 3359|  3.15k|{
 3360|  3.15k|    m_register_state_plugin(m, STATE_TYPE_NOSPAMKEYS, nospam_keys_size, load_nospam_keys, save_nospam_keys);
 3361|  3.15k|    m_register_state_plugin(m, STATE_TYPE_DHT, m_dht_size, m_dht_load, save_dht);
 3362|  3.15k|    m_register_state_plugin(m, STATE_TYPE_FRIENDS, saved_friendslist_size, friends_list_load, friends_list_save);
 3363|  3.15k|    m_register_state_plugin(m, STATE_TYPE_NAME, name_size, load_name, save_name);
 3364|  3.15k|    m_register_state_plugin(m, STATE_TYPE_STATUSMESSAGE, status_message_size, load_status_message,
 3365|  3.15k|                            save_status_message);
 3366|  3.15k|    m_register_state_plugin(m, STATE_TYPE_STATUS, status_size, load_status, save_status);
 3367|  3.15k|    if (m->options.groups_persistence_enabled) {
  ------------------
  |  Branch (3367:9): [True: 3.15k, False: 0]
  ------------------
 3368|  3.15k|        m_register_state_plugin(m, STATE_TYPE_GROUPS, saved_groups_size, groups_load, groups_save);
 3369|  3.15k|    }
 3370|  3.15k|    m_register_state_plugin(m, STATE_TYPE_TCP_RELAY, tcp_relay_size, load_tcp_relays, save_tcp_relays);
 3371|  3.15k|    m_register_state_plugin(m, STATE_TYPE_PATH_NODE, path_node_size, load_path_nodes, save_path_nodes);
 3372|  3.15k|}
Messenger.c:nospam_keys_size:
 2917|  2.81k|{
 2918|  2.81k|    return sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SECRET_KEY_SIZE;
  ------------------
  |  |   43|  2.81k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  return sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SECRET_KEY_SIZE;
  ------------------
  |  |   48|  2.81k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 2919|  2.81k|}
Messenger.c:load_nospam_keys:
 2923|    973|{
 2924|    973|    if (length != m_plugin_size(m, STATE_TYPE_NOSPAMKEYS)) {
  ------------------
  |  Branch (2924:9): [True: 1, False: 972]
  ------------------
 2925|      1|        return STATE_LOAD_STATUS_ERROR;
 2926|      1|    }
 2927|       |
 2928|    972|    uint32_t nospam;
 2929|    972|    lendian_bytes_to_host32(&nospam, data);
 2930|    972|    set_nospam(m->fr, nospam);
 2931|    972|    load_secret_key(m->net_crypto, data + sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|    972|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2932|       |
 2933|    972|    if (!pk_equal(data + sizeof(uint32_t), nc_get_self_public_key(m->net_crypto))) {
  ------------------
  |  Branch (2933:9): [True: 41, False: 931]
  ------------------
 2934|     41|        LOGGER_ERROR(m->log, "public key stored in savedata does not match its secret key");
  ------------------
  |  |   87|     41|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     41|    do {                                                                         \
  |  |  |  |   77|     41|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     82|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     41|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     41|        }                                                                        \
  |  |  |  |   80|     41|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2935|     41|        return STATE_LOAD_STATUS_ERROR;
 2936|     41|    }
 2937|       |
 2938|    931|    return STATE_LOAD_STATUS_CONTINUE;
 2939|    972|}
Messenger.c:m_plugin_size:
 2883|  4.71k|{
 2884|  14.2k|    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
  ------------------
  |  Branch (2884:25): [True: 14.2k, False: 0]
  ------------------
 2885|  14.2k|        const Messenger_State_Plugin plugin = m->options.state_plugins[i];
 2886|       |
 2887|  14.2k|        if (plugin.type == type) {
  ------------------
  |  Branch (2887:13): [True: 4.71k, False: 9.55k]
  ------------------
 2888|  4.71k|            return plugin.size(m);
 2889|  4.71k|        }
 2890|  14.2k|    }
 2891|       |
 2892|      0|    LOGGER_ERROR(m->log, "Unknown type encountered: %u", type);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2893|       |
 2894|      0|    return UINT32_MAX;
 2895|  4.71k|}
Messenger.c:save_nospam_keys:
 2943|    615|{
 2944|    615|    const uint32_t len = m_plugin_size(m, STATE_TYPE_NOSPAMKEYS);
 2945|    615|    static_assert(sizeof(get_nospam(m->fr)) == sizeof(uint32_t), "nospam doesn't fit in a 32 bit int");
 2946|    615|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_NOSPAMKEYS);
  ------------------
  |  |   29|    615|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 2947|    615|    const uint32_t nospam = get_nospam(m->fr);
 2948|    615|    host_to_lendian_bytes32(data, nospam);
 2949|    615|    save_keys(m->net_crypto, data + sizeof(uint32_t));
 2950|    615|    data += len;
 2951|    615|    return data;
 2952|    615|}
Messenger.c:m_dht_size:
 2957|  1.84k|{
 2958|  1.84k|    return dht_size(m->dht);
 2959|  1.84k|}
Messenger.c:m_dht_load:
 2973|    851|{
 2974|    851|    dht_load(m->dht, data, length); // TODO(endoffile78): Should we throw an error if dht_load fails?
 2975|    851|    return STATE_LOAD_STATUS_CONTINUE;
 2976|    851|}
Messenger.c:save_dht:
 2963|    615|{
 2964|    615|    const uint32_t len = m_plugin_size(m, STATE_TYPE_DHT);
 2965|    615|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_DHT);
  ------------------
  |  |   29|    615|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 2966|    615|    dht_save(m->dht, data);
 2967|    615|    data += len;
 2968|    615|    return data;
 2969|    615|}
Messenger.c:saved_friendslist_size:
 2981|  1.84k|{
 2982|  1.84k|    return count_friendlist(m) * friend_size();
 2983|  1.84k|}
Messenger.c:friend_size:
 2726|  3.15k|{
 2727|  3.15k|    uint32_t data = 0;
 2728|  3.15k|    const struct Saved_Friend *const temp = nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2729|       |
 2730|  3.15k|#define VALUE_MEMBER(data, name) \
 2731|  3.15k|    do {                         \
 2732|  3.15k|        data += sizeof(name);    \
 2733|  3.15k|    } while (0)
 2734|  3.15k|#define ARRAY_MEMBER(data, name) \
 2735|  3.15k|    do {                         \
 2736|  3.15k|        data += sizeof(name);    \
 2737|  3.15k|    } while (0)
 2738|       |
 2739|       |    // Exactly the same in friend_load, friend_save, and friend_size
 2740|  3.15k|    VALUE_MEMBER(data, temp->status);
  ------------------
  |  | 2731|  3.15k|    do {                         \
  |  | 2732|  3.15k|        data += sizeof(name);    \
  |  | 2733|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2733:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2741|  3.15k|    ARRAY_MEMBER(data, temp->real_pk);
  ------------------
  |  | 2735|  3.15k|    do {                         \
  |  | 2736|  3.15k|        data += sizeof(name);    \
  |  | 2737|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2737:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2742|  3.15k|    ARRAY_MEMBER(data, temp->info);
  ------------------
  |  | 2735|  3.15k|    do {                         \
  |  | 2736|  3.15k|        data += sizeof(name);    \
  |  | 2737|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2737:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2743|  3.15k|    ++data; // padding
 2744|  3.15k|    VALUE_MEMBER(data, temp->info_size);
  ------------------
  |  | 2731|  3.15k|    do {                         \
  |  | 2732|  3.15k|        data += sizeof(name);    \
  |  | 2733|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2733:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2745|  3.15k|    ARRAY_MEMBER(data, temp->name);
  ------------------
  |  | 2735|  3.15k|    do {                         \
  |  | 2736|  3.15k|        data += sizeof(name);    \
  |  | 2737|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2737:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2746|  3.15k|    VALUE_MEMBER(data, temp->name_length);
  ------------------
  |  | 2731|  3.15k|    do {                         \
  |  | 2732|  3.15k|        data += sizeof(name);    \
  |  | 2733|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2733:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2747|  3.15k|    ARRAY_MEMBER(data, temp->statusmessage);
  ------------------
  |  | 2735|  3.15k|    do {                         \
  |  | 2736|  3.15k|        data += sizeof(name);    \
  |  | 2737|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2737:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2748|  3.15k|    ++data; // padding
 2749|  3.15k|    VALUE_MEMBER(data, temp->statusmessage_length);
  ------------------
  |  | 2731|  3.15k|    do {                         \
  |  | 2732|  3.15k|        data += sizeof(name);    \
  |  | 2733|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2733:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2750|  3.15k|    VALUE_MEMBER(data, temp->userstatus);
  ------------------
  |  | 2731|  3.15k|    do {                         \
  |  | 2732|  3.15k|        data += sizeof(name);    \
  |  | 2733|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2733:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2751|  3.15k|    data += 3; // padding
 2752|  3.15k|    VALUE_MEMBER(data, temp->friendrequest_nospam);
  ------------------
  |  | 2731|  3.15k|    do {                         \
  |  | 2732|  3.15k|        data += sizeof(name);    \
  |  | 2733|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2733:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2753|  3.15k|    ARRAY_MEMBER(data, temp->last_seen_time);
  ------------------
  |  | 2735|  3.15k|    do {                         \
  |  | 2736|  3.15k|        data += sizeof(name);    \
  |  | 2737|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2737:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2754|       |
 2755|  3.15k|#undef VALUE_MEMBER
 2756|  3.15k|#undef ARRAY_MEMBER
 2757|       |
 2758|  3.15k|    return data;
 2759|  3.15k|}
Messenger.c:friends_list_load:
 3038|    443|{
 3039|    443|    const uint32_t l_friend_size = friend_size();
 3040|       |
 3041|    443|    if (length % l_friend_size != 0) {
  ------------------
  |  Branch (3041:9): [True: 1, False: 442]
  ------------------
 3042|      1|        return STATE_LOAD_STATUS_ERROR; // TODO(endoffile78): error or continue?
 3043|      1|    }
 3044|       |
 3045|    442|    const uint32_t num = length / l_friend_size;
 3046|    442|    const uint8_t *cur_data = data;
 3047|       |
 3048|  1.28k|    for (uint32_t i = 0; i < num; ++i) {
  ------------------
  |  Branch (3048:26): [True: 840, False: 442]
  ------------------
 3049|    840|        struct Saved_Friend temp = { 0 };
 3050|    840|        const uint8_t *next_data = friend_load(&temp, cur_data);
 3051|    840|        assert(next_data - cur_data == l_friend_size);
 3052|       |
 3053|    840|        cur_data = next_data;
 3054|       |
 3055|    840|        if (temp.status >= 3) {
  ------------------
  |  Branch (3055:13): [True: 585, False: 255]
  ------------------
 3056|    585|            const int fnum = m_addfriend_norequest(m, temp.real_pk);
 3057|       |
 3058|    585|            if (fnum < 0) {
  ------------------
  |  Branch (3058:17): [True: 97, False: 488]
  ------------------
 3059|     97|                continue;
 3060|     97|            }
 3061|       |
 3062|    488|            setfriendname(m, fnum, temp.name, net_ntohs(temp.name_length));
 3063|    488|            set_friend_statusmessage(m, fnum, temp.statusmessage, net_ntohs(temp.statusmessage_length));
 3064|    488|            set_friend_userstatus(m, fnum, temp.userstatus);
 3065|    488|            net_unpack_u64(temp.last_seen_time, &m->friendlist[fnum].last_seen_time);
 3066|    488|        } else if (temp.status != 0) {
  ------------------
  |  Branch (3066:20): [True: 132, False: 123]
  ------------------
 3067|       |            /* TODO(irungentoo): This is not a good way to do this. */
 3068|    132|            uint8_t address[FRIEND_ADDRESS_SIZE];
 3069|    132|            pk_copy(address, temp.real_pk);
 3070|    132|            memcpy(address + CRYPTO_PUBLIC_KEY_SIZE, &temp.friendrequest_nospam, sizeof(uint32_t));
  ------------------
  |  |   43|    132|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3071|    132|            uint16_t checksum = data_checksum(address, FRIEND_ADDRESS_SIZE - sizeof(checksum));
  ------------------
  |  |   42|    132|#define FRIEND_ADDRESS_SIZE (CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t) + sizeof(uint16_t))
  |  |  ------------------
  |  |  |  |   43|    132|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 3072|    132|            memcpy(address + CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t), &checksum, sizeof(checksum));
  ------------------
  |  |   43|    132|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3073|    132|            m_addfriend(m, address, temp.info, net_ntohs(temp.info_size));
 3074|    132|        }
 3075|    840|    }
 3076|       |
 3077|    442|    return STATE_LOAD_STATUS_CONTINUE;
 3078|    442|}
Messenger.c:friend_load:
 2800|    840|{
 2801|    840|#define VALUE_MEMBER(data, name)           \
 2802|    840|    do {                                   \
 2803|    840|        memcpy(&name, data, sizeof(name)); \
 2804|    840|        data += sizeof(name);              \
 2805|    840|    } while (0)
 2806|       |
 2807|    840|#define ARRAY_MEMBER(data, name)          \
 2808|    840|    do {                                  \
 2809|    840|        memcpy(name, data, sizeof(name)); \
 2810|    840|        data += sizeof(name);             \
 2811|    840|    } while (0)
 2812|       |
 2813|       |    // Exactly the same in friend_load, friend_save, and friend_size
 2814|    840|    VALUE_MEMBER(data, temp->status);
  ------------------
  |  | 2802|    840|    do {                                   \
  |  | 2803|    840|        memcpy(&name, data, sizeof(name)); \
  |  | 2804|    840|        data += sizeof(name);              \
  |  | 2805|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2805:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2815|    840|    ARRAY_MEMBER(data, temp->real_pk);
  ------------------
  |  | 2808|    840|    do {                                  \
  |  | 2809|    840|        memcpy(name, data, sizeof(name)); \
  |  | 2810|    840|        data += sizeof(name);             \
  |  | 2811|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2811:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2816|    840|    ARRAY_MEMBER(data, temp->info);
  ------------------
  |  | 2808|    840|    do {                                  \
  |  | 2809|    840|        memcpy(name, data, sizeof(name)); \
  |  | 2810|    840|        data += sizeof(name);             \
  |  | 2811|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2811:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2817|    840|    ++data; // padding
 2818|    840|    VALUE_MEMBER(data, temp->info_size);
  ------------------
  |  | 2802|    840|    do {                                   \
  |  | 2803|    840|        memcpy(&name, data, sizeof(name)); \
  |  | 2804|    840|        data += sizeof(name);              \
  |  | 2805|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2805:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2819|    840|    ARRAY_MEMBER(data, temp->name);
  ------------------
  |  | 2808|    840|    do {                                  \
  |  | 2809|    840|        memcpy(name, data, sizeof(name)); \
  |  | 2810|    840|        data += sizeof(name);             \
  |  | 2811|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2811:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2820|    840|    VALUE_MEMBER(data, temp->name_length);
  ------------------
  |  | 2802|    840|    do {                                   \
  |  | 2803|    840|        memcpy(&name, data, sizeof(name)); \
  |  | 2804|    840|        data += sizeof(name);              \
  |  | 2805|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2805:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2821|    840|    ARRAY_MEMBER(data, temp->statusmessage);
  ------------------
  |  | 2808|    840|    do {                                  \
  |  | 2809|    840|        memcpy(name, data, sizeof(name)); \
  |  | 2810|    840|        data += sizeof(name);             \
  |  | 2811|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2811:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2822|    840|    ++data; // padding
 2823|    840|    VALUE_MEMBER(data, temp->statusmessage_length);
  ------------------
  |  | 2802|    840|    do {                                   \
  |  | 2803|    840|        memcpy(&name, data, sizeof(name)); \
  |  | 2804|    840|        data += sizeof(name);              \
  |  | 2805|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2805:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2824|    840|    VALUE_MEMBER(data, temp->userstatus);
  ------------------
  |  | 2802|    840|    do {                                   \
  |  | 2803|    840|        memcpy(&name, data, sizeof(name)); \
  |  | 2804|    840|        data += sizeof(name);              \
  |  | 2805|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2805:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2825|    840|    data += 3; // padding
 2826|    840|    VALUE_MEMBER(data, temp->friendrequest_nospam);
  ------------------
  |  | 2802|    840|    do {                                   \
  |  | 2803|    840|        memcpy(&name, data, sizeof(name)); \
  |  | 2804|    840|        data += sizeof(name);              \
  |  | 2805|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2805:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2827|    840|    ARRAY_MEMBER(data, temp->last_seen_time);
  ------------------
  |  | 2808|    840|    do {                                  \
  |  | 2809|    840|        memcpy(name, data, sizeof(name)); \
  |  | 2810|    840|        data += sizeof(name);             \
  |  | 2811|    840|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2811:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2828|       |
 2829|    840|#undef VALUE_MEMBER
 2830|    840|#undef ARRAY_MEMBER
 2831|       |
 2832|    840|    return data;
 2833|    840|}
Messenger.c:friends_list_save:
 2987|    615|{
 2988|    615|    const uint32_t len = m_plugin_size(m, STATE_TYPE_FRIENDS);
 2989|    615|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_FRIENDS);
  ------------------
  |  |   29|    615|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 2990|       |
 2991|    615|    uint32_t num = 0;
 2992|    615|    uint8_t *cur_data = data;
 2993|       |
 2994|    743|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (2994:26): [True: 128, False: 615]
  ------------------
 2995|    128|        if (m->friendlist[i].status > 0) {
  ------------------
  |  Branch (2995:13): [True: 128, False: 0]
  ------------------
 2996|    128|            struct Saved_Friend temp = { 0 };
 2997|    128|            temp.status = m->friendlist[i].status;
 2998|    128|            memcpy(temp.real_pk, m->friendlist[i].real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|    128|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2999|       |
 3000|    128|            if (temp.status < 3) {
  ------------------
  |  Branch (3000:17): [True: 26, False: 102]
  ------------------
 3001|       |                // TODO(iphydf): Use uint16_t and min_u16 here.
 3002|     26|                const size_t friendrequest_length =
 3003|     26|                    min_u32(m->friendlist[i].info_size,
 3004|     26|                            min_u32(SAVED_FRIEND_REQUEST_SIZE, MAX_FRIEND_REQUEST_DATA_SIZE));
  ------------------
  |  | 2708|     26|#define SAVED_FRIEND_REQUEST_SIZE 1024
  ------------------
                                          min_u32(SAVED_FRIEND_REQUEST_SIZE, MAX_FRIEND_REQUEST_DATA_SIZE));
  ------------------
  |  |   19|     26|#define MAX_FRIEND_REQUEST_DATA_SIZE (ONION_CLIENT_MAX_DATA_SIZE - 100)
  |  |  ------------------
  |  |  |  |  188|     26|#define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   42|     26|#define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   52|     26|#define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   41|     26|#define ONION_MAX_PACKET_SIZE 1400
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   50|     26|#define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   69|     26|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |   47|     26|#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   43|     26|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  189|     26|#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  187|     26|#define SIZE_IP (1 + SIZE_IP6)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  186|     26|#define SIZE_IP6 16
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |               #define SIZE_IPPORT (SIZE_IP + SIZE_PORT)
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  188|     26|#define SIZE_PORT 2
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |               #define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |   64|     26|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   41|     26|#define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   43|     26|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   69|     26|#define CRYPTO_NONCE_SIZE              24
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   43|     26|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |               #define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   64|     26|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |  185|     26|#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   43|     26|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|     26|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3005|     26|                memcpy(temp.info, m->friendlist[i].info, friendrequest_length);
 3006|       |
 3007|     26|                temp.info_size = net_htons(m->friendlist[i].info_size);
 3008|     26|                temp.friendrequest_nospam = m->friendlist[i].friendrequest_nospam;
 3009|    102|            } else {
 3010|    102|                temp.status = 3;
 3011|    102|                memcpy(temp.name, m->friendlist[i].name, m->friendlist[i].name_length);
 3012|    102|                temp.name_length = net_htons(m->friendlist[i].name_length);
 3013|    102|                memcpy(temp.statusmessage, m->friendlist[i].statusmessage, m->friendlist[i].statusmessage_length);
 3014|    102|                temp.statusmessage_length = net_htons(m->friendlist[i].statusmessage_length);
 3015|    102|                temp.userstatus = m->friendlist[i].userstatus;
 3016|       |
 3017|    102|                net_pack_u64(temp.last_seen_time, m->friendlist[i].last_seen_time);
 3018|    102|            }
 3019|       |
 3020|    128|            uint8_t *next_data = friend_save(&temp, cur_data);
 3021|    128|            assert(next_data - cur_data == friend_size());
 3022|    128|#ifdef __LP64__
 3023|    128|            assert(memcmp(cur_data, &temp, friend_size()) == 0);
 3024|    128|#endif /* __LP64__ */
 3025|    128|            cur_data = next_data;
 3026|    128|            ++num;
 3027|    128|        }
 3028|    128|    }
 3029|       |
 3030|    615|    assert(cur_data - data == num * friend_size());
 3031|    615|    data += len;
 3032|       |
 3033|    615|    return data;
 3034|    615|}
Messenger.c:friend_save:
 2763|    128|{
 2764|    128|#define VALUE_MEMBER(data, name)           \
 2765|    128|    do {                                   \
 2766|    128|        memcpy(data, &name, sizeof(name)); \
 2767|    128|        data += sizeof(name);              \
 2768|    128|    } while (0)
 2769|       |
 2770|    128|#define ARRAY_MEMBER(data, name)          \
 2771|    128|    do {                                  \
 2772|    128|        memcpy(data, name, sizeof(name)); \
 2773|    128|        data += sizeof(name);             \
 2774|    128|    } while (0)
 2775|       |
 2776|       |    // Exactly the same in friend_load, friend_save, and friend_size
 2777|    128|    VALUE_MEMBER(data, temp->status);
  ------------------
  |  | 2765|    128|    do {                                   \
  |  | 2766|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2767|    128|        data += sizeof(name);              \
  |  | 2768|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2768:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2778|    128|    ARRAY_MEMBER(data, temp->real_pk);
  ------------------
  |  | 2771|    128|    do {                                  \
  |  | 2772|    128|        memcpy(data, name, sizeof(name)); \
  |  | 2773|    128|        data += sizeof(name);             \
  |  | 2774|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2774:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2779|    128|    ARRAY_MEMBER(data, temp->info);
  ------------------
  |  | 2771|    128|    do {                                  \
  |  | 2772|    128|        memcpy(data, name, sizeof(name)); \
  |  | 2773|    128|        data += sizeof(name);             \
  |  | 2774|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2774:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2780|    128|    ++data; // padding
 2781|    128|    VALUE_MEMBER(data, temp->info_size);
  ------------------
  |  | 2765|    128|    do {                                   \
  |  | 2766|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2767|    128|        data += sizeof(name);              \
  |  | 2768|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2768:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2782|    128|    ARRAY_MEMBER(data, temp->name);
  ------------------
  |  | 2771|    128|    do {                                  \
  |  | 2772|    128|        memcpy(data, name, sizeof(name)); \
  |  | 2773|    128|        data += sizeof(name);             \
  |  | 2774|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2774:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2783|    128|    VALUE_MEMBER(data, temp->name_length);
  ------------------
  |  | 2765|    128|    do {                                   \
  |  | 2766|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2767|    128|        data += sizeof(name);              \
  |  | 2768|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2768:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2784|    128|    ARRAY_MEMBER(data, temp->statusmessage);
  ------------------
  |  | 2771|    128|    do {                                  \
  |  | 2772|    128|        memcpy(data, name, sizeof(name)); \
  |  | 2773|    128|        data += sizeof(name);             \
  |  | 2774|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2774:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2785|    128|    ++data; // padding
 2786|    128|    VALUE_MEMBER(data, temp->statusmessage_length);
  ------------------
  |  | 2765|    128|    do {                                   \
  |  | 2766|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2767|    128|        data += sizeof(name);              \
  |  | 2768|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2768:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2787|    128|    VALUE_MEMBER(data, temp->userstatus);
  ------------------
  |  | 2765|    128|    do {                                   \
  |  | 2766|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2767|    128|        data += sizeof(name);              \
  |  | 2768|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2768:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2788|    128|    data += 3; // padding
 2789|    128|    VALUE_MEMBER(data, temp->friendrequest_nospam);
  ------------------
  |  | 2765|    128|    do {                                   \
  |  | 2766|    128|        memcpy(data, &name, sizeof(name)); \
  |  | 2767|    128|        data += sizeof(name);              \
  |  | 2768|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2768:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2790|    128|    ARRAY_MEMBER(data, temp->last_seen_time);
  ------------------
  |  | 2771|    128|    do {                                  \
  |  | 2772|    128|        memcpy(data, name, sizeof(name)); \
  |  | 2773|    128|        data += sizeof(name);             \
  |  | 2774|    128|    } while (0)
  |  |  ------------------
  |  |  |  Branch (2774:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2791|       |
 2792|    128|#undef VALUE_MEMBER
 2793|    128|#undef ARRAY_MEMBER
 2794|       |
 2795|    128|    return data;
 2796|    128|}
Messenger.c:name_size:
 3185|  1.84k|{
 3186|  1.84k|    return m->name_length;
 3187|  1.84k|}
Messenger.c:load_name:
 3201|    643|{
 3202|    643|    if (length > 0 && length <= MAX_NAME_LENGTH) {
  ------------------
  |  |   34|    577|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (3202:9): [True: 577, False: 66]
  |  Branch (3202:23): [True: 511, False: 66]
  ------------------
 3203|    511|        setname(m, data, length);
 3204|    511|    }
 3205|       |
 3206|    643|    return STATE_LOAD_STATUS_CONTINUE;
 3207|    643|}
Messenger.c:save_name:
 3191|    615|{
 3192|    615|    const uint32_t len = m_plugin_size(m, STATE_TYPE_NAME);
 3193|    615|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_NAME);
  ------------------
  |  |   29|    615|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3194|    615|    memcpy(data, m->name, len);
 3195|    615|    data += len;
 3196|    615|    return data;
 3197|    615|}
Messenger.c:status_message_size:
 3212|  1.84k|{
 3213|  1.84k|    return m->statusmessage_length;
 3214|  1.84k|}
Messenger.c:load_status_message:
 3228|  1.06k|{
 3229|  1.06k|    if (length > 0 && length <= MAX_STATUSMESSAGE_LENGTH) {
  ------------------
  |  |   36|    883|#define MAX_STATUSMESSAGE_LENGTH 1007
  ------------------
  |  Branch (3229:9): [True: 883, False: 182]
  |  Branch (3229:23): [True: 873, False: 10]
  ------------------
 3230|    873|        m_set_statusmessage(m, data, length);
 3231|    873|    }
 3232|       |
 3233|  1.06k|    return STATE_LOAD_STATUS_CONTINUE;
 3234|  1.06k|}
Messenger.c:save_status_message:
 3218|    615|{
 3219|    615|    const uint32_t len = m_plugin_size(m, STATE_TYPE_STATUSMESSAGE);
 3220|    615|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_STATUSMESSAGE);
  ------------------
  |  |   29|    615|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3221|    615|    memcpy(data, m->statusmessage, len);
 3222|    615|    data += len;
 3223|    615|    return data;
 3224|    615|}
Messenger.c:status_size:
 3239|  1.84k|{
 3240|  1.84k|    return 1;
 3241|  1.84k|}
Messenger.c:load_status:
 3255|    655|{
 3256|    655|    if (length == 1) {
  ------------------
  |  Branch (3256:9): [True: 619, False: 36]
  ------------------
 3257|    619|        m_set_userstatus(m, *data);
 3258|    619|    }
 3259|       |
 3260|    655|    return STATE_LOAD_STATUS_CONTINUE;
 3261|    655|}
Messenger.c:save_status:
 3245|    615|{
 3246|    615|    const uint32_t len = m_plugin_size(m, STATE_TYPE_STATUS);
 3247|    615|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_STATUS);
  ------------------
  |  |   29|    615|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3248|    615|    *data = m->userstatus;
 3249|    615|    data += len;
 3250|    615|    return data;
 3251|    615|}
Messenger.c:saved_groups_size:
 3107|  1.28k|{
 3108|  1.28k|    const GC_Session *session = m->group_handler;
 3109|  1.28k|    return bin_pack_obj_size(pack_groupchats_handler, session, m->log);
 3110|  1.28k|}
Messenger.c:pack_groupchats_handler:
 3099|  1.34k|{
 3100|  1.34k|    const GC_Session *session = (const GC_Session *)obj;
 3101|  1.34k|    pack_groupchats(session, bp);
 3102|  1.34k|    return true;  // TODO(iphydf): Return bool from pack functions.
 3103|  1.34k|}
Messenger.c:pack_groupchats:
 3082|  1.34k|{
 3083|  1.34k|    assert(bp != nullptr && c != nullptr);
 3084|  1.34k|    bin_pack_array(bp, gc_count_groups(c));
 3085|       |
 3086|  2.36k|    for (uint32_t i = 0; i < c->chats_index; ++i) { // this loop must match the one in gc_count_groups()
  ------------------
  |  Branch (3086:26): [True: 1.02k, False: 1.34k]
  ------------------
 3087|  1.02k|        const GC_Chat *chat = &c->chats[i];
 3088|       |
 3089|  1.02k|        if (!gc_group_is_valid(chat)) {
  ------------------
  |  Branch (3089:13): [True: 736, False: 292]
  ------------------
 3090|    736|            continue;
 3091|    736|        }
 3092|       |
 3093|    292|        gc_group_save(chat, bp);
 3094|    292|    }
 3095|  1.34k|}
Messenger.c:groups_load:
 3173|  25.8k|{
 3174|  25.8k|    if (!bin_unpack_obj(m->mem, handle_groups_load, m, data, length)) {
  ------------------
  |  Branch (3174:9): [True: 104, False: 25.7k]
  ------------------
 3175|    104|        LOGGER_ERROR(m->log, "msgpack failed to unpack groupchats array");
  ------------------
  |  |   87|    104|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|    104|    do {                                                                         \
  |  |  |  |   77|    104|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    208|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|    104|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|    104|        }                                                                        \
  |  |  |  |   80|    104|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3176|    104|        return STATE_LOAD_STATUS_ERROR;
 3177|    104|    }
 3178|       |
 3179|  25.7k|    return STATE_LOAD_STATUS_CONTINUE;
 3180|  25.8k|}
Messenger.c:handle_groups_load:
 3145|  25.8k|{
 3146|  25.8k|    Messenger *m = (Messenger *)obj;
 3147|       |
 3148|  25.8k|    uint32_t num_groups;
 3149|  25.8k|    if (!bin_unpack_array(bu, &num_groups)) {
  ------------------
  |  Branch (3149:9): [True: 104, False: 25.7k]
  ------------------
 3150|    104|        LOGGER_ERROR(m->log, "msgpack failed to unpack groupchats array: expected array");
  ------------------
  |  |   87|    104|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|    104|    do {                                                                         \
  |  |  |  |   77|    104|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    208|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|    104|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|    104|        }                                                                        \
  |  |  |  |   80|    104|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3151|    104|        return false;
 3152|    104|    }
 3153|       |
 3154|  25.7k|    LOGGER_DEBUG(m->log, "Loading %u groups", num_groups);
  ------------------
  |  |   84|  25.7k|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  25.7k|    do {                                                                         \
  |  |  |  |   77|  25.7k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  51.5k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|  25.7k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3155|       |
 3156|  25.8k|    for (uint32_t i = 0; i < num_groups; ++i) {
  ------------------
  |  Branch (3156:26): [True: 25.7k, False: 85]
  ------------------
 3157|  25.7k|        const int group_number = gc_group_load(m->group_handler, bu);
 3158|       |
 3159|  25.7k|        if (group_number < 0) {
  ------------------
  |  Branch (3159:13): [True: 25.6k, False: 64]
  ------------------
 3160|  25.6k|            LOGGER_WARNING(m->log, "Failed to load group %u", i);
  ------------------
  |  |   86|  25.6k|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  25.6k|    do {                                                                         \
  |  |  |  |   77|  25.6k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  51.3k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|  25.6k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|  25.6k|        }                                                                        \
  |  |  |  |   80|  25.6k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3161|       |            // Can't recover trivially. We may need to skip over some data here.
 3162|  25.6k|            break;
 3163|  25.6k|        }
 3164|  25.7k|    }
 3165|       |
 3166|  25.7k|    LOGGER_DEBUG(m->log, "Successfully loaded %u groups", gc_count_groups(m->group_handler));
  ------------------
  |  |   84|  25.7k|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  25.7k|    do {                                                                         \
  |  |  |  |   77|  25.7k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  51.5k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|  25.7k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3167|       |
 3168|  25.7k|    return true;
 3169|  25.8k|}
Messenger.c:groups_save:
 3114|    615|{
 3115|    615|    const GC_Session *c = m->group_handler;
 3116|       |
 3117|    615|    const uint32_t num_groups = gc_count_groups(c);
 3118|       |
 3119|    615|    if (num_groups == 0) {
  ------------------
  |  Branch (3119:9): [True: 560, False: 55]
  ------------------
 3120|    560|        return data;
 3121|    560|    }
 3122|       |
 3123|     55|    const uint32_t len = m_plugin_size(m, STATE_TYPE_GROUPS);
 3124|       |
 3125|     55|    if (len == 0) {
  ------------------
  |  Branch (3125:9): [True: 0, False: 55]
  ------------------
 3126|      0|        return data;
 3127|      0|    }
 3128|       |
 3129|     55|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_GROUPS);
  ------------------
  |  |   29|     55|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3130|       |
 3131|     55|    if (!bin_pack_obj(pack_groupchats_handler, c, m->log, data, len)) {
  ------------------
  |  Branch (3131:9): [True: 0, False: 55]
  ------------------
 3132|      0|        LOGGER_FATAL(m->log, "failed to pack group chats into buffer of length %u", len);
  ------------------
  |  |   90|      0|    do {                                \
  |  |   91|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   92|      0|        logger_abort();                 \
  |  |   93|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (93:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3133|      0|        return data;
 3134|      0|    }
 3135|       |
 3136|     55|    data += len;
 3137|       |
 3138|     55|    LOGGER_DEBUG(m->log, "Saved %u groups (length %u)", num_groups, len);
  ------------------
  |  |   84|     55|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     55|    do {                                                                         \
  |  |  |  |   77|     55|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    110|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|     55|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3139|       |
 3140|     55|    return data;
 3141|     55|}
Messenger.c:tcp_relay_size:
 3266|  1.23k|{
 3267|  1.23k|    return NUM_SAVED_TCP_RELAYS * packed_node_size(net_family_tcp_ipv6());
  ------------------
  |  |   38|  1.23k|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
 3268|  1.23k|}
Messenger.c:load_tcp_relays:
 3297|    684|{
 3298|    684|    if (length > 0) {
  ------------------
  |  Branch (3298:9): [True: 618, False: 66]
  ------------------
 3299|    618|        const int num = unpack_nodes(m->loaded_relays, NUM_SAVED_TCP_RELAYS, nullptr, data, length, true);
  ------------------
  |  |   38|    618|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
                      const int num = unpack_nodes(m->loaded_relays, NUM_SAVED_TCP_RELAYS, nullptr, data, length, true);
  ------------------
  |  |   63|    618|#define nullptr NULL
  ------------------
 3300|       |
 3301|    618|        if (num == -1) {
  ------------------
  |  Branch (3301:13): [True: 146, False: 472]
  ------------------
 3302|    146|            m->num_loaded_relays = 0;
 3303|    146|            return STATE_LOAD_STATUS_CONTINUE;
 3304|    146|        }
 3305|       |
 3306|    472|        m->num_loaded_relays = num;
 3307|    472|        m->has_added_relays = false;
 3308|    472|    }
 3309|       |
 3310|    538|    return STATE_LOAD_STATUS_CONTINUE;
 3311|    684|}
Messenger.c:save_tcp_relays:
 3272|    615|{
 3273|    615|    Node_format relays[NUM_SAVED_TCP_RELAYS] = {{{0}}};
 3274|    615|    uint8_t *temp_data = data;
 3275|    615|    data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, 0, STATE_TYPE_TCP_RELAY);
  ------------------
  |  |   29|    615|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3276|       |
 3277|    615|    if (m->num_loaded_relays > 0) {
  ------------------
  |  Branch (3277:9): [True: 40, False: 575]
  ------------------
 3278|     40|        memcpy(relays, m->loaded_relays, sizeof(Node_format) * m->num_loaded_relays);
 3279|     40|    }
 3280|       |
 3281|    615|    uint32_t num = m->num_loaded_relays;
 3282|    615|    num += copy_connected_tcp_relays(m->net_crypto, relays + num, NUM_SAVED_TCP_RELAYS - num);
  ------------------
  |  |   38|    615|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
 3283|       |
 3284|    615|    const int l = pack_nodes(m->log, data, NUM_SAVED_TCP_RELAYS * packed_node_size(net_family_tcp_ipv6()), relays, num);
  ------------------
  |  |   38|    615|#define NUM_SAVED_TCP_RELAYS 8
  ------------------
 3285|       |
 3286|    615|    if (l > 0) {
  ------------------
  |  Branch (3286:9): [True: 40, False: 575]
  ------------------
 3287|     40|        const uint32_t len = l;
 3288|     40|        data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, len, STATE_TYPE_TCP_RELAY);
  ------------------
  |  |   29|     40|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3289|     40|        data += len;
 3290|     40|    }
 3291|       |
 3292|    615|    return data;
 3293|    615|}
Messenger.c:path_node_size:
 3316|  1.23k|{
 3317|  1.23k|    return NUM_SAVED_PATH_NODES * packed_node_size(net_family_tcp_ipv6());
  ------------------
  |  | 2709|  1.23k|#define NUM_SAVED_PATH_NODES 8
  ------------------
 3318|  1.23k|}
Messenger.c:load_path_nodes:
 3340|    768|{
 3341|    768|    if (length > 0) {
  ------------------
  |  Branch (3341:9): [True: 699, False: 69]
  ------------------
 3342|    699|        Node_format nodes[NUM_SAVED_PATH_NODES];
 3343|    699|        const int num = unpack_nodes(nodes, NUM_SAVED_PATH_NODES, nullptr, data, length, false);
  ------------------
  |  | 2709|    699|#define NUM_SAVED_PATH_NODES 8
  ------------------
                      const int num = unpack_nodes(nodes, NUM_SAVED_PATH_NODES, nullptr, data, length, false);
  ------------------
  |  |   63|    699|#define nullptr NULL
  ------------------
 3344|       |
 3345|    699|        if (num == -1) {
  ------------------
  |  Branch (3345:13): [True: 131, False: 568]
  ------------------
 3346|    131|            return STATE_LOAD_STATUS_CONTINUE;
 3347|    131|        }
 3348|       |
 3349|  4.06k|        for (int i = 0; i < num; ++i) {
  ------------------
  |  Branch (3349:25): [True: 3.49k, False: 568]
  ------------------
 3350|  3.49k|            onion_add_bs_path_node(m->onion_c, &nodes[i].ip_port, nodes[i].public_key);
 3351|  3.49k|        }
 3352|    568|    }
 3353|       |
 3354|    637|    return STATE_LOAD_STATUS_CONTINUE;
 3355|    768|}
Messenger.c:save_path_nodes:
 3322|    615|{
 3323|    615|    Node_format nodes[NUM_SAVED_PATH_NODES] = {{{0}}};
 3324|    615|    uint8_t *temp_data = data;
 3325|    615|    data = state_write_section_header(data, STATE_COOKIE_TYPE, 0, STATE_TYPE_PATH_NODE);
  ------------------
  |  |   29|    615|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3326|    615|    const unsigned int num = onion_backup_nodes(m->onion_c, nodes, NUM_SAVED_PATH_NODES);
  ------------------
  |  | 2709|    615|#define NUM_SAVED_PATH_NODES 8
  ------------------
 3327|    615|    const int l = pack_nodes(m->log, data, NUM_SAVED_PATH_NODES * packed_node_size(net_family_tcp_ipv6()), nodes, num);
  ------------------
  |  | 2709|    615|#define NUM_SAVED_PATH_NODES 8
  ------------------
 3328|       |
 3329|    615|    if (l > 0) {
  ------------------
  |  Branch (3329:9): [True: 53, False: 562]
  ------------------
 3330|     53|        const uint32_t len = l;
 3331|     53|        data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, len, STATE_TYPE_PATH_NODE);
  ------------------
  |  |   29|     53|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3332|     53|        data += len;
 3333|     53|    }
 3334|       |
 3335|    615|    return data;
 3336|    615|}

tcp_connections_count:
   74|     64|{
   75|     64|    return tcp_c->tcp_connections_length;
   76|     64|}
set_packet_tcp_connection_callback:
  551|  3.21k|{
  552|  3.21k|    tcp_c->tcp_data_callback = tcp_data_callback;
  553|  3.21k|    tcp_c->tcp_data_callback_object = object;
  554|  3.21k|}
set_oob_packet_tcp_connection_callback:
  558|  3.21k|{
  559|  3.21k|    tcp_c->tcp_oob_callback = tcp_oob_callback;
  560|  3.21k|    tcp_c->tcp_oob_callback_object = object;
  561|  3.21k|}
set_onion_packet_tcp_connection_callback:
  565|  6.30k|{
  566|  6.30k|    tcp_c->tcp_onion_callback = tcp_onion_callback;
  567|  6.30k|    tcp_c->tcp_onion_callback_object = object;
  568|  6.30k|}
tcp_copy_connected_relays:
 1489|    592|{
 1490|    592|    const uint32_t r = random_u32(tcp_c->rng);
 1491|    592|    uint32_t copied = 0;
 1492|       |
 1493|    592|    for (uint32_t i = 0; (i < tcp_c->tcp_connections_length) && (copied < max_num); ++i) {
  ------------------
  |  Branch (1493:26): [True: 0, False: 592]
  |  Branch (1493:65): [True: 0, False: 0]
  ------------------
 1494|      0|        const uint16_t idx = (i + r) % tcp_c->tcp_connections_length;
 1495|       |
 1496|      0|        if (copy_tcp_relay_conn(tcp_c, &tcp_relays[copied], idx)) {
  ------------------
  |  Branch (1496:13): [True: 0, False: 0]
  ------------------
 1497|      0|            ++copied;
 1498|      0|        }
 1499|      0|    }
 1500|       |
 1501|    592|    return copied;
 1502|    592|}
new_tcp_connections:
 1600|  3.21k|{
 1601|  3.21k|    assert(logger != nullptr);
 1602|  3.21k|    assert(mem != nullptr);
 1603|  3.21k|    assert(rng != nullptr);
 1604|  3.21k|    assert(ns != nullptr);
 1605|  3.21k|    assert(mono_time != nullptr);
 1606|       |
 1607|  3.21k|    if (secret_key == nullptr) {
  ------------------
  |  |   63|  3.21k|#define nullptr NULL
  ------------------
  |  Branch (1607:9): [True: 0, False: 3.21k]
  ------------------
 1608|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1609|      0|    }
 1610|       |
 1611|  3.21k|    TCP_Connections *temp = (TCP_Connections *)mem_alloc(mem, sizeof(TCP_Connections));
 1612|       |
 1613|  3.21k|    if (temp == nullptr) {
  ------------------
  |  |   63|  3.21k|#define nullptr NULL
  ------------------
  |  Branch (1613:9): [True: 0, False: 3.21k]
  ------------------
 1614|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1615|      0|    }
 1616|       |
 1617|  3.21k|    Net_Profile *np = netprof_new(logger, mem);
 1618|       |
 1619|  3.21k|    if (np == nullptr) {
  ------------------
  |  |   63|  3.21k|#define nullptr NULL
  ------------------
  |  Branch (1619:9): [True: 0, False: 3.21k]
  ------------------
 1620|      0|        mem_delete(mem, temp);
 1621|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1622|      0|    }
 1623|       |
 1624|  3.21k|    temp->net_profile = np;
 1625|  3.21k|    temp->logger = logger;
 1626|  3.21k|    temp->mem = mem;
 1627|  3.21k|    temp->rng = rng;
 1628|  3.21k|    temp->mono_time = mono_time;
 1629|  3.21k|    temp->ns = ns;
 1630|       |
 1631|  3.21k|    memcpy(temp->self_secret_key, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   48|  3.21k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 1632|  3.21k|    crypto_derive_public_key(temp->self_public_key, temp->self_secret_key);
 1633|  3.21k|    temp->proxy_info = *proxy_info;
 1634|       |
 1635|  3.21k|    return temp;
 1636|  3.21k|}
kill_tcp_connections:
 1728|  3.21k|{
 1729|  3.21k|    if (tcp_c == nullptr) {
  ------------------
  |  |   63|  3.21k|#define nullptr NULL
  ------------------
  |  Branch (1729:9): [True: 0, False: 3.21k]
  ------------------
 1730|      0|        return;
 1731|      0|    }
 1732|       |
 1733|  3.21k|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1733:26): [True: 0, False: 3.21k]
  ------------------
 1734|      0|        kill_tcp_connection(tcp_c->tcp_connections[i].connection);
 1735|      0|    }
 1736|       |
 1737|  3.21k|    crypto_memzero(tcp_c->self_secret_key, sizeof(tcp_c->self_secret_key));
 1738|       |
 1739|  3.21k|    netprof_kill(tcp_c->mem, tcp_c->net_profile);
 1740|  3.21k|    mem_delete(tcp_c->mem, tcp_c->tcp_connections);
 1741|  3.21k|    mem_delete(tcp_c->mem, tcp_c->connections);
 1742|  3.21k|    mem_delete(tcp_c->mem, tcp_c);
 1743|  3.21k|}

new_announcements:
  648|  3.15k|{
  649|  3.15k|    if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (649:9): [True: 0, False: 3.15k]
  |  Branch (649:27): [True: 0, False: 3.15k]
  |  Branch (649:51): [True: 0, False: 3.15k]
  ------------------
  650|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  651|      0|    }
  652|       |
  653|  3.15k|    Announcements *announce = (Announcements *)mem_alloc(mem, sizeof(Announcements));
  654|       |
  655|  3.15k|    if (announce == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (655:9): [True: 0, False: 3.15k]
  ------------------
  656|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  657|      0|    }
  658|       |
  659|  3.15k|    announce->log = log;
  660|  3.15k|    announce->mem = mem;
  661|  3.15k|    announce->rng = rng;
  662|  3.15k|    announce->forwarding = forwarding;
  663|  3.15k|    announce->mono_time = mono_time;
  664|  3.15k|    announce->dht = forwarding_get_dht(forwarding);
  665|  3.15k|    announce->net = dht_get_net(announce->dht);
  666|  3.15k|    announce->public_key = dht_get_self_public_key(announce->dht);
  667|  3.15k|    announce->secret_key = dht_get_self_secret_key(announce->dht);
  668|  3.15k|    new_hmac_key(announce->rng, announce->hmac_key);
  669|  3.15k|    announce->shared_keys = shared_key_cache_new(log, mono_time, mem, announce->secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   30|  3.15k|#define KEYS_TIMEOUT 600
  ------------------
                  announce->shared_keys = shared_key_cache_new(log, mono_time, mem, announce->secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   29|  3.15k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  670|  3.15k|    if (announce->shared_keys == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (670:9): [True: 0, False: 3.15k]
  ------------------
  671|      0|        mem_delete(announce->mem, announce);
  672|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  673|      0|    }
  674|       |
  675|  3.15k|    announce->start_time = mono_time_get(announce->mono_time);
  676|       |
  677|  3.15k|    set_callback_forwarded_request(forwarding, forwarded_request_callback, announce);
  678|       |
  679|  3.15k|    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, handle_dht_announce_request, announce);
  680|  3.15k|    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, handle_dht_announce_request, announce);
  681|  3.15k|    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, handle_dht_announce_request, announce);
  682|       |
  683|  3.15k|    return announce;
  684|  3.15k|}
kill_announcements:
  687|  3.15k|{
  688|  3.15k|    if (announce == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (688:9): [True: 0, False: 3.15k]
  ------------------
  689|      0|        return;
  690|      0|    }
  691|       |
  692|  3.15k|    set_callback_forwarded_request(announce->forwarding, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  set_callback_forwarded_request(announce->forwarding, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  693|       |
  694|  3.15k|    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  695|  3.15k|    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  696|  3.15k|    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  697|       |
  698|  3.15k|    crypto_memzero(announce->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  162|  3.15k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  699|  3.15k|    shared_key_cache_free(announce->shared_keys);
  700|       |
  701|   809k|    for (uint32_t i = 0; i < ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   72|   809k|#define ANNOUNCE_BUCKETS 32 // ANNOUNCE_BUCKETS = 2 ** ANNOUNCE_BUCKET_PREFIX_LENGTH
  ------------------
                  for (uint32_t i = 0; i < ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   70|   809k|#define ANNOUNCE_BUCKET_SIZE 8
  ------------------
  |  Branch (701:26): [True: 806k, False: 3.15k]
  ------------------
  702|   806k|        mem_delete(announce->mem, announce->entries[i].data);
  703|   806k|    }
  704|       |
  705|  3.15k|    mem_delete(announce->mem, announce);
  706|  3.15k|}

bin_pack_obj_size:
   68|  1.54k|{
   69|  1.54k|    Bin_Pack bp;
   70|  1.54k|    bin_pack_init(&bp, nullptr, 0);
  ------------------
  |  |   63|  1.54k|#define nullptr NULL
  ------------------
   71|  1.54k|    if (!callback(obj, logger, &bp)) {
  ------------------
  |  Branch (71:9): [True: 0, False: 1.54k]
  ------------------
   72|      0|        return UINT32_MAX;
   73|      0|    }
   74|  1.54k|    return bp.bytes_pos;
   75|  1.54k|}
bin_pack_obj:
   78|    315|{
   79|    315|    Bin_Pack bp;
   80|    315|    bin_pack_init(&bp, buf, buf_size);
   81|    315|    return callback(obj, logger, &bp);
   82|    315|}
bin_pack_obj_array_b_size:
   85|  2.17k|{
   86|  2.17k|    Bin_Pack bp;
   87|  2.17k|    bin_pack_init(&bp, nullptr, 0);
  ------------------
  |  |   63|  2.17k|#define nullptr NULL
  ------------------
   88|  2.17k|    if (arr == nullptr) {
  ------------------
  |  |   63|  2.17k|#define nullptr NULL
  ------------------
  |  Branch (88:9): [True: 0, False: 2.17k]
  ------------------
   89|      0|        assert(arr_size == 0);
   90|      0|    }
   91|  5.68k|    for (uint32_t i = 0; i < arr_size; ++i) {
  ------------------
  |  Branch (91:26): [True: 3.50k, False: 2.17k]
  ------------------
   92|  3.50k|        if (!callback(arr, i, logger, &bp)) {
  ------------------
  |  Branch (92:13): [True: 0, False: 3.50k]
  ------------------
   93|      0|            return UINT32_MAX;
   94|      0|        }
   95|  3.50k|    }
   96|  2.17k|    return bp.bytes_pos;
   97|  2.17k|}
bin_pack_obj_array_b:
  100|  2.17k|{
  101|  2.17k|    Bin_Pack bp;
  102|  2.17k|    bin_pack_init(&bp, buf, buf_size);
  103|  2.17k|    if (arr == nullptr) {
  ------------------
  |  |   63|  2.17k|#define nullptr NULL
  ------------------
  |  Branch (103:9): [True: 0, False: 2.17k]
  ------------------
  104|      0|        assert(arr_size == 0);
  105|      0|    }
  106|  5.68k|    for (uint32_t i = 0; i < arr_size; ++i) {
  ------------------
  |  Branch (106:26): [True: 3.50k, False: 2.17k]
  ------------------
  107|  3.50k|        if (!callback(arr, i, logger, &bp)) {
  ------------------
  |  Branch (107:13): [True: 0, False: 3.50k]
  ------------------
  108|      0|            return false;
  109|      0|        }
  110|  3.50k|    }
  111|  2.17k|    return true;
  112|  2.17k|}
bin_pack_array:
  135|  1.94k|{
  136|  1.94k|    return cmp_write_array(&bp->ctx, size);
  137|  1.94k|}
bin_pack_bool:
  140|     76|{
  141|     76|    return cmp_write_bool(&bp->ctx, val);
  142|     76|}
bin_pack_u08:
  145|    304|{
  146|    304|    return cmp_write_uinteger(&bp->ctx, val);
  147|    304|}
bin_pack_u16:
  150|    608|{
  151|    608|    return cmp_write_uinteger(&bp->ctx, val);
  152|    608|}
bin_pack_u32:
  155|    228|{
  156|    228|    return cmp_write_uinteger(&bp->ctx, val);
  157|    228|}
bin_pack_bin:
  165|  1.13k|{
  166|  1.13k|    return cmp_write_bin(&bp->ctx, data, length);
  167|  1.13k|}
bin_pack_nil:
  170|      4|{
  171|      4|    return cmp_write_nil(&bp->ctx);
  172|      4|}
bin_pack_u08_b:
  180|  22.6k|{
  181|  22.6k|    return bp->ctx.write(&bp->ctx, &val, 1) == 1;
  182|  22.6k|}
bin_pack_u16_b:
  185|  7.53k|{
  186|  7.53k|    return bin_pack_u08_b(bp, (val >> 8) & 0xff)
  ------------------
  |  Branch (186:12): [True: 7.53k, False: 0]
  ------------------
  187|  7.53k|           && bin_pack_u08_b(bp, val & 0xff);
  ------------------
  |  Branch (187:15): [True: 7.53k, False: 0]
  ------------------
  188|  7.53k|}
bin_pack_bin_b:
  203|  14.5k|{
  204|  14.5k|    return bp->ctx.write(&bp->ctx, data, length) == length;
  205|  14.5k|}
bin_pack.c:bin_pack_init:
   60|  6.20k|{
   61|  6.20k|    bp->bytes = buf;
   62|  6.20k|    bp->bytes_size = buf_size;
   63|  6.20k|    bp->bytes_pos = 0;
   64|  6.20k|    cmp_init(&bp->ctx, bp, null_reader, null_skipper, buf_writer);
   65|  6.20k|}
bin_pack.c:buf_writer:
   38|  43.7k|{
   39|  43.7k|    const uint8_t *bytes = (const uint8_t *)data;
   40|  43.7k|    Bin_Pack *bp = (Bin_Pack *)ctx->buf;
   41|  43.7k|    assert(bp != nullptr);
   42|  43.7k|    const uint32_t new_pos = bp->bytes_pos + count;
   43|  43.7k|    if (new_pos < bp->bytes_pos) {
  ------------------
  |  Branch (43:9): [True: 0, False: 43.7k]
  ------------------
   44|       |        // 32 bit overflow.
   45|      0|        return 0;
   46|      0|    }
   47|  43.7k|    if (bp->bytes != nullptr) {
  ------------------
  |  |   63|  43.7k|#define nullptr NULL
  ------------------
  |  Branch (47:9): [True: 19.9k, False: 23.8k]
  ------------------
   48|  19.9k|        if (new_pos > bp->bytes_size) {
  ------------------
  |  Branch (48:13): [True: 0, False: 19.9k]
  ------------------
   49|       |            // Buffer too small.
   50|      0|            return 0;
   51|      0|        }
   52|  19.9k|        memcpy(&bp->bytes[bp->bytes_pos], bytes, count);
   53|  19.9k|    }
   54|  43.7k|    bp->bytes_pos += count;
   55|  43.7k|    return count;
   56|  43.7k|}

bin_unpack_obj:
   68|  25.8k|{
   69|  25.8k|    Bin_Unpack bu;
   70|  25.8k|    bin_unpack_init(&bu, mem, buf, buf_size);
   71|  25.8k|    return callback(obj, &bu);
   72|  25.8k|}
bin_unpack_array:
   75|  25.8k|{
   76|  25.8k|    return cmp_read_array(&bu->ctx, size) && *size <= bu->bytes_size;
  ------------------
  |  Branch (76:12): [True: 25.7k, False: 101]
  |  Branch (76:46): [True: 25.7k, False: 3]
  ------------------
   77|  25.8k|}
bin_unpack_array_fixed:
   80|  48.8k|{
   81|  48.8k|    uint32_t size = 0;
   82|  48.8k|    const bool success = cmp_read_array(&bu->ctx, &size) && size == required_size;
  ------------------
  |  Branch (82:26): [True: 42.8k, False: 5.99k]
  |  Branch (82:61): [True: 42.6k, False: 176]
  ------------------
   83|  48.8k|    if (actual_size != nullptr) {
  ------------------
  |  |   63|  48.8k|#define nullptr NULL
  ------------------
  |  Branch (83:9): [True: 25.8k, False: 22.9k]
  ------------------
   84|  25.8k|        *actual_size = size;
   85|  25.8k|    }
   86|  48.8k|    return success;
   87|  48.8k|}
bin_unpack_bool:
   90|  20.5k|{
   91|  20.5k|    return cmp_read_bool(&bu->ctx, val);
   92|  20.5k|}
bin_unpack_u08:
   95|  13.9k|{
   96|  13.9k|    return cmp_read_uchar(&bu->ctx, val);
   97|  13.9k|}
bin_unpack_u16:
  100|  29.9k|{
  101|  29.9k|    return cmp_read_ushort(&bu->ctx, val);
  102|  29.9k|}
bin_unpack_u32:
  105|  8.31k|{
  106|  8.31k|    return cmp_read_uint(&bu->ctx, val);
  107|  8.31k|}
bin_unpack_nil:
  115|     32|{
  116|     32|    return cmp_read_nil(&bu->ctx);
  117|     32|}
bin_unpack_bin_max:
  143|    558|{
  144|    558|    uint32_t bin_size;
  145|    558|    if (!bin_unpack_bin_size(bu, &bin_size) || bin_size > max_data_length) {
  ------------------
  |  Branch (145:9): [True: 27, False: 531]
  |  Branch (145:48): [True: 2, False: 529]
  ------------------
  146|     29|        return false;
  147|     29|    }
  148|       |
  149|    529|    *data_length_ptr = bin_size;
  150|       |
  151|    529|    return bin_unpack_bin_b(bu, data, bin_size);
  152|    558|}
bin_unpack_bin_fixed:
  155|  1.62k|{
  156|  1.62k|    uint32_t bin_size;
  157|  1.62k|    if (!bin_unpack_bin_size(bu, &bin_size) || bin_size != data_length) {
  ------------------
  |  Branch (157:9): [True: 95, False: 1.52k]
  |  Branch (157:48): [True: 7, False: 1.51k]
  ------------------
  158|    102|        return false;
  159|    102|    }
  160|       |
  161|  1.51k|    return bin_unpack_bin_b(bu, data, bin_size);
  162|  1.62k|}
bin_unpack_bin_size:
  165|  2.17k|{
  166|  2.17k|    return cmp_read_bin_size(&bu->ctx, size);
  167|  2.17k|}
bin_unpack_bin_b:
  211|  2.04k|{
  212|  2.04k|    return bu->ctx.read(&bu->ctx, data, length);
  213|  2.04k|}
bin_unpack.c:bin_unpack_init:
   60|  25.8k|{
   61|  25.8k|    bu->mem = mem;
   62|  25.8k|    bu->bytes = buf;
   63|  25.8k|    bu->bytes_size = buf_size;
   64|  25.8k|    cmp_init(&bu->ctx, bu, buf_reader, buf_skipper, null_writer);
   65|  25.8k|}
bin_unpack.c:buf_reader:
   25|   187k|{
   26|   187k|    uint8_t *bytes = (uint8_t *)data;
   27|   187k|    Bin_Unpack *reader = (Bin_Unpack *)ctx->buf;
   28|   187k|    assert(reader != nullptr && reader->bytes != nullptr);
   29|   187k|    if (limit > reader->bytes_size) {
  ------------------
  |  Branch (29:9): [True: 5.02k, False: 182k]
  ------------------
   30|  5.02k|        return false;
   31|  5.02k|    }
   32|   182k|    memcpy(bytes, reader->bytes, limit);
   33|   182k|    reader->bytes += limit;
   34|   182k|    reader->bytes_size -= limit;
   35|   182k|    return true;
   36|   187k|}

get_enc_key:
   66|    140|{
   67|    140|    return key->enc;
   68|    140|}
get_sig_pk:
   71|    128|{
   72|    128|    return key->sig;
   73|    128|}
get_sig_sk:
   81|     64|{
   82|     64|    return key->sig;
   83|     64|}
get_chat_id:
   86|    134|{
   87|    134|    return key->sig;
   88|    134|}
crypto_memzero:
  116|  52.6k|{
  117|  52.6k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  118|  52.6k|    memzero((uint8_t *)data, length);
  119|       |#else
  120|       |    sodium_memzero(data, length);
  121|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  122|  52.6k|}
crypto_memlock:
  125|  22.1k|{
  126|  22.1k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  127|  22.1k|    return false;
  128|       |#else
  129|       |
  130|       |    return sodium_mlock(data, length) == 0;
  131|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  132|  22.1k|}
crypto_memunlock:
  135|  25.7k|{
  136|  25.7k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  137|  25.7k|    return false;
  138|       |#else
  139|       |
  140|       |    return sodium_munlock(data, length) == 0;
  141|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  142|  25.7k|}
pk_equal:
  145|  6.62M|{
  146|  6.62M|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  147|       |    // Hope that this is better for the fuzzer
  148|  6.62M|    return memcmp(pk1, pk2, CRYPTO_PUBLIC_KEY_SIZE) == 0;
  ------------------
  |  |   43|  6.62M|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  149|       |#else
  150|       |    return crypto_verify_32(pk1, pk2) == 0;
  151|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  152|  6.62M|}
pk_copy:
  155|  15.2k|{
  156|  15.2k|    memcpy(dest, src, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|  15.2k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  157|  15.2k|}
random_u32:
  194|  3.74k|{
  195|  3.74k|    uint32_t randnum;
  196|  3.74k|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  197|  3.74k|    return randnum;
  198|  3.74k|}
random_u64:
  201|  6.30k|{
  202|  6.30k|    uint64_t randnum;
  203|  6.30k|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  204|  6.30k|    return randnum;
  205|  6.30k|}
public_key_valid:
  227|    704|{
  228|       |    /* Last bit of key is always zero. */
  229|    704|    return public_key[31] < 128;
  230|    704|}
new_symmetric_key:
  432|  9.45k|{
  433|  9.45k|    random_bytes(rng, key, CRYPTO_SYMMETRIC_KEY_SIZE);
  ------------------
  |  |   58|  9.45k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  ------------------
  |  |  |  |   53|  9.45k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  ------------------
  ------------------
  434|  9.45k|}
crypto_new_keypair:
  439|  16.4k|{
  440|  16.4k|    random_bytes(rng, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   48|  16.4k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
  441|  16.4k|    memzero(public_key, CRYPTO_PUBLIC_KEY_SIZE);  // Make MSAN happy
  ------------------
  |  |   43|  16.4k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  442|  16.4k|    crypto_derive_public_key(public_key, secret_key);
  443|  16.4k|    return 0;
  444|  16.4k|}
crypto_derive_public_key:
  448|  20.5k|{
  449|  20.5k|    crypto_scalarmult_curve25519_base(public_key, secret_key);
  450|  20.5k|}
new_hmac_key:
  453|  9.45k|{
  454|  9.45k|    random_bytes(rng, key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  162|  9.45k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  455|  9.45k|}
os_random:
  518|  3.15k|{
  519|  3.15k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  520|  3.15k|    if ((true)) {
  ------------------
  |  Branch (520:9): [Folded - Ignored]
  ------------------
  521|  3.15k|        return nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  522|  3.15k|    }
  523|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  524|       |    // It is safe to call this function more than once and from different
  525|       |    // threads -- subsequent calls won't have any effects.
  526|      0|    if (sodium_init() == -1) {
  ------------------
  |  Branch (526:9): [True: 0, False: 0]
  ------------------
  527|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  528|      0|    }
  529|      0|    return &os_random_obj;
  530|      0|}
random_bytes:
  533|  45.4k|{
  534|  45.4k|    rng->funcs->random_bytes(rng->obj, bytes, length);
  535|  45.4k|}

pack_extended_public_key:
   16|    228|{
   17|    228|    uint8_t ext_key[EXT_PUBLIC_KEY_SIZE];
   18|    228|    static_assert(sizeof(ext_key) == sizeof(key->enc) + sizeof(key->sig),
  ------------------
  |  |   67|    228|#define static_assert _Static_assert
  ------------------
   19|    228|                  "extended secret key size is not the sum of the encryption and sign secret key sizes");
   20|    228|    memcpy(ext_key, key->enc, sizeof(key->enc));
   21|    228|    memcpy(&ext_key[sizeof(key->enc)], key->sig, sizeof(key->sig));
   22|       |
   23|    228|    return bin_pack_bin(bp, ext_key, sizeof(ext_key));
   24|    228|}
pack_extended_secret_key:
   27|    152|{
   28|    152|    uint8_t ext_key[EXT_SECRET_KEY_SIZE];
   29|    152|    static_assert(sizeof(ext_key) == sizeof(key->enc) + sizeof(key->sig),
  ------------------
  |  |   67|    152|#define static_assert _Static_assert
  ------------------
   30|    152|                  "extended secret key size is not the sum of the encryption and sign secret key sizes");
   31|    152|    memcpy(ext_key, key->enc, sizeof(key->enc));
   32|    152|    memcpy(&ext_key[sizeof(key->enc)], key->sig, sizeof(key->sig));
   33|       |
   34|    152|    const bool result = bin_pack_bin(bp, ext_key, sizeof(ext_key));
   35|    152|    crypto_memzero(ext_key, sizeof(ext_key));
   36|    152|    return result;
   37|    152|}
unpack_extended_public_key:
   40|    453|{
   41|    453|    uint8_t ext_key[EXT_PUBLIC_KEY_SIZE];
   42|       |
   43|    453|    if (!bin_unpack_bin_fixed(bu, ext_key, sizeof(ext_key))) {
  ------------------
  |  Branch (43:9): [True: 42, False: 411]
  ------------------
   44|     42|        return false;
   45|     42|    }
   46|       |
   47|    411|    memcpy(key->enc, ext_key, sizeof(key->enc));
   48|    411|    memcpy(key->sig, &ext_key[sizeof(key->enc)], sizeof(key->sig));
   49|       |
   50|    411|    return true;
   51|    453|}
unpack_extended_secret_key:
   54|    204|{
   55|    204|    uint8_t ext_key[EXT_SECRET_KEY_SIZE];
   56|       |
   57|    204|    if (!bin_unpack_bin_fixed(bu, ext_key, sizeof(ext_key))) {
  ------------------
  |  Branch (57:9): [True: 18, False: 186]
  ------------------
   58|     18|        return false;
   59|     18|    }
   60|       |
   61|    186|    memcpy(key->enc, ext_key, sizeof(key->enc));
   62|    186|    memcpy(key->sig, &ext_key[sizeof(key->enc)], sizeof(key->sig));
   63|    186|    crypto_memzero(ext_key, sizeof(ext_key));
   64|       |
   65|    186|    return true;
   66|    204|}

forwarding_get_dht:
   41|  3.15k|{
   42|  3.15k|    return forwarding->dht;
   43|  3.15k|}
set_callback_forwarded_request:
  344|  6.30k|{
  345|  6.30k|    forwarding->forwarded_request_callback = function;
  346|  6.30k|    forwarding->forwarded_request_callback_object = object;
  347|  6.30k|}
new_forwarding:
  362|  3.15k|{
  363|  3.15k|    if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (363:9): [True: 0, False: 3.15k]
  |  Branch (363:27): [True: 0, False: 3.15k]
  |  Branch (363:51): [True: 0, False: 3.15k]
  ------------------
  364|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  365|      0|    }
  366|       |
  367|  3.15k|    Forwarding *forwarding = (Forwarding *)mem_alloc(mem, sizeof(Forwarding));
  368|       |
  369|  3.15k|    if (forwarding == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (369:9): [True: 0, False: 3.15k]
  ------------------
  370|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  371|      0|    }
  372|       |
  373|  3.15k|    forwarding->log = log;
  374|  3.15k|    forwarding->mem = mem;
  375|  3.15k|    forwarding->rng = rng;
  376|  3.15k|    forwarding->mono_time = mono_time;
  377|  3.15k|    forwarding->dht = dht;
  378|  3.15k|    forwarding->net = dht_get_net(dht);
  379|       |
  380|  3.15k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, &handle_forward_request, forwarding);
  381|  3.15k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, &handle_forward_reply, forwarding);
  382|  3.15k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, &handle_forwarding, forwarding);
  383|       |
  384|  3.15k|    new_hmac_key(forwarding->rng, forwarding->hmac_key);
  385|       |
  386|  3.15k|    return forwarding;
  387|  3.15k|}
kill_forwarding:
  390|  3.15k|{
  391|  3.15k|    if (forwarding == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (391:9): [True: 0, False: 3.15k]
  ------------------
  392|      0|        return;
  393|      0|    }
  394|       |
  395|  3.15k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  396|  3.15k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  397|  3.15k|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  398|       |
  399|  3.15k|    crypto_memzero(forwarding->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  162|  3.15k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  400|       |
  401|  3.15k|    mem_delete(forwarding->mem, forwarding);
  402|  3.15k|}

friend_conn_get_onion_friendnum:
   95|     64|{
   96|     64|    return fc->onion_friendnum;
   97|     64|}
get_conn:
  201|  2.58k|{
  202|  2.58k|    if (!friendconn_id_valid(fr_c, friendcon_id)) {
  ------------------
  |  Branch (202:9): [True: 0, False: 2.58k]
  ------------------
  203|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  204|      0|    }
  205|       |
  206|  2.58k|    return &fr_c->conns[friendcon_id];
  207|  2.58k|}
getfriend_conn_id_pk:
  214|    590|{
  215|  1.27k|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (215:26): [True: 689, False: 582]
  ------------------
  216|    689|        const Friend_Conn *friend_con = get_conn(fr_c, i);
  217|       |
  218|    689|        if (friend_con != nullptr) {
  ------------------
  |  |   63|    689|#define nullptr NULL
  ------------------
  |  Branch (218:13): [True: 689, False: 0]
  ------------------
  219|    689|            if (pk_equal(friend_con->real_public_key, real_pk)) {
  ------------------
  |  Branch (219:17): [True: 8, False: 681]
  ------------------
  220|      8|                return i;
  221|      8|            }
  222|    689|        }
  223|    689|    }
  224|       |
  225|    582|    return -1;
  226|    590|}
friend_con_connected:
  684|    654|{
  685|    654|    const Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  686|       |
  687|    654|    if (friend_con == nullptr) {
  ------------------
  |  |   63|    654|#define nullptr NULL
  ------------------
  |  Branch (687:9): [True: 0, False: 654]
  ------------------
  688|      0|        return 0;
  689|      0|    }
  690|       |
  691|    654|    return friend_con->status;
  692|    654|}
friend_connection_callbacks:
  736|    590|{
  737|    590|    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  738|       |
  739|    590|    if (friend_con == nullptr) {
  ------------------
  |  |   63|    590|#define nullptr NULL
  ------------------
  |  Branch (739:9): [True: 0, False: 590]
  ------------------
  740|      0|        return -1;
  741|      0|    }
  742|       |
  743|    590|    if (index >= MAX_FRIEND_CONNECTION_CALLBACKS) {
  ------------------
  |  |   23|    590|#define MAX_FRIEND_CONNECTION_CALLBACKS 2
  ------------------
  |  Branch (743:9): [True: 0, False: 590]
  ------------------
  744|      0|        return -1;
  745|      0|    }
  746|       |
  747|    590|    if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   63|  1.18k|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   63|  1.05k|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   63|  1.05k|#define nullptr NULL
  ------------------
                  if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
  ------------------
  |  |   63|    526|#define nullptr NULL
  ------------------
  |  Branch (747:9): [True: 526, False: 64]
  |  Branch (747:31): [True: 0, False: 526]
  |  Branch (747:61): [True: 0, False: 526]
  |  Branch (747:89): [True: 0, False: 526]
  ------------------
  748|      0|        LOGGER_ERROR(fr_c->logger, "non-null user data object but null callbacks");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  749|      0|        return -1;
  750|      0|    }
  751|       |
  752|    590|    friend_con->callbacks[index].status_callback = status_callback;
  753|    590|    friend_con->callbacks[index].data_callback = data_callback;
  754|    590|    friend_con->callbacks[index].lossy_data_callback = lossy_data_callback;
  755|       |
  756|    590|    friend_con->callbacks[index].callback_object = object;
  757|    590|    friend_con->callbacks[index].callback_id = number;
  758|       |
  759|    590|    return 0;
  760|    590|}
set_global_status_callback:
  764|  6.30k|{
  765|  6.30k|    if (object != nullptr && global_status_callback == nullptr) {
  ------------------
  |  |   63|  12.6k|#define nullptr NULL
  ------------------
                  if (object != nullptr && global_status_callback == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (765:9): [True: 3.15k, False: 3.15k]
  |  Branch (765:30): [True: 0, False: 3.15k]
  ------------------
  766|      0|        LOGGER_ERROR(fr_c->logger, "non-null user data object but null callback");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  767|      0|        object = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  768|      0|    }
  769|       |
  770|  6.30k|    fr_c->global_status_callback = global_status_callback;
  771|  6.30k|    fr_c->global_status_callback_object = object;
  772|  6.30k|}
new_friend_connection:
  797|    590|{
  798|    590|    int friendcon_id = getfriend_conn_id_pk(fr_c, real_public_key);
  799|       |
  800|    590|    if (friendcon_id != -1) {
  ------------------
  |  Branch (800:9): [True: 8, False: 582]
  ------------------
  801|      8|        ++fr_c->conns[friendcon_id].lock_count;
  802|      8|        return friendcon_id;
  803|      8|    }
  804|       |
  805|    582|    friendcon_id = create_friend_conn(fr_c);
  806|       |
  807|    582|    if (friendcon_id == -1) {
  ------------------
  |  Branch (807:9): [True: 0, False: 582]
  ------------------
  808|      0|        return -1;
  809|      0|    }
  810|       |
  811|    582|    const int32_t onion_friendnum = onion_addfriend(fr_c->onion_c, real_public_key);
  812|       |
  813|    582|    if (onion_friendnum == -1) {
  ------------------
  |  Branch (813:9): [True: 0, False: 582]
  ------------------
  814|      0|        return -1;
  815|      0|    }
  816|       |
  817|    582|    Friend_Conn *const friend_con = &fr_c->conns[friendcon_id];
  818|       |
  819|    582|    friend_con->crypt_connection_id = -1;
  820|    582|    friend_con->status = FRIENDCONN_STATUS_CONNECTING;
  821|    582|    memcpy(friend_con->real_public_key, real_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|    582|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  822|    582|    friend_con->onion_friendnum = onion_friendnum;
  823|       |
  824|    582|    recv_tcp_relay_handler(fr_c->onion_c, onion_friendnum, &tcp_relay_node_callback, fr_c, friendcon_id);
  825|    582|    onion_dht_pk_callback(fr_c->onion_c, onion_friendnum, &dht_pk_callback, fr_c, friendcon_id);
  826|       |
  827|    582|    return friendcon_id;
  828|    582|}
kill_friend_connection:
  836|    590|{
  837|    590|    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);
  838|       |
  839|    590|    if (friend_con == nullptr) {
  ------------------
  |  |   63|    590|#define nullptr NULL
  ------------------
  |  Branch (839:9): [True: 0, False: 590]
  ------------------
  840|      0|        return -1;
  841|      0|    }
  842|       |
  843|    590|    if (friend_con->lock_count > 0) {
  ------------------
  |  Branch (843:9): [True: 8, False: 582]
  ------------------
  844|      8|        --friend_con->lock_count;
  845|      8|        return 0;
  846|      8|    }
  847|       |
  848|    582|    onion_delfriend(fr_c->onion_c, friend_con->onion_friendnum);
  849|    582|    crypto_kill(fr_c->net_crypto, friend_con->crypt_connection_id);
  850|       |
  851|    582|    if (friend_con->dht_lock_token > 0) {
  ------------------
  |  Branch (851:9): [True: 0, False: 582]
  ------------------
  852|      0|        dht_delfriend(fr_c->dht, friend_con->dht_temp_pk, friend_con->dht_lock_token);
  853|      0|        friend_con->dht_lock_token = 0;
  854|      0|    }
  855|       |
  856|    582|    return wipe_friend_conn(fr_c, friendcon_id);
  857|    590|}
set_friend_request_callback:
  864|  3.15k|{
  865|  3.15k|    fr_c->fr_request_callback = fr_request_callback;
  866|  3.15k|    fr_c->fr_request_object = object;
  867|  3.15k|    oniondata_registerhandler(fr_c->onion_c, CRYPTO_PACKET_FRIEND_REQ, fr_request_callback, object);
  ------------------
  |  |   66|  3.15k|#define CRYPTO_PACKET_FRIEND_REQ    32  // Friend request crypto packet ID.
  ------------------
  868|  3.15k|}
new_friend_connections:
  918|  3.15k|{
  919|  3.15k|    if (onion_c == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (919:9): [True: 0, False: 3.15k]
  ------------------
  920|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  921|      0|    }
  922|       |
  923|  3.15k|    Friend_Connections *const temp = (Friend_Connections *)mem_alloc(mem, sizeof(Friend_Connections));
  924|       |
  925|  3.15k|    if (temp == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (925:9): [True: 0, False: 3.15k]
  ------------------
  926|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  927|      0|    }
  928|       |
  929|  3.15k|    temp->local_discovery_enabled = local_discovery_enabled;
  930|       |
  931|  3.15k|    if (temp->local_discovery_enabled) {
  ------------------
  |  Branch (931:9): [True: 3.15k, False: 0]
  ------------------
  932|  3.15k|        temp->broadcast = lan_discovery_init(mem, ns);
  933|       |
  934|  3.15k|        if (temp->broadcast == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (934:13): [True: 0, False: 3.15k]
  ------------------
  935|      0|            LOGGER_ERROR(logger, "could not initialise LAN discovery");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  936|      0|            temp->local_discovery_enabled = false;
  937|      0|        }
  938|  3.15k|    }
  939|       |
  940|  3.15k|    temp->mono_time = mono_time;
  941|  3.15k|    temp->mem = mem;
  942|  3.15k|    temp->logger = logger;
  943|  3.15k|    temp->dht = onion_get_dht(onion_c);
  944|  3.15k|    temp->net_crypto = onion_get_net_crypto(onion_c);
  945|  3.15k|    temp->onion_c = onion_c;
  946|       |    // Don't include default port in port range
  947|  3.15k|    temp->next_lan_port = TOX_PORTRANGE_FROM + 1;
  ------------------
  |  |  162|  3.15k|#define TOX_PORTRANGE_FROM 33445
  ------------------
  948|       |
  949|  3.15k|    new_connection_handler(temp->net_crypto, &handle_new_connections, temp);
  950|       |
  951|  3.15k|    return temp;
  952|  3.15k|}
kill_friend_connections:
 1032|  3.15k|{
 1033|  3.15k|    if (fr_c == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1033:9): [True: 0, False: 3.15k]
  ------------------
 1034|      0|        return;
 1035|      0|    }
 1036|       |
 1037|  3.67k|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (1037:26): [True: 526, False: 3.15k]
  ------------------
 1038|    526|        kill_friend_connection(fr_c, i);
 1039|    526|    }
 1040|       |
 1041|       |    // there might be allocated NONE connections
 1042|  3.15k|    if (fr_c->conns != nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1042:9): [True: 0, False: 3.15k]
  ------------------
 1043|      0|        mem_delete(fr_c->mem, fr_c->conns);
 1044|      0|    }
 1045|       |
 1046|  3.15k|    lan_discovery_kill(fr_c->broadcast);
 1047|  3.15k|    mem_delete(fr_c->mem, fr_c);
 1048|  3.15k|}
friend_connection.c:friendconn_id_valid:
  115|  3.16k|{
  116|  3.16k|    return (unsigned int)friendcon_id < fr_c->num_cons &&
  ------------------
  |  Branch (116:12): [True: 3.16k, False: 0]
  ------------------
  117|  3.16k|           fr_c->conns != nullptr &&
  ------------------
  |  |   63|  6.33k|#define nullptr NULL
  ------------------
  |  Branch (117:12): [True: 3.16k, False: 0]
  ------------------
  118|  3.16k|           fr_c->conns[friendcon_id].status != FRIENDCONN_STATUS_NONE;
  ------------------
  |  Branch (118:12): [True: 3.16k, False: 0]
  ------------------
  119|  3.16k|}
friend_connection.c:create_friend_conn:
  152|    582|{
  153|  1.26k|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (153:26): [True: 681, False: 582]
  ------------------
  154|    681|        if (fr_c->conns[i].status == FRIENDCONN_STATUS_NONE) {
  ------------------
  |  Branch (154:13): [True: 0, False: 681]
  ------------------
  155|      0|            return i;
  156|      0|        }
  157|    681|    }
  158|       |
  159|    582|    if (!realloc_friendconns(fr_c, fr_c->num_cons + 1)) {
  ------------------
  |  Branch (159:9): [True: 0, False: 582]
  ------------------
  160|      0|        return -1;
  161|      0|    }
  162|       |
  163|    582|    const int id = fr_c->num_cons;
  164|    582|    ++fr_c->num_cons;
  165|    582|    fr_c->conns[id] = empty_friend_conn;
  166|       |
  167|    582|    return id;
  168|    582|}
friend_connection.c:realloc_friendconns:
  128|    895|{
  129|    895|    if (num == 0) {
  ------------------
  |  Branch (129:9): [True: 274, False: 621]
  ------------------
  130|    274|        mem_delete(fr_c->mem, fr_c->conns);
  131|    274|        fr_c->conns = nullptr;
  ------------------
  |  |   63|    274|#define nullptr NULL
  ------------------
  132|    274|        return true;
  133|    274|    }
  134|       |
  135|    621|    Friend_Conn *newgroup_cons = (Friend_Conn *)mem_vrealloc(fr_c->mem, fr_c->conns, num, sizeof(Friend_Conn));
  136|       |
  137|    621|    if (newgroup_cons == nullptr) {
  ------------------
  |  |   63|    621|#define nullptr NULL
  ------------------
  |  Branch (137:9): [True: 0, False: 621]
  ------------------
  138|      0|        return false;
  139|      0|    }
  140|       |
  141|    621|    fr_c->conns = newgroup_cons;
  142|    621|    return true;
  143|    621|}
friend_connection.c:wipe_friend_conn:
  177|    582|{
  178|    582|    if (!friendconn_id_valid(fr_c, friendcon_id)) {
  ------------------
  |  Branch (178:9): [True: 0, False: 582]
  ------------------
  179|      0|        return -1;
  180|      0|    }
  181|       |
  182|    582|    fr_c->conns[friendcon_id] = empty_friend_conn;
  183|       |
  184|    582|    uint32_t i;
  185|       |
  186|  1.16k|    for (i = fr_c->num_cons; i != 0; --i) {
  ------------------
  |  Branch (186:30): [True: 890, False: 274]
  ------------------
  187|    890|        if (fr_c->conns[i - 1].status != FRIENDCONN_STATUS_NONE) {
  ------------------
  |  Branch (187:13): [True: 308, False: 582]
  ------------------
  188|    308|            break;
  189|    308|        }
  190|    890|    }
  191|       |
  192|    582|    if (fr_c->num_cons != i) {
  ------------------
  |  Branch (192:9): [True: 313, False: 269]
  ------------------
  193|    313|        fr_c->num_cons = i;
  194|    313|        realloc_friendconns(fr_c, fr_c->num_cons);
  195|    313|    }
  196|       |
  197|    582|    return 0;
  198|    582|}

set_nospam:
   54|  4.12k|{
   55|  4.12k|    fr->nospam = num;
   56|  4.12k|}
get_nospam:
   59|    615|{
   60|    615|    return fr->nospam;
   61|    615|}
callback_friendrequest:
   65|  3.15k|{
   66|  3.15k|    fr->handle_friendrequest = function;
   67|  3.15k|    fr->handle_friendrequest_isset = 1;
   68|  3.15k|    fr->handle_friendrequest_object = object;
   69|  3.15k|}
set_filter_function:
   75|  3.15k|{
   76|  3.15k|    fr->filter_function = function;
   77|  3.15k|    fr->filter_function_userdata = userdata;
   78|  3.15k|}
remove_request_received:
  115|     64|{
  116|  2.11k|    for (uint32_t i = 0; i < MAX_RECEIVED_STORED; ++i) {
  ------------------
  |  |   31|  2.11k|#define MAX_RECEIVED_STORED 32
  ------------------
  |  Branch (116:26): [True: 2.04k, False: 64]
  ------------------
  117|  2.04k|        if (pk_equal(fr->received.requests[i], real_pk)) {
  ------------------
  |  Branch (117:13): [True: 0, False: 2.04k]
  ------------------
  118|      0|            crypto_memzero(fr->received.requests[i], CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  119|      0|            return 0;
  120|      0|        }
  121|  2.04k|    }
  122|       |
  123|     64|    return -1;
  124|     64|}
friendreq_init:
  169|  3.15k|{
  170|  3.15k|    set_friend_request_callback(fr_c, &friendreq_handlepacket, fr);
  171|  3.15k|}
friendreq_new:
  174|  3.15k|{
  175|  3.15k|    Friend_Requests *fr = (Friend_Requests *)mem_alloc(mem, sizeof(Friend_Requests));
  176|       |
  177|  3.15k|    if (fr == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (177:9): [True: 0, False: 3.15k]
  ------------------
  178|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  179|      0|    }
  180|       |
  181|  3.15k|    fr->mem = mem;
  182|       |
  183|  3.15k|    return fr;
  184|  3.15k|}
friendreq_kill:
  187|  3.15k|{
  188|  3.15k|    if (fr == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (188:9): [True: 0, False: 3.15k]
  ------------------
  189|      0|        return;
  190|      0|    }
  191|       |
  192|  3.15k|    mem_delete(fr->mem, fr);
  193|  3.15k|}

del_groupchat:
 1410|  1.54k|{
 1411|  1.54k|    Group_c *g = get_group_c(g_c, groupnumber);
 1412|       |
 1413|  1.54k|    if (g == nullptr) {
  ------------------
  |  |   63|  1.54k|#define nullptr NULL
  ------------------
  |  Branch (1413:9): [True: 0, False: 1.54k]
  ------------------
 1414|      0|        return false;
 1415|      0|    }
 1416|       |
 1417|  1.54k|    group_leave(g_c, groupnumber, leave_permanently);
 1418|       |
 1419|  26.1k|    for (uint32_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
  ------------------
  |  |   56|  26.1k|#define MAX_GROUP_CONNECTIONS 16
  ------------------
  |  Branch (1419:26): [True: 24.6k, False: 1.54k]
  ------------------
 1420|  24.6k|        if (g->connections[i].type == GROUPCHAT_CONNECTION_NONE) {
  ------------------
  |  Branch (1420:13): [True: 24.6k, False: 0]
  ------------------
 1421|  24.6k|            continue;
 1422|  24.6k|        }
 1423|       |
 1424|      0|        g->connections[i].type = GROUPCHAT_CONNECTION_NONE;
 1425|      0|        kill_friend_connection(g_c->fr_c, g->connections[i].number);
 1426|      0|    }
 1427|       |
 1428|  3.08k|    for (uint32_t i = 0; i < g->numpeers; ++i) {
  ------------------
  |  Branch (1428:26): [True: 1.54k, False: 1.54k]
  ------------------
 1429|  1.54k|        if (g->peer_on_leave != nullptr) {
  ------------------
  |  |   63|  1.54k|#define nullptr NULL
  ------------------
  |  Branch (1429:13): [True: 0, False: 1.54k]
  ------------------
 1430|      0|            g->peer_on_leave(g->object, groupnumber, g->group[i].object);
 1431|      0|        }
 1432|  1.54k|    }
 1433|       |
 1434|  1.54k|    if (g->group_on_delete != nullptr) {
  ------------------
  |  |   63|  1.54k|#define nullptr NULL
  ------------------
  |  Branch (1434:9): [True: 0, False: 1.54k]
  ------------------
 1435|      0|        g->group_on_delete(g->object, groupnumber);
 1436|      0|    }
 1437|       |
 1438|  1.54k|    return wipe_group_chat(g_c, groupnumber);
 1439|  1.54k|}
g_callback_group_invite:
 1884|    615|{
 1885|    615|    g_c->invite_callback = function;
 1886|    615|}
g_callback_group_connected:
 1890|    615|{
 1891|    615|    g_c->connected_callback = function;
 1892|    615|}
g_callback_group_message:
 1896|    615|{
 1897|    615|    g_c->message_callback = function;
 1898|    615|}
g_callback_peer_name:
 1905|    615|{
 1906|    615|    g_c->peer_name_callback = function;
 1907|    615|}
g_callback_peer_list_changed:
 1914|    615|{
 1915|    615|    g_c->peer_list_changed_callback = function;
 1916|    615|}
g_callback_group_title:
 1920|    615|{
 1921|    615|    g_c->title_callback = function;
 1922|    615|}
conferences_size:
 3586|  1.23k|{
 3587|  1.23k|    return 2 * sizeof(uint32_t) + conferences_section_size(g_c);
 3588|  1.23k|}
conferences_save:
 3591|    615|{
 3592|    615|    const uint32_t len = conferences_section_size(g_c);
 3593|    615|    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_CONFERENCES);
  ------------------
  |  |   29|    615|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 3594|       |
 3595|  1.47k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3595:26): [True: 862, False: 615]
  ------------------
 3596|    862|        const Group_c *g = get_group_c(g_c, i);
 3597|       |
 3598|    862|        if (g == nullptr || g->status != GROUPCHAT_STATUS_CONNECTED) {
  ------------------
  |  |   63|  1.72k|#define nullptr NULL
  ------------------
  |  Branch (3598:13): [True: 0, False: 862]
  |  Branch (3598:29): [True: 0, False: 862]
  ------------------
 3599|      0|            continue;
 3600|      0|        }
 3601|       |
 3602|    862|        data = save_conf(g, data);
 3603|    862|    }
 3604|       |
 3605|    615|    return data;
 3606|    615|}
conferences_load_state_section:
 3798|  1.79k|{
 3799|  1.79k|    if (type != STATE_TYPE_CONFERENCES) {
  ------------------
  |  Branch (3799:9): [True: 1.38k, False: 408]
  ------------------
 3800|  1.38k|        return false;
 3801|  1.38k|    }
 3802|       |
 3803|    408|    *status = load_conferences(g_c, data, length);
 3804|    408|    return true;
 3805|  1.79k|}
new_groupchats:
 3809|  3.15k|{
 3810|  3.15k|    if (m == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3810:9): [True: 0, False: 3.15k]
  ------------------
 3811|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3812|      0|    }
 3813|       |
 3814|  3.15k|    Group_Chats *temp = (Group_Chats *)mem_alloc(mem, sizeof(Group_Chats));
 3815|       |
 3816|  3.15k|    if (temp == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3816:9): [True: 0, False: 3.15k]
  ------------------
 3817|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3818|      0|    }
 3819|       |
 3820|  3.15k|    temp->mem = mem;
 3821|  3.15k|    temp->mono_time = mono_time;
 3822|  3.15k|    temp->m = m;
 3823|  3.15k|    temp->fr_c = m->fr_c;
 3824|  3.15k|    m_callback_conference_invite(m, &handle_friend_invite_packet);
 3825|       |
 3826|  3.15k|    set_global_status_callback(m->fr_c, &g_handle_any_status, temp);
 3827|       |
 3828|  3.15k|    return temp;
 3829|  3.15k|}
kill_groupchats:
 3859|  3.15k|{
 3860|  3.15k|    if (g_c == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3860:9): [True: 0, False: 3.15k]
  ------------------
 3861|      0|        return;
 3862|      0|    }
 3863|       |
 3864|  4.69k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3864:26): [True: 1.54k, False: 3.15k]
  ------------------
 3865|  1.54k|        del_groupchat(g_c, i, false);
 3866|  1.54k|    }
 3867|       |
 3868|  3.15k|    m_callback_conference_invite(g_c->m, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 3869|  3.15k|    set_global_status_callback(g_c->m->fr_c, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  set_global_status_callback(g_c->m->fr_c, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 3870|  3.15k|    g_c->m->conferences_object = nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 3871|  3.15k|    mem_delete(g_c->mem, g_c);
 3872|  3.15k|}
group.c:create_group_chat:
  287|  4.37k|{
  288|   185k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (288:26): [True: 181k, False: 4.37k]
  ------------------
  289|   181k|        if (g_c->chats[i].status == GROUPCHAT_STATUS_NONE) {
  ------------------
  |  Branch (289:13): [True: 0, False: 181k]
  ------------------
  290|      0|            return i;
  291|      0|        }
  292|   181k|    }
  293|       |
  294|  4.37k|    if (realloc_conferences(g_c, g_c->num_chats + 1)) {
  ------------------
  |  Branch (294:9): [True: 4.37k, False: 0]
  ------------------
  295|  4.37k|        const uint16_t id = g_c->num_chats;
  296|  4.37k|        ++g_c->num_chats;
  297|  4.37k|        setup_conference(&g_c->chats[id]);
  298|  4.37k|        return id;
  299|  4.37k|    }
  300|       |
  301|      0|    return -1;
  302|  4.37k|}
group.c:realloc_conferences:
  256|  4.57k|{
  257|  4.57k|    if (num == 0) {
  ------------------
  |  Branch (257:9): [True: 148, False: 4.42k]
  ------------------
  258|    148|        mem_delete(g_c->mem, g_c->chats);
  259|    148|        g_c->chats = nullptr;
  ------------------
  |  |   63|    148|#define nullptr NULL
  ------------------
  260|    148|        return true;
  261|    148|    }
  262|       |
  263|  4.42k|    Group_c *newgroup_chats = (Group_c *)mem_vrealloc(g_c->mem, g_c->chats, num, sizeof(Group_c));
  264|       |
  265|  4.42k|    if (newgroup_chats == nullptr) {
  ------------------
  |  |   63|  4.42k|#define nullptr NULL
  ------------------
  |  Branch (265:9): [True: 0, False: 4.42k]
  ------------------
  266|      0|        return false;
  267|      0|    }
  268|       |
  269|  4.42k|    g_c->chats = newgroup_chats;
  270|  4.42k|    return true;
  271|  4.42k|}
group.c:setup_conference:
  275|  8.75k|{
  276|  8.75k|    *g = empty_group_c;
  277|  8.75k|    g->maxfrozen = MAX_FROZEN_DEFAULT;
  ------------------
  |  |   61|  8.75k|#define MAX_FROZEN_DEFAULT 128
  ------------------
  278|  8.75k|}
group.c:addpeer:
  801|  4.31k|{
  802|  4.31k|    Group_c *g = get_group_c(g_c, groupnumber);
  803|       |
  804|  4.31k|    if (g == nullptr) {
  ------------------
  |  |   63|  4.31k|#define nullptr NULL
  ------------------
  |  Branch (804:9): [True: 0, False: 4.31k]
  ------------------
  805|      0|        return -1;
  806|      0|    }
  807|       |
  808|  4.31k|    const int peer_index = fresh ?
  ------------------
  |  Branch (808:28): [True: 4.31k, False: 0]
  ------------------
  809|  4.31k|                           note_peer_active(g_c, groupnumber, peer_number, userdata) :
  810|  4.31k|                           get_peer_index(g, peer_number);
  811|       |
  812|  4.31k|    if (peer_index != -1) {
  ------------------
  |  Branch (812:9): [True: 49, False: 4.26k]
  ------------------
  813|     49|        if (!pk_equal(g->group[peer_index].real_pk, real_pk)) {
  ------------------
  |  Branch (813:13): [True: 14, False: 35]
  ------------------
  814|     14|            LOGGER_ERROR(g_c->m->log, "peer public key is incorrect for peer %d", peer_number);
  ------------------
  |  |   87|     14|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     14|    do {                                                                         \
  |  |  |  |   77|     14|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     28|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     14|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     14|        }                                                                        \
  |  |  |  |   80|     14|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  815|     14|            return -1;
  816|     14|        }
  817|       |
  818|     35|        if (fresh || !g->group[peer_index].temp_pk_updated) {
  ------------------
  |  Branch (818:13): [True: 35, False: 0]
  |  Branch (818:22): [True: 0, False: 0]
  ------------------
  819|     35|            pk_copy(g->group[peer_index].temp_pk, temp_pk);
  820|     35|            g->group[peer_index].temp_pk_updated = true;
  821|     35|        }
  822|       |
  823|     35|        return peer_index;
  824|     49|    }
  825|       |
  826|  4.26k|    if (!fresh) {
  ------------------
  |  Branch (826:9): [True: 0, False: 4.26k]
  ------------------
  827|      0|        const int frozen_index = get_frozen_index(g, peer_number);
  828|       |
  829|      0|        if (frozen_index != -1) {
  ------------------
  |  Branch (829:13): [True: 0, False: 0]
  ------------------
  830|      0|            if (!pk_equal(g->frozen[frozen_index].real_pk, real_pk)) {
  ------------------
  |  Branch (830:17): [True: 0, False: 0]
  ------------------
  831|      0|                return -1;
  832|      0|            }
  833|       |
  834|      0|            pk_copy(g->frozen[frozen_index].temp_pk, temp_pk);
  835|       |
  836|      0|            return -1;
  837|      0|        }
  838|      0|    }
  839|       |
  840|  4.26k|    delete_any_peer_with_pk(g_c, groupnumber, real_pk, userdata);
  841|       |
  842|  4.26k|    Group_Peer *temp = (Group_Peer *)mem_vrealloc(g_c->mem, g->group, g->numpeers + 1, sizeof(Group_Peer));
  843|       |
  844|  4.26k|    if (temp == nullptr) {
  ------------------
  |  |   63|  4.26k|#define nullptr NULL
  ------------------
  |  Branch (844:9): [True: 0, False: 4.26k]
  ------------------
  845|      0|        return -1;
  846|      0|    }
  847|       |
  848|  4.26k|    temp[g->numpeers] = empty_group_peer;
  849|  4.26k|    g->group = temp;
  850|       |
  851|  4.26k|    const uint32_t new_index = g->numpeers;
  852|       |
  853|  4.26k|    pk_copy(g->group[new_index].real_pk, real_pk);
  854|  4.26k|    pk_copy(g->group[new_index].temp_pk, temp_pk);
  855|  4.26k|    g->group[new_index].temp_pk_updated = true;
  856|  4.26k|    g->group[new_index].peer_number = peer_number;
  857|  4.26k|    g->group[new_index].last_active = mono_time_get(g_c->mono_time);
  858|  4.26k|    g->group[new_index].is_friend = getfriend_id(g_c->m, real_pk) != -1;
  859|  4.26k|    ++g->numpeers;
  860|       |
  861|  4.26k|    add_to_closest(g, real_pk, temp_pk);
  862|       |
  863|  4.26k|    if (do_gc_callback && g_c->peer_list_changed_callback != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (863:9): [True: 0, False: 4.26k]
  |  Branch (863:27): [True: 0, False: 0]
  ------------------
  864|      0|        g_c->peer_list_changed_callback(g_c->m, groupnumber, userdata);
  865|      0|    }
  866|       |
  867|  4.26k|    if (g->peer_on_join != nullptr) {
  ------------------
  |  |   63|  4.26k|#define nullptr NULL
  ------------------
  |  Branch (867:9): [True: 0, False: 4.26k]
  ------------------
  868|      0|        g->peer_on_join(g->object, groupnumber, new_index);
  869|      0|    }
  870|       |
  871|  4.26k|    return new_index;
  872|  4.26k|}
group.c:note_peer_active:
  707|  4.31k|{
  708|  4.31k|    Group_c *g = get_group_c(g_c, groupnumber);
  709|       |
  710|  4.31k|    if (g == nullptr) {
  ------------------
  |  |   63|  4.31k|#define nullptr NULL
  ------------------
  |  Branch (710:9): [True: 0, False: 4.31k]
  ------------------
  711|      0|        return -1;
  712|      0|    }
  713|       |
  714|  4.31k|    const int peer_index = get_peer_index(g, peer_number);
  715|       |
  716|  4.31k|    if (peer_index != -1) {
  ------------------
  |  Branch (716:9): [True: 0, False: 4.31k]
  ------------------
  717|      0|        g->group[peer_index].last_active = mono_time_get(g_c->mono_time);
  718|      0|        return peer_index;
  719|      0|    }
  720|       |
  721|  4.31k|    const int frozen_index = get_frozen_index(g, peer_number);
  722|       |
  723|  4.31k|    if (frozen_index == -1) {
  ------------------
  |  Branch (723:9): [True: 4.26k, False: 49]
  ------------------
  724|  4.26k|        return -1;
  725|  4.26k|    }
  726|       |
  727|       |    /* Now thaw the peer */
  728|       |
  729|     49|    Group_Peer *temp = (Group_Peer *)mem_vrealloc(g_c->mem, g->group, g->numpeers + 1, sizeof(Group_Peer));
  730|       |
  731|     49|    if (temp == nullptr) {
  ------------------
  |  |   63|     49|#define nullptr NULL
  ------------------
  |  Branch (731:9): [True: 0, False: 49]
  ------------------
  732|      0|        return -1;
  733|      0|    }
  734|       |
  735|     49|    const uint32_t thawed_index = g->numpeers;
  736|       |
  737|     49|    g->group = temp;
  738|     49|    g->group[thawed_index] = g->frozen[frozen_index];
  739|     49|    g->group[thawed_index].temp_pk_updated = false;
  740|     49|    g->group[thawed_index].last_active = mono_time_get(g_c->mono_time);
  741|       |
  742|     49|    add_to_closest(g, g->group[thawed_index].real_pk, g->group[thawed_index].temp_pk);
  743|       |
  744|     49|    ++g->numpeers;
  745|       |
  746|     49|    delete_frozen(g_c->mem, g, frozen_index);
  747|       |
  748|     49|    if (g_c->peer_list_changed_callback != nullptr) {
  ------------------
  |  |   63|     49|#define nullptr NULL
  ------------------
  |  Branch (748:9): [True: 0, False: 49]
  ------------------
  749|      0|        g_c->peer_list_changed_callback(g_c->m, groupnumber, userdata);
  750|      0|    }
  751|       |
  752|     49|    if (g->peer_on_join != nullptr) {
  ------------------
  |  |   63|     49|#define nullptr NULL
  ------------------
  |  Branch (752:9): [True: 0, False: 49]
  ------------------
  753|      0|        g->peer_on_join(g->object, groupnumber, thawed_index);
  754|      0|    }
  755|       |
  756|     49|    g->need_send_name = true;
  757|       |
  758|     49|    return thawed_index;
  759|     49|}
group.c:delete_frozen:
  673|     89|{
  674|     89|    if (frozen_index >= g->numfrozen) {
  ------------------
  |  Branch (674:9): [True: 0, False: 89]
  ------------------
  675|      0|        return false;
  676|      0|    }
  677|       |
  678|     89|    --g->numfrozen;
  679|       |
  680|     89|    if (g->numfrozen == 0) {
  ------------------
  |  Branch (680:9): [True: 61, False: 28]
  ------------------
  681|     61|        mem_delete(mem, g->frozen);
  682|     61|        g->frozen = nullptr;
  ------------------
  |  |   63|     61|#define nullptr NULL
  ------------------
  683|     61|    } else {
  684|     28|        if (g->numfrozen != frozen_index) {
  ------------------
  |  Branch (684:13): [True: 25, False: 3]
  ------------------
  685|     25|            g->frozen[frozen_index] = g->frozen[g->numfrozen];
  686|     25|        }
  687|       |
  688|     28|        Group_Peer *const frozen_temp = (Group_Peer *)mem_vrealloc(mem, g->frozen, g->numfrozen, sizeof(Group_Peer));
  689|       |
  690|     28|        if (frozen_temp == nullptr) {
  ------------------
  |  |   63|     28|#define nullptr NULL
  ------------------
  |  Branch (690:13): [True: 0, False: 28]
  ------------------
  691|      0|            return false;
  692|      0|        }
  693|       |
  694|     28|        g->frozen = frozen_temp;
  695|     28|    }
  696|       |
  697|     89|    return true;
  698|     89|}
group.c:get_peer_index:
  424|  4.31k|{
  425|  4.31k|    for (uint32_t i = 0; i < g->numpeers; ++i) {
  ------------------
  |  Branch (425:26): [True: 0, False: 4.31k]
  ------------------
  426|      0|        if (g->group[i].peer_number == peer_number) {
  ------------------
  |  Branch (426:13): [True: 0, False: 0]
  ------------------
  427|      0|            return i;
  428|      0|        }
  429|      0|    }
  430|       |
  431|  4.31k|    return -1;
  432|  4.31k|}
group.c:get_frozen_index:
  661|  4.31k|{
  662|  4.94k|    for (uint32_t i = 0; i < g->numfrozen; ++i) {
  ------------------
  |  Branch (662:26): [True: 676, False: 4.26k]
  ------------------
  663|    676|        if (g->frozen[i].peer_number == peer_number) {
  ------------------
  |  Branch (663:13): [True: 49, False: 627]
  ------------------
  664|     49|            return i;
  665|     49|        }
  666|    676|    }
  667|       |
  668|  4.26k|    return -1;
  669|  4.31k|}
group.c:delete_any_peer_with_pk:
  766|  4.26k|{
  767|  4.26k|    Group_c *g = get_group_c(g_c, groupnumber);
  768|       |
  769|  4.26k|    if (g == nullptr) {
  ------------------
  |  |   63|  4.26k|#define nullptr NULL
  ------------------
  |  Branch (769:9): [True: 0, False: 4.26k]
  ------------------
  770|      0|        return;
  771|      0|    }
  772|       |
  773|  4.26k|    const int peer_index = peer_in_group(g, real_pk);
  774|       |
  775|  4.26k|    if (peer_index >= 0) {
  ------------------
  |  Branch (775:9): [True: 0, False: 4.26k]
  ------------------
  776|      0|        delpeer(g_c, groupnumber, peer_index, userdata);
  777|      0|    }
  778|       |
  779|  4.26k|    const int frozen_index = frozen_in_group(g, real_pk);
  780|       |
  781|  4.26k|    if (frozen_index >= 0) {
  ------------------
  |  Branch (781:9): [True: 40, False: 4.22k]
  ------------------
  782|     40|        delete_frozen(g_c->mem, g, frozen_index);
  783|     40|    }
  784|  4.26k|}
group.c:peer_in_group:
  361|  4.26k|{
  362|  4.26k|    for (uint32_t i = 0; i < g->numpeers; ++i) {
  ------------------
  |  Branch (362:26): [True: 0, False: 4.26k]
  ------------------
  363|      0|        if (pk_equal(g->group[i].real_pk, real_pk)) {
  ------------------
  |  Branch (363:13): [True: 0, False: 0]
  ------------------
  364|      0|            return i;
  365|      0|        }
  366|      0|    }
  367|       |
  368|  4.26k|    return -1;
  369|  4.26k|}
group.c:frozen_in_group:
  373|  4.26k|{
  374|  4.64k|    for (uint32_t i = 0; i < g->numfrozen; ++i) {
  ------------------
  |  Branch (374:26): [True: 418, False: 4.22k]
  ------------------
  375|    418|        if (pk_equal(g->frozen[i].real_pk, real_pk)) {
  ------------------
  |  Branch (375:13): [True: 40, False: 378]
  ------------------
  376|     40|            return i;
  377|     40|        }
  378|    418|    }
  379|       |
  380|  4.22k|    return -1;
  381|  4.26k|}
group.c:add_to_closest:
  456|  4.31k|{
  457|  4.31k|    if (pk_equal(g->real_pk, real_pk)) {
  ------------------
  |  Branch (457:9): [True: 4.30k, False: 14]
  ------------------
  458|  4.30k|        return false;
  459|  4.30k|    }
  460|       |
  461|     14|    unsigned int index = DESIRED_CLOSEST;
  ------------------
  |  |   55|     14|#define DESIRED_CLOSEST 4
  ------------------
  462|       |
  463|     70|    for (unsigned int i = 0; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   55|     70|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (463:30): [True: 56, False: 14]
  ------------------
  464|     56|        if (g->closest_peers[i].active && pk_equal(real_pk, g->closest_peers[i].real_pk)) {
  ------------------
  |  Branch (464:13): [True: 0, False: 56]
  |  Branch (464:43): [True: 0, False: 0]
  ------------------
  465|      0|            return true;
  466|      0|        }
  467|     56|    }
  468|       |
  469|     14|    for (unsigned int i = 0; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   55|     14|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (469:30): [True: 14, False: 0]
  ------------------
  470|     14|        if (!g->closest_peers[i].active) {
  ------------------
  |  Branch (470:13): [True: 14, False: 0]
  ------------------
  471|     14|            index = i;
  472|     14|            break;
  473|     14|        }
  474|     14|    }
  475|       |
  476|     14|    if (index == DESIRED_CLOSEST) {
  ------------------
  |  |   55|     14|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (476:9): [True: 0, False: 14]
  ------------------
  477|      0|        uint64_t comp_val = calculate_comp_value(g->real_pk, real_pk);
  478|      0|        uint64_t comp_d = 0;
  479|       |
  480|      0|        for (unsigned int i = 0; i < (DESIRED_CLOSEST / 2); ++i) {
  ------------------
  |  |   55|      0|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (480:34): [True: 0, False: 0]
  ------------------
  481|      0|            const uint64_t comp = calculate_comp_value(g->real_pk, g->closest_peers[i].real_pk);
  482|       |
  483|      0|            if (comp > comp_val && comp > comp_d) {
  ------------------
  |  Branch (483:17): [True: 0, False: 0]
  |  Branch (483:36): [True: 0, False: 0]
  ------------------
  484|      0|                index = i;
  485|      0|                comp_d = comp;
  486|      0|            }
  487|      0|        }
  488|       |
  489|      0|        comp_val = calculate_comp_value(real_pk, g->real_pk);
  490|       |
  491|      0|        for (unsigned int i = DESIRED_CLOSEST / 2; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   55|      0|#define DESIRED_CLOSEST 4
  ------------------
                      for (unsigned int i = DESIRED_CLOSEST / 2; i < DESIRED_CLOSEST; ++i) {
  ------------------
  |  |   55|      0|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (491:52): [True: 0, False: 0]
  ------------------
  492|      0|            const uint64_t comp = calculate_comp_value(g->closest_peers[i].real_pk, g->real_pk);
  493|       |
  494|      0|            if (comp > comp_val && comp > comp_d) {
  ------------------
  |  Branch (494:17): [True: 0, False: 0]
  |  Branch (494:36): [True: 0, False: 0]
  ------------------
  495|      0|                index = i;
  496|      0|                comp_d = comp;
  497|      0|            }
  498|      0|        }
  499|      0|    }
  500|       |
  501|     14|    if (index == DESIRED_CLOSEST) {
  ------------------
  |  |   55|     14|#define DESIRED_CLOSEST 4
  ------------------
  |  Branch (501:9): [True: 0, False: 14]
  ------------------
  502|      0|        return false;
  503|      0|    }
  504|       |
  505|     14|    uint8_t old_real_pk[CRYPTO_PUBLIC_KEY_SIZE];
  506|     14|    uint8_t old_temp_pk[CRYPTO_PUBLIC_KEY_SIZE];
  507|     14|    bool old = false;
  508|       |
  509|     14|    if (g->closest_peers[index].active) {
  ------------------
  |  Branch (509:9): [True: 0, False: 14]
  ------------------
  510|      0|        memcpy(old_real_pk, g->closest_peers[index].real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  511|      0|        memcpy(old_temp_pk, g->closest_peers[index].temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  512|      0|        old = true;
  513|      0|    }
  514|       |
  515|     14|    g->closest_peers[index].active = true;
  516|     14|    memcpy(g->closest_peers[index].real_pk, real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|     14|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  517|     14|    memcpy(g->closest_peers[index].temp_pk, temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|     14|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  518|       |
  519|     14|    if (old) {
  ------------------
  |  Branch (519:9): [True: 0, False: 14]
  ------------------
  520|      0|        add_to_closest(g, old_real_pk, old_temp_pk);
  521|      0|    }
  522|       |
  523|     14|    if (g->changed == GROUPCHAT_CLOSEST_CHANGE_NONE) {
  ------------------
  |  Branch (523:9): [True: 14, False: 0]
  ------------------
  524|     14|        g->changed = GROUPCHAT_CLOSEST_CHANGE_ADDED;
  525|     14|    }
  526|       |
  527|     14|    return true;
  528|     14|}
group.c:setnick:
 1104|  4.30k|{
 1105|  4.30k|    if (nick_len > MAX_NAME_LENGTH) {
  ------------------
  |  |   34|  4.30k|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (1105:9): [True: 0, False: 4.30k]
  ------------------
 1106|      0|        return false;
 1107|      0|    }
 1108|       |
 1109|  4.30k|    Group_c *g = get_group_c(g_c, groupnumber);
 1110|       |
 1111|  4.30k|    if (g == nullptr) {
  ------------------
  |  |   63|  4.30k|#define nullptr NULL
  ------------------
  |  Branch (1111:9): [True: 0, False: 4.30k]
  ------------------
 1112|      0|        return false;
 1113|      0|    }
 1114|       |
 1115|  4.30k|    g->group[peer_index].nick_updated = true;
 1116|       |
 1117|  4.30k|    if (g_peer_nick_eq(&g->group[peer_index], nick, nick_len)) {
  ------------------
  |  Branch (1117:9): [True: 3.73k, False: 563]
  ------------------
 1118|       |        /* same name as already stored */
 1119|  3.73k|        return true;
 1120|  3.73k|    }
 1121|       |
 1122|    563|    if (nick_len > 0) {
  ------------------
  |  Branch (1122:9): [True: 529, False: 34]
  ------------------
 1123|    529|        memcpy(g->group[peer_index].nick, nick, nick_len);
 1124|    529|    }
 1125|       |
 1126|    563|    g->group[peer_index].nick_len = nick_len;
 1127|       |
 1128|    563|    if (do_gc_callback && g_c->peer_name_callback != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1128:9): [True: 0, False: 563]
  |  Branch (1128:27): [True: 0, False: 0]
  ------------------
 1129|      0|        g_c->peer_name_callback(g_c->m, groupnumber, peer_index, nick, nick_len, userdata);
 1130|      0|    }
 1131|       |
 1132|    563|    return true;
 1133|  4.30k|}
group.c:g_peer_nick_eq:
  233|  4.30k|{
  234|  4.30k|    return memeq(peer->nick, peer->nick_len, nick, nick_len);
  235|  4.30k|}
group.c:get_group_c:
  343|  25.2k|{
  344|  25.2k|    if (!is_groupnumber_valid(g_c, groupnumber)) {
  ------------------
  |  Branch (344:9): [True: 0, False: 25.2k]
  ------------------
  345|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  346|      0|    }
  347|       |
  348|  25.2k|    return &g_c->chats[groupnumber];
  349|  25.2k|}
group.c:is_groupnumber_valid:
  243|  25.2k|{
  244|  25.2k|    return groupnumber < g_c->num_chats
  ------------------
  |  Branch (244:12): [True: 25.2k, False: 0]
  ------------------
  245|  25.2k|           && g_c->chats != nullptr
  ------------------
  |  |   63|  50.5k|#define nullptr NULL
  ------------------
  |  Branch (245:15): [True: 25.2k, False: 0]
  ------------------
  246|  25.2k|           && g_c->chats[groupnumber].status != GROUPCHAT_STATUS_NONE;
  ------------------
  |  Branch (246:15): [True: 25.2k, False: 0]
  ------------------
  247|  25.2k|}
group.c:wipe_group_chat:
  318|  4.37k|{
  319|  4.37k|    if (groupnumber >= g_c->num_chats || g_c->chats == nullptr) {
  ------------------
  |  |   63|  4.37k|#define nullptr NULL
  ------------------
  |  Branch (319:9): [True: 0, False: 4.37k]
  |  Branch (319:42): [True: 0, False: 4.37k]
  ------------------
  320|      0|        return false;
  321|      0|    }
  322|       |
  323|  4.37k|    wipe_group_c(g_c->mem, &g_c->chats[groupnumber]);
  324|       |
  325|  4.37k|    uint16_t i;
  326|       |
  327|  8.75k|    for (i = g_c->num_chats; i != 0; --i) {
  ------------------
  |  Branch (327:30): [True: 8.60k, False: 148]
  ------------------
  328|  8.60k|        if (g_c->chats[i - 1].status != GROUPCHAT_STATUS_NONE) {
  ------------------
  |  Branch (328:13): [True: 4.22k, False: 4.37k]
  ------------------
  329|  4.22k|            break;
  330|  4.22k|        }
  331|  8.60k|    }
  332|       |
  333|  4.37k|    if (g_c->num_chats != i) {
  ------------------
  |  Branch (333:9): [True: 199, False: 4.17k]
  ------------------
  334|    199|        g_c->num_chats = i;
  335|    199|        realloc_conferences(g_c, g_c->num_chats);
  336|    199|    }
  337|       |
  338|  4.37k|    return true;
  339|  4.37k|}
group.c:wipe_group_c:
  306|  4.37k|{
  307|  4.37k|    mem_delete(mem, g->frozen);
  308|  4.37k|    mem_delete(mem, g->group);
  309|  4.37k|    crypto_memzero(g, sizeof(Group_c));
  310|  4.37k|}
group.c:count_connected:
 2311|  1.54k|{
 2312|  1.54k|    unsigned int count = 0;
 2313|       |
 2314|  26.1k|    for (unsigned int i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
  ------------------
  |  |   56|  26.1k|#define MAX_GROUP_CONNECTIONS 16
  ------------------
  |  Branch (2314:30): [True: 24.6k, False: 1.54k]
  ------------------
 2315|  24.6k|        if (g->connections[i].type == GROUPCHAT_CONNECTION_ONLINE) {
  ------------------
  |  Branch (2315:13): [True: 0, False: 24.6k]
  ------------------
 2316|      0|            ++count;
 2317|      0|        }
 2318|  24.6k|    }
 2319|       |
 2320|  1.54k|    return count;
 2321|  1.54k|}
group.c:group_leave:
 2050|  1.54k|{
 2051|  1.54k|    const Group_c *g = get_group_c(g_c, groupnumber);
 2052|       |
 2053|  1.54k|    if (g == nullptr) {
  ------------------
  |  |   63|  1.54k|#define nullptr NULL
  ------------------
  |  Branch (2053:9): [True: 0, False: 1.54k]
  ------------------
 2054|      0|        return false;
 2055|      0|    }
 2056|       |
 2057|  1.54k|    if (permanent) {
  ------------------
  |  Branch (2057:9): [True: 0, False: 1.54k]
  ------------------
 2058|      0|        return group_kill_peer_send(g_c, groupnumber, g->peer_number);
 2059|  1.54k|    } else {
 2060|  1.54k|        return group_freeze_peer_send(g_c, groupnumber, g->peer_number);
 2061|  1.54k|    }
 2062|  1.54k|}
group.c:group_freeze_peer_send:
 2024|  1.54k|{
 2025|  1.54k|    uint8_t packet[GROUP_MESSAGE_KILL_PEER_LENGTH];
 2026|       |
 2027|  1.54k|    peer_num = net_htons(peer_num);
 2028|  1.54k|    memcpy(packet, &peer_num, sizeof(uint16_t));
 2029|       |
 2030|  1.54k|    return send_message_group(g_c, groupnumber, GROUP_MESSAGE_FREEZE_PEER_ID, packet, sizeof(packet)) > 0;
 2031|  1.54k|}
group.c:send_message_group:
 2727|  1.54k|{
 2728|  1.54k|    assert(len == 0 || data != nullptr);
 2729|  1.54k|    Group_c *g = get_group_c(g_c, groupnumber);
 2730|       |
 2731|  1.54k|    if (g == nullptr) {
  ------------------
  |  |   63|  1.54k|#define nullptr NULL
  ------------------
  |  Branch (2731:9): [True: 0, False: 1.54k]
  ------------------
 2732|      0|        return -1;
 2733|      0|    }
 2734|       |
 2735|  1.54k|    if (len > MAX_GROUP_MESSAGE_DATA_LEN) {
  ------------------
  |  |  188|  1.54k|#define MAX_GROUP_MESSAGE_DATA_LEN (MAX_CRYPTO_DATA_SIZE - (1 + MIN_MESSAGE_PACKET_LEN))
  |  |  ------------------
  |  |  |  |   93|  1.54k|#define MAX_CRYPTO_DATA_SIZE (uint16_t)(MAX_CRYPTO_PACKET_SIZE - CRYPTO_DATA_PACKET_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   88|  1.54k|#define MAX_CRYPTO_PACKET_SIZE (uint16_t)1400
  |  |  |  |  ------------------
  |  |  |  |               #define MAX_CRYPTO_DATA_SIZE (uint16_t)(MAX_CRYPTO_PACKET_SIZE - CRYPTO_DATA_PACKET_MIN_SIZE)
  |  |  |  |  ------------------
  |  |  |  |  |  |   90|  1.54k|#define CRYPTO_DATA_PACKET_MIN_SIZE (uint16_t)(1 + sizeof(uint16_t) + (sizeof(uint32_t) + sizeof(uint32_t)) + CRYPTO_MAC_SIZE)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|  1.54k|#define CRYPTO_MAC_SIZE                16
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define MAX_GROUP_MESSAGE_DATA_LEN (MAX_CRYPTO_DATA_SIZE - (1 + MIN_MESSAGE_PACKET_LEN))
  |  |  ------------------
  |  |  |  |  209|  1.54k|#define MIN_MESSAGE_PACKET_LEN (sizeof(uint16_t) * 2 + sizeof(uint32_t) + 1)
  |  |  ------------------
  ------------------
  |  Branch (2735:9): [True: 0, False: 1.54k]
  ------------------
 2736|      0|        return -2;
 2737|      0|    }
 2738|       |
 2739|  1.54k|    if (g->status != GROUPCHAT_STATUS_CONNECTED || count_connected(g) == 0) {
  ------------------
  |  Branch (2739:9): [True: 0, False: 1.54k]
  |  Branch (2739:52): [True: 1.54k, False: 0]
  ------------------
 2740|  1.54k|        return -3;
 2741|  1.54k|    }
 2742|       |
 2743|      0|    const uint16_t packet_size = sizeof(uint16_t) + sizeof(uint32_t) + 1 + len;
 2744|      0|    VLA(uint8_t, packet, packet_size);
  ------------------
  |  |   59|      0|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|      0|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 2745|      0|    const uint16_t peer_num = net_htons(g->peer_number);
 2746|      0|    memcpy(packet, &peer_num, sizeof(peer_num));
 2747|       |
 2748|      0|    ++g->message_number;
 2749|       |
 2750|      0|    if (g->message_number == 0) {
  ------------------
  |  Branch (2750:9): [True: 0, False: 0]
  ------------------
 2751|      0|        ++g->message_number;
 2752|      0|    }
 2753|       |
 2754|      0|    const uint32_t message_num = net_htonl(g->message_number);
 2755|      0|    memcpy(packet + sizeof(uint16_t), &message_num, sizeof(message_num));
 2756|       |
 2757|      0|    packet[sizeof(uint16_t) + sizeof(uint32_t)] = message_id;
 2758|       |
 2759|      0|    if (len != 0) {
  ------------------
  |  Branch (2759:9): [True: 0, False: 0]
  ------------------
 2760|      0|        memcpy(packet + sizeof(uint16_t) + sizeof(uint32_t) + 1, data, len);
 2761|      0|    }
 2762|       |
 2763|      0|    const unsigned int ret = send_message_all_connections(g_c, g, packet, packet_size, -1);
 2764|       |
 2765|      0|    if (ret == 0) {
  ------------------
  |  Branch (2765:9): [True: 0, False: 0]
  ------------------
 2766|      0|        return -4;
 2767|      0|    }
 2768|       |
 2769|      0|    return ret;
 2770|      0|}
group.c:conferences_section_size:
 3569|  1.84k|{
 3570|  1.84k|    uint32_t len = 0;
 3571|       |
 3572|  4.43k|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3572:26): [True: 2.58k, False: 1.84k]
  ------------------
 3573|  2.58k|        const Group_c *g = get_group_c(g_c, i);
 3574|       |
 3575|  2.58k|        if (g == nullptr || g->status != GROUPCHAT_STATUS_CONNECTED) {
  ------------------
  |  |   63|  5.17k|#define nullptr NULL
  ------------------
  |  Branch (3575:13): [True: 0, False: 2.58k]
  |  Branch (3575:29): [True: 0, False: 2.58k]
  ------------------
 3576|      0|            continue;
 3577|      0|        }
 3578|       |
 3579|  2.58k|        len += saved_conf_size(g);
 3580|  2.58k|    }
 3581|       |
 3582|  1.84k|    return len;
 3583|  1.84k|}
group.c:saved_conf_size:
 3499|  2.58k|{
 3500|  2.58k|    uint32_t len = SAVED_CONF_SIZE_CONSTANT + g->title_len;
  ------------------
  |  | 3494|  2.58k|#define SAVED_CONF_SIZE_CONSTANT (1 + GROUP_ID_LENGTH + sizeof(uint32_t) \
  |  |  ------------------
  |  |  |  |   53|  2.58k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   58|  2.58k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   53|  2.58k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 3495|  2.58k|      + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t) + 1)
  ------------------
 3501|       |
 3502|  6.06k|    for (uint32_t j = 0; j < g->numpeers + g->numfrozen; ++j) {
  ------------------
  |  Branch (3502:26): [True: 3.47k, False: 2.58k]
  ------------------
 3503|  3.47k|        const Group_Peer *peer = (j < g->numpeers) ? &g->group[j] : &g->frozen[j - g->numpeers];
  ------------------
  |  Branch (3503:34): [True: 2.58k, False: 888]
  ------------------
 3504|       |
 3505|  3.47k|        if (pk_equal(peer->real_pk, g->real_pk)) {
  ------------------
  |  Branch (3505:13): [True: 2.58k, False: 888]
  ------------------
 3506|  2.58k|            continue;
 3507|  2.58k|        }
 3508|       |
 3509|    888|        len += saved_peer_size(peer);
 3510|    888|    }
 3511|       |
 3512|  2.58k|    return len;
 3513|  2.58k|}
group.c:saved_peer_size:
 3465|    888|{
 3466|    888|    return SAVED_PEER_SIZE_CONSTANT + peer->nick_len;
  ------------------
  |  | 3461|    888|#define SAVED_PEER_SIZE_CONSTANT (2 * CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint16_t) + sizeof(uint64_t) + 1)
  |  |  ------------------
  |  |  |  |   43|    888|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 3467|    888|}
group.c:save_conf:
 3524|    862|{
 3525|    862|    *data = g->type;
 3526|    862|    ++data;
 3527|       |
 3528|    862|    memcpy(data, g->id, GROUP_ID_LENGTH);
  ------------------
  |  |   53|    862|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   58|    862|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   53|    862|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3529|    862|    data += GROUP_ID_LENGTH;
  ------------------
  |  |   53|    862|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   58|    862|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   53|    862|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3530|       |
 3531|    862|    host_to_lendian_bytes32(data, g->message_number + SAVE_OFFSET_MESSAGE_NUMBER);
  ------------------
  |  | 3519|    862|#define SAVE_OFFSET_MESSAGE_NUMBER (1 << 16)
  ------------------
 3532|    862|    data += sizeof(uint32_t);
 3533|       |
 3534|    862|    host_to_lendian_bytes16(data, g->lossy_message_number + SAVE_OFFSET_LOSSY_MESSAGE_NUMBER);
  ------------------
  |  | 3520|    862|#define SAVE_OFFSET_LOSSY_MESSAGE_NUMBER (1 << 13)
  ------------------
 3535|    862|    data += sizeof(uint16_t);
 3536|       |
 3537|    862|    host_to_lendian_bytes16(data, g->peer_number);
 3538|    862|    data += sizeof(uint16_t);
 3539|       |
 3540|    862|    uint8_t *const numsaved_location = data;
 3541|    862|    data += sizeof(uint32_t);
 3542|       |
 3543|    862|    *data = g->title_len;
 3544|    862|    ++data;
 3545|       |
 3546|    862|    memcpy(data, g->title, g->title_len);
 3547|    862|    data += g->title_len;
 3548|       |
 3549|    862|    uint32_t numsaved = 0;
 3550|       |
 3551|  2.02k|    for (uint32_t j = 0; j < g->numpeers + g->numfrozen; ++j) {
  ------------------
  |  Branch (3551:26): [True: 1.15k, False: 862]
  ------------------
 3552|  1.15k|        const Group_Peer *peer = (j < g->numpeers) ? &g->group[j] : &g->frozen[j - g->numpeers];
  ------------------
  |  Branch (3552:34): [True: 862, False: 296]
  ------------------
 3553|       |
 3554|  1.15k|        if (pk_equal(peer->real_pk, g->real_pk)) {
  ------------------
  |  Branch (3554:13): [True: 862, False: 296]
  ------------------
 3555|    862|            continue;
 3556|    862|        }
 3557|       |
 3558|    296|        data = save_peer(peer, data);
 3559|    296|        ++numsaved;
 3560|    296|    }
 3561|       |
 3562|    862|    host_to_lendian_bytes32(numsaved_location, numsaved);
 3563|       |
 3564|    862|    return data;
 3565|    862|}
group.c:save_peer:
 3471|    296|{
 3472|    296|    memcpy(data, peer->real_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|    296|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3473|    296|    data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   43|    296|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3474|       |
 3475|    296|    memcpy(data, peer->temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|    296|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3476|    296|    data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   43|    296|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3477|       |
 3478|    296|    host_to_lendian_bytes16(data, peer->peer_number);
 3479|    296|    data += sizeof(uint16_t);
 3480|       |
 3481|    296|    host_to_lendian_bytes64(data, peer->last_active);
 3482|    296|    data += sizeof(uint64_t);
 3483|       |
 3484|       |    // TODO(iphydf): This looks broken: nick_len can be > 255.
 3485|    296|    *data = peer->nick_len;
 3486|    296|    ++data;
 3487|       |
 3488|    296|    memcpy(data, peer->nick, peer->nick_len);
 3489|    296|    data += peer->nick_len;
 3490|       |
 3491|    296|    return data;
 3492|    296|}
group.c:load_conferences:
 3777|    408|{
 3778|    408|    const State_Load_Status res = load_conferences_helper(g_c, data, length);
 3779|       |
 3780|    408|    if (res == STATE_LOAD_STATUS_CONTINUE) {
  ------------------
  |  Branch (3780:9): [True: 331, False: 77]
  ------------------
 3781|    331|        return res;
 3782|    331|    }
 3783|       |
 3784|       |    // Loading failed, cleanup all Group_c
 3785|       |
 3786|       |    // save locally, because wipe_group_chat(...) modifies it
 3787|     77|    const uint16_t num_groups = g_c->num_chats;
 3788|       |
 3789|  2.85k|    for (uint16_t i = 0; i < num_groups; ++i) {
  ------------------
  |  Branch (3789:26): [True: 2.77k, False: 77]
  ------------------
 3790|  2.77k|        wipe_group_chat(g_c, i);
 3791|  2.77k|    }
 3792|       |
 3793|     77|    return res;
 3794|    408|}
group.c:load_conferences_helper:
 3726|    408|{
 3727|    408|    const uint8_t *init_data = data;
 3728|       |
 3729|  4.70k|    while (length >= (uint32_t)(data - init_data) + SAVED_CONF_SIZE_CONSTANT) {
  ------------------
  |  | 3494|  4.70k|#define SAVED_CONF_SIZE_CONSTANT (1 + GROUP_ID_LENGTH + sizeof(uint32_t) \
  |  |  ------------------
  |  |  |  |   53|  4.70k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   58|  4.70k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   53|  4.70k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 3495|  4.70k|      + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t) + 1)
  ------------------
  |  Branch (3729:12): [True: 4.37k, False: 331]
  ------------------
 3730|  4.37k|        const int groupnumber = create_group_chat(g_c);
 3731|       |
 3732|       |        // Helpful for testing
 3733|  4.37k|        assert(groupnumber != -1);
 3734|       |
 3735|  4.37k|        if (groupnumber == -1) {
  ------------------
  |  Branch (3735:13): [True: 0, False: 4.37k]
  ------------------
 3736|       |            // If this fails there's a serious problem, don't bother with cleanup
 3737|      0|            LOGGER_ERROR(g_c->m->log, "conference creation failed");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3738|      0|            return STATE_LOAD_STATUS_ERROR;
 3739|      0|        }
 3740|       |
 3741|  4.37k|        Group_c *g = &g_c->chats[groupnumber];
 3742|       |
 3743|  4.37k|        const uint32_t consumed = load_group(g, g_c, data, length - (uint32_t)(data - init_data));
 3744|       |
 3745|  4.37k|        if (consumed == 0) {
  ------------------
  |  Branch (3745:13): [True: 63, False: 4.31k]
  ------------------
 3746|       |            // remove partially loaded stuff, wipe_group_chat must be able to wipe a partially loaded group
 3747|     63|            const bool ret = wipe_group_chat(g_c, groupnumber);
 3748|       |
 3749|       |            // HACK: suppress unused variable warning
 3750|     63|            if (!ret) {
  ------------------
  |  Branch (3750:17): [True: 0, False: 63]
  ------------------
 3751|       |                // wipe_group_chat(...) must be able to wipe partially allocated groups
 3752|      0|                assert(ret);
 3753|      0|            }
 3754|       |
 3755|     63|            LOGGER_ERROR(g_c->m->log, "conference loading failed");
  ------------------
  |  |   87|     63|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     63|    do {                                                                         \
  |  |  |  |   77|     63|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    126|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     63|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     63|        }                                                                        \
  |  |  |  |   80|     63|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3756|     63|            return STATE_LOAD_STATUS_ERROR;
 3757|     63|        }
 3758|       |
 3759|  4.31k|        data += consumed;
 3760|       |
 3761|  4.31k|        const int peer_index = addpeer(g_c, groupnumber, g->real_pk, dht_get_self_public_key(g_c->m->dht), g->peer_number,
 3762|  4.31k|                                       nullptr, true, false);
  ------------------
  |  |   63|  4.31k|#define nullptr NULL
  ------------------
 3763|       |
 3764|  4.31k|        if (peer_index == -1) {
  ------------------
  |  Branch (3764:13): [True: 14, False: 4.30k]
  ------------------
 3765|     14|            LOGGER_ERROR(g_c->m->log, "adding peer %d failed", g->peer_number);
  ------------------
  |  |   87|     14|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     14|    do {                                                                         \
  |  |  |  |   77|     14|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     28|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     14|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     14|        }                                                                        \
  |  |  |  |   80|     14|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3766|     14|            return STATE_LOAD_STATUS_ERROR;
 3767|     14|        }
 3768|       |
 3769|  4.30k|        setnick(g_c, groupnumber, peer_index, g_c->m->name, g_c->m->name_length, nullptr, false);
  ------------------
  |  |   63|  4.30k|#define nullptr NULL
  ------------------
 3770|  4.30k|    }
 3771|       |
 3772|    331|    return STATE_LOAD_STATUS_CONTINUE;
 3773|    408|}
group.c:load_group:
 3618|  4.37k|{
 3619|  4.37k|    const uint8_t *init_data = data;
 3620|       |
 3621|       |    // Initialize to default values so we can unconditionally free in case of an error
 3622|  4.37k|    setup_conference(g);
 3623|       |
 3624|  4.37k|    g->type = *data;
 3625|  4.37k|    ++data;
 3626|       |
 3627|  4.37k|    memcpy(g->id, data, GROUP_ID_LENGTH);
  ------------------
  |  |   53|  4.37k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   58|  4.37k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   53|  4.37k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3628|  4.37k|    data += GROUP_ID_LENGTH;
  ------------------
  |  |   53|  4.37k|#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   58|  4.37k|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   53|  4.37k|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3629|       |
 3630|  4.37k|    lendian_bytes_to_host32(&g->message_number, data);
 3631|  4.37k|    data += sizeof(uint32_t);
 3632|       |
 3633|  4.37k|    lendian_bytes_to_host16(&g->lossy_message_number, data);
 3634|  4.37k|    data += sizeof(uint16_t);
 3635|       |
 3636|  4.37k|    lendian_bytes_to_host16(&g->peer_number, data);
 3637|  4.37k|    data += sizeof(uint16_t);
 3638|       |
 3639|  4.37k|    lendian_bytes_to_host32(&g->numfrozen, data);
 3640|  4.37k|    data += sizeof(uint32_t);
 3641|       |
 3642|  4.37k|    g->title_len = *data;
 3643|       |
 3644|  4.37k|    if (g->title_len > MAX_NAME_LENGTH) {
  ------------------
  |  |   34|  4.37k|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (3644:9): [True: 18, False: 4.35k]
  ------------------
 3645|     18|        return 0;
 3646|     18|    }
 3647|       |
 3648|  4.35k|    ++data;
 3649|       |
 3650|  4.35k|    assert((data - init_data) < UINT32_MAX);
 3651|       |
 3652|  4.35k|    if (length < (uint32_t)(data - init_data) + g->title_len) {
  ------------------
  |  Branch (3652:9): [True: 2, False: 4.35k]
  ------------------
 3653|      2|        return 0;
 3654|      2|    }
 3655|       |
 3656|  4.35k|    memcpy(g->title, data, g->title_len);
 3657|  4.35k|    data += g->title_len;
 3658|       |
 3659|  5.13k|    for (uint32_t j = 0; j < g->numfrozen; ++j) {
  ------------------
  |  Branch (3659:26): [True: 823, False: 4.31k]
  ------------------
 3660|       |
 3661|    823|        assert((data - init_data) < UINT32_MAX);
 3662|       |
 3663|    823|        if (length < (uint32_t)(data - init_data) + SAVED_PEER_SIZE_CONSTANT) {
  ------------------
  |  | 3461|    823|#define SAVED_PEER_SIZE_CONSTANT (2 * CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint16_t) + sizeof(uint64_t) + 1)
  |  |  ------------------
  |  |  |  |   43|    823|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (3663:13): [True: 30, False: 793]
  ------------------
 3664|     30|            return 0;
 3665|     30|        }
 3666|       |
 3667|       |        // This is inefficient, but allows us to check data consistency before allocating memory
 3668|    793|        Group_Peer *tmp_frozen = (Group_Peer *)mem_vrealloc(g_c->mem, g->frozen, j + 1, sizeof(Group_Peer));
 3669|       |
 3670|    793|        if (tmp_frozen == nullptr) {
  ------------------
  |  |   63|    793|#define nullptr NULL
  ------------------
  |  Branch (3670:13): [True: 0, False: 793]
  ------------------
 3671|       |            // Memory allocation failure
 3672|      0|            return 0;
 3673|      0|        }
 3674|       |
 3675|    793|        g->frozen = tmp_frozen;
 3676|       |
 3677|    793|        Group_Peer *peer = &g->frozen[j];
 3678|    793|        *peer = empty_group_peer;
 3679|       |
 3680|    793|        pk_copy(peer->real_pk, data);
 3681|    793|        data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   43|    793|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3682|    793|        pk_copy(peer->temp_pk, data);
 3683|    793|        data += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   43|    793|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 3684|       |
 3685|    793|        lendian_bytes_to_host16(&peer->peer_number, data);
 3686|    793|        data += sizeof(uint16_t);
 3687|       |
 3688|    793|        lendian_bytes_to_host64(&peer->last_active, data);
 3689|    793|        data += sizeof(uint64_t);
 3690|       |
 3691|    793|        peer->nick_len = *data;
 3692|       |
 3693|    793|        if (peer->nick_len > MAX_NAME_LENGTH) {
  ------------------
  |  |   34|    793|#define MAX_NAME_LENGTH 128
  ------------------
  |  Branch (3693:13): [True: 6, False: 787]
  ------------------
 3694|      6|            return 0;
 3695|      6|        }
 3696|       |
 3697|    787|        ++data;
 3698|    787|        assert((data - init_data) < UINT32_MAX);
 3699|       |
 3700|    787|        if (length < (uint32_t)(data - init_data) + peer->nick_len) {
  ------------------
  |  Branch (3700:13): [True: 7, False: 780]
  ------------------
 3701|      7|            return 0;
 3702|      7|        }
 3703|       |
 3704|    780|        memcpy(peer->nick, data, peer->nick_len);
 3705|    780|        data += peer->nick_len;
 3706|       |
 3707|       |        // NOTE: this relies on friends being loaded before conferences.
 3708|    780|        peer->is_friend = getfriend_id(g_c->m, peer->real_pk) != -1;
 3709|    780|    }
 3710|       |
 3711|  4.31k|    if (g->numfrozen > g->maxfrozen) {
  ------------------
  |  Branch (3711:9): [True: 0, False: 4.31k]
  ------------------
 3712|      0|        g->maxfrozen = g->numfrozen;
 3713|      0|    }
 3714|       |
 3715|  4.31k|    g->status = GROUPCHAT_STATUS_CONNECTED;
 3716|       |
 3717|  4.31k|    pk_copy(g->real_pk, nc_get_self_public_key(g_c->m->net_crypto));
 3718|       |
 3719|  4.31k|    assert((data - init_data) < UINT32_MAX);
 3720|       |
 3721|  4.31k|    return (uint32_t)(data - init_data);
 3722|  4.31k|}

new_gca_list:
  415|  3.15k|{
  416|  3.15k|    GC_Announces_List *announces_list = (GC_Announces_List *)mem_alloc(mem, sizeof(GC_Announces_List));
  417|       |
  418|  3.15k|    if (announces_list == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (418:9): [True: 0, False: 3.15k]
  ------------------
  419|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  420|      0|    }
  421|       |
  422|  3.15k|    announces_list->mem = mem;
  423|       |
  424|  3.15k|    return announces_list;
  425|  3.15k|}
kill_gca:
  428|  3.15k|{
  429|  3.15k|    if (announces_list == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (429:9): [True: 0, False: 3.15k]
  ------------------
  430|      0|        return;
  431|      0|    }
  432|       |
  433|  3.15k|    GC_Announces *root = announces_list->root_announces;
  434|       |
  435|  3.15k|    while (root != nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (435:12): [True: 0, False: 3.15k]
  ------------------
  436|      0|        GC_Announces *next = root->next_announce;
  437|      0|        mem_delete(announces_list->mem, root);
  438|      0|        root = next;
  439|      0|    }
  440|       |
  441|  3.15k|    mem_delete(announces_list->mem, announces_list);
  442|  3.15k|}

gc_peer_id_from_int:
  192|     70|{
  193|     70|    const GC_Peer_Id peer_id = {(force GC_Peer_Id_Value)value};
  194|     70|    return peer_id;
  195|     70|}
gc_peer_number_is_valid:
  236|     70|{
  237|     70|    return peer_number >= 0 && peer_number < (int)chat->numpeers;
  ------------------
  |  Branch (237:12): [True: 70, False: 0]
  |  Branch (237:32): [True: 70, False: 0]
  ------------------
  238|     70|}
get_gc_connection:
  251|     70|{
  252|     70|    GC_Peer *peer = get_gc_peer(chat, peer_number);
  253|       |
  254|     70|    if (peer == nullptr) {
  ------------------
  |  |   63|     70|#define nullptr NULL
  ------------------
  |  Branch (254:9): [True: 0, False: 70]
  ------------------
  255|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  256|      0|    }
  257|       |
  258|     70|    return &peer->gconn;
  259|     70|}
pack_gc_saved_peers:
  429|     76|{
  430|     76|    uint16_t packed_len = 0;
  431|     76|    uint16_t count = 0;
  432|       |
  433|  7.67k|    for (uint32_t i = 0; i < GC_MAX_SAVED_PEERS; ++i) {
  ------------------
  |  |   48|  7.67k|#define GC_MAX_SAVED_PEERS 100
  ------------------
  |  Branch (433:26): [True: 7.60k, False: 76]
  ------------------
  434|  7.60k|        const GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];
  435|       |
  436|  7.60k|        if (!saved_peer_is_valid(saved_peer)) {
  ------------------
  |  Branch (436:13): [True: 7.24k, False: 356]
  ------------------
  437|  7.24k|            continue;
  438|  7.24k|        }
  439|       |
  440|    356|        int packed_ipp_len = 0;
  441|    356|        int packed_tcp_len = 0;
  442|       |
  443|    356|        if (ipport_isset(&saved_peer->ip_port)) {
  ------------------
  |  Branch (443:13): [True: 260, False: 96]
  ------------------
  444|    260|            if (packed_len > length) {
  ------------------
  |  Branch (444:17): [True: 0, False: 260]
  ------------------
  445|      0|                return -1;
  446|      0|            }
  447|       |
  448|    260|            packed_ipp_len = pack_ip_port(chat->log, data + packed_len, length - packed_len, &saved_peer->ip_port);
  449|       |
  450|    260|            if (packed_ipp_len > 0) {
  ------------------
  |  Branch (450:17): [True: 260, False: 0]
  ------------------
  451|    260|                packed_len += packed_ipp_len;
  452|    260|            }
  453|    260|        }
  454|       |
  455|    356|        if (ipport_isset(&saved_peer->tcp_relay.ip_port)) {
  ------------------
  |  Branch (455:13): [True: 328, False: 28]
  ------------------
  456|    328|            if (packed_len > length) {
  ------------------
  |  Branch (456:17): [True: 0, False: 328]
  ------------------
  457|      0|                return -1;
  458|      0|            }
  459|       |
  460|    328|            packed_tcp_len = pack_nodes(chat->log, data + packed_len, length - packed_len, &saved_peer->tcp_relay, 1);
  461|       |
  462|    328|            if (packed_tcp_len > 0) {
  ------------------
  |  Branch (462:17): [True: 328, False: 0]
  ------------------
  463|    328|                packed_len += packed_tcp_len;
  464|    328|            }
  465|    328|        }
  466|       |
  467|    356|        if (packed_len + ENC_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |  122|    356|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   43|    356|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (467:13): [True: 0, False: 356]
  ------------------
  468|      0|            return -1;
  469|      0|        }
  470|       |
  471|    356|        if (packed_tcp_len > 0 || packed_ipp_len > 0) {
  ------------------
  |  Branch (471:13): [True: 328, False: 28]
  |  Branch (471:35): [True: 28, False: 0]
  ------------------
  472|    356|            memcpy(data + packed_len, chat->saved_peers[i].public_key, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |  122|    356|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   43|    356|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  473|    356|            packed_len += ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |  122|    356|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   43|    356|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  474|    356|            ++count;
  475|    356|        } else {
  476|      0|            LOGGER_WARNING(chat->log, "Failed to pack saved peer");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  477|      0|        }
  478|    356|    }
  479|       |
  480|     76|    if (processed != nullptr) {
  ------------------
  |  |   63|     76|#define nullptr NULL
  ------------------
  |  Branch (480:9): [True: 76, False: 0]
  ------------------
  481|     76|        *processed = packed_len;
  482|     76|    }
  483|       |
  484|     76|    return count;
  485|     76|}
unpack_gc_saved_peers:
  488|     61|{
  489|     61|    uint16_t count = 0;
  490|     61|    uint16_t unpacked_len = 0;
  491|       |
  492|    417|    for (size_t i = 0; unpacked_len < length; ++i) {
  ------------------
  |  Branch (492:24): [True: 415, False: 2]
  ------------------
  493|    415|        GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];
  494|       |
  495|    415|        const int ipp_len = unpack_ip_port(&saved_peer->ip_port, data + unpacked_len, length - unpacked_len, false);
  496|       |
  497|    415|        if (ipp_len > 0) {
  ------------------
  |  Branch (497:13): [True: 292, False: 123]
  ------------------
  498|    292|            unpacked_len += ipp_len;
  499|    292|        }
  500|       |
  501|    415|        if (unpacked_len > length) {
  ------------------
  |  Branch (501:13): [True: 0, False: 415]
  ------------------
  502|      0|            return -1;
  503|      0|        }
  504|       |
  505|    415|        uint16_t tcp_len_processed = 0;
  506|    415|        const int tcp_len = unpack_nodes(&saved_peer->tcp_relay, 1, &tcp_len_processed, data + unpacked_len,
  507|    415|                                         length - unpacked_len, true);
  508|       |
  509|    415|        if (tcp_len == 1 && tcp_len_processed > 0) {
  ------------------
  |  Branch (509:13): [True: 244, False: 171]
  |  Branch (509:29): [True: 244, False: 0]
  ------------------
  510|    244|            unpacked_len += tcp_len_processed;
  511|    244|        } else if (ipp_len <= 0) {
  ------------------
  |  Branch (511:20): [True: 56, False: 115]
  ------------------
  512|     56|            LOGGER_WARNING(chat->log, "Failed to unpack saved peer: Invalid connection info.");
  ------------------
  |  |   86|     56|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     56|    do {                                                                         \
  |  |  |  |   77|     56|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    112|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     56|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     56|        }                                                                        \
  |  |  |  |   80|     56|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  513|     56|            return -1;
  514|     56|        }
  515|       |
  516|    359|        if (unpacked_len + ENC_PUBLIC_KEY_SIZE > length) {
  ------------------
  |  |  122|    359|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   43|    359|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (516:13): [True: 3, False: 356]
  ------------------
  517|      3|            return -1;
  518|      3|        }
  519|       |
  520|    356|        if (tcp_len > 0 || ipp_len > 0) {
  ------------------
  |  Branch (520:13): [True: 244, False: 112]
  |  Branch (520:28): [True: 112, False: 0]
  ------------------
  521|    356|            memcpy(saved_peer->public_key, data + unpacked_len, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |  122|    356|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   43|    356|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  522|    356|            unpacked_len += ENC_PUBLIC_KEY_SIZE;
  ------------------
  |  |  122|    356|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   43|    356|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  523|    356|            ++count;
  524|    356|        } else {
  525|      0|            LOGGER_ERROR(chat->log, "Unpacked peer with bad connection info");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  526|      0|            return -1;
  527|      0|        }
  528|    356|    }
  529|       |
  530|      2|    return count;
  531|     61|}
gc_get_pk_jenkins_hash:
  594|     70|{
  595|     70|    return jenkins_one_at_a_time_hash(public_key, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |  122|     70|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   43|     70|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  596|     70|}
get_peer_number_of_enc_pk:
  628|     70|{
  629|     70|    for (uint32_t i = 0; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (629:26): [True: 0, False: 70]
  ------------------
  630|      0|        const GC_Connection *gconn = get_gc_connection(chat, i);
  631|       |
  632|      0|        assert(gconn != nullptr);
  633|       |
  634|      0|        if (gconn->pending_delete) {
  ------------------
  |  Branch (634:13): [True: 0, False: 0]
  ------------------
  635|      0|            continue;
  636|      0|        }
  637|       |
  638|      0|        if (confirmed && !gconn->confirmed) {
  ------------------
  |  Branch (638:13): [True: 0, False: 0]
  |  Branch (638:26): [True: 0, False: 0]
  ------------------
  639|      0|            continue;
  640|      0|        }
  641|       |
  642|      0|        if (memcmp(gconn->addr.public_key.enc, public_enc_key, ENC_PUBLIC_KEY_SIZE) == 0) {
  ------------------
  |  |  122|      0|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  |  Branch (642:13): [True: 0, False: 0]
  ------------------
  643|      0|            return i;
  644|      0|        }
  645|      0|    }
  646|       |
  647|     70|    return -1;
  648|     70|}
gc_callback_message:
 6609|    615|{
 6610|    615|    GC_Session *c = m->group_handler;
 6611|    615|    c->message = function;
 6612|    615|}
gc_callback_private_message:
 6615|    615|{
 6616|    615|    GC_Session *c = m->group_handler;
 6617|    615|    c->private_message = function;
 6618|    615|}
gc_callback_custom_packet:
 6621|    615|{
 6622|    615|    GC_Session *c = m->group_handler;
 6623|    615|    c->custom_packet = function;
 6624|    615|}
gc_callback_custom_private_packet:
 6627|    615|{
 6628|    615|    GC_Session *c = m->group_handler;
 6629|    615|    c->custom_private_packet = function;
 6630|    615|}
gc_callback_moderation:
 6633|    615|{
 6634|    615|    GC_Session *c = m->group_handler;
 6635|    615|    c->moderation = function;
 6636|    615|}
gc_callback_nick_change:
 6639|    615|{
 6640|    615|    GC_Session *c = m->group_handler;
 6641|    615|    c->nick_change = function;
 6642|    615|}
gc_callback_status_change:
 6645|    615|{
 6646|    615|    GC_Session *c = m->group_handler;
 6647|    615|    c->status_change = function;
 6648|    615|}
gc_callback_topic_change:
 6651|    615|{
 6652|    615|    GC_Session *c = m->group_handler;
 6653|    615|    c->topic_change = function;
 6654|    615|}
gc_callback_topic_lock:
 6657|    615|{
 6658|    615|    GC_Session *c = m->group_handler;
 6659|    615|    c->topic_lock = function;
 6660|    615|}
gc_callback_voice_state:
 6663|    615|{
 6664|    615|    GC_Session *c = m->group_handler;
 6665|    615|    c->voice_state = function;
 6666|    615|}
gc_callback_peer_limit:
 6669|    615|{
 6670|    615|    GC_Session *c = m->group_handler;
 6671|    615|    c->peer_limit = function;
 6672|    615|}
gc_callback_privacy_state:
 6675|    615|{
 6676|    615|    GC_Session *c = m->group_handler;
 6677|    615|    c->privacy_state = function;
 6678|    615|}
gc_callback_password:
 6681|    615|{
 6682|    615|    GC_Session *c = m->group_handler;
 6683|    615|    c->password = function;
 6684|    615|}
gc_callback_peer_join:
 6687|    615|{
 6688|    615|    GC_Session *c = m->group_handler;
 6689|    615|    c->peer_join = function;
 6690|    615|}
gc_callback_peer_exit:
 6693|    615|{
 6694|    615|    GC_Session *c = m->group_handler;
 6695|    615|    c->peer_exit = function;
 6696|    615|}
gc_callback_self_join:
 6699|    615|{
 6700|    615|    GC_Session *c = m->group_handler;
 6701|    615|    c->self_join = function;
 6702|    615|}
gc_callback_rejected:
 6705|    615|{
 6706|    615|    GC_Session *c = m->group_handler;
 6707|    615|    c->rejected = function;
 6708|    615|}
peer_add:
 6807|     70|{
 6808|     70|    if (get_peer_number_of_enc_pk(chat, public_key, false) != -1) {
  ------------------
  |  Branch (6808:9): [True: 0, False: 70]
  ------------------
 6809|      0|        return -2;
 6810|      0|    }
 6811|       |
 6812|     70|    const GC_Peer_Id peer_id = get_new_peer_id(chat);
 6813|       |
 6814|     70|    if (!gc_peer_id_is_valid(peer_id)) {
  ------------------
  |  Branch (6814:9): [True: 0, False: 70]
  ------------------
 6815|      0|        LOGGER_WARNING(chat->log, "Failed to add peer: all peer ID's are taken?");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6816|      0|        return -1;
 6817|      0|    }
 6818|       |
 6819|     70|    const int peer_number = chat->numpeers;
 6820|     70|    int tcp_connection_num = -1;
 6821|       |
 6822|     70|    if (peer_number > 0) {  // we don't need a connection to ourself
  ------------------
  |  Branch (6822:9): [True: 0, False: 70]
  ------------------
 6823|      0|        tcp_connection_num = new_tcp_connection_to(chat->tcp_conn, public_key, 0);
 6824|       |
 6825|      0|        if (tcp_connection_num == -1) {
  ------------------
  |  Branch (6825:13): [True: 0, False: 0]
  ------------------
 6826|      0|            LOGGER_WARNING(chat->log, "Failed to init tcp connection for peer %d", peer_number);
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6827|      0|        }
 6828|      0|    }
 6829|       |
 6830|     70|    GC_Message_Array_Entry *send = (GC_Message_Array_Entry *)mem_valloc(chat->mem, GCC_BUFFER_SIZE, sizeof(GC_Message_Array_Entry));
  ------------------
  |  |   55|     70|#define GCC_BUFFER_SIZE 2048
  ------------------
 6831|     70|    GC_Message_Array_Entry *recv = (GC_Message_Array_Entry *)mem_valloc(chat->mem, GCC_BUFFER_SIZE, sizeof(GC_Message_Array_Entry));
  ------------------
  |  |   55|     70|#define GCC_BUFFER_SIZE 2048
  ------------------
 6832|       |
 6833|     70|    if (send == nullptr || recv == nullptr) {
  ------------------
  |  |   63|    140|#define nullptr NULL
  ------------------
                  if (send == nullptr || recv == nullptr) {
  ------------------
  |  |   63|     70|#define nullptr NULL
  ------------------
  |  Branch (6833:9): [True: 0, False: 70]
  |  Branch (6833:28): [True: 0, False: 70]
  ------------------
 6834|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for gconn buffers");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6835|       |
 6836|      0|        if (tcp_connection_num != -1) {
  ------------------
  |  Branch (6836:13): [True: 0, False: 0]
  ------------------
 6837|      0|            kill_tcp_connection_to(chat->tcp_conn, tcp_connection_num);
 6838|      0|        }
 6839|       |
 6840|      0|        mem_delete(chat->mem, send);
 6841|      0|        mem_delete(chat->mem, recv);
 6842|      0|        return -1;
 6843|      0|    }
 6844|       |
 6845|     70|    GC_Peer *tmp_group = (GC_Peer *)mem_vrealloc(chat->mem, chat->group, chat->numpeers + 1, sizeof(GC_Peer));
 6846|       |
 6847|     70|    if (tmp_group == nullptr) {
  ------------------
  |  |   63|     70|#define nullptr NULL
  ------------------
  |  Branch (6847:9): [True: 0, False: 70]
  ------------------
 6848|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for group mem_vrealloc");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6849|       |
 6850|      0|        if (tcp_connection_num != -1) {
  ------------------
  |  Branch (6850:13): [True: 0, False: 0]
  ------------------
 6851|      0|            kill_tcp_connection_to(chat->tcp_conn, tcp_connection_num);
 6852|      0|        }
 6853|       |
 6854|      0|        mem_delete(chat->mem, send);
 6855|      0|        mem_delete(chat->mem, recv);
 6856|      0|        return -1;
 6857|      0|    }
 6858|       |
 6859|     70|    ++chat->numpeers;
 6860|     70|    chat->group = tmp_group;
 6861|       |
 6862|     70|    chat->group[peer_number] = (GC_Peer) {
 6863|     70|        0
 6864|     70|    };
 6865|       |
 6866|     70|    GC_Connection *gconn = &chat->group[peer_number].gconn;
 6867|       |
 6868|     70|    gconn->send_array = send;
 6869|     70|    gconn->recv_array = recv;
 6870|       |
 6871|     70|    gcc_set_ip_port(gconn, ipp);
 6872|     70|    chat->group[peer_number].role = GR_USER;
 6873|     70|    chat->group[peer_number].peer_id = peer_id;
 6874|     70|    chat->group[peer_number].ignore = false;
 6875|       |
 6876|     70|    crypto_memlock(gconn->session_secret_key, sizeof(gconn->session_secret_key));
 6877|       |
 6878|     70|    create_gc_session_keypair(chat->log, chat->rng, gconn->session_public_key, gconn->session_secret_key);
 6879|       |
 6880|     70|    if (peer_number > 0) {
  ------------------
  |  Branch (6880:9): [True: 0, False: 70]
  ------------------
 6881|      0|        memcpy(gconn->addr.public_key.enc, public_key, ENC_PUBLIC_KEY_SIZE);  // we get the sig key in the handshake
  ------------------
  |  |  122|      0|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
 6882|     70|    } else {
 6883|     70|        gconn->addr.public_key = chat->self_public_key;
 6884|     70|    }
 6885|       |
 6886|     70|    const uint64_t tm = mono_time_get(chat->mono_time);
 6887|       |
 6888|     70|    gcc_set_send_message_id(gconn, 1);
 6889|     70|    gconn->public_key_hash = gc_get_pk_jenkins_hash(public_key);
 6890|     70|    gconn->last_received_packet_time = tm;
 6891|     70|    gconn->last_key_rotation = tm;
 6892|     70|    gconn->tcp_connection_num = tcp_connection_num;
 6893|     70|    gconn->last_sent_ip_time = tm;
 6894|     70|    gconn->last_sent_ping_time = tm - (GC_PING_TIMEOUT / 2) + (peer_number % (GC_PING_TIMEOUT / 2));
  ------------------
  |  |   28|     70|#define GC_PING_TIMEOUT 12
  ------------------
                  gconn->last_sent_ping_time = tm - (GC_PING_TIMEOUT / 2) + (peer_number % (GC_PING_TIMEOUT / 2));
  ------------------
  |  |   28|     70|#define GC_PING_TIMEOUT 12
  ------------------
 6895|     70|    gconn->self_is_closer = id_closest(get_chat_id(&chat->chat_public_key),
 6896|     70|                                       get_enc_key(&chat->self_public_key),
 6897|     70|                                       get_enc_key(&gconn->addr.public_key)) == 1;
 6898|     70|    return peer_number;
 6899|     70|}
gc_group_save:
 7626|    292|{
 7627|    292|    gc_save_pack_group(chat, bp);
 7628|    292|}
gc_group_load:
 7631|  25.7k|{
 7632|  25.7k|    const int group_number = get_new_group_index(c->messenger->mem, c);
 7633|       |
 7634|  25.7k|    if (group_number < 0) {
  ------------------
  |  Branch (7634:9): [True: 0, False: 25.7k]
  ------------------
 7635|      0|        return -1;
 7636|      0|    }
 7637|       |
 7638|  25.7k|    const uint64_t tm = mono_time_get(c->messenger->mono_time);
 7639|       |
 7640|  25.7k|    Messenger *m = c->messenger;
 7641|  25.7k|    GC_Chat *chat = &c->chats[group_number];
 7642|       |
 7643|  25.7k|    chat->group_number = group_number;
 7644|  25.7k|    chat->numpeers = 0;
 7645|  25.7k|    chat->net = m->net;
 7646|  25.7k|    chat->mono_time = m->mono_time;
 7647|  25.7k|    chat->log = m->log;
 7648|  25.7k|    chat->mem = m->mem;
 7649|  25.7k|    chat->rng = m->rng;
 7650|  25.7k|    chat->last_ping_interval = tm;
 7651|  25.7k|    chat->friend_connection_id = -1;
 7652|       |
 7653|       |    // Initialise these first, because we may need to log/dealloc things on cleanup.
 7654|  25.7k|    chat->moderation.log = m->log;
 7655|  25.7k|    chat->moderation.mem = m->mem;
 7656|       |
 7657|  25.7k|    if (!gc_load_unpack_group(chat, bu)) {
  ------------------
  |  Branch (7657:9): [True: 25.6k, False: 64]
  ------------------
 7658|  25.6k|        LOGGER_ERROR(chat->log, "Failed to unpack group");
  ------------------
  |  |   87|  25.6k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  25.6k|    do {                                                                         \
  |  |  |  |   77|  25.6k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  51.3k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|  25.6k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|  25.6k|        }                                                                        \
  |  |  |  |   80|  25.6k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 7659|  25.6k|        return -1;
 7660|  25.6k|    }
 7661|       |
 7662|     64|    init_gc_moderation(chat);
 7663|       |
 7664|     64|    if (!init_gc_tcp_connection(c, chat)) {
  ------------------
  |  Branch (7664:9): [True: 0, False: 64]
  ------------------
 7665|      0|        LOGGER_ERROR(chat->log, "Failed to init tcp connection");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 7666|      0|        return -1;
 7667|      0|    }
 7668|       |
 7669|     64|    if (chat->connection_state == CS_DISCONNECTED) {
  ------------------
  |  Branch (7669:9): [True: 0, False: 64]
  ------------------
 7670|      0|        return group_number;
 7671|      0|    }
 7672|       |
 7673|     64|    if (is_public_chat(chat)) {
  ------------------
  |  Branch (7673:9): [True: 64, False: 0]
  ------------------
 7674|     64|        if (!m_create_group_connection(m, chat)) {
  ------------------
  |  Branch (7674:13): [True: 0, False: 64]
  ------------------
 7675|      0|            LOGGER_ERROR(chat->log, "Failed to initialize group friend connection");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 7676|      0|        }
 7677|     64|    }
 7678|       |
 7679|     64|    return group_number;
 7680|     64|}
new_dht_groupchats:
 8264|  3.15k|{
 8265|  3.15k|    if (m == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (8265:9): [True: 0, False: 3.15k]
  ------------------
 8266|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 8267|      0|    }
 8268|       |
 8269|  3.15k|    GC_Session *c = (GC_Session *)mem_alloc(m->mem, sizeof(GC_Session));
 8270|       |
 8271|  3.15k|    if (c == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (8271:9): [True: 0, False: 3.15k]
  ------------------
 8272|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 8273|      0|    }
 8274|       |
 8275|  3.15k|    c->messenger = m;
 8276|  3.15k|    c->announces_list = m->group_announce;
 8277|       |
 8278|  3.15k|    networking_registerhandler(m->net, NET_PACKET_GC_LOSSLESS, &handle_gc_udp_packet, m);
 8279|  3.15k|    networking_registerhandler(m->net, NET_PACKET_GC_LOSSY, &handle_gc_udp_packet, m);
 8280|  3.15k|    networking_registerhandler(m->net, NET_PACKET_GC_HANDSHAKE, &handle_gc_udp_packet, m);
 8281|  3.15k|    onion_group_announce_register(m->onion_c, gc_handle_announce_response_callback, c);
 8282|       |
 8283|  3.15k|    return c;
 8284|  3.15k|}
gc_group_exit:
 8342|  1.19k|{
 8343|  1.19k|    chat->flag_exit = true;
 8344|  1.19k|    return group_can_handle_packets(chat) ? send_gc_self_exit(chat, message, length) : 0;
  ------------------
  |  Branch (8344:12): [True: 1.17k, False: 20]
  ------------------
 8345|  1.19k|}
kill_dht_groupchats:
 8356|  3.15k|{
 8357|  3.15k|    if (c == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (8357:9): [True: 0, False: 3.15k]
  ------------------
 8358|      0|        return;
 8359|      0|    }
 8360|       |
 8361|  6.20k|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (8361:26): [True: 3.05k, False: 3.15k]
  ------------------
 8362|  3.05k|        GC_Chat *chat = &c->chats[i];
 8363|       |
 8364|  3.05k|        if (chat->connection_state == CS_NONE) {
  ------------------
  |  Branch (8364:13): [True: 1.86k, False: 1.19k]
  ------------------
 8365|  1.86k|            continue;
 8366|  1.86k|        }
 8367|       |
 8368|  1.19k|        if (kill_group(c, chat) != 0) {
  ------------------
  |  Branch (8368:13): [True: 0, False: 1.19k]
  ------------------
 8369|      0|            LOGGER_WARNING(c->messenger->log, "Failed to send group exit packet");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8370|      0|        }
 8371|  1.19k|    }
 8372|       |
 8373|  3.15k|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSY, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSY, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 8374|  3.15k|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSLESS, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSLESS, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 8375|  3.15k|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_HANDSHAKE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_HANDSHAKE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 8376|  3.15k|    onion_group_announce_register(c->messenger->onion_c, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  onion_group_announce_register(c->messenger->onion_c, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 8377|       |
 8378|  3.15k|    mem_delete(c->messenger->mem, c->chats);
 8379|  3.15k|    mem_delete(c->messenger->mem, c);
 8380|  3.15k|}
gc_group_is_valid:
 8383|  2.44k|{
 8384|  2.44k|    return chat->connection_state != CS_NONE && chat->shared_state.version > 0;
  ------------------
  |  Branch (8384:12): [True: 1.14k, False: 1.29k]
  |  Branch (8384:49): [True: 657, False: 485]
  ------------------
 8385|  2.44k|}
gc_count_groups:
 8402|  1.95k|{
 8403|  1.95k|    uint32_t count = 0;
 8404|       |
 8405|  3.36k|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (8405:26): [True: 1.41k, False: 1.95k]
  ------------------
 8406|  1.41k|        const GC_Chat *chat = &c->chats[i];
 8407|       |
 8408|  1.41k|        if (gc_group_is_valid(chat)) {
  ------------------
  |  Branch (8408:13): [True: 365, False: 1.04k]
  ------------------
 8409|    365|            ++count;
 8410|    365|        }
 8411|  1.41k|    }
 8412|       |
 8413|  1.95k|    return count;
 8414|  1.95k|}
group_chats.c:get_gc_peer:
  242|     70|{
  243|     70|    if (!gc_peer_number_is_valid(chat, peer_number)) {
  ------------------
  |  Branch (243:9): [True: 0, False: 70]
  ------------------
  244|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  245|      0|    }
  246|       |
  247|     70|    return &chat->group[peer_number];
  248|     70|}
group_chats.c:saved_peer_is_valid:
  817|  7.60k|{
  818|  7.60k|    return ipport_isset(&saved_peer->ip_port) || ipport_isset(&saved_peer->tcp_relay.ip_port);
  ------------------
  |  Branch (818:12): [True: 260, False: 7.34k]
  |  Branch (818:50): [True: 96, False: 7.24k]
  ------------------
  819|  7.60k|}
group_chats.c:send_gc_broadcast_message:
 2397|  1.17k|{
 2398|  1.17k|    if (length + GC_BROADCAST_ENC_HEADER_SIZE > MAX_GC_PACKET_SIZE) {
  ------------------
  |  |   58|  1.17k|#define GC_BROADCAST_ENC_HEADER_SIZE 1
  ------------------
                  if (length + GC_BROADCAST_ENC_HEADER_SIZE > MAX_GC_PACKET_SIZE) {
  ------------------
  |  |   52|  1.17k|#define MAX_GC_PACKET_SIZE (MAX_GC_PACKET_CHUNK_SIZE * 100)
  |  |  ------------------
  |  |  |  |   36|  1.17k|#define MAX_GC_PACKET_CHUNK_SIZE 500
  |  |  ------------------
  ------------------
  |  Branch (2398:9): [True: 0, False: 1.17k]
  ------------------
 2399|      0|        LOGGER_ERROR(chat->log, "Failed to broadcast message: invalid length %u", length);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2400|      0|        return false;
 2401|      0|    }
 2402|       |
 2403|  1.17k|    uint8_t *packet = (uint8_t *)mem_balloc(chat->mem, length + GC_BROADCAST_ENC_HEADER_SIZE);
  ------------------
  |  |   58|  1.17k|#define GC_BROADCAST_ENC_HEADER_SIZE 1
  ------------------
 2404|       |
 2405|  1.17k|    if (packet == nullptr) {
  ------------------
  |  |   63|  1.17k|#define nullptr NULL
  ------------------
  |  Branch (2405:9): [True: 0, False: 1.17k]
  ------------------
 2406|      0|        return false;
 2407|      0|    }
 2408|       |
 2409|  1.17k|    const uint16_t packet_len = make_gc_broadcast_header(data, length, packet, bc_type);
 2410|       |
 2411|  1.17k|    const bool ret = send_gc_lossless_packet_all_peers(chat, packet, packet_len, GP_BROADCAST);
 2412|       |
 2413|  1.17k|    mem_delete(chat->mem, packet);
 2414|       |
 2415|  1.17k|    return ret;
 2416|  1.17k|}
group_chats.c:get_peer_number_of_peer_id:
  720|     70|{
  721|     70|    for (uint32_t i = 0; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (721:26): [True: 0, False: 70]
  ------------------
  722|      0|        if (chat->group[i].peer_id.value == peer_id.value) {
  ------------------
  |  Branch (722:13): [True: 0, False: 0]
  ------------------
  723|      0|            return i;
  724|      0|        }
  725|      0|    }
  726|       |
  727|     70|    return -1;
  728|     70|}
group_chats.c:kill_group_friend_connection:
  209|  1.19k|{
  210|  1.19k|    if (chat->friend_connection_id != -1) {
  ------------------
  |  Branch (210:9): [True: 64, False: 1.12k]
  ------------------
  211|     64|        m_kill_group_connection(c->messenger, chat);
  212|     64|    }
  213|  1.19k|}
group_chats.c:make_gc_broadcast_header:
 2380|  1.17k|{
 2381|  1.17k|    packet[0] = bc_type;
 2382|  1.17k|    const uint16_t header_len = sizeof(uint8_t);
 2383|       |
 2384|  1.17k|    if (data != nullptr && length > 0) {
  ------------------
  |  |   63|  2.34k|#define nullptr NULL
  ------------------
  |  Branch (2384:9): [True: 0, False: 1.17k]
  |  Branch (2384:28): [True: 0, False: 0]
  ------------------
 2385|      0|        memcpy(packet + header_len, data, length);
 2386|      0|    }
 2387|       |
 2388|  1.17k|    return length + header_len;
 2389|  1.17k|}
group_chats.c:send_gc_lossless_packet_all_peers:
 2321|  1.17k|{
 2322|  1.17k|    uint32_t sent = 0;
 2323|  1.17k|    uint32_t confirmed_peers = 0;
 2324|       |
 2325|  1.17k|    for (uint32_t i = 1; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (2325:26): [True: 0, False: 1.17k]
  ------------------
 2326|      0|        GC_Connection *gconn = get_gc_connection(chat, i);
 2327|       |
 2328|      0|        assert(gconn != nullptr);
 2329|       |
 2330|      0|        if (!gconn->confirmed) {
  ------------------
  |  Branch (2330:13): [True: 0, False: 0]
  ------------------
 2331|      0|            continue;
 2332|      0|        }
 2333|       |
 2334|      0|        ++confirmed_peers;
 2335|       |
 2336|      0|        if (send_lossless_group_packet(chat, gconn, data, length, type)) {
  ------------------
  |  Branch (2336:13): [True: 0, False: 0]
  ------------------
 2337|      0|            ++sent;
 2338|      0|        }
 2339|      0|    }
 2340|       |
 2341|  1.17k|    return sent > 0 || confirmed_peers == 0;
  ------------------
  |  Branch (2341:12): [True: 0, False: 1.17k]
  |  Branch (2341:24): [True: 1.17k, False: 0]
  ------------------
 2342|  1.17k|}
group_chats.c:get_new_peer_id:
  738|     70|{
  739|     70|    for (uint32_t i = 0; i < UINT32_MAX - 1; ++i) {
  ------------------
  |  Branch (739:26): [True: 70, False: 0]
  ------------------
  740|     70|        const GC_Peer_Id peer_id = gc_peer_id_from_int(i);
  741|     70|        if (get_peer_number_of_peer_id(chat, peer_id) == -1) {
  ------------------
  |  Branch (741:13): [True: 70, False: 0]
  ------------------
  742|     70|            return peer_id;
  743|     70|        }
  744|     70|    }
  745|       |
  746|      0|    return gc_invalid_peer_id();
  747|     70|}
group_chats.c:gc_peer_id_is_valid:
  187|     70|{
  188|     70|    return peer_id.value != GC_INVALID_PEER_ID_VALUE;
  ------------------
  |  |  178|     70|#define GC_INVALID_PEER_ID_VALUE ((force GC_Peer_Id_Value)-1)
  ------------------
  189|     70|}
group_chats.c:add_tcp_relays_to_chat:
 7391|     64|{
 7392|     64|    const Messenger *m = c->messenger;
 7393|       |
 7394|     64|    const uint32_t num_relays = tcp_connections_count(nc_get_tcp_c(m->net_crypto));
 7395|       |
 7396|     64|    if (num_relays == 0) {
  ------------------
  |  Branch (7396:9): [True: 64, False: 0]
  ------------------
 7397|     64|        return;
 7398|     64|    }
 7399|       |
 7400|      0|    Node_format *tcp_relays = (Node_format *)mem_valloc(chat->mem, num_relays, sizeof(Node_format));
 7401|       |
 7402|      0|    if (tcp_relays == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (7402:9): [True: 0, False: 0]
  ------------------
 7403|      0|        return;
 7404|      0|    }
 7405|       |
 7406|      0|    const uint32_t num_copied = tcp_copy_connected_relays(nc_get_tcp_c(m->net_crypto), tcp_relays, (uint16_t)num_relays);
 7407|       |
 7408|      0|    for (uint32_t i = 0; i < num_copied; ++i) {
  ------------------
  |  Branch (7408:26): [True: 0, False: 0]
  ------------------
 7409|      0|        add_tcp_relay_global(chat->tcp_conn, &tcp_relays[i].ip_port, tcp_relays[i].public_key);
 7410|      0|    }
 7411|       |
 7412|      0|    mem_delete(chat->mem, tcp_relays);
 7413|      0|}
group_chats.c:get_new_group_index:
 7361|  25.7k|{
 7362|  25.7k|    if (c == nullptr) {
  ------------------
  |  |   63|  25.7k|#define nullptr NULL
  ------------------
  |  Branch (7362:9): [True: 0, False: 25.7k]
  ------------------
 7363|      0|        return -1;
 7364|      0|    }
 7365|       |
 7366|  41.7k|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (7366:26): [True: 38.4k, False: 3.34k]
  ------------------
 7367|  38.4k|        if (c->chats[i].connection_state == CS_NONE) {
  ------------------
  |  Branch (7367:13): [True: 22.3k, False: 16.0k]
  ------------------
 7368|  22.3k|            return i;
 7369|  22.3k|        }
 7370|  38.4k|    }
 7371|       |
 7372|  3.34k|    if (!realloc_groupchats(mem, c, c->chats_index + 1)) {
  ------------------
  |  Branch (7372:9): [True: 0, False: 3.34k]
  ------------------
 7373|      0|        return -1;
 7374|      0|    }
 7375|       |
 7376|  3.34k|    const int new_index = c->chats_index;
 7377|       |
 7378|  3.34k|    c->chats[new_index] = empty_gc_chat;
 7379|       |
 7380|  36.8k|    for (size_t i = 0; i < sizeof(c->chats[new_index].saved_invites) / sizeof(*c->chats[new_index].saved_invites); ++i) {
  ------------------
  |  Branch (7380:24): [True: 33.4k, False: 3.34k]
  ------------------
 7381|  33.4k|        c->chats[new_index].saved_invites[i] = -1;
 7382|  33.4k|    }
 7383|       |
 7384|  3.34k|    ++c->chats_index;
 7385|       |
 7386|  3.34k|    return new_index;
 7387|  3.34k|}
group_chats.c:realloc_groupchats:
 7342|  4.15k|{
 7343|  4.15k|    if (n == 0) {
  ------------------
  |  Branch (7343:9): [True: 657, False: 3.49k]
  ------------------
 7344|    657|        mem_delete(mem, c->chats);
 7345|    657|        c->chats = nullptr;
  ------------------
  |  |   63|    657|#define nullptr NULL
  ------------------
 7346|    657|        return true;
 7347|    657|    }
 7348|       |
 7349|  3.49k|    GC_Chat *temp = (GC_Chat *)mem_vrealloc(mem, c->chats, n, sizeof(GC_Chat));
 7350|       |
 7351|  3.49k|    if (temp == nullptr) {
  ------------------
  |  |   63|  3.49k|#define nullptr NULL
  ------------------
  |  Branch (7351:9): [True: 0, False: 3.49k]
  ------------------
 7352|      0|        return false;
 7353|      0|    }
 7354|       |
 7355|  3.49k|    c->chats = temp;
 7356|  3.49k|    return true;
 7357|  3.49k|}
group_chats.c:init_gc_moderation:
 7468|     64|{
 7469|     64|    memcpy(chat->moderation.founder_public_sig_key,
 7470|     64|           get_sig_pk(&chat->shared_state.founder_public_key), SIG_PUBLIC_KEY_SIZE);
  ------------------
  |  |  132|     64|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   33|     64|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
 7471|     64|    memcpy(chat->moderation.self_public_sig_key, get_sig_pk(&chat->self_public_key), SIG_PUBLIC_KEY_SIZE);
  ------------------
  |  |  132|     64|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   33|     64|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
 7472|     64|    memcpy(chat->moderation.self_secret_sig_key, get_sig_sk(&chat->self_secret_key), SIG_SECRET_KEY_SIZE);
  ------------------
  |  |  137|     64|#define SIG_SECRET_KEY_SIZE            CRYPTO_SIGN_SECRET_KEY_SIZE
  |  |  ------------------
  |  |  |  |   38|     64|#define CRYPTO_SIGN_SECRET_KEY_SIZE    64
  |  |  ------------------
  ------------------
 7473|     64|    chat->moderation.shared_state_version = chat->shared_state.version;
 7474|     64|    chat->moderation.log = chat->log;
 7475|     64|    chat->moderation.mem = chat->mem;
 7476|     64|}
group_chats.c:init_gc_tcp_connection:
 7417|     64|{
 7418|     64|    const Messenger *m = c->messenger;
 7419|       |
 7420|     64|    chat->tcp_conn = new_tcp_connections(chat->log, chat->mem, chat->rng, m->ns, chat->mono_time, chat->self_secret_key.enc,
 7421|     64|                                         &m->options.proxy_info);
 7422|       |
 7423|     64|    if (chat->tcp_conn == nullptr) {
  ------------------
  |  |   63|     64|#define nullptr NULL
  ------------------
  |  Branch (7423:9): [True: 0, False: 64]
  ------------------
 7424|      0|        return false;
 7425|      0|    }
 7426|       |
 7427|     64|    add_tcp_relays_to_chat(c, chat);
 7428|       |
 7429|     64|    set_packet_tcp_connection_callback(chat->tcp_conn, &handle_gc_tcp_packet, c->messenger);
 7430|     64|    set_oob_packet_tcp_connection_callback(chat->tcp_conn, &handle_gc_tcp_oob_packet, c->messenger);
 7431|       |
 7432|     64|    return true;
 7433|     64|}
group_chats.c:is_public_chat:
  536|     64|{
  537|     64|    return chat->shared_state.privacy_state == GI_PUBLIC;
  538|     64|}
group_chats.c:group_can_handle_packets:
 6383|  1.19k|{
 6384|  1.19k|    const GC_Conn_State state = chat->connection_state;
 6385|  1.19k|    return state == CS_CONNECTING || state == CS_CONNECTED;
  ------------------
  |  Branch (6385:12): [True: 1.17k, False: 20]
  |  Branch (6385:38): [True: 0, False: 20]
  ------------------
 6386|  1.19k|}
group_chats.c:send_gc_self_exit:
 3450|  1.17k|{
 3451|  1.17k|    if (length > MAX_GC_PART_MESSAGE_SIZE) {
  ------------------
  |  |   25|  1.17k|#define MAX_GC_PART_MESSAGE_SIZE 128
  ------------------
  |  Branch (3451:9): [True: 0, False: 1.17k]
  ------------------
 3452|      0|        return -1;
 3453|      0|    }
 3454|       |
 3455|  1.17k|    if (!send_gc_broadcast_message(chat, partmessage, length, GM_PEER_EXIT)) {
  ------------------
  |  Branch (3455:9): [True: 0, False: 1.17k]
  ------------------
 3456|      0|        return -2;
 3457|      0|    }
 3458|       |
 3459|  1.17k|    return 0;
 3460|  1.17k|}
group_chats.c:group_delete:
 8311|  1.19k|{
 8312|  1.19k|    if (c == nullptr || chat == nullptr) {
  ------------------
  |  |   63|  2.38k|#define nullptr NULL
  ------------------
                  if (c == nullptr || chat == nullptr) {
  ------------------
  |  |   63|  1.19k|#define nullptr NULL
  ------------------
  |  Branch (8312:9): [True: 0, False: 1.19k]
  |  Branch (8312:25): [True: 0, False: 1.19k]
  ------------------
 8313|      0|        if (chat != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (8313:13): [True: 0, False: 0]
  ------------------
 8314|      0|            LOGGER_ERROR(chat->log, "Null pointer");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8315|      0|        }
 8316|       |
 8317|      0|        return;
 8318|      0|    }
 8319|       |
 8320|  1.19k|    group_cleanup(c, chat);
 8321|       |
 8322|  1.19k|    c->chats[chat->group_number] = empty_gc_chat;
 8323|       |
 8324|  1.19k|    uint32_t i;
 8325|       |
 8326|  2.67k|    for (i = c->chats_index; i > 0; --i) {
  ------------------
  |  Branch (8326:30): [True: 2.02k, False: 657]
  ------------------
 8327|  2.02k|        if (c->chats[i - 1].connection_state != CS_NONE) {
  ------------------
  |  Branch (8327:13): [True: 533, False: 1.48k]
  ------------------
 8328|    533|            break;
 8329|    533|        }
 8330|  2.02k|    }
 8331|       |
 8332|  1.19k|    if (c->chats_index != i) {
  ------------------
  |  Branch (8332:9): [True: 806, False: 384]
  ------------------
 8333|    806|        c->chats_index = i;
 8334|       |
 8335|    806|        if (!realloc_groupchats(c->messenger->mem, c, c->chats_index)) {
  ------------------
  |  Branch (8335:13): [True: 0, False: 806]
  ------------------
 8336|      0|            LOGGER_ERROR(c->messenger->log, "Failed to reallocate groupchats array");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8337|      0|        }
 8338|    806|    }
 8339|  1.19k|}
group_chats.c:group_cleanup:
 8287|  1.19k|{
 8288|  1.19k|    kill_group_friend_connection(c, chat);
 8289|       |
 8290|  1.19k|    mod_list_cleanup(&chat->moderation);
 8291|  1.19k|    sanctions_list_cleanup(&chat->moderation);
 8292|       |
 8293|  1.19k|    if (chat->tcp_conn != nullptr) {
  ------------------
  |  |   63|  1.19k|#define nullptr NULL
  ------------------
  |  Branch (8293:9): [True: 64, False: 1.12k]
  ------------------
 8294|     64|        kill_tcp_connections(chat->tcp_conn);
 8295|     64|    }
 8296|       |
 8297|  1.19k|    gcc_cleanup(chat);
 8298|       |
 8299|  1.19k|    if (chat->group != nullptr) {
  ------------------
  |  |   63|  1.19k|#define nullptr NULL
  ------------------
  |  Branch (8299:9): [True: 70, False: 1.12k]
  ------------------
 8300|     70|        mem_delete(chat->mem, chat->group);
 8301|     70|        chat->group = nullptr;
  ------------------
  |  |   63|     70|#define nullptr NULL
  ------------------
 8302|     70|    }
 8303|       |
 8304|  1.19k|    crypto_memunlock(&chat->self_secret_key, sizeof(chat->self_secret_key));
 8305|  1.19k|    crypto_memunlock(&chat->chat_secret_key, sizeof(chat->chat_secret_key));
 8306|  1.19k|    crypto_memunlock(chat->shared_state.password, sizeof(chat->shared_state.password));
 8307|  1.19k|}
group_chats.c:kill_group:
 8349|  1.19k|{
 8350|  1.19k|    const int ret = gc_group_exit(c, chat, nullptr, 0);
  ------------------
  |  |   63|  1.19k|#define nullptr NULL
  ------------------
 8351|  1.19k|    group_delete(c, chat);
 8352|  1.19k|    return ret;
 8353|  1.19k|}
group_chats.c:create_gc_session_keypair:
 8450|     70|{
 8451|     70|    if (crypto_new_keypair(rng, public_key, secret_key) != 0) {
  ------------------
  |  Branch (8451:9): [True: 0, False: 70]
  ------------------
 8452|      0|        LOGGER_FATAL(log, "Failed to create group session keypair");
  ------------------
  |  |   90|      0|    do {                                \
  |  |   91|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   92|      0|        logger_abort();                 \
  |  |   93|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (93:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 8453|      0|    }
 8454|     70|}

gcc_set_send_message_id:
   76|     70|{
   77|     70|    gconn->send_message_id = id;
   78|     70|    gconn->send_array_start = id % GCC_BUFFER_SIZE;
  ------------------
  |  |   55|     70|#define GCC_BUFFER_SIZE 2048
  ------------------
   79|     70|}
gcc_set_ip_port:
  279|     70|{
  280|     70|    if (ipp != nullptr && ipport_isset(ipp)) {
  ------------------
  |  |   63|    140|#define nullptr NULL
  ------------------
  |  Branch (280:9): [True: 0, False: 70]
  |  Branch (280:27): [True: 0, False: 0]
  ------------------
  281|      0|        gconn->addr.ip_port = *ipp;
  282|      0|    }
  283|     70|}
gcc_peer_cleanup:
  690|     70|{
  691|   143k|    for (size_t i = 0; i < GCC_BUFFER_SIZE; ++i) {
  ------------------
  |  |   55|   143k|#define GCC_BUFFER_SIZE 2048
  ------------------
  |  Branch (691:24): [True: 143k, False: 70]
  ------------------
  692|   143k|        mem_delete(mem, gconn->send_array[i].data);
  693|   143k|        mem_delete(mem, gconn->recv_array[i].data);
  694|   143k|    }
  695|       |
  696|     70|    mem_delete(mem, gconn->recv_array);
  697|     70|    mem_delete(mem, gconn->send_array);
  698|       |
  699|     70|    crypto_memunlock(gconn->session_secret_key, sizeof(gconn->session_secret_key));
  700|     70|    crypto_memunlock(gconn->session_shared_key, sizeof(gconn->session_shared_key));
  701|     70|    crypto_memzero(gconn, sizeof(GC_Connection));
  702|     70|}
gcc_cleanup:
  705|  1.19k|{
  706|  1.26k|    for (uint32_t i = 0; i < chat->numpeers; ++i) {
  ------------------
  |  Branch (706:26): [True: 70, False: 1.19k]
  ------------------
  707|     70|        GC_Connection *gconn = get_gc_connection(chat, i);
  708|     70|        assert(gconn != nullptr);
  709|       |
  710|     70|        gcc_peer_cleanup(chat->mem, gconn);
  711|     70|    }
  712|  1.19k|}

mod_list_unpack:
   43|     99|{
   44|     99|    if (length < num_mods * MOD_LIST_ENTRY_SIZE) {
  ------------------
  |  |   27|     99|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |  132|     99|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   33|     99|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (44:9): [True: 0, False: 99]
  ------------------
   45|      0|        return -1;
   46|      0|    }
   47|       |
   48|     99|    mod_list_cleanup(moderation);
   49|       |
   50|     99|    if (num_mods == 0) {
  ------------------
  |  Branch (50:9): [True: 0, False: 99]
  ------------------
   51|      0|        return 0;
   52|      0|    }
   53|       |
   54|     99|    uint8_t **tmp_list = (uint8_t **)mem_valloc(moderation->mem, num_mods, sizeof(uint8_t *));
   55|       |
   56|     99|    if (tmp_list == nullptr) {
  ------------------
  |  |   63|     99|#define nullptr NULL
  ------------------
  |  Branch (56:9): [True: 0, False: 99]
  ------------------
   57|      0|        return -1;
   58|      0|    }
   59|       |
   60|     99|    uint16_t unpacked_len = 0;
   61|       |
   62|  1.68k|    for (uint16_t i = 0; i < num_mods; ++i) {
  ------------------
  |  Branch (62:26): [True: 1.58k, False: 99]
  ------------------
   63|  1.58k|        uint8_t *entry = (uint8_t *)mem_balloc(moderation->mem, MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|  1.58k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |  132|  1.58k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   33|  1.58k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   64|       |
   65|  1.58k|        if (entry == nullptr) {
  ------------------
  |  |   63|  1.58k|#define nullptr NULL
  ------------------
  |  Branch (65:13): [True: 0, False: 1.58k]
  ------------------
   66|      0|            free_uint8_t_pointer_array(moderation->mem, tmp_list, i);
   67|      0|            return -1;
   68|      0|        }
   69|       |
   70|  1.58k|        memcpy(entry, &data[i * MOD_LIST_ENTRY_SIZE], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|  1.58k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |  132|  1.58k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   33|  1.58k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      memcpy(entry, &data[i * MOD_LIST_ENTRY_SIZE], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|  1.58k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |  132|  1.58k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   33|  1.58k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   71|  1.58k|        tmp_list[i] = entry;
   72|       |
   73|  1.58k|        unpacked_len += MOD_LIST_ENTRY_SIZE;
  ------------------
  |  |   27|  1.58k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |  132|  1.58k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   33|  1.58k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   74|  1.58k|    }
   75|       |
   76|     99|    moderation->mod_list = tmp_list;
   77|     99|    moderation->num_mods = num_mods;
   78|       |
   79|     99|    return unpacked_len;
   80|     99|}
mod_list_pack:
   83|     76|{
   84|  1.29k|    for (uint16_t i = 0; i < moderation->num_mods; ++i) {
  ------------------
  |  Branch (84:26): [True: 1.21k, False: 76]
  ------------------
   85|  1.21k|        memcpy(&data[i * MOD_LIST_ENTRY_SIZE], moderation->mod_list[i], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|  1.21k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |  132|  1.21k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   33|  1.21k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      memcpy(&data[i * MOD_LIST_ENTRY_SIZE], moderation->mod_list[i], MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|  1.21k|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |  132|  1.21k|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   33|  1.21k|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   86|  1.21k|    }
   87|     76|}
mod_list_cleanup:
  229|  1.28k|{
  230|  1.28k|    free_uint8_t_pointer_array(moderation->mem, moderation->mod_list, moderation->num_mods);
  231|  1.28k|    moderation->num_mods = 0;
  232|  1.28k|    moderation->mod_list = nullptr;
  ------------------
  |  |   63|  1.28k|#define nullptr NULL
  ------------------
  233|  1.28k|}
sanctions_list_cleanup:
  866|  1.19k|{
  867|  1.19k|    mem_delete(moderation->mem, moderation->sanctions);
  868|       |
  869|  1.19k|    moderation->sanctions = nullptr;
  ------------------
  |  |   63|  1.19k|#define nullptr NULL
  ------------------
  870|  1.19k|    moderation->num_sanctions = 0;
  871|  1.19k|}

gca_onion_init:
   78|  3.15k|{
   79|  3.15k|    onion_announce_extra_data_callback(onion_a, GCA_MAX_SENT_ANNOUNCES * sizeof(GC_Announce), pack_group_announces,
  ------------------
  |  |   34|  3.15k|#define GCA_MAX_SENT_ANNOUNCES 4
  ------------------
   80|  3.15k|                                       group_announce);
   81|  3.15k|}

group_privacy_state_from_int:
   33|  1.19k|{
   34|  1.19k|    switch (value) {
   35|    779|        case GI_PUBLIC: {
  ------------------
  |  Branch (35:9): [True: 779, False: 411]
  ------------------
   36|    779|            *out_enum = GI_PUBLIC;
   37|    779|            return true;
   38|      0|        }
   39|       |
   40|      7|        case GI_PRIVATE: {
  ------------------
  |  Branch (40:9): [True: 7, False: 1.18k]
  ------------------
   41|      7|            *out_enum = GI_PRIVATE;
   42|      7|            return true;
   43|      0|        }
   44|       |
   45|    404|        default: {
  ------------------
  |  Branch (45:9): [True: 404, False: 786]
  ------------------
   46|    404|            *out_enum = GI_PUBLIC;
   47|    404|            return false;
   48|      0|        }
   49|  1.19k|    }
   50|  1.19k|}
group_voice_state_from_int:
   53|  1.19k|{
   54|  1.19k|    switch (value) {
   55|    731|        case GV_ALL: {
  ------------------
  |  Branch (55:9): [True: 731, False: 459]
  ------------------
   56|    731|            *out_enum = GV_ALL;
   57|    731|            return true;
   58|      0|        }
   59|       |
   60|      5|        case GV_MODS: {
  ------------------
  |  Branch (60:9): [True: 5, False: 1.18k]
  ------------------
   61|      5|            *out_enum = GV_MODS;
   62|      5|            return true;
   63|      0|        }
   64|       |
   65|     42|        case GV_FOUNDER: {
  ------------------
  |  Branch (65:9): [True: 42, False: 1.14k]
  ------------------
   66|     42|            *out_enum = GV_FOUNDER;
   67|     42|            return true;
   68|      0|        }
   69|       |
   70|    412|        default: {
  ------------------
  |  Branch (70:9): [True: 412, False: 778]
  ------------------
   71|    412|            *out_enum = GV_ALL;
   72|    412|            return false;
   73|      0|        }
   74|  1.19k|    }
   75|  1.19k|}
gc_load_unpack_group:
  328|  25.7k|{
  329|  25.7k|    uint32_t actual_size;
  330|  25.7k|    if (!bin_unpack_array_fixed(bu, 7, &actual_size)) {
  ------------------
  |  Branch (330:9): [True: 4.39k, False: 21.3k]
  ------------------
  331|  4.39k|        LOGGER_ERROR(chat->log, "Group info array malformed: %d != 7", actual_size);
  ------------------
  |  |   87|  4.39k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  4.39k|    do {                                                                         \
  |  |  |  |   77|  4.39k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  8.78k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|  4.39k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|  4.39k|        }                                                                        \
  |  |  |  |   80|  4.39k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  332|  4.39k|        return false;
  333|  4.39k|    }
  334|       |
  335|  21.3k|    return load_unpack_state_values(chat, bu)
  ------------------
  |  Branch (335:12): [True: 1.19k, False: 20.1k]
  ------------------
  336|  21.3k|           && load_unpack_state_bin(chat, bu)
  ------------------
  |  Branch (336:15): [True: 177, False: 1.01k]
  ------------------
  337|  21.3k|           && load_unpack_topic_info(chat, bu)
  ------------------
  |  Branch (337:15): [True: 140, False: 37]
  ------------------
  338|  21.3k|           && load_unpack_mod_list(chat, bu)
  ------------------
  |  Branch (338:15): [True: 128, False: 12]
  ------------------
  339|  21.3k|           && load_unpack_keys(chat, bu)
  ------------------
  |  Branch (339:15): [True: 81, False: 47]
  ------------------
  340|  21.3k|           && load_unpack_self_info(chat, bu)
  ------------------
  |  Branch (340:15): [True: 70, False: 11]
  ------------------
  341|  21.3k|           && load_unpack_saved_peers(chat, bu);
  ------------------
  |  Branch (341:15): [True: 64, False: 6]
  ------------------
  342|  25.7k|}
gc_save_pack_group:
  482|    292|{
  483|    292|    if (chat->numpeers == 0) {
  ------------------
  |  Branch (483:9): [True: 216, False: 76]
  ------------------
  484|    216|        LOGGER_ERROR(chat->log, "Failed to pack group: numpeers is 0");
  ------------------
  |  |   87|    216|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|    216|    do {                                                                         \
  |  |  |  |   77|    216|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    432|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|    216|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|    216|        }                                                                        \
  |  |  |  |   80|    216|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  485|    216|        return;
  486|    216|    }
  487|       |
  488|     76|    bin_pack_array(bp, 7);
  489|       |
  490|     76|    save_pack_state_values(chat, bp); // 1
  491|     76|    save_pack_state_bin(chat, bp); // 2
  492|     76|    save_pack_topic_info(chat, bp); // 3
  493|     76|    save_pack_mod_list(chat, bp); // 4
  494|     76|    save_pack_keys(chat, bp); // 5
  495|     76|    save_pack_self_info(chat, bp); // 6
  496|     76|    save_pack_saved_peers(chat, bp); // 7
  497|     76|}
group_pack.c:load_unpack_state_values:
   79|  21.3k|{
   80|  21.3k|    if (!bin_unpack_array_fixed(bu, 8, nullptr)) {
  ------------------
  |  |   63|  21.3k|#define nullptr NULL
  ------------------
  |  Branch (80:9): [True: 808, False: 20.5k]
  ------------------
   81|    808|        LOGGER_ERROR(chat->log, "Group state values array malformed");
  ------------------
  |  |   87|    808|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|    808|    do {                                                                         \
  |  |  |  |   77|    808|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  1.61k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|    808|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|    808|        }                                                                        \
  |  |  |  |   80|    808|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   82|    808|        return false;
   83|    808|    }
   84|       |
   85|  20.5k|    bool manually_disconnected = false;
   86|  20.5k|    uint8_t privacy_state = 0;
   87|  20.5k|    uint8_t voice_state = 0;
   88|       |
   89|  20.5k|    if (!(bin_unpack_bool(bu, &manually_disconnected)
  ------------------
  |  Branch (89:11): [True: 12.9k, False: 7.62k]
  ------------------
   90|  20.5k|            && bin_unpack_u16(bu, &chat->shared_state.group_name_len)
  ------------------
  |  Branch (90:16): [True: 12.3k, False: 545]
  ------------------
   91|  20.5k|            && bin_unpack_u08(bu, &privacy_state)
  ------------------
  |  Branch (91:16): [True: 11.8k, False: 549]
  ------------------
   92|  20.5k|            && bin_unpack_u16(bu, &chat->shared_state.maxpeers)
  ------------------
  |  Branch (92:16): [True: 4.57k, False: 7.24k]
  ------------------
   93|  20.5k|            && bin_unpack_u16(bu, &chat->shared_state.password_length)
  ------------------
  |  Branch (93:16): [True: 4.24k, False: 330]
  ------------------
   94|  20.5k|            && bin_unpack_u32(bu, &chat->shared_state.version)
  ------------------
  |  Branch (94:16): [True: 3.89k, False: 356]
  ------------------
   95|  20.5k|            && bin_unpack_u32(bu, &chat->shared_state.topic_lock)
  ------------------
  |  Branch (95:16): [True: 1.42k, False: 2.46k]
  ------------------
   96|  20.5k|            && bin_unpack_u08(bu, &voice_state))) {
  ------------------
  |  Branch (96:16): [True: 1.19k, False: 238]
  ------------------
   97|  19.3k|        LOGGER_ERROR(chat->log, "Failed to unpack state value");
  ------------------
  |  |   87|  19.3k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  19.3k|    do {                                                                         \
  |  |  |  |   77|  19.3k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  38.6k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|  19.3k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|  19.3k|        }                                                                        \
  |  |  |  |   80|  19.3k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   98|  19.3k|        return false;
   99|  19.3k|    }
  100|       |
  101|  1.19k|    chat->connection_state = manually_disconnected ? CS_DISCONNECTED : CS_CONNECTING;
  ------------------
  |  Branch (101:30): [True: 20, False: 1.17k]
  ------------------
  102|  1.19k|    group_privacy_state_from_int(privacy_state, &chat->shared_state.privacy_state);
  103|  1.19k|    group_voice_state_from_int(voice_state, &chat->shared_state.voice_state);
  104|       |
  105|       |    // we always load saved groups as private in case the group became private while we were offline.
  106|       |    // this will have no detrimental effect if the group is public, as the correct privacy
  107|       |    // state will be set via sync.
  108|  1.19k|    chat->join_type = HJ_PRIVATE;
  109|       |
  110|  1.19k|    return true;
  111|  20.5k|}
group_pack.c:load_unpack_state_bin:
  115|  1.19k|{
  116|  1.19k|    if (!bin_unpack_array_fixed(bu, 5, nullptr)) {
  ------------------
  |  |   63|  1.19k|#define nullptr NULL
  ------------------
  |  Branch (116:9): [True: 953, False: 237]
  ------------------
  117|    953|        LOGGER_ERROR(chat->log, "Group state binary array malformed");
  ------------------
  |  |   87|    953|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|    953|    do {                                                                         \
  |  |  |  |   77|    953|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  1.90k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|    953|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|    953|        }                                                                        \
  |  |  |  |   80|    953|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  118|    953|        return false;
  119|    953|    }
  120|       |
  121|    237|    if (!bin_unpack_bin_fixed(bu, chat->shared_state_sig, SIGNATURE_SIZE)) {
  ------------------
  |  |   27|    237|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   28|    237|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  |  Branch (121:9): [True: 8, False: 229]
  ------------------
  122|      8|        LOGGER_ERROR(chat->log, "Failed to unpack shared state signature");
  ------------------
  |  |   87|      8|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      8|    do {                                                                         \
  |  |  |  |   77|      8|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     16|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      8|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      8|        }                                                                        \
  |  |  |  |   80|      8|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  123|      8|        return false;
  124|      8|    }
  125|       |
  126|    229|    if (!unpack_extended_public_key(&chat->shared_state.founder_public_key, bu)) {
  ------------------
  |  Branch (126:9): [True: 22, False: 207]
  ------------------
  127|     22|        LOGGER_ERROR(chat->log, "Failed to unpack founder public key");
  ------------------
  |  |   87|     22|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     22|    do {                                                                         \
  |  |  |  |   77|     22|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     44|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     22|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     22|        }                                                                        \
  |  |  |  |   80|     22|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  128|     22|        return false;
  129|     22|    }
  130|       |
  131|    207|    if (!(bin_unpack_bin_max(bu, chat->shared_state.group_name, &chat->shared_state.group_name_len, sizeof(chat->shared_state.group_name))
  ------------------
  |  Branch (131:11): [True: 186, False: 21]
  ------------------
  132|    207|            && bin_unpack_bin_max(bu, chat->shared_state.password, &chat->shared_state.password_length, sizeof(chat->shared_state.password))
  ------------------
  |  Branch (132:16): [True: 182, False: 4]
  ------------------
  133|    207|            && bin_unpack_bin_fixed(bu, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE))) {
  ------------------
  |  |   26|    182|#define MOD_MODERATION_HASH_SIZE CRYPTO_SHA256_SIZE
  |  |  ------------------
  |  |  |  |   74|    182|#define CRYPTO_SHA256_SIZE             32
  |  |  ------------------
  ------------------
  |  Branch (133:16): [True: 177, False: 5]
  ------------------
  134|     30|        LOGGER_ERROR(chat->log, "Failed to unpack state binary data");
  ------------------
  |  |   87|     30|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     30|    do {                                                                         \
  |  |  |  |   77|     30|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     60|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     30|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     30|        }                                                                        \
  |  |  |  |   80|     30|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  135|     30|        return false;
  136|     30|    }
  137|       |
  138|    177|    return true;
  139|    207|}
group_pack.c:load_unpack_topic_info:
  143|    177|{
  144|    177|    if (!bin_unpack_array_fixed(bu, 6, nullptr)) {
  ------------------
  |  |   63|    177|#define nullptr NULL
  ------------------
  |  Branch (144:9): [True: 2, False: 175]
  ------------------
  145|      2|        LOGGER_ERROR(chat->log, "Group topic array malformed");
  ------------------
  |  |   87|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      2|    do {                                                                         \
  |  |  |  |   77|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      2|        }                                                                        \
  |  |  |  |   80|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  146|      2|        return false;
  147|      2|    }
  148|       |
  149|    175|    if (!(bin_unpack_u32(bu, &chat->topic_info.version)
  ------------------
  |  Branch (149:11): [True: 170, False: 5]
  ------------------
  150|    175|            && bin_unpack_u16(bu, &chat->topic_info.length)
  ------------------
  |  Branch (150:16): [True: 166, False: 4]
  ------------------
  151|    175|            && bin_unpack_u16(bu, &chat->topic_info.checksum)
  ------------------
  |  Branch (151:16): [True: 165, False: 1]
  ------------------
  152|    175|            && bin_unpack_bin_max(bu, chat->topic_info.topic, &chat->topic_info.length, sizeof(chat->topic_info.topic))
  ------------------
  |  Branch (152:16): [True: 161, False: 4]
  ------------------
  153|    175|            && bin_unpack_bin_fixed(bu, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE)
  ------------------
  |  |  132|    161|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   33|    161|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
  |  Branch (153:16): [True: 146, False: 15]
  ------------------
  154|    175|            && bin_unpack_bin_fixed(bu, chat->topic_sig, SIGNATURE_SIZE))) {
  ------------------
  |  |   27|    146|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   28|    146|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  |  Branch (154:16): [True: 140, False: 6]
  ------------------
  155|     35|        LOGGER_ERROR(chat->log, "Failed to unpack topic info");
  ------------------
  |  |   87|     35|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     35|    do {                                                                         \
  |  |  |  |   77|     35|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     70|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     35|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     35|        }                                                                        \
  |  |  |  |   80|     35|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  156|     35|        return false;
  157|     35|    }
  158|       |
  159|    140|    return true;
  160|    175|}
group_pack.c:load_unpack_mod_list:
  164|    140|{
  165|    140|    uint32_t actual_size = 0;
  166|    140|    if (!bin_unpack_array_fixed(bu, 2, &actual_size)) {
  ------------------
  |  Branch (166:9): [True: 4, False: 136]
  ------------------
  167|      4|        LOGGER_ERROR(chat->log, "Group mod list array malformed: %d != 2", actual_size);
  ------------------
  |  |   87|      4|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      4|    do {                                                                         \
  |  |  |  |   77|      4|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      8|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      4|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      4|        }                                                                        \
  |  |  |  |   80|      4|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  168|      4|        return false;
  169|      4|    }
  170|       |
  171|    136|    if (!bin_unpack_u16(bu, &chat->moderation.num_mods)) {
  ------------------
  |  Branch (171:9): [True: 4, False: 132]
  ------------------
  172|      4|        LOGGER_ERROR(chat->log, "Failed to unpack mod list value");
  ------------------
  |  |   87|      4|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      4|    do {                                                                         \
  |  |  |  |   77|      4|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      8|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      4|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      4|        }                                                                        \
  |  |  |  |   80|      4|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  173|      4|        return false;
  174|      4|    }
  175|       |
  176|    132|    if (chat->moderation.num_mods == 0) {
  ------------------
  |  Branch (176:9): [True: 29, False: 103]
  ------------------
  177|     29|        bin_unpack_nil(bu);
  178|     29|        return true;
  179|     29|    }
  180|       |
  181|    103|    if (chat->moderation.num_mods > MOD_MAX_NUM_MODERATORS) {
  ------------------
  |  |   46|    103|#define MOD_MAX_NUM_MODERATORS       ((MOD_MAX_NUM_MODERATORS_LIMIT / 16) + 3)
  |  |  ------------------
  |  |  |  |   43|    103|#define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|    103|#define MAX_PACKET_SIZE_NO_HEADERS 49900
  |  |  |  |  ------------------
  |  |  |  |               #define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   27|    103|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  132|    103|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   33|    103|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (181:9): [True: 2, False: 101]
  ------------------
  182|      2|        LOGGER_ERROR(chat->log, "moderation count %u exceeds maximum %u", chat->moderation.num_mods, MOD_MAX_NUM_MODERATORS);
  ------------------
  |  |   87|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      2|    do {                                                                         \
  |  |  |  |   77|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      2|        }                                                                        \
  |  |  |  |   80|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  183|      2|        chat->moderation.num_mods = MOD_MAX_NUM_MODERATORS;
  ------------------
  |  |   46|      2|#define MOD_MAX_NUM_MODERATORS       ((MOD_MAX_NUM_MODERATORS_LIMIT / 16) + 3)
  |  |  ------------------
  |  |  |  |   43|      2|#define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|      2|#define MAX_PACKET_SIZE_NO_HEADERS 49900
  |  |  |  |  ------------------
  |  |  |  |               #define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   27|      2|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  132|      2|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   33|      2|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  184|      2|    }
  185|       |
  186|    103|    uint8_t *packed_mod_list = (uint8_t *)mem_balloc(chat->mem, chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|    103|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |  132|    103|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   33|    103|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  187|       |
  188|    103|    if (packed_mod_list == nullptr) {
  ------------------
  |  |   63|    103|#define nullptr NULL
  ------------------
  |  Branch (188:9): [True: 0, False: 103]
  ------------------
  189|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for packed mod list");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  190|      0|        return false;
  191|      0|    }
  192|       |
  193|    103|    const size_t packed_size = chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE;
  ------------------
  |  |   27|    103|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |  132|    103|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   33|    103|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  194|       |
  195|    103|    if (!bin_unpack_bin_fixed(bu, packed_mod_list, packed_size)) {
  ------------------
  |  Branch (195:9): [True: 4, False: 99]
  ------------------
  196|      4|        LOGGER_ERROR(chat->log, "Failed to unpack mod list binary data");
  ------------------
  |  |   87|      4|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      4|    do {                                                                         \
  |  |  |  |   77|      4|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      8|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      4|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      4|        }                                                                        \
  |  |  |  |   80|      4|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  197|      4|        mem_delete(chat->mem, packed_mod_list);
  198|      4|        return false;
  199|      4|    }
  200|       |
  201|     99|    if (mod_list_unpack(&chat->moderation, packed_mod_list, packed_size, chat->moderation.num_mods) == -1) {
  ------------------
  |  Branch (201:9): [True: 0, False: 99]
  ------------------
  202|      0|        LOGGER_ERROR(chat->log, "Failed to unpack mod list info");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  203|      0|        mem_delete(chat->mem, packed_mod_list);
  204|      0|        return false;
  205|      0|    }
  206|       |
  207|     99|    mem_delete(chat->mem, packed_mod_list);
  208|       |
  209|     99|    return true;
  210|     99|}
group_pack.c:load_unpack_keys:
  214|    128|{
  215|    128|    if (!bin_unpack_array_fixed(bu, 4, nullptr)) {
  ------------------
  |  |   63|    128|#define nullptr NULL
  ------------------
  |  Branch (215:9): [True: 9, False: 119]
  ------------------
  216|      9|        LOGGER_ERROR(chat->log, "Group keys array malformed");
  ------------------
  |  |   87|      9|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      9|    do {                                                                         \
  |  |  |  |   77|      9|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     18|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      9|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      9|        }                                                                        \
  |  |  |  |   80|      9|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  217|      9|        return false;
  218|      9|    }
  219|       |
  220|    119|    if (!(unpack_extended_public_key(&chat->chat_public_key, bu)
  ------------------
  |  Branch (220:11): [True: 117, False: 2]
  ------------------
  221|    119|            && unpack_extended_secret_key(&chat->chat_secret_key, bu)
  ------------------
  |  Branch (221:16): [True: 105, False: 12]
  ------------------
  222|    119|            && unpack_extended_public_key(&chat->self_public_key, bu)
  ------------------
  |  Branch (222:16): [True: 87, False: 18]
  ------------------
  223|    119|            && unpack_extended_secret_key(&chat->self_secret_key, bu))) {
  ------------------
  |  Branch (223:16): [True: 81, False: 6]
  ------------------
  224|     38|        LOGGER_ERROR(chat->log, "Failed to unpack keys");
  ------------------
  |  |   87|     38|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     38|    do {                                                                         \
  |  |  |  |   77|     38|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     76|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     38|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     38|        }                                                                        \
  |  |  |  |   80|     38|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  225|     38|        return false;
  226|     38|    }
  227|       |
  228|     81|    return true;
  229|    119|}
group_pack.c:load_unpack_self_info:
  233|     81|{
  234|     81|    if (!bin_unpack_array_fixed(bu, 4, nullptr)) {
  ------------------
  |  |   63|     81|#define nullptr NULL
  ------------------
  |  Branch (234:9): [True: 3, False: 78]
  ------------------
  235|      3|        LOGGER_ERROR(chat->log, "Group self info array malformed");
  ------------------
  |  |   87|      3|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      3|    do {                                                                         \
  |  |  |  |   77|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      3|        }                                                                        \
  |  |  |  |   80|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  236|      3|        return false;
  237|      3|    }
  238|       |
  239|     78|    uint8_t self_nick[MAX_GC_NICK_SIZE];
  240|     78|    uint16_t self_nick_len = 0;
  241|     78|    uint8_t self_role = GR_USER;
  242|     78|    uint8_t self_status = GS_NONE;
  243|       |
  244|     78|    if (!(bin_unpack_u16(bu, &self_nick_len)
  ------------------
  |  Branch (244:11): [True: 77, False: 1]
  ------------------
  245|     78|            && bin_unpack_u08(bu, &self_role)
  ------------------
  |  Branch (245:16): [True: 75, False: 2]
  ------------------
  246|     78|            && bin_unpack_u08(bu, &self_status))) {
  ------------------
  |  Branch (246:16): [True: 71, False: 4]
  ------------------
  247|      7|        LOGGER_ERROR(chat->log, "Failed to unpack self values");
  ------------------
  |  |   87|      7|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      7|    do {                                                                         \
  |  |  |  |   77|      7|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     14|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      7|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      7|        }                                                                        \
  |  |  |  |   80|      7|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  248|      7|        return false;
  249|      7|    }
  250|       |
  251|     71|    if (self_nick_len > MAX_GC_NICK_SIZE) {
  ------------------
  |  |   26|     71|#define MAX_GC_NICK_SIZE 128
  ------------------
  |  Branch (251:9): [True: 0, False: 71]
  ------------------
  252|      0|        LOGGER_ERROR(chat->log, "self_nick too big (%u bytes), truncating to %d", self_nick_len, MAX_GC_NICK_SIZE);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  253|      0|        self_nick_len = MAX_GC_NICK_SIZE;
  ------------------
  |  |   26|      0|#define MAX_GC_NICK_SIZE 128
  ------------------
  254|      0|    }
  255|       |
  256|     71|    if (!bin_unpack_bin_fixed(bu, self_nick, self_nick_len)) {
  ------------------
  |  Branch (256:9): [True: 1, False: 70]
  ------------------
  257|      1|        LOGGER_ERROR(chat->log, "Failed to unpack self nick bytes");
  ------------------
  |  |   87|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      1|    do {                                                                         \
  |  |  |  |   77|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      1|        }                                                                        \
  |  |  |  |   80|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  258|      1|        return false;
  259|      1|    }
  260|       |
  261|       |    // we have to add ourself before setting self info
  262|     70|    if (peer_add(chat, nullptr, chat->self_public_key.enc) != 0) {
  ------------------
  |  |   63|     70|#define nullptr NULL
  ------------------
  |  Branch (262:9): [True: 0, False: 70]
  ------------------
  263|      0|        LOGGER_ERROR(chat->log, "Failed to add self to peer list");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  264|      0|        return false;
  265|      0|    }
  266|       |
  267|     70|    if (chat->numpeers == 0) {
  ------------------
  |  Branch (267:9): [True: 0, False: 70]
  ------------------
  268|      0|        LOGGER_ERROR(chat->log, "Failed to unpack self: numpeers should be > 0");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  269|      0|        return false;
  270|      0|    }
  271|       |
  272|     70|    GC_Peer *self = &chat->group[0];
  273|       |
  274|     70|    self->gconn.addr.public_key = chat->self_public_key;
  275|     70|    memcpy(self->nick, self_nick, self_nick_len);
  276|     70|    self->nick_length = self_nick_len;
  277|     70|    self->role = (Group_Role)self_role;
  278|     70|    self->status = (Group_Peer_Status)self_status;
  279|     70|    self->gconn.confirmed = true;
  280|       |
  281|     70|    return true;
  282|     70|}
group_pack.c:load_unpack_saved_peers:
  286|     70|{
  287|     70|    if (!bin_unpack_array_fixed(bu, 2, nullptr)) {
  ------------------
  |  |   63|     70|#define nullptr NULL
  ------------------
  |  Branch (287:9): [True: 2, False: 68]
  ------------------
  288|      2|        LOGGER_ERROR(chat->log, "Group saved peers array malformed");
  ------------------
  |  |   87|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      2|    do {                                                                         \
  |  |  |  |   77|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      2|        }                                                                        \
  |  |  |  |   80|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  289|      2|        return false;
  290|      2|    }
  291|       |
  292|       |    // Saved peers
  293|     68|    uint16_t saved_peers_size = 0;
  294|       |
  295|     68|    if (!bin_unpack_u16(bu, &saved_peers_size)) {
  ------------------
  |  Branch (295:9): [True: 1, False: 67]
  ------------------
  296|      1|        LOGGER_ERROR(chat->log, "Failed to unpack saved peers value");
  ------------------
  |  |   87|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      1|    do {                                                                         \
  |  |  |  |   77|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      1|        }                                                                        \
  |  |  |  |   80|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  297|      1|        return false;
  298|      1|    }
  299|       |
  300|     67|    if (saved_peers_size == 0) {
  ------------------
  |  Branch (300:9): [True: 3, False: 64]
  ------------------
  301|      3|        bin_unpack_nil(bu);
  302|      3|        return true;
  303|      3|    }
  304|       |
  305|     64|    uint8_t *saved_peers = (uint8_t *)mem_balloc(chat->mem, saved_peers_size * GC_SAVED_PEER_SIZE);
  ------------------
  |  |   49|     64|#define GC_SAVED_PEER_SIZE (ENC_PUBLIC_KEY_SIZE + sizeof(Node_format) + sizeof(IP_Port))
  |  |  ------------------
  |  |  |  |  122|     64|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|     64|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  306|       |
  307|     64|    if (saved_peers == nullptr) {
  ------------------
  |  |   63|     64|#define nullptr NULL
  ------------------
  |  Branch (307:9): [True: 0, False: 64]
  ------------------
  308|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for saved peer list");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  309|      0|        return false;
  310|      0|    }
  311|       |
  312|     64|    if (!bin_unpack_bin_fixed(bu, saved_peers, saved_peers_size)) {
  ------------------
  |  Branch (312:9): [True: 3, False: 61]
  ------------------
  313|      3|        LOGGER_ERROR(chat->log, "Failed to unpack saved peers binary data");
  ------------------
  |  |   87|      3|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      3|    do {                                                                         \
  |  |  |  |   77|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      3|        }                                                                        \
  |  |  |  |   80|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  314|      3|        mem_delete(chat->mem, saved_peers);
  315|      3|        return false;
  316|      3|    }
  317|       |
  318|     61|    if (unpack_gc_saved_peers(chat, saved_peers, saved_peers_size) == -1) {
  ------------------
  |  Branch (318:9): [True: 59, False: 2]
  ------------------
  319|     59|        LOGGER_ERROR(chat->log, "Failed to unpack saved peers");  // recoverable error
  ------------------
  |  |   87|     59|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     59|    do {                                                                         \
  |  |  |  |   77|     59|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    118|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     59|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     59|        }                                                                        \
  |  |  |  |   80|     59|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  320|     59|    }
  321|       |
  322|     61|    mem_delete(chat->mem, saved_peers);
  323|       |
  324|     61|    return true;
  325|     64|}
group_pack.c:save_pack_state_values:
  346|     76|{
  347|     76|    bin_pack_array(bp, 8);
  348|     76|    bin_pack_bool(bp, chat->connection_state == CS_DISCONNECTED); // 1
  349|     76|    bin_pack_u16(bp, chat->shared_state.group_name_len); // 2
  350|     76|    bin_pack_u08(bp, chat->shared_state.privacy_state); // 3
  351|     76|    bin_pack_u16(bp, chat->shared_state.maxpeers); // 4
  352|     76|    bin_pack_u16(bp, chat->shared_state.password_length); // 5
  353|     76|    bin_pack_u32(bp, chat->shared_state.version); // 6
  354|     76|    bin_pack_u32(bp, chat->shared_state.topic_lock); // 7
  355|     76|    bin_pack_u08(bp, chat->shared_state.voice_state); // 8
  356|     76|}
group_pack.c:save_pack_state_bin:
  360|     76|{
  361|     76|    bin_pack_array(bp, 5);
  362|       |
  363|     76|    bin_pack_bin(bp, chat->shared_state_sig, SIGNATURE_SIZE); // 1
  ------------------
  |  |   27|     76|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   28|     76|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  364|     76|    pack_extended_public_key(&chat->shared_state.founder_public_key, bp); // 2
  365|     76|    bin_pack_bin(bp, chat->shared_state.group_name, chat->shared_state.group_name_len); // 3
  366|     76|    bin_pack_bin(bp, chat->shared_state.password, chat->shared_state.password_length); // 4
  367|     76|    bin_pack_bin(bp, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE); // 5
  ------------------
  |  |   26|     76|#define MOD_MODERATION_HASH_SIZE CRYPTO_SHA256_SIZE
  |  |  ------------------
  |  |  |  |   74|     76|#define CRYPTO_SHA256_SIZE             32
  |  |  ------------------
  ------------------
  368|     76|}
group_pack.c:save_pack_topic_info:
  372|     76|{
  373|     76|    bin_pack_array(bp, 6);
  374|       |
  375|     76|    bin_pack_u32(bp, chat->topic_info.version); // 1
  376|     76|    bin_pack_u16(bp, chat->topic_info.length); // 2
  377|     76|    bin_pack_u16(bp, chat->topic_info.checksum); // 3
  378|     76|    bin_pack_bin(bp, chat->topic_info.topic, chat->topic_info.length); // 4
  379|     76|    bin_pack_bin(bp, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE); // 5
  ------------------
  |  |  132|     76|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   33|     76|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  ------------------
  ------------------
  380|     76|    bin_pack_bin(bp, chat->topic_sig, SIGNATURE_SIZE); // 6
  ------------------
  |  |   27|     76|#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
  |  |  ------------------
  |  |  |  |   28|     76|#define CRYPTO_SIGNATURE_SIZE          64
  |  |  ------------------
  ------------------
  381|     76|}
group_pack.c:save_pack_mod_list:
  385|     76|{
  386|     76|    bin_pack_array(bp, 2);
  387|       |
  388|     76|    const uint16_t num_mods = min_u16(chat->moderation.num_mods, MOD_MAX_NUM_MODERATORS);
  ------------------
  |  |   46|     76|#define MOD_MAX_NUM_MODERATORS       ((MOD_MAX_NUM_MODERATORS_LIMIT / 16) + 3)
  |  |  ------------------
  |  |  |  |   43|     76|#define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   40|     76|#define MAX_PACKET_SIZE_NO_HEADERS 49900
  |  |  |  |  ------------------
  |  |  |  |               #define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))
  |  |  |  |  ------------------
  |  |  |  |  |  |   27|     76|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  132|     76|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   33|     76|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  389|       |
  390|     76|    if (num_mods == 0) {
  ------------------
  |  Branch (390:9): [True: 0, False: 76]
  ------------------
  391|      0|        bin_pack_u16(bp, num_mods); // 1
  392|      0|        bin_pack_nil(bp); // 2
  393|      0|        return;
  394|      0|    }
  395|       |
  396|     76|    uint8_t *packed_mod_list = (uint8_t *)mem_balloc(chat->mem, num_mods * MOD_LIST_ENTRY_SIZE);
  ------------------
  |  |   27|     76|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |  132|     76|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   33|     76|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  397|       |
  398|       |    // we can still recover without the mod list
  399|     76|    if (packed_mod_list == nullptr) {
  ------------------
  |  |   63|     76|#define nullptr NULL
  ------------------
  |  Branch (399:9): [True: 0, False: 76]
  ------------------
  400|      0|        bin_pack_u16(bp, 0); // 1
  401|      0|        bin_pack_nil(bp); // 2
  402|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for moderation list");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  403|      0|        return;
  404|      0|    }
  405|       |
  406|     76|    bin_pack_u16(bp, num_mods); // 1
  407|       |
  408|     76|    mod_list_pack(&chat->moderation, packed_mod_list);
  409|       |
  410|     76|    const size_t packed_size = num_mods * MOD_LIST_ENTRY_SIZE;
  ------------------
  |  |   27|     76|#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |  132|     76|#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   33|     76|#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  411|       |
  412|     76|    bin_pack_bin(bp, packed_mod_list, packed_size); // 2
  413|       |
  414|     76|    mem_delete(chat->mem, packed_mod_list);
  415|     76|}
group_pack.c:save_pack_keys:
  419|     76|{
  420|     76|    bin_pack_array(bp, 4);
  421|       |
  422|     76|    pack_extended_public_key(&chat->chat_public_key, bp); // 1
  423|     76|    pack_extended_secret_key(&chat->chat_secret_key, bp); // 2
  424|     76|    pack_extended_public_key(&chat->self_public_key, bp); // 3
  425|     76|    pack_extended_secret_key(&chat->self_secret_key, bp); // 4
  426|     76|}
group_pack.c:save_pack_self_info:
  430|     76|{
  431|     76|    bin_pack_array(bp, 4);
  432|       |
  433|     76|    GC_Peer *self = &chat->group[0];
  434|       |
  435|     76|    if (self->nick_length > MAX_GC_NICK_SIZE) {
  ------------------
  |  |   26|     76|#define MAX_GC_NICK_SIZE 128
  ------------------
  |  Branch (435:9): [True: 0, False: 76]
  ------------------
  436|      0|        LOGGER_ERROR(chat->log, "self_nick is too big (%u). Truncating to %d", self->nick_length, MAX_GC_NICK_SIZE);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  437|      0|        self->nick_length = MAX_GC_NICK_SIZE;
  ------------------
  |  |   26|      0|#define MAX_GC_NICK_SIZE 128
  ------------------
  438|      0|    }
  439|       |
  440|     76|    bin_pack_u16(bp, self->nick_length); // 1
  441|     76|    bin_pack_u08(bp, (uint8_t)self->role); // 2
  442|     76|    bin_pack_u08(bp, self->status); // 3
  443|     76|    bin_pack_bin(bp, self->nick, self->nick_length); // 4
  444|     76|}
group_pack.c:save_pack_saved_peers:
  448|     76|{
  449|     76|    bin_pack_array(bp, 2);
  450|       |
  451|     76|    uint8_t *saved_peers = (uint8_t *)mem_balloc(chat->mem, GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE);
  ------------------
  |  |   48|     76|#define GC_MAX_SAVED_PEERS 100
  ------------------
                  uint8_t *saved_peers = (uint8_t *)mem_balloc(chat->mem, GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE);
  ------------------
  |  |   49|     76|#define GC_SAVED_PEER_SIZE (ENC_PUBLIC_KEY_SIZE + sizeof(Node_format) + sizeof(IP_Port))
  |  |  ------------------
  |  |  |  |  122|     76|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|     76|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  452|       |
  453|       |    // we can still recover without the saved peers list
  454|     76|    if (saved_peers == nullptr) {
  ------------------
  |  |   63|     76|#define nullptr NULL
  ------------------
  |  Branch (454:9): [True: 0, False: 76]
  ------------------
  455|      0|        bin_pack_u16(bp, 0); // 1
  456|      0|        bin_pack_nil(bp); // 2
  457|      0|        LOGGER_ERROR(chat->log, "Failed to allocate memory for saved peers list");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  458|      0|        return;
  459|      0|    }
  460|       |
  461|     76|    uint16_t packed_size = 0;
  462|     76|    const int count = pack_gc_saved_peers(chat, saved_peers, GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE, &packed_size);
  ------------------
  |  |   48|     76|#define GC_MAX_SAVED_PEERS 100
  ------------------
                  const int count = pack_gc_saved_peers(chat, saved_peers, GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE, &packed_size);
  ------------------
  |  |   49|     76|#define GC_SAVED_PEER_SIZE (ENC_PUBLIC_KEY_SIZE + sizeof(Node_format) + sizeof(IP_Port))
  |  |  ------------------
  |  |  |  |  122|     76|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  |  |  ------------------
  |  |  |  |  |  |   43|     76|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  463|       |
  464|     76|    if (count < 0) {
  ------------------
  |  Branch (464:9): [True: 0, False: 76]
  ------------------
  465|      0|        LOGGER_ERROR(chat->log, "Failed to pack saved peers");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  466|      0|    }
  467|       |
  468|     76|    bin_pack_u16(bp, packed_size); // 1
  469|       |
  470|     76|    if (packed_size == 0) {
  ------------------
  |  Branch (470:9): [True: 4, False: 72]
  ------------------
  471|      4|        bin_pack_nil(bp); // 2
  472|      4|        mem_delete(chat->mem, saved_peers);
  473|      4|        return;
  474|      4|    }
  475|       |
  476|     72|    bin_pack_bin(bp, saved_peers, packed_size); // 2
  477|       |
  478|     72|    mem_delete(chat->mem, saved_peers);
  479|     72|}

bs_list_init:
  138|  3.15k|{
  139|  3.15k|    list->mem = mem;
  140|       |
  141|       |    // set initial values
  142|  3.15k|    list->n = 0;
  143|  3.15k|    list->element_size = element_size;
  144|  3.15k|    list->capacity = 0;
  145|  3.15k|    list->data = nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  146|  3.15k|    list->ids = nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  147|  3.15k|    list->cmp_callback = cmp_callback;
  148|       |
  149|  3.15k|    if (initial_capacity != 0) {
  ------------------
  |  Branch (149:9): [True: 3.15k, False: 0]
  ------------------
  150|  3.15k|        if (!resize(list, initial_capacity)) {
  ------------------
  |  Branch (150:13): [True: 0, False: 3.15k]
  ------------------
  151|      0|            return 0;
  152|      0|        }
  153|  3.15k|    }
  154|       |
  155|  3.15k|    list->capacity = initial_capacity;
  156|       |
  157|  3.15k|    return 1;
  158|  3.15k|}
bs_list_free:
  161|  3.15k|{
  162|  3.15k|    if (list == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (162:9): [True: 0, False: 3.15k]
  ------------------
  163|      0|        return;
  164|      0|    }
  165|       |
  166|       |    // free both arrays
  167|  3.15k|    mem_delete(list->mem, list->data);
  168|  3.15k|    list->data = nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  169|       |
  170|  3.15k|    mem_delete(list->mem, list->ids);
  171|  3.15k|    list->ids = nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  172|  3.15k|}
list.c:resize:
  112|  3.15k|{
  113|  3.15k|    if (new_size == 0) {
  ------------------
  |  Branch (113:9): [True: 0, False: 3.15k]
  ------------------
  114|      0|        bs_list_free(list);
  115|      0|        return true;
  116|      0|    }
  117|       |
  118|  3.15k|    uint8_t *data = (uint8_t *)mem_brealloc(list->mem, list->data, new_size * list->element_size);
  119|       |
  120|  3.15k|    if (data == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (120:9): [True: 0, False: 3.15k]
  ------------------
  121|      0|        return false;
  122|      0|    }
  123|       |
  124|  3.15k|    list->data = data;
  125|       |
  126|  3.15k|    int *ids = (int *)mem_vrealloc(list->mem, list->ids, new_size, sizeof(int));
  127|       |
  128|  3.15k|    if (ids == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (128:9): [True: 0, False: 3.15k]
  ------------------
  129|      0|        return false;
  130|      0|    }
  131|       |
  132|  3.15k|    list->ids = ids;
  133|       |
  134|  3.15k|    return true;
  135|  3.15k|}

logger_new:
   33|  3.15k|{
   34|  3.15k|    Logger *log = (Logger *)mem_alloc(mem, sizeof(Logger));
   35|       |
   36|  3.15k|    if (log == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (36:9): [True: 0, False: 3.15k]
  ------------------
   37|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   38|      0|    }
   39|       |
   40|  3.15k|    log->mem = mem;
   41|       |
   42|  3.15k|    return log;
   43|  3.15k|}
logger_kill:
   46|  3.15k|{
   47|  3.15k|    if (log == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (47:9): [True: 0, False: 3.15k]
  ------------------
   48|      0|        return;
   49|      0|    }
   50|       |
   51|  3.15k|    mem_delete(log->mem, log);
   52|  3.15k|}
logger_callback_log:
   55|  3.15k|{
   56|  3.15k|    assert(log != nullptr);
   57|  3.15k|    log->callback = function;
   58|  3.15k|    log->context  = context;
   59|  3.15k|    log->userdata = userdata;
   60|  3.15k|}
logger_write:
   64|  82.0k|{
   65|  82.0k|    if (log == nullptr) {
  ------------------
  |  |   63|  82.0k|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 0, False: 82.0k]
  ------------------
   66|      0|        return;
   67|      0|    }
   68|       |
   69|  82.0k|    if (log->callback == nullptr) {
  ------------------
  |  |   63|  82.0k|#define nullptr NULL
  ------------------
  |  Branch (69:9): [True: 0, False: 82.0k]
  ------------------
   70|      0|        return;
   71|      0|    }
   72|       |
   73|       |    // Only pass the file name, not the entire file path, for privacy reasons.
   74|       |    // The full path may contain PII of the person compiling toxcore (their
   75|       |    // username and directory layout).
   76|  82.0k|    const char *filename = strrchr(file, '/');
   77|  82.0k|    file = filename != nullptr ? filename + 1 : file;
  ------------------
  |  |   63|  82.0k|#define nullptr NULL
  ------------------
  |  Branch (77:12): [True: 82.0k, False: 0]
  ------------------
   78|       |#if defined(_WIN32) || defined(__CYGWIN__)
   79|       |    // On Windows, the path separator *may* be a backslash, so we look for that
   80|       |    // one too.
   81|       |    const char *windows_filename = strrchr(file, '\\');
   82|       |    file = windows_filename != nullptr ? windows_filename + 1 : file;
   83|       |#endif /* WIN32 */
   84|       |
   85|       |    // Format message
   86|  82.0k|    char msg[1024];
   87|  82.0k|    va_list args;
   88|  82.0k|    va_start(args, format);
   89|  82.0k|    vsnprintf(msg, sizeof(msg), format, args);
   90|  82.0k|    va_end(args);
   91|       |
   92|  82.0k|    log->callback(log->context, level, file, line, func, msg, log->userdata);
   93|  82.0k|}

os_memory:
   46|  3.15k|{
   47|  3.15k|    return &os_memory_obj;
   48|  3.15k|}
mem_balloc:
   51|  3.07k|{
   52|  3.07k|    void *const ptr = mem->funcs->malloc(mem->obj, size);
   53|  3.07k|    return ptr;
   54|  3.07k|}
mem_brealloc:
   57|  3.15k|{
   58|  3.15k|    void *const new_ptr = mem->funcs->realloc(mem->obj, ptr, size);
   59|  3.15k|    return new_ptr;
   60|  3.15k|}
mem_alloc:
   63|   104k|{
   64|   104k|    void *const ptr = mem->funcs->calloc(mem->obj, 1, size);
   65|   104k|    return ptr;
   66|   104k|}
mem_valloc:
   69|  33.0k|{
   70|  33.0k|    const uint32_t bytes = nmemb * size;
   71|       |
   72|  33.0k|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (72:9): [True: 33.0k, False: 0]
  |  Branch (72:22): [True: 0, False: 33.0k]
  ------------------
   73|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   74|      0|    }
   75|       |
   76|  33.0k|    void *const ptr = mem->funcs->calloc(mem->obj, nmemb, size);
   77|  33.0k|    return ptr;
   78|  33.0k|}
mem_vrealloc:
   81|  52.7k|{
   82|  52.7k|    const uint32_t bytes = nmemb * size;
   83|       |
   84|  52.7k|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (84:9): [True: 52.7k, False: 0]
  |  Branch (84:22): [True: 0, False: 52.7k]
  ------------------
   85|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   86|      0|    }
   87|       |
   88|  52.7k|    void *const new_ptr = mem->funcs->realloc(mem->obj, ptr, bytes);
   89|  52.7k|    return new_ptr;
   90|  52.7k|}
mem_delete:
   93|  1.27M|{
   94|  1.27M|    mem->funcs->free(mem->obj, ptr);
   95|  1.27M|}

mono_time_new:
  114|  3.15k|{
  115|  3.15k|    Mono_Time *mono_time = (Mono_Time *)mem_alloc(mem, sizeof(Mono_Time));
  116|       |
  117|  3.15k|    if (mono_time == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (117:9): [True: 0, False: 3.15k]
  ------------------
  118|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  119|      0|    }
  120|       |
  121|  3.15k|#ifndef ESP_PLATFORM
  122|  3.15k|    pthread_rwlock_t *rwlock = (pthread_rwlock_t *)mem_alloc(mem, sizeof(pthread_rwlock_t));
  123|       |
  124|  3.15k|    if (rwlock == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (124:9): [True: 0, False: 3.15k]
  ------------------
  125|      0|        mem_delete(mem, mono_time);
  126|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  127|      0|    }
  128|       |
  129|  3.15k|    if (pthread_rwlock_init(rwlock, nullptr) != 0) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (129:9): [True: 0, False: 3.15k]
  ------------------
  130|      0|        mem_delete(mem, rwlock);
  131|      0|        mem_delete(mem, mono_time);
  132|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  133|      0|    }
  134|       |
  135|  3.15k|    mono_time->time_update_lock = rwlock;
  136|  3.15k|#endif /* ESP_PLATFORM */
  137|       |
  138|  3.15k|    mono_time_set_current_time_callback(mono_time, current_time_callback, user_data);
  139|       |
  140|  3.15k|    mono_time->cur_time = 0;
  141|  3.15k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  142|       |    // Maximum reproducibility. Never return time = 0.
  143|  3.15k|    mono_time->base_time = 1000000000;
  144|       |#else
  145|       |    // Never return time = 0 in case time() returns 0 (e.g. on microcontrollers
  146|       |    // without battery-powered RTC or ones where NTP didn't initialise it yet).
  147|       |    mono_time->base_time = max_u64(1, (uint64_t)time(nullptr)) * UINT64_C(1000) - current_time_monotonic(mono_time);
  148|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  149|       |
  150|  3.15k|    mono_time_update(mono_time);
  151|       |
  152|  3.15k|    return mono_time;
  153|  3.15k|}
mono_time_free:
  156|  3.15k|{
  157|  3.15k|    if (mono_time == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (157:9): [True: 0, False: 3.15k]
  ------------------
  158|      0|        return;
  159|      0|    }
  160|  3.15k|#ifndef ESP_PLATFORM
  161|  3.15k|    pthread_rwlock_destroy(mono_time->time_update_lock);
  162|  3.15k|    mem_delete(mem, mono_time->time_update_lock);
  163|  3.15k|#endif /* ESP_PLATFORM */
  164|  3.15k|    mem_delete(mem, mono_time);
  165|  3.15k|}
mono_time_update:
  168|  3.15k|{
  169|  3.15k|    const uint64_t cur_time =
  170|  3.15k|        mono_time->base_time + mono_time->current_time_callback(mono_time->user_data);
  171|       |
  172|  3.15k|#ifndef ESP_PLATFORM
  173|  3.15k|    pthread_rwlock_wrlock(mono_time->time_update_lock);
  174|  3.15k|#endif /* ESP_PLATFORM */
  175|  3.15k|    mono_time->cur_time = cur_time;
  176|  3.15k|#ifndef ESP_PLATFORM
  177|  3.15k|    pthread_rwlock_unlock(mono_time->time_update_lock);
  178|  3.15k|#endif /* ESP_PLATFORM */
  179|  3.15k|}
mono_time_get_ms:
  182|  61.6k|{
  183|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  184|       |    // Fuzzing is only single thread for now, no locking needed */
  185|       |    pthread_rwlock_rdlock(mono_time->time_update_lock);
  186|       |#endif /* !ESP_PLATFORM */
  187|  61.6k|    const uint64_t cur_time = mono_time->cur_time;
  188|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  189|       |    pthread_rwlock_unlock(mono_time->time_update_lock);
  190|       |#endif /* !ESP_PLATFORM */
  191|  61.6k|    return cur_time;
  192|  61.6k|}
mono_time_get:
  195|  61.6k|{
  196|  61.6k|    return mono_time_get_ms(mono_time) / UINT64_C(1000);
  197|  61.6k|}
mono_time_set_current_time_callback:
  206|  3.15k|{
  207|  3.15k|    if (current_time_callback == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (207:9): [True: 0, False: 3.15k]
  ------------------
  208|      0|        mono_time->current_time_callback = current_time_monotonic_default;
  209|      0|        mono_time->user_data = mono_time;
  210|  3.15k|    } else {
  211|  3.15k|        mono_time->current_time_callback = current_time_callback;
  212|  3.15k|        mono_time->user_data = user_data;
  213|  3.15k|    }
  214|  3.15k|}

nc_get_self_public_key:
  165|  6.41k|{
  166|  6.41k|    return c->self_public_key;
  167|  6.41k|}
nc_get_tcp_c:
  175|  6.36k|{
  176|  6.36k|    return c->tcp_c;
  177|  6.36k|}
nc_get_dht:
  180|  3.15k|{
  181|  3.15k|    return c->dht;
  182|  3.15k|}
new_connection_handler:
 1947|  3.15k|{
 1948|  3.15k|    c->new_connection_callback = new_connection_callback;
 1949|  3.15k|    c->new_connection_callback_object = object;
 1950|  3.15k|}
copy_connected_tcp_relays:
 2298|    615|{
 2299|    615|    if (num == 0) {
  ------------------
  |  Branch (2299:9): [True: 23, False: 592]
  ------------------
 2300|     23|        return 0;
 2301|     23|    }
 2302|       |
 2303|    592|    return tcp_copy_connected_relays(c->tcp_c, tcp_relays, num);
 2304|    615|}
crypto_kill:
 2912|    582|{
 2913|    582|    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);
 2914|       |
 2915|    582|    int ret = -1;
 2916|       |
 2917|    582|    if (conn != nullptr) {
  ------------------
  |  |   63|    582|#define nullptr NULL
  ------------------
  |  Branch (2917:9): [True: 0, False: 582]
  ------------------
 2918|      0|        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
  ------------------
  |  Branch (2918:13): [True: 0, False: 0]
  ------------------
 2919|      0|            send_kill_packet(c, crypt_connection_id);
 2920|      0|        }
 2921|       |
 2922|      0|        kill_tcp_connection_to(c->tcp_c, conn->connection_number_tcp);
 2923|       |
 2924|      0|        bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv4, crypt_connection_id);
 2925|      0|        bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv6, crypt_connection_id);
 2926|      0|        clear_temp_packet(c, crypt_connection_id);
 2927|      0|        clear_buffer(c->mem, &conn->send_array);
 2928|      0|        clear_buffer(c->mem, &conn->recv_array);
 2929|      0|        ret = wipe_crypto_connection(c, crypt_connection_id);
 2930|      0|    }
 2931|       |
 2932|    582|    return ret;
 2933|    582|}
new_keys:
 2963|  3.15k|{
 2964|  3.15k|    crypto_new_keypair(c->rng, c->self_public_key, c->self_secret_key);
 2965|  3.15k|}
save_keys:
 2973|    615|{
 2974|    615|    memcpy(keys, c->self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|    615|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2975|    615|    memcpy(keys + CRYPTO_PUBLIC_KEY_SIZE, c->self_secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   43|    615|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(keys + CRYPTO_PUBLIC_KEY_SIZE, c->self_secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   48|    615|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 2976|    615|}
load_secret_key:
 2982|    972|{
 2983|    972|    memcpy(c->self_secret_key, sk, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   48|    972|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 2984|    972|    crypto_derive_public_key(c->self_public_key, c->self_secret_key);
 2985|    972|}
new_net_crypto:
 2992|  3.15k|{
 2993|  3.15k|    if (dht == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2993:9): [True: 0, False: 3.15k]
  ------------------
 2994|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2995|      0|    }
 2996|       |
 2997|  3.15k|    Net_Crypto *temp = (Net_Crypto *)mem_alloc(mem, sizeof(Net_Crypto));
 2998|       |
 2999|  3.15k|    if (temp == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2999:9): [True: 0, False: 3.15k]
  ------------------
 3000|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3001|      0|    }
 3002|       |
 3003|  3.15k|    temp->log = log;
 3004|  3.15k|    temp->mem = mem;
 3005|  3.15k|    temp->rng = rng;
 3006|  3.15k|    temp->mono_time = mono_time;
 3007|  3.15k|    temp->ns = ns;
 3008|       |
 3009|  3.15k|    temp->tcp_c = new_tcp_connections(log, mem, rng, ns, mono_time, dht_get_self_secret_key(dht), proxy_info);
 3010|       |
 3011|  3.15k|    if (temp->tcp_c == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3011:9): [True: 0, False: 3.15k]
  ------------------
 3012|      0|        mem_delete(mem, temp);
 3013|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3014|      0|    }
 3015|       |
 3016|  3.15k|    set_packet_tcp_connection_callback(temp->tcp_c, &tcp_data_callback, temp);
 3017|  3.15k|    set_oob_packet_tcp_connection_callback(temp->tcp_c, &tcp_oob_callback, temp);
 3018|       |
 3019|  3.15k|    temp->dht = dht;
 3020|       |
 3021|  3.15k|    new_keys(temp);
 3022|  3.15k|    new_symmetric_key(rng, temp->secret_symmetric_key);
 3023|       |
 3024|  3.15k|    temp->current_sleep_time = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |   96|  3.15k|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 3025|       |
 3026|  3.15k|    networking_registerhandler(dht_get_net(dht), NET_PACKET_COOKIE_REQUEST, &udp_handle_cookie_request, temp);
 3027|  3.15k|    networking_registerhandler(dht_get_net(dht), NET_PACKET_COOKIE_RESPONSE, &udp_handle_packet, temp);
 3028|  3.15k|    networking_registerhandler(dht_get_net(dht), NET_PACKET_CRYPTO_HS, &udp_handle_packet, temp);
 3029|  3.15k|    networking_registerhandler(dht_get_net(dht), NET_PACKET_CRYPTO_DATA, &udp_handle_packet, temp);
 3030|       |
 3031|  3.15k|    bs_list_init(&temp->ip_port_list, mem, sizeof(IP_Port), 8, ipport_cmp_handler);
 3032|       |
 3033|  3.15k|    return temp;
 3034|  3.15k|}
kill_net_crypto:
 3081|  3.15k|{
 3082|  3.15k|    if (c == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (3082:9): [True: 0, False: 3.15k]
  ------------------
 3083|      0|        return;
 3084|      0|    }
 3085|       |
 3086|  3.15k|    const Memory *mem = c->mem;
 3087|       |
 3088|  3.15k|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (3088:26): [True: 0, False: 3.15k]
  ------------------
 3089|      0|        crypto_kill(c, i);
 3090|      0|    }
 3091|       |
 3092|  3.15k|    kill_tcp_connections(c->tcp_c);
 3093|  3.15k|    bs_list_free(&c->ip_port_list);
 3094|  3.15k|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 3095|  3.15k|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 3096|  3.15k|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 3097|  3.15k|    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 3098|  3.15k|    crypto_memzero(c, sizeof(Net_Crypto));
 3099|  3.15k|    mem_delete(mem, c);
 3100|  3.15k|}
net_crypto.c:crypt_connection_id_is_valid:
  186|    582|{
  187|    582|    if ((uint32_t)crypt_connection_id >= c->crypto_connections_length) {
  ------------------
  |  Branch (187:9): [True: 582, False: 0]
  ------------------
  188|    582|        return false;
  189|    582|    }
  190|       |
  191|      0|    if (c->crypto_connections == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (191:9): [True: 0, False: 0]
  ------------------
  192|      0|        return false;
  193|      0|    }
  194|       |
  195|      0|    const Crypto_Conn_State status = c->crypto_connections[crypt_connection_id].status;
  196|       |
  197|      0|    return status != CRYPTO_CONN_NO_CONNECTION && status != CRYPTO_CONN_FREE;
  ------------------
  |  Branch (197:12): [True: 0, False: 0]
  |  Branch (197:51): [True: 0, False: 0]
  ------------------
  198|      0|}
net_crypto.c:get_crypto_connection:
  567|    582|{
  568|    582|    if (!crypt_connection_id_is_valid(c, crypt_connection_id)) {
  ------------------
  |  Branch (568:9): [True: 582, False: 0]
  ------------------
  569|    582|        return nullptr;
  ------------------
  |  |   63|    582|#define nullptr NULL
  ------------------
  570|    582|    }
  571|       |
  572|      0|    return &c->crypto_connections[crypt_connection_id];
  573|    582|}

netprof_new:
  141|  6.36k|{
  142|  6.36k|    Net_Profile *np = (Net_Profile *)mem_alloc(mem, sizeof(Net_Profile));
  143|       |
  144|  6.36k|    if (np == nullptr) {
  ------------------
  |  |   63|  6.36k|#define nullptr NULL
  ------------------
  |  Branch (144:9): [True: 0, False: 6.36k]
  ------------------
  145|      0|        LOGGER_ERROR(log, "failed to allocate memory for net profiler");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  146|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  147|      0|    }
  148|       |
  149|  6.36k|    return np;
  150|  6.36k|}
netprof_kill:
  153|  6.36k|{
  154|  6.36k|    if (net_profile != nullptr) {
  ------------------
  |  |   63|  6.36k|#define nullptr NULL
  ------------------
  |  Branch (154:9): [True: 6.36k, False: 0]
  ------------------
  155|  6.36k|        mem_delete(mem, net_profile);
  156|  6.36k|    }
  157|  6.36k|}

net_socket_from_native:
  380|  3.15k|{
  381|  3.15k|    const Socket res = {(force Socket_Value)sock};
  382|  3.15k|    return res;
  383|  3.15k|}
net_invalid_socket:
  386|  3.15k|{
  387|  3.15k|    return net_socket_from_native(INVALID_SOCKET);
  ------------------
  |  |  371|  3.15k|#define INVALID_SOCKET (-1)
  ------------------
  388|  3.15k|}
net_family_unspec:
  391|  6.30k|{
  392|  6.30k|    return family_unspec;
  393|  6.30k|}
net_family_ipv4:
  396|  19.0k|{
  397|  19.0k|    return family_ipv4;
  398|  19.0k|}
net_family_ipv6:
  401|  6.63k|{
  402|  6.63k|    return family_ipv6;
  403|  6.63k|}
net_family_tcp_ipv4:
  416|    854|{
  417|    854|    return family_tcp_ipv4;
  418|    854|}
net_family_tcp_ipv6:
  421|  3.80k|{
  422|  3.80k|    return family_tcp_ipv6;
  423|  3.80k|}
net_family_is_unspec:
  436|  19.8k|{
  437|  19.8k|    return family.value == family_unspec.value;
  438|  19.8k|}
net_family_is_ipv4:
  441|  48.3k|{
  442|  48.3k|    return family.value == family_ipv4.value;
  443|  48.3k|}
net_family_is_ipv6:
  446|  39.2k|{
  447|  39.2k|    return family.value == family_ipv6.value;
  448|  39.2k|}
net_family_is_tcp_ipv4:
  461|  7.02k|{
  462|  7.02k|    return family.value == family_tcp_ipv4.value;
  463|  7.02k|}
net_family_is_tcp_ipv6:
  466|  3.70k|{
  467|  3.70k|    return family.value == family_tcp_ipv6.value;
  468|  3.70k|}
sock_valid:
  481|  3.15k|{
  482|  3.15k|    const Socket invalid_socket = net_invalid_socket();
  483|  3.15k|    return sock.value != invalid_socket.value;
  484|  3.15k|}
os_network:
  705|  3.15k|{
  706|  3.15k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  707|  3.15k|    if ((true)) {
  ------------------
  |  Branch (707:9): [Folded - Ignored]
  ------------------
  708|  3.15k|        return nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  709|  3.15k|    }
  710|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  711|       |#ifdef OS_WIN32
  712|       |    WSADATA wsaData;
  713|       |
  714|       |    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != NO_ERROR) {
  715|       |        return nullptr;
  716|       |    }
  717|       |#endif /* OS_WIN32 */
  718|      0|    return &os_network_obj;
  719|  3.15k|}
kill_sock:
  965|  3.15k|{
  966|  3.15k|    ns->funcs->close(ns->obj, sock);
  967|  3.15k|}
set_socket_nonblock:
  970|  3.15k|{
  971|  3.15k|    return ns->funcs->socket_nonblock(ns->obj, sock, true) == 0;
  972|  3.15k|}
set_socket_nosigpipe:
  975|  3.15k|{
  976|       |#if defined(__APPLE__)
  977|       |    int set = 1;
  978|       |    return net_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
  979|       |#else
  980|  3.15k|    return true;
  981|  3.15k|#endif /* __APPLE__ */
  982|  3.15k|}
set_socket_dualstack:
  995|  3.15k|{
  996|  3.15k|    int ipv6only = 0;
  997|  3.15k|    size_t optsize = sizeof(ipv6only);
  998|  3.15k|    const int res = net_getsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, &optsize);
  999|       |
 1000|  3.15k|    if ((res == 0) && (ipv6only == 0)) {
  ------------------
  |  Branch (1000:9): [True: 3.15k, False: 0]
  |  Branch (1000:23): [True: 3.15k, False: 0]
  ------------------
 1001|  3.15k|        return true;
 1002|  3.15k|    }
 1003|       |
 1004|      0|    ipv6only = 0;
 1005|      0|    return net_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only)) == 0;
 1006|  3.15k|}
networking_registerhandler:
 1197|   198k|{
 1198|   198k|    net->packethandlers[byte].function = cb;
 1199|   198k|    net->packethandlers[byte].object = object;
 1200|   198k|}
new_networking_ex:
 1246|  3.15k|{
 1247|       |    /* If both from and to are 0, use default port range
 1248|       |     * If one is 0 and the other is non-0, use the non-0 value as only port
 1249|       |     * If from > to, swap
 1250|       |     */
 1251|  3.15k|    if (port_from == 0 && port_to == 0) {
  ------------------
  |  Branch (1251:9): [True: 3.15k, False: 0]
  |  Branch (1251:27): [True: 3.15k, False: 0]
  ------------------
 1252|  3.15k|        port_from = TOX_PORTRANGE_FROM;
  ------------------
  |  |  162|  3.15k|#define TOX_PORTRANGE_FROM 33445
  ------------------
 1253|  3.15k|        port_to = TOX_PORTRANGE_TO;
  ------------------
  |  |  163|  3.15k|#define TOX_PORTRANGE_TO   33545
  ------------------
 1254|  3.15k|    } else if (port_from == 0 && port_to != 0) {
  ------------------
  |  Branch (1254:16): [True: 0, False: 0]
  |  Branch (1254:34): [True: 0, False: 0]
  ------------------
 1255|      0|        port_from = port_to;
 1256|      0|    } else if (port_from != 0 && port_to == 0) {
  ------------------
  |  Branch (1256:16): [True: 0, False: 0]
  |  Branch (1256:34): [True: 0, False: 0]
  ------------------
 1257|      0|        port_to = port_from;
 1258|      0|    } else if (port_from > port_to) {
  ------------------
  |  Branch (1258:16): [True: 0, False: 0]
  ------------------
 1259|      0|        const uint16_t temp_port = port_from;
 1260|      0|        port_from = port_to;
 1261|      0|        port_to = temp_port;
 1262|      0|    }
 1263|       |
 1264|  3.15k|    if (error != nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1264:9): [True: 3.15k, False: 0]
  ------------------
 1265|  3.15k|        *error = 2;
 1266|  3.15k|    }
 1267|       |
 1268|       |    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
 1269|  3.15k|    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1269:9): [True: 3.15k, False: 0]
  |  Branch (1269:44): [True: 0, False: 3.15k]
  ------------------
 1270|      0|        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1271|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1272|      0|    }
 1273|       |
 1274|  3.15k|    Networking_Core *temp = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
 1275|       |
 1276|  3.15k|    if (temp == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1276:9): [True: 0, False: 3.15k]
  ------------------
 1277|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1278|      0|    }
 1279|       |
 1280|  3.15k|    Net_Profile *np = netprof_new(log, mem);
 1281|       |
 1282|  3.15k|    if (np == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1282:9): [True: 0, False: 3.15k]
  ------------------
 1283|      0|        free(temp);
 1284|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1285|      0|    }
 1286|       |
 1287|  3.15k|    temp->udp_net_profile = np;
 1288|  3.15k|    temp->ns = ns;
 1289|  3.15k|    temp->log = log;
 1290|  3.15k|    temp->mem = mem;
 1291|  3.15k|    temp->family = ip->family;
 1292|  3.15k|    temp->port = 0;
 1293|       |
 1294|       |    /* Initialize our socket. */
 1295|       |    /* add log message what we're creating */
 1296|  3.15k|    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  174|  3.15k|#define TOX_SOCK_DGRAM 2
  ------------------
                  temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  177|  3.15k|#define TOX_PROTO_UDP 2
  ------------------
 1297|       |
 1298|       |    /* Check for socket error. */
 1299|  3.15k|    if (!sock_valid(temp->sock)) {
  ------------------
  |  Branch (1299:9): [True: 0, False: 3.15k]
  ------------------
 1300|      0|        const int neterror = net_error();
 1301|      0|        Net_Strerror error_str;
 1302|      0|        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1303|      0|        netprof_kill(mem, temp->udp_net_profile);
 1304|      0|        mem_delete(mem, temp);
 1305|       |
 1306|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1306:13): [True: 0, False: 0]
  ------------------
 1307|      0|            *error = 1;
 1308|      0|        }
 1309|       |
 1310|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1311|      0|    }
 1312|       |
 1313|       |    /* Functions to increase the size of the send and receive UDP buffers.
 1314|       |     */
 1315|  3.15k|    int n = 1024 * 1024 * 2;
 1316|       |
 1317|  3.15k|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1317:9): [True: 0, False: 3.15k]
  ------------------
 1318|      0|        LOGGER_WARNING(log, "failed to set socket option %d", SO_RCVBUF);
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1319|      0|    }
 1320|       |
 1321|  3.15k|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_SNDBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1321:9): [True: 0, False: 3.15k]
  ------------------
 1322|      0|        LOGGER_WARNING(log, "failed to set socket option %d", SO_SNDBUF);
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1323|      0|    }
 1324|       |
 1325|       |    /* Enable broadcast on socket */
 1326|  3.15k|    int broadcast = 1;
 1327|       |
 1328|  3.15k|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) != 0) {
  ------------------
  |  Branch (1328:9): [True: 0, False: 3.15k]
  ------------------
 1329|      0|        LOGGER_ERROR(log, "failed to set socket option %d", SO_BROADCAST);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1330|      0|    }
 1331|       |
 1332|       |    /* iOS UDP sockets are weird and apparently can SIGPIPE */
 1333|  3.15k|    if (!set_socket_nosigpipe(ns, temp->sock)) {
  ------------------
  |  Branch (1333:9): [True: 0, False: 3.15k]
  ------------------
 1334|      0|        kill_networking(temp);
 1335|       |
 1336|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1336:13): [True: 0, False: 0]
  ------------------
 1337|      0|            *error = 1;
 1338|      0|        }
 1339|       |
 1340|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1341|      0|    }
 1342|       |
 1343|       |    /* Set socket nonblocking. */
 1344|  3.15k|    if (!set_socket_nonblock(ns, temp->sock)) {
  ------------------
  |  Branch (1344:9): [True: 0, False: 3.15k]
  ------------------
 1345|      0|        kill_networking(temp);
 1346|       |
 1347|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1347:13): [True: 0, False: 0]
  ------------------
 1348|      0|            *error = 1;
 1349|      0|        }
 1350|       |
 1351|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1352|      0|    }
 1353|       |
 1354|       |    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
 1355|  3.15k|    uint16_t *portptr = nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 1356|  3.15k|    Network_Addr addr = {{0}};
 1357|       |
 1358|  3.15k|    if (net_family_is_ipv4(temp->family)) {
  ------------------
  |  Branch (1358:9): [True: 0, False: 3.15k]
  ------------------
 1359|      0|        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr.addr;
 1360|       |
 1361|      0|        addr.size = sizeof(struct sockaddr_in);
 1362|      0|        addr4->sin_family = AF_INET;
 1363|      0|        addr4->sin_port = 0;
 1364|      0|        fill_addr4(&ip->ip.v4, &addr4->sin_addr);
 1365|       |
 1366|      0|        portptr = &addr4->sin_port;
 1367|  3.15k|    } else if (net_family_is_ipv6(temp->family)) {
  ------------------
  |  Branch (1367:16): [True: 3.15k, False: 0]
  ------------------
 1368|  3.15k|        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr.addr;
 1369|       |
 1370|  3.15k|        addr.size = sizeof(struct sockaddr_in6);
 1371|  3.15k|        addr6->sin6_family = AF_INET6;
 1372|  3.15k|        addr6->sin6_port = 0;
 1373|  3.15k|        fill_addr6(&ip->ip.v6, &addr6->sin6_addr);
 1374|       |
 1375|  3.15k|        addr6->sin6_flowinfo = 0;
 1376|  3.15k|        addr6->sin6_scope_id = 0;
 1377|       |
 1378|  3.15k|        portptr = &addr6->sin6_port;
 1379|  3.15k|    } else {
 1380|      0|        mem_delete(mem, temp);
 1381|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1382|      0|    }
 1383|       |
 1384|  3.15k|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1384:9): [True: 3.15k, False: 0]
  ------------------
 1385|  3.15k|        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);
 1386|       |
 1387|  3.15k|        if (is_dualstack) {
  ------------------
  |  Branch (1387:13): [True: 3.15k, False: 0]
  ------------------
 1388|  3.15k|            LOGGER_TRACE(log, "Dual-stack socket: enabled");
  ------------------
  |  |   83|  3.15k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  3.15k|    do {                                                                         \
  |  |  |  |   77|  3.15k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  6.30k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|  3.15k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1389|  3.15k|        } else {
 1390|      0|            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1391|      0|        }
 1392|       |
 1393|  3.15k|#ifndef ESP_PLATFORM
 1394|       |        /* multicast local nodes */
 1395|  3.15k|        struct ipv6_mreq mreq = {{{{0}}}};
 1396|  3.15k|        mreq.ipv6mr_multiaddr.s6_addr[0] = 0xFF;
 1397|  3.15k|        mreq.ipv6mr_multiaddr.s6_addr[1] = 0x02;
 1398|  3.15k|        mreq.ipv6mr_multiaddr.s6_addr[15] = 0x01;
 1399|  3.15k|        mreq.ipv6mr_interface = 0;
 1400|       |
 1401|  3.15k|        const int res = net_setsockopt(ns, temp->sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
 1402|       |
 1403|  3.15k|        const int neterror = net_error();
 1404|  3.15k|        Net_Strerror error_str;
 1405|       |
 1406|  3.15k|        if (res < 0) {
  ------------------
  |  Branch (1406:13): [True: 0, False: 3.15k]
  ------------------
 1407|      0|            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   85|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1408|  3.15k|        } else {
 1409|  3.15k|            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   83|  3.15k|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  3.15k|    do {                                                                         \
  |  |  |  |   77|  3.15k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  6.30k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|  3.15k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1410|  3.15k|        }
 1411|  3.15k|#endif /* ESP_PLATFORM */
 1412|  3.15k|    }
 1413|       |
 1414|       |    /* A hanging program or a different user might block the standard port.
 1415|       |     * As long as it isn't a parameter coming from the commandline,
 1416|       |     * try a few ports after it, to see if we can find a "free" one.
 1417|       |     *
 1418|       |     * If we go on without binding, the first sendto() automatically binds to
 1419|       |     * a free port chosen by the system (i.e. anything from 1024 to 65535).
 1420|       |     *
 1421|       |     * Returning NULL after bind fails has both advantages and disadvantages:
 1422|       |     * advantage:
 1423|       |     *   we can rely on getting the port in the range 33445..33450, which
 1424|       |     *   enables us to tell joe user to open their firewall to a small range
 1425|       |     *
 1426|       |     * disadvantage:
 1427|       |     *   some clients might not test return of tox_new(), blindly assuming that
 1428|       |     *   it worked ok (which it did previously without a successful bind)
 1429|       |     */
 1430|  3.15k|    uint16_t port_to_try = port_from;
 1431|  3.15k|    *portptr = net_htons(port_to_try);
 1432|       |
 1433|  3.15k|    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
  ------------------
  |  Branch (1433:38): [True: 3.15k, False: 0]
  ------------------
 1434|  3.15k|        const int res = net_bind(ns, temp->sock, &addr);
 1435|       |
 1436|  3.15k|        if (res == 0) {
  ------------------
  |  Branch (1436:13): [True: 3.15k, False: 0]
  ------------------
 1437|  3.15k|            temp->port = *portptr;
 1438|       |
 1439|  3.15k|            Ip_Ntoa ip_str;
 1440|  3.15k|            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
  ------------------
  |  |   84|  3.15k|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  3.15k|    do {                                                                         \
  |  |  |  |   77|  3.15k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  6.30k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|  3.15k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1441|  3.15k|                         net_ntohs(temp->port));
 1442|       |
 1443|       |            /* errno isn't reset on success, only set on failure, the failed
 1444|       |             * binds with parallel clients yield a -EPERM to the outside if
 1445|       |             * errno isn't cleared here */
 1446|  3.15k|            if (tries > 0) {
  ------------------
  |  Branch (1446:17): [True: 3.15k, False: 0]
  ------------------
 1447|  3.15k|                errno = 0;
 1448|  3.15k|            }
 1449|       |
 1450|  3.15k|            if (error != nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1450:17): [True: 3.15k, False: 0]
  ------------------
 1451|  3.15k|                *error = 0;
 1452|  3.15k|            }
 1453|       |
 1454|  3.15k|            return temp;
 1455|  3.15k|        }
 1456|       |
 1457|      0|        ++port_to_try;
 1458|       |
 1459|      0|        if (port_to_try > port_to) {
  ------------------
  |  Branch (1459:13): [True: 0, False: 0]
  ------------------
 1460|      0|            port_to_try = port_from;
 1461|      0|        }
 1462|       |
 1463|      0|        *portptr = net_htons(port_to_try);
 1464|      0|    }
 1465|       |
 1466|      0|    Ip_Ntoa ip_str;
 1467|      0|    const int neterror = net_error();
 1468|      0|    Net_Strerror error_str;
 1469|      0|    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u",
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1470|      0|                 neterror, net_strerror(neterror, &error_str), net_ip_ntoa(ip, &ip_str), port_from, port_to);
 1471|      0|    kill_networking(temp);
 1472|       |
 1473|      0|    if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1473:9): [True: 0, False: 0]
  ------------------
 1474|      0|        *error = 1;
 1475|      0|    }
 1476|       |
 1477|      0|    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1478|  3.15k|}
kill_networking:
 1498|  3.15k|{
 1499|  3.15k|    if (net == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1499:9): [True: 0, False: 3.15k]
  ------------------
 1500|      0|        return;
 1501|      0|    }
 1502|       |
 1503|  3.15k|    if (!net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (1503:9): [True: 3.15k, False: 0]
  ------------------
 1504|       |        /* Socket is initialized, so we close it. */
 1505|  3.15k|        kill_sock(net->ns, net->sock);
 1506|  3.15k|    }
 1507|       |
 1508|  3.15k|    netprof_kill(net->mem, net->udp_net_profile);
 1509|  3.15k|    mem_delete(net->mem, net);
 1510|  3.15k|}
ip_reset:
 1626|  3.15k|{
 1627|  3.15k|    if (ip == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1627:9): [True: 0, False: 3.15k]
  ------------------
 1628|      0|        return;
 1629|      0|    }
 1630|       |
 1631|  3.15k|    *ip = empty_ip;
 1632|  3.15k|}
ipport_reset:
 1638|  19.8k|{
 1639|  19.8k|    if (ipport == nullptr) {
  ------------------
  |  |   63|  19.8k|#define nullptr NULL
  ------------------
  |  Branch (1639:9): [True: 0, False: 19.8k]
  ------------------
 1640|      0|        return;
 1641|      0|    }
 1642|       |
 1643|  19.8k|    *ipport = empty_ip_port;
 1644|  19.8k|}
ip_init:
 1648|  3.15k|{
 1649|  3.15k|    if (ip == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1649:9): [True: 0, False: 3.15k]
  ------------------
 1650|      0|        return;
 1651|      0|    }
 1652|       |
 1653|  3.15k|    ip_reset(ip);
 1654|  3.15k|    ip->family = ipv6enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (1654:18): [True: 3.15k, False: 0]
  ------------------
 1655|  3.15k|}
ip_isset:
 1659|    944|{
 1660|    944|    if (ip == nullptr) {
  ------------------
  |  |   63|    944|#define nullptr NULL
  ------------------
  |  Branch (1660:9): [True: 0, False: 944]
  ------------------
 1661|      0|        return false;
 1662|      0|    }
 1663|       |
 1664|    944|    return !net_family_is_unspec(ip->family);
 1665|    944|}
ipport_isset:
 1669|  15.6k|{
 1670|  15.6k|    if (ipport == nullptr) {
  ------------------
  |  |   63|  15.6k|#define nullptr NULL
  ------------------
  |  Branch (1670:9): [True: 0, False: 15.6k]
  ------------------
 1671|      0|        return false;
 1672|      0|    }
 1673|       |
 1674|  15.6k|    if (ipport->port == 0) {
  ------------------
  |  Branch (1674:9): [True: 14.7k, False: 944]
  ------------------
 1675|  14.7k|        return false;
 1676|  14.7k|    }
 1677|       |
 1678|    944|    return ip_isset(&ipport->ip);
 1679|  15.6k|}
bin_pack_ip_port:
 1732|  7.53k|{
 1733|  7.53k|    bool is_ipv4;
 1734|  7.53k|    uint8_t family;
 1735|       |
 1736|  7.53k|    if (net_family_is_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (1736:9): [True: 6.04k, False: 1.49k]
  ------------------
 1737|       |        // TODO(irungentoo): use functions to convert endianness
 1738|  6.04k|        is_ipv4 = true;
 1739|  6.04k|        family = TOX_AF_INET;
  ------------------
  |  |  168|  6.04k|#define TOX_AF_INET 2
  ------------------
 1740|  6.04k|    } else if (net_family_is_tcp_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (1740:16): [True: 1.02k, False: 468]
  ------------------
 1741|  1.02k|        is_ipv4 = true;
 1742|  1.02k|        family = TOX_TCP_INET;
  ------------------
  |  |  170|  1.02k|#define TOX_TCP_INET 130
  ------------------
 1743|  1.02k|    } else if (net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (1743:16): [True: 454, False: 14]
  ------------------
 1744|    454|        is_ipv4 = false;
 1745|    454|        family = TOX_AF_INET6;
  ------------------
  |  |  169|    454|#define TOX_AF_INET6 10
  ------------------
 1746|    454|    } else if (net_family_is_tcp_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (1746:16): [True: 14, False: 0]
  ------------------
 1747|     14|        is_ipv4 = false;
 1748|     14|        family = TOX_TCP_INET6;
  ------------------
  |  |  171|     14|#define TOX_TCP_INET6 138
  ------------------
 1749|     14|    } else {
 1750|      0|        Ip_Ntoa ip_str;
 1751|       |        // TODO(iphydf): Find out why we're trying to pack invalid IPs, stop
 1752|       |        // doing that, and turn this into an error.
 1753|      0|        LOGGER_TRACE(logger, "cannot pack invalid IP: %s", net_ip_ntoa(&ip_port->ip, &ip_str));
  ------------------
  |  |   83|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1754|      0|        return false;
 1755|      0|    }
 1756|       |
 1757|  7.53k|    return bin_pack_u08_b(bp, family)
  ------------------
  |  Branch (1757:12): [True: 7.53k, False: 0]
  ------------------
 1758|  7.53k|           && bin_pack_ip(bp, &ip_port->ip, is_ipv4)
  ------------------
  |  Branch (1758:15): [True: 7.53k, False: 0]
  ------------------
 1759|  7.53k|           && bin_pack_u16_b(bp, net_ntohs(ip_port->port));
  ------------------
  |  Branch (1759:15): [True: 7.53k, False: 0]
  ------------------
 1760|  7.53k|}
pack_ip_port:
 1770|    260|{
 1771|    260|    const uint32_t size = bin_pack_obj_size(bin_pack_ip_port_handler, ip_port, logger);
 1772|       |
 1773|    260|    if (size > length) {
  ------------------
  |  Branch (1773:9): [True: 0, False: 260]
  ------------------
 1774|      0|        return -1;
 1775|      0|    }
 1776|       |
 1777|    260|    if (!bin_pack_obj(bin_pack_ip_port_handler, ip_port, logger, data, length)) {
  ------------------
  |  Branch (1777:9): [True: 0, False: 260]
  ------------------
 1778|      0|        return -1;
 1779|      0|    }
 1780|       |
 1781|    260|    assert(size < INT_MAX);
 1782|    260|    return (int)size;
 1783|    260|}
unpack_ip_port:
 1786|  20.7k|{
 1787|  20.7k|    if (data == nullptr) {
  ------------------
  |  |   63|  20.7k|#define nullptr NULL
  ------------------
  |  Branch (1787:9): [True: 0, False: 20.7k]
  ------------------
 1788|      0|        return -1;
 1789|      0|    }
 1790|       |
 1791|  20.7k|    bool is_ipv4;
 1792|  20.7k|    Family host_family;
 1793|       |
 1794|  20.7k|    if (data[0] == TOX_AF_INET) {
  ------------------
  |  |  168|  20.7k|#define TOX_AF_INET 2
  ------------------
  |  Branch (1794:9): [True: 17.1k, False: 3.52k]
  ------------------
 1795|  17.1k|        is_ipv4 = true;
 1796|  17.1k|        host_family = net_family_ipv4();
 1797|  17.1k|    } else if (data[0] == TOX_TCP_INET) {
  ------------------
  |  |  170|  3.52k|#define TOX_TCP_INET 130
  ------------------
  |  Branch (1797:16): [True: 985, False: 2.53k]
  ------------------
 1798|    985|        if (!tcp_enabled) {
  ------------------
  |  Branch (1798:13): [True: 131, False: 854]
  ------------------
 1799|    131|            return -1;
 1800|    131|        }
 1801|       |
 1802|    854|        is_ipv4 = true;
 1803|    854|        host_family = net_family_tcp_ipv4();
 1804|  2.53k|    } else if (data[0] == TOX_AF_INET6) {
  ------------------
  |  |  169|  2.53k|#define TOX_AF_INET6 10
  ------------------
  |  Branch (1804:16): [True: 1.63k, False: 898]
  ------------------
 1805|  1.63k|        is_ipv4 = false;
 1806|  1.63k|        host_family = net_family_ipv6();
 1807|  1.63k|    } else if (data[0] == TOX_TCP_INET6) {
  ------------------
  |  |  171|    898|#define TOX_TCP_INET6 138
  ------------------
  |  Branch (1807:16): [True: 130, False: 768]
  ------------------
 1808|    130|        if (!tcp_enabled) {
  ------------------
  |  Branch (1808:13): [True: 12, False: 118]
  ------------------
 1809|     12|            return -1;
 1810|     12|        }
 1811|       |
 1812|    118|        is_ipv4 = false;
 1813|    118|        host_family = net_family_tcp_ipv6();
 1814|    768|    } else {
 1815|    768|        return -1;
 1816|    768|    }
 1817|       |
 1818|  19.8k|    ipport_reset(ip_port);
 1819|       |
 1820|  19.8k|    if (is_ipv4) {
  ------------------
  |  Branch (1820:9): [True: 18.0k, False: 1.75k]
  ------------------
 1821|  18.0k|        const uint32_t size = 1 + SIZE_IP4 + sizeof(uint16_t);
  ------------------
  |  |  185|  18.0k|#define SIZE_IP4 4
  ------------------
 1822|       |
 1823|  18.0k|        if (size > length) {
  ------------------
  |  Branch (1823:13): [True: 59, False: 17.9k]
  ------------------
 1824|     59|            return -1;
 1825|     59|        }
 1826|       |
 1827|  17.9k|        ip_port->ip.family = host_family;
 1828|  17.9k|        memcpy(ip_port->ip.ip.v4.uint8, data + 1, SIZE_IP4);
  ------------------
  |  |  185|  17.9k|#define SIZE_IP4 4
  ------------------
 1829|  17.9k|        memcpy(&ip_port->port, data + 1 + SIZE_IP4, sizeof(uint16_t));
  ------------------
  |  |  185|  17.9k|#define SIZE_IP4 4
  ------------------
 1830|  17.9k|        return size;
 1831|  18.0k|    } else {
 1832|  1.75k|        const uint32_t size = 1 + SIZE_IP6 + sizeof(uint16_t);
  ------------------
  |  |  186|  1.75k|#define SIZE_IP6 16
  ------------------
 1833|       |
 1834|  1.75k|        if (size > length) {
  ------------------
  |  Branch (1834:13): [True: 66, False: 1.69k]
  ------------------
 1835|     66|            return -1;
 1836|     66|        }
 1837|       |
 1838|  1.69k|        ip_port->ip.family = host_family;
 1839|  1.69k|        memcpy(ip_port->ip.ip.v6.uint8, data + 1, SIZE_IP6);
  ------------------
  |  |  186|  1.69k|#define SIZE_IP6 16
  ------------------
 1840|  1.69k|        memcpy(&ip_port->port, data + 1 + SIZE_IP6, sizeof(uint16_t));
  ------------------
  |  |  186|  1.69k|#define SIZE_IP6 16
  ------------------
 1841|  1.69k|        return size;
 1842|  1.75k|    }
 1843|  19.8k|}
net_socket:
 2252|  3.15k|{
 2253|  3.15k|    const int platform_domain = make_family(domain);
 2254|  3.15k|    const int platform_type = make_socktype(type);
 2255|  3.15k|    const int platform_prot = make_proto(protocol);
 2256|  3.15k|    return ns->funcs->socket(ns->obj, platform_domain, platform_type, platform_prot);
 2257|  3.15k|}
net_htons:
 2271|  4.92k|{
 2272|  4.92k|    return htons(hostshort);
 2273|  4.92k|}
net_ntohs:
 2281|  8.64k|{
 2282|  8.64k|    return ntohs(hostshort);
 2283|  8.64k|}
net_pack_u16:
 2292|    408|{
 2293|    408|    bytes[0] = (v >> 8) & 0xff;
 2294|    408|    bytes[1] = v & 0xff;
 2295|    408|    return sizeof(v);
 2296|    408|}
net_pack_u32:
 2299|    204|{
 2300|    204|    uint8_t *p = bytes;
 2301|    204|    p += net_pack_u16(p, (v >> 16) & 0xffff);
 2302|    204|    p += net_pack_u16(p, v & 0xffff);
 2303|    204|    return p - bytes;
 2304|    204|}
net_pack_u64:
 2307|    102|{
 2308|    102|    uint8_t *p = bytes;
 2309|    102|    p += net_pack_u32(p, (v >> 32) & 0xffffffff);
 2310|    102|    p += net_pack_u32(p, v & 0xffffffff);
 2311|    102|    return p - bytes;
 2312|    102|}
net_unpack_u16:
 2321|  1.95k|{
 2322|  1.95k|    const uint8_t hi = bytes[0];
 2323|  1.95k|    const uint8_t lo = bytes[1];
 2324|  1.95k|    *v = ((uint16_t)hi << 8) | lo;
 2325|  1.95k|    return sizeof(*v);
 2326|  1.95k|}
net_unpack_u32:
 2329|    976|{
 2330|    976|    const uint8_t *p = bytes;
 2331|    976|    uint16_t hi;
 2332|    976|    uint16_t lo;
 2333|    976|    p += net_unpack_u16(p, &hi);
 2334|    976|    p += net_unpack_u16(p, &lo);
 2335|    976|    *v = ((uint32_t)hi << 16) | lo;
 2336|    976|    return p - bytes;
 2337|    976|}
net_unpack_u64:
 2340|    488|{
 2341|    488|    const uint8_t *p = bytes;
 2342|    488|    uint32_t hi;
 2343|    488|    uint32_t lo;
 2344|    488|    p += net_unpack_u32(p, &hi);
 2345|    488|    p += net_unpack_u32(p, &lo);
 2346|    488|    *v = ((uint64_t)hi << 32) | lo;
 2347|    488|    return p - bytes;
 2348|    488|}
net_error:
 2356|  3.15k|{
 2357|       |#ifdef OS_WIN32
 2358|       |    return WSAGetLastError();
 2359|       |#else
 2360|  3.15k|    return errno;
 2361|  3.15k|#endif /* OS_WIN32 */
 2362|  3.15k|}
network.c:net_setsockopt:
  733|  12.6k|{
  734|  12.6k|    return ns->funcs->setsockopt(ns->obj, sock, level, optname, optval, optlen);
  735|  12.6k|}
network.c:net_getsockopt:
  739|  3.15k|{
  740|  3.15k|    return ns->funcs->getsockopt(ns->obj, sock, level, optname, optval, optlen);
  741|  3.15k|}
network.c:fill_addr6:
  333|  3.15k|{
  334|  3.15k|    memcpy(addr->s6_addr, ip->uint8, sizeof(ip->uint8));
  335|  3.15k|}
network.c:net_bind:
  954|  3.15k|{
  955|  3.15k|    return ns->funcs->bind(ns->obj, sock, addr);
  956|  3.15k|}
network.c:bin_pack_ip:
 1719|  7.53k|{
 1720|  7.53k|    if (is_ipv4) {
  ------------------
  |  Branch (1720:9): [True: 7.06k, False: 468]
  ------------------
 1721|  7.06k|        return bin_pack_bin_b(bp, ip->ip.v4.uint8, SIZE_IP4);
  ------------------
  |  |  185|  7.06k|#define SIZE_IP4 4
  ------------------
 1722|  7.06k|    } else {
 1723|    468|        return bin_pack_bin_b(bp, ip->ip.v6.uint8, SIZE_IP6);
  ------------------
  |  |  186|    468|#define SIZE_IP6 16
  ------------------
 1724|    468|    }
 1725|  7.53k|}
network.c:bin_pack_ip_port_handler:
 1764|    520|{
 1765|    520|    const IP_Port *ip_port = (const IP_Port *)obj;
 1766|    520|    return bin_pack_ip_port(bp, logger, ip_port);
 1767|    520|}
network.c:make_family:
  264|  3.15k|{
  265|  3.15k|    switch (tox_family.value) {
  266|      0|        case TOX_AF_INET:
  ------------------
  |  |  168|      0|#define TOX_AF_INET 2
  ------------------
  |  Branch (266:9): [True: 0, False: 3.15k]
  ------------------
  267|      0|        case TCP_INET:
  ------------------
  |  |  181|      0|#define TCP_INET (TOX_AF_INET6 + 2)
  |  |  ------------------
  |  |  |  |  169|      0|#define TOX_AF_INET6 10
  |  |  ------------------
  ------------------
  |  Branch (267:9): [True: 0, False: 3.15k]
  ------------------
  268|      0|            return AF_INET;
  269|       |
  270|  3.15k|        case TOX_AF_INET6:
  ------------------
  |  |  169|  3.15k|#define TOX_AF_INET6 10
  ------------------
  |  Branch (270:9): [True: 3.15k, False: 0]
  ------------------
  271|  3.15k|        case TCP_INET6:
  ------------------
  |  |  182|  3.15k|#define TCP_INET6 (TOX_AF_INET6 + 3)
  |  |  ------------------
  |  |  |  |  169|  3.15k|#define TOX_AF_INET6 10
  |  |  ------------------
  ------------------
  |  Branch (271:9): [True: 0, False: 3.15k]
  ------------------
  272|  3.15k|            return AF_INET6;
  273|       |
  274|      0|        case TOX_AF_UNSPEC:
  ------------------
  |  |  167|      0|#define TOX_AF_UNSPEC 0
  ------------------
  |  Branch (274:9): [True: 0, False: 3.15k]
  ------------------
  275|      0|            return AF_UNSPEC;
  276|       |
  277|      0|        default:
  ------------------
  |  Branch (277:9): [True: 0, False: 3.15k]
  ------------------
  278|      0|            return tox_family.value;
  279|  3.15k|    }
  280|  3.15k|}
network.c:make_socktype:
  250|  3.15k|{
  251|  3.15k|    switch (type) {
  252|      0|        case TOX_SOCK_STREAM:
  ------------------
  |  |  173|      0|#define TOX_SOCK_STREAM 1
  ------------------
  |  Branch (252:9): [True: 0, False: 3.15k]
  ------------------
  253|      0|            return SOCK_STREAM;
  254|       |
  255|  3.15k|        case TOX_SOCK_DGRAM:
  ------------------
  |  |  174|  3.15k|#define TOX_SOCK_DGRAM 2
  ------------------
  |  Branch (255:9): [True: 3.15k, False: 0]
  ------------------
  256|  3.15k|            return SOCK_DGRAM;
  257|       |
  258|      0|        default:
  ------------------
  |  Branch (258:9): [True: 0, False: 3.15k]
  ------------------
  259|      0|            return type;
  260|  3.15k|    }
  261|  3.15k|}
network.c:make_proto:
  236|  3.15k|{
  237|  3.15k|    switch (proto) {
  238|      0|        case TOX_PROTO_TCP:
  ------------------
  |  |  176|      0|#define TOX_PROTO_TCP 1
  ------------------
  |  Branch (238:9): [True: 0, False: 3.15k]
  ------------------
  239|      0|            return IPPROTO_TCP;
  240|       |
  241|  3.15k|        case TOX_PROTO_UDP:
  ------------------
  |  |  177|  3.15k|#define TOX_PROTO_UDP 2
  ------------------
  |  Branch (241:9): [True: 3.15k, False: 0]
  ------------------
  242|  3.15k|            return IPPROTO_UDP;
  243|       |
  244|      0|        default:
  ------------------
  |  Branch (244:9): [True: 0, False: 3.15k]
  ------------------
  245|      0|            return proto;
  246|  3.15k|    }
  247|  3.15k|}

new_onion:
  718|  3.15k|{
  719|  3.15k|    if (dht == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (719:9): [True: 0, False: 3.15k]
  ------------------
  720|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  721|      0|    }
  722|       |
  723|  3.15k|    Onion *onion = (Onion *)mem_alloc(mem, sizeof(Onion));
  724|       |
  725|  3.15k|    if (onion == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (725:9): [True: 0, False: 3.15k]
  ------------------
  726|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  727|      0|    }
  728|       |
  729|  3.15k|    onion->log = log;
  730|  3.15k|    onion->dht = dht;
  731|  3.15k|    onion->net = dht_get_net(dht);
  732|  3.15k|    onion->mono_time = mono_time;
  733|  3.15k|    onion->rng = rng;
  734|  3.15k|    onion->mem = mem;
  735|  3.15k|    new_symmetric_key(rng, onion->secret_symmetric_key);
  736|  3.15k|    onion->timestamp = mono_time_get(onion->mono_time);
  737|       |
  738|  3.15k|    const uint8_t *secret_key = dht_get_self_secret_key(dht);
  739|  3.15k|    onion->shared_keys_1 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   38|  3.15k|#define KEYS_TIMEOUT 600
  ------------------
                  onion->shared_keys_1 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   37|  3.15k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  740|  3.15k|    onion->shared_keys_2 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   38|  3.15k|#define KEYS_TIMEOUT 600
  ------------------
                  onion->shared_keys_2 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   37|  3.15k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  741|  3.15k|    onion->shared_keys_3 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   38|  3.15k|#define KEYS_TIMEOUT 600
  ------------------
                  onion->shared_keys_3 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   37|  3.15k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  742|       |
  743|  3.15k|    if (onion->shared_keys_1 == nullptr ||
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
  |  Branch (743:9): [True: 0, False: 3.15k]
  ------------------
  744|  3.15k|            onion->shared_keys_2 == nullptr ||
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
  |  Branch (744:13): [True: 0, False: 3.15k]
  ------------------
  745|  3.15k|            onion->shared_keys_3 == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (745:13): [True: 0, False: 3.15k]
  ------------------
  746|       |        // cppcheck-suppress mismatchAllocDealloc
  747|      0|        kill_onion(onion);
  748|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  749|      0|    }
  750|       |
  751|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, &handle_send_initial, onion);
  752|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, &handle_send_1, onion);
  753|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, &handle_send_2, onion);
  754|       |
  755|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, &handle_recv_3, onion);
  756|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, &handle_recv_2, onion);
  757|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, &handle_recv_1, onion);
  758|       |
  759|  3.15k|    return onion;
  760|  3.15k|}
kill_onion:
  763|  3.15k|{
  764|  3.15k|    if (onion == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (764:9): [True: 0, False: 3.15k]
  ------------------
  765|      0|        return;
  766|      0|    }
  767|       |
  768|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  769|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  770|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  771|       |
  772|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  773|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  774|  3.15k|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  775|       |
  776|  3.15k|    crypto_memzero(onion->secret_symmetric_key, sizeof(onion->secret_symmetric_key));
  777|       |
  778|  3.15k|    shared_key_cache_free(onion->shared_keys_1);
  779|  3.15k|    shared_key_cache_free(onion->shared_keys_2);
  780|  3.15k|    shared_key_cache_free(onion->shared_keys_3);
  781|       |
  782|  3.15k|    mem_delete(onion->mem, onion);
  783|  3.15k|}

onion_announce_extra_data_callback:
   76|  3.15k|{
   77|  3.15k|    onion_a->extra_data_max_size = extra_data_max_size;
   78|  3.15k|    onion_a->extra_data_callback = extra_data_callback;
   79|  3.15k|    onion_a->extra_data_object = extra_data_object;
   80|  3.15k|}
new_onion_announce:
  705|  3.15k|{
  706|  3.15k|    if (dht == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (706:9): [True: 0, False: 3.15k]
  ------------------
  707|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  708|      0|    }
  709|       |
  710|  3.15k|    Onion_Announce *onion_a = (Onion_Announce *)mem_alloc(mem, sizeof(Onion_Announce));
  711|       |
  712|  3.15k|    if (onion_a == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (712:9): [True: 0, False: 3.15k]
  ------------------
  713|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  714|      0|    }
  715|       |
  716|  3.15k|    onion_a->log = log;
  717|  3.15k|    onion_a->rng = rng;
  718|  3.15k|    onion_a->mem = mem;
  719|  3.15k|    onion_a->mono_time = mono_time;
  720|  3.15k|    onion_a->dht = dht;
  721|  3.15k|    onion_a->net = dht_get_net(dht);
  722|  3.15k|    onion_a->extra_data_max_size = 0;
  723|  3.15k|    onion_a->extra_data_callback = nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  724|  3.15k|    onion_a->extra_data_object = nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  725|  3.15k|    new_hmac_key(rng, onion_a->hmac_key);
  726|       |
  727|  3.15k|    onion_a->shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht_get_self_secret_key(dht), KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   44|  3.15k|#define KEYS_TIMEOUT 600
  ------------------
                  onion_a->shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht_get_self_secret_key(dht), KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   43|  3.15k|#define MAX_KEYS_PER_SLOT 4
  ------------------
  728|  3.15k|    if (onion_a->shared_keys_recv == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (728:9): [True: 0, False: 3.15k]
  ------------------
  729|       |        // cppcheck-suppress mismatchAllocDealloc
  730|      0|        kill_onion_announce(onion_a);
  731|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  732|      0|    }
  733|       |
  734|  3.15k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, &handle_announce_request, onion_a);
  735|  3.15k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, &handle_announce_request_old, onion_a);
  736|  3.15k|    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, &handle_data_request, onion_a);
  737|       |
  738|  3.15k|    return onion_a;
  739|  3.15k|}
kill_onion_announce:
  742|  3.15k|{
  743|  3.15k|    if (onion_a == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (743:9): [True: 0, False: 3.15k]
  ------------------
  744|      0|        return;
  745|      0|    }
  746|       |
  747|  3.15k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  748|  3.15k|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  749|  3.15k|    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  750|       |
  751|  3.15k|    crypto_memzero(onion_a->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  162|  3.15k|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  752|  3.15k|    shared_key_cache_free(onion_a->shared_keys_recv);
  753|       |
  754|  3.15k|    mem_delete(onion_a->mem, onion_a);
  755|  3.15k|}

onion_get_friend:
  172|     64|{
  173|     64|    return &onion_c->friends_list[friend_num];
  174|     64|}
onion_friend_set_gc_public_key:
  187|     64|{
  188|     64|    memcpy(onion_friend->gc_public_key, public_key, ENC_PUBLIC_KEY_SIZE);
  ------------------
  |  |  122|     64|#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE
  |  |  ------------------
  |  |  |  |   43|     64|#define CRYPTO_PUBLIC_KEY_SIZE         32
  |  |  ------------------
  ------------------
  189|     64|}
onion_friend_set_gc_data:
  192|     64|{
  193|     64|    if (gc_data_length > 0 && gc_data != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (193:9): [True: 0, False: 64]
  |  Branch (193:31): [True: 0, False: 0]
  ------------------
  194|      0|        memcpy(onion_friend->gc_data, gc_data, gc_data_length);
  195|      0|    }
  196|       |
  197|     64|    onion_friend->gc_data_length = gc_data_length;
  198|     64|    onion_friend->is_groupchat = true;
  199|     64|}
onion_get_dht:
  207|  3.15k|{
  208|  3.15k|    return onion_c->dht;
  209|  3.15k|}
onion_get_net_crypto:
  212|  3.15k|{
  213|  3.15k|    return onion_c->c;
  214|  3.15k|}
onion_add_bs_path_node:
  230|  3.49k|{
  231|  3.49k|    if (!net_family_is_ipv4(ip_port->ip.family) && !net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (231:9): [True: 132, False: 3.36k]
  |  Branch (231:52): [True: 0, False: 132]
  ------------------
  232|      0|        return false;
  233|      0|    }
  234|       |
  235|  83.0k|    for (unsigned int i = 0; i < MAX_PATH_NODES; ++i) {
  ------------------
  |  |   51|  83.0k|#define MAX_PATH_NODES 32
  ------------------
  |  Branch (235:30): [True: 81.0k, False: 1.92k]
  ------------------
  236|  81.0k|        if (pk_equal(public_key, onion_c->path_nodes_bs[i].public_key)) {
  ------------------
  |  Branch (236:13): [True: 1.57k, False: 79.5k]
  ------------------
  237|  1.57k|            return true;
  238|  1.57k|        }
  239|  81.0k|    }
  240|       |
  241|  1.92k|    onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].ip_port = *ip_port;
  ------------------
  |  |   51|  1.92k|#define MAX_PATH_NODES 32
  ------------------
  242|  1.92k|    memcpy(onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].public_key, public_key,
  ------------------
  |  |   51|  1.92k|#define MAX_PATH_NODES 32
  ------------------
  243|  1.92k|           CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|  1.92k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  244|       |
  245|  1.92k|    const uint16_t last = onion_c->path_nodes_index_bs;
  246|  1.92k|    ++onion_c->path_nodes_index_bs;
  247|       |
  248|  1.92k|    if (onion_c->path_nodes_index_bs < last) {
  ------------------
  |  Branch (248:9): [True: 0, False: 1.92k]
  ------------------
  249|      0|        onion_c->path_nodes_index_bs = MAX_PATH_NODES + 1;
  ------------------
  |  |   51|      0|#define MAX_PATH_NODES 32
  ------------------
  250|      0|    }
  251|       |
  252|  1.92k|    return true;
  253|  3.49k|}
onion_backup_nodes:
  292|    615|{
  293|    615|    if (max_num == 0) {
  ------------------
  |  Branch (293:9): [True: 0, False: 615]
  ------------------
  294|      0|        return 0;
  295|      0|    }
  296|       |
  297|    615|    const uint16_t num_nodes = min_u16(onion_c->path_nodes_index, MAX_PATH_NODES);
  ------------------
  |  |   51|    615|#define MAX_PATH_NODES 32
  ------------------
  298|    615|    uint16_t i = 0;
  299|       |
  300|    615|    while (i < max_num && i < num_nodes) {
  ------------------
  |  Branch (300:12): [True: 615, False: 0]
  |  Branch (300:27): [True: 0, False: 615]
  ------------------
  301|      0|        nodes[i] = onion_c->path_nodes[(onion_c->path_nodes_index - (1 + i)) % num_nodes];
  302|      0|        ++i;
  303|      0|    }
  304|       |
  305|    966|    for (uint16_t j = 0; i < max_num && j < MAX_PATH_NODES && j < onion_c->path_nodes_index_bs; ++j) {
  ------------------
  |  |   51|  1.89k|#define MAX_PATH_NODES 32
  ------------------
  |  Branch (305:26): [True: 931, False: 35]
  |  Branch (305:41): [True: 931, False: 0]
  |  Branch (305:63): [True: 351, False: 580]
  ------------------
  306|    351|        bool already_saved = false;
  307|       |
  308|    351|        for (uint16_t k = 0; k < num_nodes; ++k) {
  ------------------
  |  Branch (308:30): [True: 0, False: 351]
  ------------------
  309|      0|            if (pk_equal(nodes[k].public_key, onion_c->path_nodes_bs[j].public_key)) {
  ------------------
  |  Branch (309:17): [True: 0, False: 0]
  ------------------
  310|      0|                already_saved = true;
  311|      0|                break;
  312|      0|            }
  313|      0|        }
  314|       |
  315|    351|        if (!already_saved) {
  ------------------
  |  Branch (315:13): [True: 351, False: 0]
  ------------------
  316|    351|            nodes[i] = onion_c->path_nodes_bs[j];
  317|    351|            ++i;
  318|    351|        }
  319|    351|    }
  320|       |
  321|    615|    return i;
  322|    615|}
onion_friend_num:
 1534|    582|{
 1535|  1.26k|    for (unsigned int i = 0; i < onion_c->num_friends; ++i) {
  ------------------
  |  Branch (1535:30): [True: 681, False: 582]
  ------------------
 1536|    681|        if (!onion_c->friends_list[i].is_valid) {
  ------------------
  |  Branch (1536:13): [True: 0, False: 681]
  ------------------
 1537|      0|            continue;
 1538|      0|        }
 1539|       |
 1540|    681|        if (pk_equal(public_key, onion_c->friends_list[i].real_public_key)) {
  ------------------
  |  Branch (1540:13): [True: 0, False: 681]
  ------------------
 1541|      0|            return i;
 1542|      0|        }
 1543|    681|    }
 1544|       |
 1545|    582|    return -1;
 1546|    582|}
onion_addfriend:
 1578|    582|{
 1579|    582|    const int num = onion_friend_num(onion_c, public_key);
 1580|       |
 1581|    582|    if (num != -1) {
  ------------------
  |  Branch (1581:9): [True: 0, False: 582]
  ------------------
 1582|      0|        return num;
 1583|      0|    }
 1584|       |
 1585|    582|    unsigned int index = -1;
 1586|       |
 1587|  1.26k|    for (unsigned int i = 0; i < onion_c->num_friends; ++i) {
  ------------------
  |  Branch (1587:30): [True: 681, False: 582]
  ------------------
 1588|    681|        if (!onion_c->friends_list[i].is_valid) {
  ------------------
  |  Branch (1588:13): [True: 0, False: 681]
  ------------------
 1589|      0|            index = i;
 1590|      0|            break;
 1591|      0|        }
 1592|    681|    }
 1593|       |
 1594|    582|    if (index == (uint32_t) -1) {
  ------------------
  |  Branch (1594:9): [True: 582, False: 0]
  ------------------
 1595|    582|        if (realloc_onion_friends(onion_c, onion_c->num_friends + 1) == -1) {
  ------------------
  |  Branch (1595:13): [True: 0, False: 582]
  ------------------
 1596|      0|            return -1;
 1597|      0|        }
 1598|       |
 1599|    582|        index = onion_c->num_friends;
 1600|    582|        onion_c->friends_list[onion_c->num_friends] = empty_onion_friend;
 1601|    582|        ++onion_c->num_friends;
 1602|    582|    }
 1603|       |
 1604|    582|    onion_c->friends_list[index].is_valid = true;
 1605|    582|    memcpy(onion_c->friends_list[index].real_public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|    582|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1606|    582|    crypto_new_keypair(onion_c->rng, onion_c->friends_list[index].temp_public_key,
 1607|    582|                       onion_c->friends_list[index].temp_secret_key);
 1608|    582|    return index;
 1609|    582|}
onion_delfriend:
 1617|    582|{
 1618|    582|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1618:9): [True: 0, False: 582]
  ------------------
 1619|      0|        return -1;
 1620|      0|    }
 1621|       |
 1622|       |#if 0
 1623|       |
 1624|       |    if (onion_c->friends_list[friend_num].know_dht_public_key) {
 1625|       |        dht_delfriend(onion_c->dht, onion_c->friends_list[friend_num].dht_public_key, 0);
 1626|       |    }
 1627|       |
 1628|       |#endif /* 0 */
 1629|       |
 1630|    582|    crypto_memzero(&onion_c->friends_list[friend_num], sizeof(Onion_Friend));
 1631|    582|    unsigned int i;
 1632|       |
 1633|  1.16k|    for (i = onion_c->num_friends; i != 0; --i) {
  ------------------
  |  Branch (1633:36): [True: 890, False: 274]
  ------------------
 1634|    890|        if (onion_c->friends_list[i - 1].is_valid) {
  ------------------
  |  Branch (1634:13): [True: 308, False: 582]
  ------------------
 1635|    308|            break;
 1636|    308|        }
 1637|    890|    }
 1638|       |
 1639|    582|    if (onion_c->num_friends != i) {
  ------------------
  |  Branch (1639:9): [True: 313, False: 269]
  ------------------
 1640|    313|        onion_c->num_friends = i;
 1641|    313|        realloc_onion_friends(onion_c, onion_c->num_friends);
 1642|    313|    }
 1643|       |
 1644|    582|    return friend_num;
 1645|    582|}
recv_tcp_relay_handler:
 1657|    582|{
 1658|    582|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1658:9): [True: 0, False: 582]
  ------------------
 1659|      0|        return -1;
 1660|      0|    }
 1661|       |
 1662|    582|    onion_c->friends_list[friend_num].tcp_relay_node_callback = callback;
 1663|    582|    onion_c->friends_list[friend_num].tcp_relay_node_callback_object = object;
 1664|    582|    onion_c->friends_list[friend_num].tcp_relay_node_callback_number = number;
 1665|    582|    return 0;
 1666|    582|}
onion_dht_pk_callback:
 1678|    582|{
 1679|    582|    if ((uint32_t)friend_num >= onion_c->num_friends) {
  ------------------
  |  Branch (1679:9): [True: 0, False: 582]
  ------------------
 1680|      0|        return -1;
 1681|      0|    }
 1682|       |
 1683|    582|    onion_c->friends_list[friend_num].dht_pk_callback = function;
 1684|    582|    onion_c->friends_list[friend_num].dht_pk_callback_object = object;
 1685|    582|    onion_c->friends_list[friend_num].dht_pk_callback_number = number;
 1686|    582|    return 0;
 1687|    582|}
oniondata_registerhandler:
 1930|  9.45k|{
 1931|  9.45k|    onion_c->onion_data_handlers[byte].function = cb;
 1932|  9.45k|    onion_c->onion_data_handlers[byte].object = object;
 1933|  9.45k|}
onion_group_announce_register:
 1936|  6.30k|{
 1937|  6.30k|    onion_c->group_announce_response = func;
 1938|  6.30k|    onion_c->group_announce_response_user_data = user_data;
 1939|  6.30k|}
new_onion_client:
 2224|  3.15k|{
 2225|  3.15k|    if (c == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2225:9): [True: 0, False: 3.15k]
  ------------------
 2226|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2227|      0|    }
 2228|       |
 2229|  3.15k|    Onion_Client *onion_c = (Onion_Client *)mem_alloc(mem, sizeof(Onion_Client));
 2230|       |
 2231|  3.15k|    if (onion_c == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2231:9): [True: 0, False: 3.15k]
  ------------------
 2232|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2233|      0|    }
 2234|       |
 2235|  3.15k|    onion_c->announce_ping_array = ping_array_new(mem, ANNOUNCE_ARRAY_SIZE, ANNOUNCE_TIMEOUT);
  ------------------
  |  |   36|  3.15k|#define ANNOUNCE_ARRAY_SIZE 256
  ------------------
                  onion_c->announce_ping_array = ping_array_new(mem, ANNOUNCE_ARRAY_SIZE, ANNOUNCE_TIMEOUT);
  ------------------
  |  |   37|  3.15k|#define ANNOUNCE_TIMEOUT 10
  ------------------
 2236|       |
 2237|  3.15k|    if (onion_c->announce_ping_array == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2237:9): [True: 0, False: 3.15k]
  ------------------
 2238|      0|        mem_delete(mem, onion_c);
 2239|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2240|      0|    }
 2241|       |
 2242|  3.15k|    onion_c->mono_time = mono_time;
 2243|  3.15k|    onion_c->logger = logger;
 2244|  3.15k|    onion_c->rng = rng;
 2245|  3.15k|    onion_c->mem = mem;
 2246|  3.15k|    onion_c->dht = nc_get_dht(c);
 2247|  3.15k|    onion_c->net = dht_get_net(onion_c->dht);
 2248|  3.15k|    onion_c->c = c;
 2249|  3.15k|    new_symmetric_key(rng, onion_c->secret_symmetric_key);
 2250|  3.15k|    crypto_new_keypair(rng, onion_c->temp_public_key, onion_c->temp_secret_key);
 2251|  3.15k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, &handle_announce_response, onion_c);
 2252|  3.15k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, &handle_announce_response_old, onion_c);
 2253|  3.15k|    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, &handle_data_response, onion_c);
 2254|  3.15k|    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, &handle_dhtpk_announce, onion_c);
  ------------------
  |  |   65|  3.15k|#define ONION_DATA_DHTPK CRYPTO_PACKET_DHTPK
  |  |  ------------------
  |  |  |  |   67|  3.15k|#define CRYPTO_PACKET_DHTPK         156
  |  |  ------------------
  ------------------
 2255|  3.15k|    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, &handle_dht_dhtpk, onion_c);
  ------------------
  |  |   67|  3.15k|#define CRYPTO_PACKET_DHTPK         156
  ------------------
 2256|  3.15k|    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), &handle_tcp_onion, onion_c);
 2257|       |
 2258|  3.15k|    return onion_c;
 2259|  3.15k|}
kill_onion_client:
 2262|  3.15k|{
 2263|  3.15k|    if (onion_c == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (2263:9): [True: 0, False: 3.15k]
  ------------------
 2264|      0|        return;
 2265|      0|    }
 2266|       |
 2267|  3.15k|    const Memory *mem = onion_c->mem;
 2268|       |
 2269|  3.15k|    ping_array_kill(onion_c->announce_ping_array);
 2270|  3.15k|    realloc_onion_friends(onion_c, 0);
 2271|  3.15k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2272|  3.15k|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2273|  3.15k|    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2274|  3.15k|    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   65|  3.15k|#define ONION_DATA_DHTPK CRYPTO_PACKET_DHTPK
  |  |  ------------------
  |  |  |  |   67|  3.15k|#define CRYPTO_PACKET_DHTPK         156
  |  |  ------------------
  ------------------
                  oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2275|  3.15k|    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   67|  3.15k|#define CRYPTO_PACKET_DHTPK         156
  ------------------
                  cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2276|  3.15k|    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
 2277|  3.15k|    crypto_memzero(onion_c, sizeof(Onion_Client));
 2278|  3.15k|    mem_delete(mem, onion_c);
 2279|  3.15k|}
onion_client.c:realloc_onion_friends:
 1555|  4.04k|{
 1556|  4.04k|    if (num == 0) {
  ------------------
  |  Branch (1556:9): [True: 3.42k, False: 621]
  ------------------
 1557|  3.42k|        mem_delete(onion_c->mem, onion_c->friends_list);
 1558|  3.42k|        onion_c->friends_list = nullptr;
  ------------------
  |  |   63|  3.42k|#define nullptr NULL
  ------------------
 1559|  3.42k|        return 0;
 1560|  3.42k|    }
 1561|       |
 1562|    621|    Onion_Friend *newonion_friends = (Onion_Friend *)mem_vrealloc(onion_c->mem, onion_c->friends_list, num, sizeof(Onion_Friend));
 1563|       |
 1564|    621|    if (newonion_friends == nullptr) {
  ------------------
  |  |   63|    621|#define nullptr NULL
  ------------------
  |  Branch (1564:9): [True: 0, False: 621]
  ------------------
 1565|      0|        return -1;
 1566|      0|    }
 1567|       |
 1568|    621|    onion_c->friends_list = newonion_friends;
 1569|    621|    return 0;
 1570|    621|}

ping_new:
  336|  3.15k|{
  337|  3.15k|    Ping *ping = (Ping *)mem_alloc(mem, sizeof(Ping));
  338|       |
  339|  3.15k|    if (ping == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (339:9): [True: 0, False: 3.15k]
  ------------------
  340|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  341|      0|    }
  342|       |
  343|  3.15k|    ping->ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   23|  3.15k|#define PING_NUM_MAX 512
  ------------------
                  ping->ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   43|  3.15k|#define PING_TIMEOUT 5
  ------------------
  344|       |
  345|  3.15k|    if (ping->ping_array == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (345:9): [True: 0, False: 3.15k]
  ------------------
  346|      0|        mem_delete(mem, ping);
  347|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  348|      0|    }
  349|       |
  350|  3.15k|    ping->mono_time = mono_time;
  351|  3.15k|    ping->rng = rng;
  352|  3.15k|    ping->mem = mem;
  353|  3.15k|    ping->dht = dht;
  354|  3.15k|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, &handle_ping_request, dht);
  355|  3.15k|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, &handle_ping_response, dht);
  356|       |
  357|  3.15k|    return ping;
  358|  3.15k|}
ping_kill:
  361|  3.15k|{
  362|  3.15k|    if (ping == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (362:9): [True: 0, False: 3.15k]
  ------------------
  363|      0|        return;
  364|      0|    }
  365|       |
  366|  3.15k|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  367|  3.15k|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  368|  3.15k|    ping_array_kill(ping->ping_array);
  369|       |
  370|  3.15k|    mem_delete(mem, ping);
  371|  3.15k|}

ping_array_new:
   37|  9.45k|{
   38|  9.45k|    if (size == 0 || timeout == 0) {
  ------------------
  |  Branch (38:9): [True: 0, False: 9.45k]
  |  Branch (38:22): [True: 0, False: 9.45k]
  ------------------
   39|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   40|      0|    }
   41|       |
   42|  9.45k|    if ((size & (size - 1)) != 0) {
  ------------------
  |  Branch (42:9): [True: 0, False: 9.45k]
  ------------------
   43|       |        // Not a power of 2.
   44|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   45|      0|    }
   46|       |
   47|  9.45k|    Ping_Array *const empty_array = (Ping_Array *)mem_alloc(mem, sizeof(Ping_Array));
   48|       |
   49|  9.45k|    if (empty_array == nullptr) {
  ------------------
  |  |   63|  9.45k|#define nullptr NULL
  ------------------
  |  Branch (49:9): [True: 0, False: 9.45k]
  ------------------
   50|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   51|      0|    }
   52|       |
   53|  9.45k|    Ping_Array_Entry *entries = (Ping_Array_Entry *)mem_valloc(mem, size, sizeof(Ping_Array_Entry));
   54|       |
   55|  9.45k|    if (entries == nullptr) {
  ------------------
  |  |   63|  9.45k|#define nullptr NULL
  ------------------
  |  Branch (55:9): [True: 0, False: 9.45k]
  ------------------
   56|      0|        mem_delete(mem, empty_array);
   57|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   58|      0|    }
   59|       |
   60|  9.45k|    empty_array->mem = mem;
   61|  9.45k|    empty_array->entries = entries;
   62|  9.45k|    empty_array->last_deleted = 0;
   63|  9.45k|    empty_array->last_added = 0;
   64|  9.45k|    empty_array->total_size = size;
   65|  9.45k|    empty_array->timeout = timeout;
   66|  9.45k|    return empty_array;
   67|  9.45k|}
ping_array_kill:
   78|  9.45k|{
   79|  9.45k|    if (array == nullptr) {
  ------------------
  |  |   63|  9.45k|#define nullptr NULL
  ------------------
  |  Branch (79:9): [True: 0, False: 9.45k]
  ------------------
   80|      0|        return;
   81|      0|    }
   82|       |
   83|  9.45k|    while (array->last_deleted != array->last_added) {
  ------------------
  |  Branch (83:12): [True: 0, False: 9.45k]
  ------------------
   84|      0|        const uint32_t index = array->last_deleted % array->total_size;
   85|      0|        clear_entry(array, index);
   86|      0|        ++array->last_deleted;
   87|      0|    }
   88|       |
   89|  9.45k|    mem_delete(array->mem, array->entries);
   90|  9.45k|    mem_delete(array->mem, array);
   91|  9.45k|}

shared_key_cache_new:
   52|  22.0k|{
   53|  22.0k|    if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|  44.1k|#define nullptr NULL
  ------------------
                  if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|  44.1k|#define nullptr NULL
  ------------------
  |  Branch (53:9): [True: 0, False: 22.0k]
  |  Branch (53:33): [True: 0, False: 22.0k]
  |  Branch (53:63): [True: 0, False: 22.0k]
  |  Branch (53:79): [True: 0, False: 22.0k]
  ------------------
   54|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   55|      0|    }
   56|       |
   57|       |    // Time must not be zero, since we use that as special value for empty slots
   58|  22.0k|    if (mono_time_get(mono_time) == 0) {
  ------------------
  |  Branch (58:9): [True: 0, False: 22.0k]
  ------------------
   59|       |        // Fail loudly in debug environments
   60|      0|        LOGGER_FATAL(log, "time must not be zero (mono_time not initialised?)");
  ------------------
  |  |   90|      0|    do {                                \
  |  |   91|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   92|      0|        logger_abort();                 \
  |  |   93|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (93:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   61|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   62|      0|    }
   63|       |
   64|  22.0k|    Shared_Key_Cache *res = (Shared_Key_Cache *)mem_alloc(mem, sizeof(Shared_Key_Cache));
   65|  22.0k|    if (res == nullptr) {
  ------------------
  |  |   63|  22.0k|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 0, False: 22.0k]
  ------------------
   66|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   67|      0|    }
   68|       |
   69|  22.0k|    res->self_secret_key = self_secret_key;
   70|  22.0k|    res->mono_time = mono_time;
   71|  22.0k|    res->mem = mem;
   72|  22.0k|    res->log = log;
   73|  22.0k|    res->keys_per_slot = keys_per_slot;
   74|       |
   75|       |    // We take one byte from the public key for each bucket and store keys_per_slot elements there
   76|  22.0k|    const size_t cache_size = 256 * keys_per_slot;
   77|  22.0k|    Shared_Key *keys = (Shared_Key *)mem_valloc(mem, cache_size, sizeof(Shared_Key));
   78|       |
   79|  22.0k|    if (keys == nullptr) {
  ------------------
  |  |   63|  22.0k|#define nullptr NULL
  ------------------
  |  Branch (79:9): [True: 0, False: 22.0k]
  ------------------
   80|      0|        mem_delete(mem, res);
   81|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   82|      0|    }
   83|       |
   84|  22.0k|    crypto_memlock(keys, cache_size * sizeof(Shared_Key));
   85|       |
   86|  22.0k|    res->keys = keys;
   87|       |
   88|  22.0k|    return res;
   89|  22.0k|}
shared_key_cache_free:
   92|  22.0k|{
   93|  22.0k|    if (cache == nullptr) {
  ------------------
  |  |   63|  22.0k|#define nullptr NULL
  ------------------
  |  Branch (93:9): [True: 0, False: 22.0k]
  ------------------
   94|      0|        return;
   95|      0|    }
   96|       |
   97|  22.0k|    const size_t cache_size = 256 * cache->keys_per_slot;
   98|       |    // Don't leave key material in memory
   99|  22.0k|    crypto_memzero(cache->keys, cache_size * sizeof(Shared_Key));
  100|  22.0k|    crypto_memunlock(cache->keys, cache_size * sizeof(Shared_Key));
  101|  22.0k|    mem_delete(cache->mem, cache->keys);
  102|  22.0k|    mem_delete(cache->mem, cache);
  103|  22.0k|}

state_load:
   15|  3.89k|{
   16|  3.89k|    if (state_load_callback == nullptr || data == nullptr) {
  ------------------
  |  |   63|  7.78k|#define nullptr NULL
  ------------------
                  if (state_load_callback == nullptr || data == nullptr) {
  ------------------
  |  |   63|  3.89k|#define nullptr NULL
  ------------------
  |  Branch (16:9): [True: 0, False: 3.89k]
  |  Branch (16:43): [True: 0, False: 3.89k]
  ------------------
   17|      0|        LOGGER_ERROR(log, "state_load() called with invalid args.");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   18|      0|        return -1;
   19|      0|    }
   20|       |
   21|  3.89k|    const uint32_t size_head = sizeof(uint32_t) * 2;
   22|       |
   23|  38.1k|    while (length >= size_head) {
  ------------------
  |  Branch (23:12): [True: 36.1k, False: 1.96k]
  ------------------
   24|  36.1k|        uint32_t length_sub;
   25|  36.1k|        lendian_bytes_to_host32(&length_sub, data);
   26|       |
   27|  36.1k|        uint32_t cookie_type;
   28|  36.1k|        lendian_bytes_to_host32(&cookie_type, data + sizeof(uint32_t));
   29|       |
   30|  36.1k|        data += size_head;
   31|  36.1k|        length -= size_head;
   32|       |
   33|  36.1k|        if (length < length_sub) {
  ------------------
  |  Branch (33:13): [True: 1.46k, False: 34.6k]
  ------------------
   34|       |            /* file truncated */
   35|  1.46k|            LOGGER_ERROR(log, "state file too short: %u < %u", length, length_sub);
  ------------------
  |  |   87|  1.46k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  1.46k|    do {                                                                         \
  |  |  |  |   77|  1.46k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  2.93k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|  1.46k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|  1.46k|        }                                                                        \
  |  |  |  |   80|  1.46k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   36|  1.46k|            return -1;
   37|  1.46k|        }
   38|       |
   39|  34.6k|        if (lendian_to_host16(cookie_type >> 16) != cookie_inner) {
  ------------------
  |  Branch (39:13): [True: 211, False: 34.4k]
  ------------------
   40|       |            /* something is not matching up in a bad way, give up */
   41|    211|            LOGGER_ERROR(log, "state file garbled: %04x != %04x", cookie_type >> 16, cookie_inner);
  ------------------
  |  |   87|    211|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|    211|    do {                                                                         \
  |  |  |  |   77|    211|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    422|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|    211|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|    211|        }                                                                        \
  |  |  |  |   80|    211|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   42|    211|            return -1;
   43|    211|        }
   44|       |
   45|  34.4k|        const uint16_t type = lendian_to_host16(cookie_type & 0xFFFF);
   46|       |
   47|  34.4k|        switch (state_load_callback(outer, data, length_sub, type)) {
  ------------------
  |  Branch (47:17): [True: 0, False: 34.4k]
  ------------------
   48|  34.2k|            case STATE_LOAD_STATUS_CONTINUE: {
  ------------------
  |  Branch (48:13): [True: 34.2k, False: 246]
  ------------------
   49|  34.2k|                data += length_sub;
   50|  34.2k|                length -= length_sub;
   51|  34.2k|                break;
   52|      0|            }
   53|       |
   54|    225|            case STATE_LOAD_STATUS_ERROR: {
  ------------------
  |  Branch (54:13): [True: 225, False: 34.2k]
  ------------------
   55|    225|                LOGGER_ERROR(log, "Error occcured in state file (type: 0x%02x).", type);
  ------------------
  |  |   87|    225|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|    225|    do {                                                                         \
  |  |  |  |   77|    225|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    450|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|    225|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|    225|        }                                                                        \
  |  |  |  |   80|    225|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   56|    225|                return -1;
   57|      0|            }
   58|       |
   59|     21|            case STATE_LOAD_STATUS_END: {
  ------------------
  |  Branch (59:13): [True: 21, False: 34.4k]
  ------------------
   60|     21|                return 0;
   61|      0|            }
   62|  34.4k|        }
   63|  34.4k|    }
   64|       |
   65|  1.96k|    if (length != 0) {
  ------------------
  |  Branch (65:9): [True: 1.01k, False: 953]
  ------------------
   66|  1.01k|        LOGGER_ERROR(log, "unparsed data in state file of length %u", length);
  ------------------
  |  |   87|  1.01k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  1.01k|    do {                                                                         \
  |  |  |  |   77|  1.01k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  2.02k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|  1.01k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|  1.01k|        }                                                                        \
  |  |  |  |   80|  1.01k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   67|  1.01k|        return -1;
   68|  1.01k|    }
   69|       |
   70|    953|    return 0;
   71|  1.96k|}
state_write_section_header:
   74|  7.52k|{
   75|  7.52k|    host_to_lendian_bytes32(data, len);
   76|  7.52k|    data += sizeof(uint32_t);
   77|  7.52k|    host_to_lendian_bytes32(data, (host_to_lendian16(cookie_type) << 16) | host_to_lendian16(section_type));
   78|  7.52k|    data += sizeof(uint32_t);
   79|  7.52k|    return data;
   80|  7.52k|}
lendian_to_host16:
   83|  84.1k|{
   84|       |#ifdef WORDS_BIGENDIAN
   85|       |    return (lendian << 8) | (lendian >> 8);
   86|       |#else
   87|  84.1k|    return lendian;
   88|  84.1k|#endif /* WORDS_BIGENDIAN */
   89|  84.1k|}
host_to_lendian16:
   92|  15.0k|{
   93|  15.0k|    return lendian_to_host16(host);
   94|  15.0k|}
host_to_lendian_bytes64:
   97|    296|{
   98|       |#ifdef WORDS_BIGENDIAN
   99|       |    num = ((num << 8) & 0xFF00FF00FF00FF00) | ((num >> 8) & 0xFF00FF00FF00FF);
  100|       |    num = ((num << 16) & 0xFFFF0000FFFF0000) | ((num >> 16) & 0xFFFF0000FFFF);
  101|       |    num = (num << 32) | (num >> 32);
  102|       |#endif /* WORDS_BIGENDIAN */
  103|    296|    memcpy(dest, &num, sizeof(uint64_t));
  104|    296|}
lendian_bytes_to_host64:
  107|    793|{
  108|    793|    uint64_t d;
  109|    793|    memcpy(&d, lendian, sizeof(uint64_t));
  110|       |#ifdef WORDS_BIGENDIAN
  111|       |    d = ((d << 8) & 0xFF00FF00FF00FF00) | ((d >> 8) & 0xFF00FF00FF00FF);
  112|       |    d = ((d << 16) & 0xFFFF0000FFFF0000) | ((d >> 16) & 0xFFFF0000FFFF);
  113|       |    d = (d << 32) | (d >> 32);
  114|       |#endif /* WORDS_BIGENDIAN */
  115|    793|    *dest = d;
  116|    793|}
host_to_lendian_bytes32:
  119|  18.6k|{
  120|       |#ifdef WORDS_BIGENDIAN
  121|       |    num = ((num << 8) & 0xFF00FF00) | ((num >> 8) & 0xFF00FF);
  122|       |    num = (num << 16) | (num >> 16);
  123|       |#endif /* WORDS_BIGENDIAN */
  124|  18.6k|    memcpy(dest, &num, sizeof(uint32_t));
  125|  18.6k|}
lendian_bytes_to_host32:
  128|  85.9k|{
  129|  85.9k|    uint32_t d;
  130|  85.9k|    memcpy(&d, lendian, sizeof(uint32_t));
  131|       |#ifdef WORDS_BIGENDIAN
  132|       |    d = ((d << 8) & 0xFF00FF00) | ((d >> 8) & 0xFF00FF);
  133|       |    d = (d << 16) | (d >> 16);
  134|       |#endif /* WORDS_BIGENDIAN */
  135|  85.9k|    *dest = d;
  136|  85.9k|}
host_to_lendian_bytes16:
  139|  2.02k|{
  140|       |#ifdef WORDS_BIGENDIAN
  141|       |    num = (num << 8) | (num >> 8);
  142|       |#endif /* WORDS_BIGENDIAN */
  143|  2.02k|    memcpy(dest, &num, sizeof(uint16_t));
  144|  2.02k|}
lendian_bytes_to_host16:
  147|  9.54k|{
  148|  9.54k|    uint16_t d;
  149|  9.54k|    memcpy(&d, lendian, sizeof(uint16_t));
  150|       |#ifdef WORDS_BIGENDIAN
  151|       |    d = (d << 8) | (d >> 8);
  152|       |#endif /* WORDS_BIGENDIAN */
  153|  9.54k|    *dest = d;
  154|  9.54k|}

tox_new_testing:
 1036|  3.15k|{
 1037|  3.15k|    if (testing == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1037:9): [True: 0, False: 3.15k]
  ------------------
 1038|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1039|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1040|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1041|      0|    }
 1042|       |
 1043|  3.15k|    if (testing->operating_system == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1043:9): [True: 0, False: 3.15k]
  ------------------
 1044|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1045|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1046|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1047|      0|    }
 1048|       |
 1049|  3.15k|    const Tox_System *sys = testing->operating_system;
 1050|       |
 1051|  3.15k|    if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (1051:9): [True: 0, False: 3.15k]
  |  Branch (1051:32): [True: 0, False: 3.15k]
  |  Branch (1051:54): [True: 0, False: 3.15k]
  ------------------
 1052|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1053|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1054|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1055|      0|    }
 1056|       |
 1057|  3.15k|    SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_OK);
  ------------------
  |  |   44|  3.15k|    do {                              \
  |  |   45|  3.15k|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|  6.30k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 3.15k]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1058|  3.15k|    return tox_new_system(options, error, sys);
 1059|  3.15k|}
tox_kill:
 1062|    615|{
 1063|    615|    if (tox == nullptr) {
  ------------------
  |  |   63|    615|#define nullptr NULL
  ------------------
  |  Branch (1063:9): [True: 0, False: 615]
  ------------------
 1064|      0|        return;
 1065|      0|    }
 1066|       |
 1067|    615|    tox_lock(tox);
 1068|    615|    LOGGER_ASSERT(tox->m->log, tox->toxav_object == nullptr, "Attempted to kill tox while toxav is still alive");
  ------------------
  |  |   96|    615|    do {                                           \
  |  |   97|    615|        if (!(cond)) {                             \
  |  |  ------------------
  |  |  |  Branch (97:13): [True: 0, False: 615]
  |  |  ------------------
  |  |   98|      0|            LOGGER_ERROR(log, "Assertion failed"); \
  |  |  ------------------
  |  |  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   99|      0|            LOGGER_FATAL(log, __VA_ARGS__);        \
  |  |  ------------------
  |  |  |  |   90|      0|    do {                                \
  |  |  |  |   91|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |   92|      0|        logger_abort();                 \
  |  |  |  |   93|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (93:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  100|      0|        }                                          \
  |  |  101|    615|    } while (0)
  |  |  ------------------
  |  |  |  Branch (101:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1069|    615|    kill_groupchats(tox->m->conferences_object);
 1070|    615|    kill_messenger(tox->m);
 1071|    615|    mono_time_free(tox->sys.mem, tox->mono_time);
 1072|    615|    tox_unlock(tox);
 1073|       |
 1074|    615|    if (tox->mutex != nullptr) {
  ------------------
  |  |   63|    615|#define nullptr NULL
  ------------------
  |  Branch (1074:9): [True: 0, False: 615]
  ------------------
 1075|      0|        pthread_mutex_destroy(tox->mutex);
 1076|      0|        mem_delete(tox->sys.mem, tox->mutex);
 1077|      0|    }
 1078|       |
 1079|    615|    mem_delete(tox->sys.mem, tox);
 1080|    615|}
tox_get_savedata_size:
 1094|  1.23k|{
 1095|  1.23k|    assert(tox != nullptr);
 1096|  1.23k|    tox_lock(tox);
 1097|  1.23k|    const size_t ret = 2 * sizeof(uint32_t)
 1098|  1.23k|                       + messenger_size(tox->m)
 1099|  1.23k|                       + conferences_size(tox->m->conferences_object)
 1100|  1.23k|                       + end_size();
 1101|  1.23k|    tox_unlock(tox);
 1102|  1.23k|    return ret;
 1103|  1.23k|}
tox_get_savedata:
 1106|    615|{
 1107|    615|    assert(tox != nullptr);
 1108|       |
 1109|    615|    if (savedata == nullptr) {
  ------------------
  |  |   63|    615|#define nullptr NULL
  ------------------
  |  Branch (1109:9): [True: 0, False: 615]
  ------------------
 1110|      0|        return;
 1111|      0|    }
 1112|       |
 1113|    615|    memzero(savedata, tox_get_savedata_size(tox));
 1114|       |
 1115|    615|    tox_lock(tox);
 1116|       |
 1117|    615|    const uint32_t size32 = sizeof(uint32_t);
 1118|       |
 1119|       |    // write cookie
 1120|    615|    memzero(savedata, size32);
 1121|    615|    savedata += size32;
 1122|    615|    host_to_lendian_bytes32(savedata, STATE_COOKIE_GLOBAL);
  ------------------
  |  |   27|    615|#define STATE_COOKIE_GLOBAL 0x15ed1b1f
  ------------------
 1123|    615|    savedata += size32;
 1124|       |
 1125|    615|    savedata = messenger_save(tox->m, savedata);
 1126|    615|    savedata = conferences_save(tox->m->conferences_object, savedata);
 1127|    615|    end_save(savedata);
 1128|       |
 1129|    615|    tox_unlock(tox);
 1130|    615|}
tox.c:tox_new_system:
  721|  3.15k|{
  722|  3.15k|    struct Tox_Options *default_options = nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  723|       |
  724|  3.15k|    if (options == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (724:9): [True: 0, False: 3.15k]
  ------------------
  725|      0|        Tox_Err_Options_New err;
  726|      0|        default_options = tox_options_new(&err);
  727|       |
  728|      0|        switch (err) {
  ------------------
  |  Branch (728:17): [True: 0, False: 0]
  ------------------
  729|      0|            case TOX_ERR_OPTIONS_NEW_OK: {
  ------------------
  |  Branch (729:13): [True: 0, False: 0]
  ------------------
  730|      0|                assert(default_options != nullptr);
  731|      0|                break;
  732|      0|            }
  733|       |
  734|      0|            case TOX_ERR_OPTIONS_NEW_MALLOC: {
  ------------------
  |  Branch (734:13): [True: 0, False: 0]
  ------------------
  735|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  736|      0|                return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  737|      0|            }
  738|      0|        }
  739|      0|    }
  740|       |
  741|  3.15k|    const struct Tox_Options *const opts = options != nullptr ? options : default_options;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (741:44): [True: 3.15k, False: 0]
  ------------------
  742|  3.15k|    assert(opts != nullptr);
  743|       |
  744|  3.15k|    const Tox_System default_system = tox_default_system();
  745|       |
  746|  3.15k|    if (sys == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (746:9): [True: 0, False: 3.15k]
  ------------------
  747|      0|        sys = &default_system;
  748|      0|    }
  749|       |
  750|  3.15k|    if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (750:9): [True: 0, False: 3.15k]
  |  Branch (750:32): [True: 0, False: 3.15k]
  |  Branch (750:54): [True: 0, False: 3.15k]
  ------------------
  751|       |        // TODO(iphydf): Not quite right, but similar.
  752|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  753|      0|        tox_options_free(default_options);
  754|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  755|      0|    }
  756|       |
  757|  3.15k|    Messenger_Options m_options = {false};
  758|       |
  759|  3.15k|    m_options.dns_enabled = !tox_options_get_experimental_disable_dns(opts);
  760|       |
  761|  3.15k|    bool load_savedata_sk = false;
  762|  3.15k|    bool load_savedata_tox = false;
  763|       |
  764|  3.15k|    if (tox_options_get_savedata_type(opts) != TOX_SAVEDATA_TYPE_NONE) {
  ------------------
  |  Branch (764:9): [True: 3.15k, False: 0]
  ------------------
  765|  3.15k|        if (tox_options_get_savedata_data(opts) == nullptr || tox_options_get_savedata_length(opts) == 0) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
  |  Branch (765:13): [True: 0, False: 3.15k]
  |  Branch (765:63): [True: 0, False: 3.15k]
  ------------------
  766|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  767|      0|            tox_options_free(default_options);
  768|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  769|      0|        }
  770|  3.15k|    }
  771|       |
  772|  3.15k|    if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_SECRET_KEY) {
  ------------------
  |  Branch (772:9): [True: 0, False: 3.15k]
  ------------------
  773|      0|        if (tox_options_get_savedata_length(opts) != TOX_SECRET_KEY_SIZE) {
  ------------------
  |  |  219|      0|#define TOX_SECRET_KEY_SIZE            32
  ------------------
  |  Branch (773:13): [True: 0, False: 0]
  ------------------
  774|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  775|      0|            tox_options_free(default_options);
  776|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  777|      0|        }
  778|       |
  779|      0|        load_savedata_sk = true;
  780|  3.15k|    } else if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_TOX_SAVE) {
  ------------------
  |  Branch (780:16): [True: 3.15k, False: 0]
  ------------------
  781|  3.15k|        if (tox_options_get_savedata_length(opts) < TOX_ENC_SAVE_MAGIC_LENGTH) {
  ------------------
  |  |   10|  3.15k|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (781:13): [True: 1, False: 3.15k]
  ------------------
  782|      1|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   44|      1|    do {                              \
  |  |   45|      1|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      2|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 1]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  783|      1|            tox_options_free(default_options);
  784|      1|            return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  785|      1|        }
  786|       |
  787|  3.15k|        if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |    9|  3.15k|#define TOX_ENC_SAVE_MAGIC_NUMBER ((const uint8_t *)"toxEsave")
  ------------------
                      if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |   10|  3.15k|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (787:13): [True: 1, False: 3.15k]
  ------------------
  788|      1|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_ENCRYPTED);
  ------------------
  |  |   44|      1|    do {                              \
  |  |   45|      1|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      2|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 1]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  789|      1|            tox_options_free(default_options);
  790|      1|            return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  791|      1|        }
  792|       |
  793|  3.15k|        load_savedata_tox = true;
  794|  3.15k|    }
  795|       |
  796|  3.15k|    m_options.ipv6enabled = tox_options_get_ipv6_enabled(opts);
  797|  3.15k|    m_options.udp_disabled = !tox_options_get_udp_enabled(opts);
  798|  3.15k|    m_options.port_range[0] = tox_options_get_start_port(opts);
  799|  3.15k|    m_options.port_range[1] = tox_options_get_end_port(opts);
  800|  3.15k|    m_options.tcp_server_port = tox_options_get_tcp_port(opts);
  801|  3.15k|    m_options.hole_punching_enabled = tox_options_get_hole_punching_enabled(opts);
  802|  3.15k|    m_options.local_discovery_enabled = tox_options_get_local_discovery_enabled(opts);
  803|  3.15k|    m_options.dht_announcements_enabled = tox_options_get_dht_announcements_enabled(opts);
  804|  3.15k|    m_options.groups_persistence_enabled = tox_options_get_experimental_groups_persistence(opts);
  805|       |
  806|  3.15k|    if (m_options.udp_disabled) {
  ------------------
  |  Branch (806:9): [True: 0, False: 3.15k]
  ------------------
  807|      0|        m_options.local_discovery_enabled = false;
  808|      0|    }
  809|       |
  810|  3.15k|    Tox *tox = (Tox *)mem_alloc(sys->mem, sizeof(Tox));
  811|       |
  812|  3.15k|    if (tox == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (812:9): [True: 0, False: 3.15k]
  ------------------
  813|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  814|      0|        tox_options_free(default_options);
  815|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  816|      0|    }
  817|       |
  818|  3.15k|    tox->log_callback = tox_options_get_log_callback(opts);
  819|  3.15k|    m_options.log_callback = tox_log_handler;
  820|  3.15k|    m_options.log_context = tox;
  821|  3.15k|    m_options.log_user_data = tox_options_get_log_user_data(opts);
  822|       |
  823|  3.15k|    switch (tox_options_get_proxy_type(opts)) {
  824|      0|        case TOX_PROXY_TYPE_HTTP: {
  ------------------
  |  Branch (824:9): [True: 0, False: 3.15k]
  ------------------
  825|      0|            m_options.proxy_info.proxy_type = TCP_PROXY_HTTP;
  826|      0|            break;
  827|      0|        }
  828|       |
  829|      0|        case TOX_PROXY_TYPE_SOCKS5: {
  ------------------
  |  Branch (829:9): [True: 0, False: 3.15k]
  ------------------
  830|      0|            m_options.proxy_info.proxy_type = TCP_PROXY_SOCKS5;
  831|      0|            break;
  832|      0|        }
  833|       |
  834|  3.15k|        case TOX_PROXY_TYPE_NONE: {
  ------------------
  |  Branch (834:9): [True: 3.15k, False: 0]
  ------------------
  835|  3.15k|            m_options.proxy_info.proxy_type = TCP_PROXY_NONE;
  836|  3.15k|            break;
  837|      0|        }
  838|       |
  839|      0|        default: {
  ------------------
  |  Branch (839:9): [True: 0, False: 3.15k]
  ------------------
  840|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_TYPE);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  841|      0|            mem_delete(sys->mem, tox);
  842|      0|            tox_options_free(default_options);
  843|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  844|      0|        }
  845|  3.15k|    }
  846|       |
  847|  3.15k|    tox->sys = *sys;
  848|       |
  849|  3.15k|    if (m_options.proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (849:9): [True: 0, False: 3.15k]
  ------------------
  850|      0|        if (tox_options_get_proxy_port(opts) == 0) {
  ------------------
  |  Branch (850:13): [True: 0, False: 0]
  ------------------
  851|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_PORT);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  852|      0|            mem_delete(sys->mem, tox);
  853|      0|            tox_options_free(default_options);
  854|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  855|      0|        }
  856|       |
  857|      0|        ip_init(&m_options.proxy_info.ip_port.ip, m_options.ipv6enabled);
  858|       |
  859|      0|        if (m_options.ipv6enabled) {
  ------------------
  |  Branch (859:13): [True: 0, False: 0]
  ------------------
  860|      0|            m_options.proxy_info.ip_port.ip.family = net_family_unspec();
  861|      0|        }
  862|       |
  863|      0|        const char *const proxy_host = tox_options_get_proxy_host(opts);
  864|      0|        const bool dns_enabled = !tox_options_get_experimental_disable_dns(opts);
  865|       |
  866|      0|        if (proxy_host == nullptr
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (866:13): [True: 0, False: 0]
  ------------------
  867|      0|                || !addr_resolve_or_parse_ip(tox->sys.ns, tox->sys.mem, proxy_host, &m_options.proxy_info.ip_port.ip, nullptr, dns_enabled)) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (867:20): [True: 0, False: 0]
  ------------------
  868|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_HOST);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  869|       |            // TODO(irungentoo): TOX_ERR_NEW_PROXY_NOT_FOUND if domain.
  870|      0|            mem_delete(sys->mem, tox);
  871|      0|            tox_options_free(default_options);
  872|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  873|      0|        }
  874|       |
  875|      0|        m_options.proxy_info.ip_port.port = net_htons(tox_options_get_proxy_port(opts));
  876|      0|    }
  877|       |
  878|  3.15k|    tox->mono_time = mono_time_new(tox->sys.mem, sys->mono_time_callback, sys->mono_time_user_data);
  879|       |
  880|  3.15k|    if (tox->mono_time == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (880:9): [True: 0, False: 3.15k]
  ------------------
  881|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  882|      0|        mem_delete(sys->mem, tox);
  883|      0|        tox_options_free(default_options);
  884|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  885|      0|    }
  886|       |
  887|  3.15k|    if (tox_options_get_experimental_thread_safety(opts)) {
  ------------------
  |  Branch (887:9): [True: 0, False: 3.15k]
  ------------------
  888|      0|        pthread_mutex_t *mutex = (pthread_mutex_t *)mem_alloc(sys->mem, sizeof(pthread_mutex_t));
  889|       |
  890|      0|        if (mutex == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (890:13): [True: 0, False: 0]
  ------------------
  891|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  892|      0|            mem_delete(sys->mem, tox);
  893|      0|            tox_options_free(default_options);
  894|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  895|      0|        }
  896|       |
  897|      0|        pthread_mutex_init(mutex, nullptr);
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  898|       |
  899|      0|        tox->mutex = mutex;
  900|  3.15k|    } else {
  901|  3.15k|        tox->mutex = nullptr;
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  902|  3.15k|    }
  903|       |
  904|  3.15k|    tox_lock(tox);
  905|       |
  906|  3.15k|    Messenger_Error m_error;
  907|  3.15k|    tox->m = new_messenger(tox->mono_time, tox->sys.mem, tox->sys.rng, tox->sys.ns, &m_options, &m_error);
  908|       |
  909|  3.15k|    if (tox->m == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (909:9): [True: 0, False: 3.15k]
  ------------------
  910|      0|        switch (m_error) {
  ------------------
  |  Branch (910:17): [True: 0, False: 0]
  ------------------
  911|      0|            case MESSENGER_ERROR_PORT:
  ------------------
  |  Branch (911:13): [True: 0, False: 0]
  ------------------
  912|      0|            case MESSENGER_ERROR_TCP_SERVER: {
  ------------------
  |  Branch (912:13): [True: 0, False: 0]
  ------------------
  913|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PORT_ALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  914|      0|                break;
  915|      0|            }
  916|      0|            case MESSENGER_ERROR_OTHER:
  ------------------
  |  Branch (916:13): [True: 0, False: 0]
  ------------------
  917|      0|            case MESSENGER_ERROR_NONE: {
  ------------------
  |  Branch (917:13): [True: 0, False: 0]
  ------------------
  918|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  919|      0|                break;
  920|      0|            }
  921|      0|        }
  922|       |
  923|      0|        mono_time_free(tox->sys.mem, tox->mono_time);
  924|      0|        tox_unlock(tox);
  925|       |
  926|      0|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (926:13): [True: 0, False: 0]
  ------------------
  927|      0|            pthread_mutex_destroy(tox->mutex);
  928|      0|        }
  929|       |
  930|      0|        mem_delete(sys->mem, tox->mutex);
  931|      0|        mem_delete(sys->mem, tox);
  932|      0|        tox_options_free(default_options);
  933|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  934|      0|    }
  935|       |
  936|  3.15k|    tox->m->conferences_object = new_groupchats(tox->mono_time, sys->mem, tox->m);
  937|       |
  938|  3.15k|    if (tox->m->conferences_object == nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (938:9): [True: 0, False: 3.15k]
  ------------------
  939|      0|        kill_messenger(tox->m);
  940|       |
  941|      0|        mono_time_free(tox->sys.mem, tox->mono_time);
  942|      0|        tox_unlock(tox);
  943|       |
  944|      0|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (944:13): [True: 0, False: 0]
  ------------------
  945|      0|            pthread_mutex_destroy(tox->mutex);
  946|      0|        }
  947|       |
  948|      0|        mem_delete(sys->mem, tox->mutex);
  949|      0|        mem_delete(sys->mem, tox);
  950|       |
  951|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  952|      0|        tox_options_free(default_options);
  953|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  954|      0|    }
  955|       |
  956|  3.15k|    if (load_savedata_tox
  ------------------
  |  Branch (956:9): [True: 3.15k, False: 0]
  ------------------
  957|  3.15k|            && tox_load(tox, tox_options_get_savedata_data(opts), tox_options_get_savedata_length(opts)) == -1) {
  ------------------
  |  Branch (957:16): [True: 2.53k, False: 615]
  ------------------
  958|  2.53k|        kill_groupchats(tox->m->conferences_object);
  959|  2.53k|        kill_messenger(tox->m);
  960|       |
  961|  2.53k|        mono_time_free(tox->sys.mem, tox->mono_time);
  962|  2.53k|        tox_unlock(tox);
  963|       |
  964|  2.53k|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|  2.53k|#define nullptr NULL
  ------------------
  |  Branch (964:13): [True: 0, False: 2.53k]
  ------------------
  965|      0|            pthread_mutex_destroy(tox->mutex);
  966|      0|        }
  967|       |
  968|  2.53k|        mem_delete(sys->mem, tox->mutex);
  969|  2.53k|        mem_delete(sys->mem, tox);
  970|       |
  971|  2.53k|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   44|  2.53k|    do {                              \
  |  |   45|  2.53k|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|  5.07k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 2.53k]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|  2.53k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  972|  2.53k|        tox_options_free(default_options);
  973|  2.53k|        return nullptr;
  ------------------
  |  |   63|  2.53k|#define nullptr NULL
  ------------------
  974|  2.53k|    }
  975|       |
  976|    615|    if (load_savedata_sk) {
  ------------------
  |  Branch (976:9): [True: 0, False: 615]
  ------------------
  977|      0|        load_secret_key(tox->m->net_crypto, tox_options_get_savedata_data(opts));
  978|      0|    }
  979|       |
  980|    615|    m_callback_namechange(tox->m, tox_friend_name_handler);
  981|    615|    m_callback_core_connection(tox->m, tox_self_connection_status_handler);
  982|    615|    m_callback_statusmessage(tox->m, tox_friend_status_message_handler);
  983|    615|    m_callback_userstatus(tox->m, tox_friend_status_handler);
  984|    615|    m_callback_connectionstatus(tox->m, tox_friend_connection_status_handler);
  985|    615|    m_callback_typingchange(tox->m, tox_friend_typing_handler);
  986|    615|    m_callback_read_receipt(tox->m, tox_friend_read_receipt_handler);
  987|    615|    m_callback_friendrequest(tox->m, tox_friend_request_handler);
  988|    615|    m_callback_friendmessage(tox->m, tox_friend_message_handler);
  989|    615|    callback_file_control(tox->m, tox_file_recv_control_handler);
  990|    615|    callback_file_reqchunk(tox->m, tox_file_chunk_request_handler);
  991|    615|    callback_file_sendrequest(tox->m, tox_file_recv_handler);
  992|    615|    callback_file_data(tox->m, tox_file_recv_chunk_handler);
  993|    615|    dht_callback_nodes_response(tox->m->dht, tox_dht_nodes_response_handler);
  994|    615|    g_callback_group_invite(tox->m->conferences_object, tox_conference_invite_handler);
  995|    615|    g_callback_group_connected(tox->m->conferences_object, tox_conference_connected_handler);
  996|    615|    g_callback_group_message(tox->m->conferences_object, tox_conference_message_handler);
  997|    615|    g_callback_group_title(tox->m->conferences_object, tox_conference_title_handler);
  998|    615|    g_callback_peer_name(tox->m->conferences_object, tox_conference_peer_name_handler);
  999|    615|    g_callback_peer_list_changed(tox->m->conferences_object, tox_conference_peer_list_changed_handler);
 1000|    615|    custom_lossy_packet_registerhandler(tox->m, tox_friend_lossy_packet_handler);
 1001|    615|    custom_lossless_packet_registerhandler(tox->m, tox_friend_lossless_packet_handler);
 1002|       |
 1003|    615|    m_callback_group_invite(tox->m, tox_group_invite_handler);
 1004|    615|    gc_callback_message(tox->m, tox_group_message_handler);
 1005|    615|    gc_callback_private_message(tox->m, tox_group_private_message_handler);
 1006|    615|    gc_callback_custom_packet(tox->m, tox_group_custom_packet_handler);
 1007|    615|    gc_callback_custom_private_packet(tox->m, tox_group_custom_private_packet_handler);
 1008|    615|    gc_callback_moderation(tox->m, tox_group_moderation_handler);
 1009|    615|    gc_callback_nick_change(tox->m, tox_group_peer_name_handler);
 1010|    615|    gc_callback_status_change(tox->m, tox_group_peer_status_handler);
 1011|    615|    gc_callback_topic_change(tox->m, tox_group_topic_handler);
 1012|    615|    gc_callback_peer_limit(tox->m, tox_group_peer_limit_handler);
 1013|    615|    gc_callback_privacy_state(tox->m, tox_group_privacy_state_handler);
 1014|    615|    gc_callback_topic_lock(tox->m, tox_group_topic_lock_handler);
 1015|    615|    gc_callback_password(tox->m, tox_group_password_handler);
 1016|    615|    gc_callback_peer_join(tox->m, tox_group_peer_join_handler);
 1017|    615|    gc_callback_peer_exit(tox->m, tox_group_peer_exit_handler);
 1018|    615|    gc_callback_self_join(tox->m, tox_group_self_join_handler);
 1019|    615|    gc_callback_rejected(tox->m, tox_group_join_fail_handler);
 1020|    615|    gc_callback_voice_state(tox->m, tox_group_voice_state_handler);
 1021|       |
 1022|    615|    tox_unlock(tox);
 1023|       |
 1024|    615|    SET_ERROR_PARAMETER(error, TOX_ERR_NEW_OK);
  ------------------
  |  |   44|    615|    do {                              \
  |  |   45|    615|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|  1.23k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 615]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|    615|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1025|       |
 1026|    615|    tox_options_free(default_options);
 1027|    615|    return tox;
 1028|  3.15k|}
tox.c:tox_log_handler:
   86|  82.0k|{
   87|  82.0k|    Tox *tox = (Tox *)context;
   88|  82.0k|    assert(tox != nullptr);
   89|       |
   90|  82.0k|    if (tox->log_callback != nullptr) {
  ------------------
  |  |   63|  82.0k|#define nullptr NULL
  ------------------
  |  Branch (90:9): [True: 0, False: 82.0k]
  ------------------
   91|      0|        tox->log_callback(tox, (Tox_Log_Level)level, file, line, func, message, userdata);
   92|      0|    }
   93|  82.0k|}
tox.c:tox_load:
  700|  3.15k|{
  701|  3.15k|    uint32_t data32[2];
  702|  3.15k|    const uint32_t cookie_len = sizeof(data32);
  703|       |
  704|  3.15k|    if (length < cookie_len) {
  ------------------
  |  Branch (704:9): [True: 0, False: 3.15k]
  ------------------
  705|      0|        return -1;
  706|      0|    }
  707|       |
  708|  3.15k|    memcpy(data32, data, sizeof(uint32_t));
  709|  3.15k|    lendian_bytes_to_host32(data32 + 1, data + sizeof(uint32_t));
  710|       |
  711|  3.15k|    if (data32[0] != 0 || data32[1] != STATE_COOKIE_GLOBAL) {
  ------------------
  |  |   27|  3.15k|#define STATE_COOKIE_GLOBAL 0x15ed1b1f
  ------------------
  |  Branch (711:9): [True: 1, False: 3.15k]
  |  Branch (711:27): [True: 1, False: 3.14k]
  ------------------
  712|      2|        return -1;
  713|      2|    }
  714|       |
  715|  3.14k|    return state_load(tox->m->log, state_load_callback, tox, data + cookie_len,
  716|  3.14k|                      length - cookie_len, STATE_COOKIE_TYPE);
  ------------------
  |  |   29|  3.14k|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
  717|  3.15k|}
tox.c:state_load_callback:
  674|  33.7k|{
  675|  33.7k|    const Tox *tox = (const Tox *)outer;
  676|  33.7k|    State_Load_Status status = STATE_LOAD_STATUS_CONTINUE;
  677|       |
  678|  33.7k|    if (messenger_load_state_section(tox->m, data, length, type, &status)
  ------------------
  |  Branch (678:9): [True: 31.9k, False: 1.79k]
  ------------------
  679|  33.7k|            || conferences_load_state_section(tox->m->conferences_object, data, length, type, &status)) {
  ------------------
  |  Branch (679:16): [True: 408, False: 1.38k]
  ------------------
  680|  32.3k|        return status;
  681|  32.3k|    }
  682|       |
  683|  1.38k|    if (type == STATE_TYPE_END) {
  ------------------
  |  Branch (683:9): [True: 22, False: 1.36k]
  ------------------
  684|     22|        if (length != 0) {
  ------------------
  |  Branch (684:13): [True: 1, False: 21]
  ------------------
  685|      1|            return STATE_LOAD_STATUS_ERROR;
  686|      1|        }
  687|       |
  688|     21|        return STATE_LOAD_STATUS_END;
  689|     22|    }
  690|       |
  691|  1.36k|    LOGGER_ERROR(tox->m->log, "Load state: contains unrecognized part (len %u, type %u)",
  ------------------
  |  |   87|  1.36k|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|  1.36k|    do {                                                                         \
  |  |  |  |   77|  1.36k|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  2.72k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|  1.36k|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|  1.36k|        }                                                                        \
  |  |  |  |   80|  1.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  692|  1.36k|                 length, type);
  693|       |
  694|  1.36k|    return STATE_LOAD_STATUS_CONTINUE;
  695|  1.38k|}
tox.c:end_size:
 1083|  1.23k|{
 1084|  1.23k|    return 2 * sizeof(uint32_t);
 1085|  1.23k|}
tox.c:end_save:
 1089|    615|{
 1090|    615|    state_write_section_header(data, STATE_COOKIE_TYPE, 0, STATE_TYPE_END);
  ------------------
  |  |   29|    615|#define STATE_COOKIE_TYPE  0x01ce
  ------------------
 1091|    615|}

tox_options_get_ipv6_enabled:
   22|  3.15k|{
   23|  3.15k|    return options->ipv6_enabled;
   24|  3.15k|}
tox_options_set_ipv6_enabled:
   26|  3.15k|{
   27|  3.15k|    options->ipv6_enabled = ipv6_enabled;
   28|  3.15k|}
tox_options_get_udp_enabled:
   30|  3.15k|{
   31|  3.15k|    return options->udp_enabled;
   32|  3.15k|}
tox_options_set_udp_enabled:
   34|  3.15k|{
   35|  3.15k|    options->udp_enabled = udp_enabled;
   36|  3.15k|}
tox_options_get_proxy_type:
   38|  3.15k|{
   39|  3.15k|    return options->proxy_type;
   40|  3.15k|}
tox_options_set_proxy_type:
   42|  3.15k|{
   43|  3.15k|    options->proxy_type = proxy_type;
   44|  3.15k|}
tox_options_set_proxy_host:
   50|  6.30k|{
   51|  6.30k|    if (!options->experimental_owned_data) {
  ------------------
  |  Branch (51:9): [True: 6.30k, False: 0]
  ------------------
   52|  6.30k|        options->proxy_host = proxy_host;
   53|  6.30k|        return true;
   54|  6.30k|    }
   55|       |
   56|      0|    if (options->owned_proxy_host != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (56:9): [True: 0, False: 0]
  ------------------
   57|      0|        free(options->owned_proxy_host);
   58|      0|        options->owned_proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   59|      0|    }
   60|      0|    if (proxy_host == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (60:9): [True: 0, False: 0]
  ------------------
   61|      0|        options->proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   62|      0|        return true;
   63|      0|    }
   64|       |
   65|      0|    const size_t proxy_host_length = strlen(proxy_host) + 1;
   66|      0|    char *owned_ptr = (char *)malloc(proxy_host_length);
   67|      0|    if (owned_ptr == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (67:9): [True: 0, False: 0]
  ------------------
   68|      0|        options->proxy_host = proxy_host;
   69|      0|        options->owned_proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   70|      0|        return false;
   71|      0|    }
   72|       |
   73|      0|    memcpy(owned_ptr, proxy_host, proxy_host_length);
   74|      0|    options->proxy_host = owned_ptr;
   75|      0|    options->owned_proxy_host = owned_ptr;
   76|      0|    return true;
   77|      0|}
tox_options_get_start_port:
   87|  3.15k|{
   88|  3.15k|    return options->start_port;
   89|  3.15k|}
tox_options_get_end_port:
   95|  3.15k|{
   96|  3.15k|    return options->end_port;
   97|  3.15k|}
tox_options_get_tcp_port:
  103|  3.15k|{
  104|  3.15k|    return options->tcp_port;
  105|  3.15k|}
tox_options_get_hole_punching_enabled:
  111|  3.15k|{
  112|  3.15k|    return options->hole_punching_enabled;
  113|  3.15k|}
tox_options_set_hole_punching_enabled:
  115|  3.15k|{
  116|  3.15k|    options->hole_punching_enabled = hole_punching_enabled;
  117|  3.15k|}
tox_options_get_savedata_type:
  119|  9.45k|{
  120|  9.45k|    return options->savedata_type;
  121|  9.45k|}
tox_options_set_savedata_type:
  123|  3.15k|{
  124|  3.15k|    options->savedata_type = savedata_type;
  125|  3.15k|}
tox_options_get_savedata_length:
  127|  9.45k|{
  128|  9.45k|    return options->savedata_length;
  129|  9.45k|}
tox_options_get_log_callback:
  135|  3.15k|{
  136|  3.15k|    return options->log_callback;
  137|  3.15k|}
tox_options_get_log_user_data:
  143|  3.15k|{
  144|  3.15k|    return options->log_user_data;
  145|  3.15k|}
tox_options_get_local_discovery_enabled:
  151|  3.15k|{
  152|  3.15k|    return options->local_discovery_enabled;
  153|  3.15k|}
tox_options_set_local_discovery_enabled:
  155|  3.15k|{
  156|  3.15k|    options->local_discovery_enabled = local_discovery_enabled;
  157|  3.15k|}
tox_options_get_dht_announcements_enabled:
  159|  3.15k|{
  160|  3.15k|    return options->dht_announcements_enabled;
  161|  3.15k|}
tox_options_set_dht_announcements_enabled:
  163|  3.15k|{
  164|  3.15k|    options->dht_announcements_enabled = dht_announcements_enabled;
  165|  3.15k|}
tox_options_get_experimental_thread_safety:
  167|  3.15k|{
  168|  3.15k|    return options->experimental_thread_safety;
  169|  3.15k|}
tox_options_set_experimental_thread_safety:
  172|  3.15k|{
  173|  3.15k|    options->experimental_thread_safety = experimental_thread_safety;
  174|  3.15k|}
tox_options_get_experimental_groups_persistence:
  176|  3.15k|{
  177|  3.15k|    return options->experimental_groups_persistence;
  178|  3.15k|}
tox_options_set_experimental_groups_persistence:
  181|  6.30k|{
  182|  6.30k|    options->experimental_groups_persistence = experimental_groups_persistence;
  183|  6.30k|}
tox_options_get_experimental_disable_dns:
  185|  3.15k|{
  186|  3.15k|    return options->experimental_disable_dns;
  187|  3.15k|}
tox_options_set_experimental_disable_dns:
  189|  3.15k|{
  190|  3.15k|    options->experimental_disable_dns = experimental_disable_dns;
  191|  3.15k|}
tox_options_set_experimental_owned_data:
  198|  3.15k|{
  199|  3.15k|    options->experimental_owned_data = experimental_owned_data;
  200|  3.15k|}
tox_options_get_savedata_data:
  203|  9.45k|{
  204|  9.45k|    return options->savedata_data;
  205|  9.45k|}
tox_options_set_savedata_data:
  208|  9.45k|{
  209|  9.45k|    if (!options->experimental_owned_data) {
  ------------------
  |  Branch (209:9): [True: 9.45k, False: 0]
  ------------------
  210|  9.45k|        options->savedata_data = savedata_data;
  211|  9.45k|        options->savedata_length = length;
  212|  9.45k|        return true;
  213|  9.45k|    }
  214|       |
  215|      0|    if (options->owned_savedata_data != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (215:9): [True: 0, False: 0]
  ------------------
  216|      0|        free(options->owned_savedata_data);
  217|      0|        options->owned_savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  218|      0|    }
  219|      0|    if (savedata_data == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (219:9): [True: 0, False: 0]
  ------------------
  220|      0|        options->savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  221|      0|        options->savedata_length = 0;
  222|      0|        return true;
  223|      0|    }
  224|       |
  225|      0|    uint8_t *owned_ptr = (uint8_t *)malloc(length);
  226|      0|    if (owned_ptr == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (226:9): [True: 0, False: 0]
  ------------------
  227|      0|        options->savedata_data = savedata_data;
  228|      0|        options->savedata_length = length;
  229|      0|        options->owned_savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  230|      0|        return false;
  231|      0|    }
  232|       |
  233|      0|    memcpy(owned_ptr, savedata_data, length);
  234|      0|    options->savedata_data = owned_ptr;
  235|      0|    options->savedata_length = length;
  236|      0|    options->owned_savedata_data = owned_ptr;
  237|      0|    return true;
  238|      0|}
tox_options_default:
  241|  3.15k|{
  242|  3.15k|    if (options != nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (242:9): [True: 3.15k, False: 0]
  ------------------
  243|       |        // Free any owned data.
  244|  3.15k|        tox_options_set_proxy_host(options, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  245|  3.15k|        tox_options_set_savedata_data(options, nullptr, 0);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  246|       |
  247|       |        // Set the rest to default values.
  248|  3.15k|        const Tox_Options default_options = {false};
  249|  3.15k|        *options = default_options;
  250|  3.15k|        tox_options_set_ipv6_enabled(options, true);
  251|  3.15k|        tox_options_set_udp_enabled(options, true);
  252|  3.15k|        tox_options_set_proxy_type(options, TOX_PROXY_TYPE_NONE);
  253|  3.15k|        tox_options_set_hole_punching_enabled(options, true);
  254|  3.15k|        tox_options_set_local_discovery_enabled(options, true);
  255|  3.15k|        tox_options_set_dht_announcements_enabled(options, true);
  256|  3.15k|        tox_options_set_experimental_thread_safety(options, false);
  257|  3.15k|        tox_options_set_experimental_groups_persistence(options, false);
  258|  3.15k|        tox_options_set_experimental_disable_dns(options, false);
  259|  3.15k|        tox_options_set_experimental_owned_data(options, false);
  260|  3.15k|    }
  261|  3.15k|}
tox_options_new:
  264|  3.15k|{
  265|  3.15k|    Tox_Options *options = (Tox_Options *)calloc(1, sizeof(Tox_Options));
  266|       |
  267|  3.15k|    if (options != nullptr) {
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  |  Branch (267:9): [True: 3.15k, False: 0]
  ------------------
  268|  3.15k|        tox_options_default(options);
  269|  3.15k|        SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_OK);
  ------------------
  |  |   14|  3.15k|    do {                              \
  |  |   15|  3.15k|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|  6.30k|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (15:13): [True: 3.15k, False: 0]
  |  |  ------------------
  |  |   16|  3.15k|            *param = x;               \
  |  |   17|  3.15k|        }                             \
  |  |   18|  3.15k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (18:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  270|  3.15k|        return options;
  271|  3.15k|    }
  272|       |
  273|      0|    SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_MALLOC);
  ------------------
  |  |   14|      0|    do {                              \
  |  |   15|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (15:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   16|      0|            *param = x;               \
  |  |   17|      0|        }                             \
  |  |   18|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (18:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  274|      0|    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  275|  3.15k|}
tox_options_free:
  278|  6.30k|{
  279|  6.30k|    if (options != nullptr) {
  ------------------
  |  |   63|  6.30k|#define nullptr NULL
  ------------------
  |  Branch (279:9): [True: 3.15k, False: 3.15k]
  ------------------
  280|       |        // Free any owned data.
  281|  3.15k|        tox_options_set_proxy_host(options, nullptr);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  282|  3.15k|        tox_options_set_savedata_data(options, nullptr, 0);
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
  283|  3.15k|        free(options);
  284|  3.15k|    }
  285|  6.30k|}

tox_default_system:
   36|  3.15k|{
   37|  3.15k|    const Tox_System sys = {
   38|  3.15k|        nullptr,  // mono_time_callback
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
   39|  3.15k|        nullptr,  // mono_time_user_data
  ------------------
  |  |   63|  3.15k|#define nullptr NULL
  ------------------
   40|  3.15k|        os_random(),
   41|  3.15k|        os_network(),
   42|  3.15k|        os_memory(),
   43|  3.15k|    };
   44|  3.15k|    return sys;
   45|  3.15k|}
tox_lock:
   48|  5.61k|{
   49|  5.61k|    if (tox->mutex != nullptr) {
  ------------------
  |  |   63|  5.61k|#define nullptr NULL
  ------------------
  |  Branch (49:9): [True: 0, False: 5.61k]
  ------------------
   50|      0|        pthread_mutex_lock(tox->mutex);
   51|      0|    }
   52|  5.61k|}
tox_unlock:
   55|  5.61k|{
   56|  5.61k|    if (tox->mutex != nullptr) {
  ------------------
  |  |   63|  5.61k|#define nullptr NULL
  ------------------
  |  Branch (56:9): [True: 0, False: 5.61k]
  ------------------
   57|      0|        pthread_mutex_unlock(tox->mutex);
   58|      0|    }
   59|  5.61k|}

free_uint8_t_pointer_array:
   27|  1.28k|{
   28|  1.28k|    if (ary == nullptr) {
  ------------------
  |  |   63|  1.28k|#define nullptr NULL
  ------------------
  |  Branch (28:9): [True: 1.19k, False: 99]
  ------------------
   29|  1.19k|        return;
   30|  1.19k|    }
   31|       |
   32|  1.68k|    for (size_t i = 0; i < n_items; ++i) {
  ------------------
  |  Branch (32:24): [True: 1.58k, False: 99]
  ------------------
   33|  1.58k|        if (ary[i] != nullptr) {
  ------------------
  |  |   63|  1.58k|#define nullptr NULL
  ------------------
  |  Branch (33:13): [True: 1.58k, False: 0]
  ------------------
   34|  1.58k|            mem_delete(mem, ary[i]);
   35|  1.58k|        }
   36|  1.58k|    }
   37|       |
   38|     99|    mem_delete(mem, ary);
   39|     99|}
data_checksum:
   42|    241|{
   43|    241|    uint8_t checksum[2] = {0};
   44|    241|    uint16_t check;
   45|       |
   46|  8.91k|    for (uint32_t i = 0; i < length; ++i) {
  ------------------
  |  Branch (46:26): [True: 8.67k, False: 241]
  ------------------
   47|  8.67k|        checksum[i % 2] ^= data[i];
   48|  8.67k|    }
   49|       |
   50|    241|    memcpy(&check, checksum, sizeof(check));
   51|    241|    return check;
   52|    241|}
memeq:
   79|  4.30k|{
   80|  4.30k|    return a_size == b_size && memcmp(a, b, a_size) == 0;
  ------------------
  |  Branch (80:12): [True: 3.73k, False: 563]
  |  Branch (80:32): [True: 3.73k, False: 0]
  ------------------
   81|  4.30k|}
memzero:
   99|  70.3k|{
  100|  70.3k|    if (data == nullptr || data_size == 0) {
  ------------------
  |  |   63|   140k|#define nullptr NULL
  ------------------
  |  Branch (100:9): [True: 0, False: 70.3k]
  |  Branch (100:28): [True: 0, False: 70.3k]
  ------------------
  101|      0|        return;
  102|      0|    }
  103|       |
  104|  70.3k|    memset(data, 0, data_size);
  105|  70.3k|}
min_u16:
  151|    691|{
  152|    691|    return a < b ? a : b;
  ------------------
  |  Branch (152:12): [True: 691, False: 0]
  ------------------
  153|    691|}
min_u32:
  155|     52|{
  156|     52|    return a < b ? a : b;
  ------------------
  |  Branch (156:12): [True: 26, False: 26]
  ------------------
  157|     52|}
jenkins_one_at_a_time_hash:
  169|     70|{
  170|     70|    uint32_t hash = 0;
  171|       |
  172|  2.31k|    for (uint32_t i = 0; i < len; ++i) {
  ------------------
  |  Branch (172:26): [True: 2.24k, False: 70]
  ------------------
  173|  2.24k|        hash += key[i];
  174|  2.24k|        hash += (uint32_t)((uint64_t)hash << 10);
  175|  2.24k|        hash ^= hash >> 6;
  176|  2.24k|    }
  177|       |
  178|     70|    hash += (uint32_t)((uint64_t)hash << 3);
  179|     70|    hash ^= hash >> 11;
  180|     70|    hash += (uint32_t)((uint64_t)hash << 15);
  181|     70|    return hash;
  182|     70|}

