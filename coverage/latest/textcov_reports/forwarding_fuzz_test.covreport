fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Fuzz_SystemjjEXadL_ZN3$_18__invokeES3_jjEEEcvPFT_T0_DpT1_EIS1_S1_JjjEEEvENKUlS1_DpT_E_clIJjjEEEDaS1_SG_:
   31|    603|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Fuzz_SystemjjEXadL_ZN3$_18__invokeES3_jjEEE13static_casterIS1_EcvT_IS3_EEv:
   22|    603|        {
   23|    603|            return static_cast<To>(obj);
   24|    603|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Fuzz_SystemPvEXadL_ZN3$_38__invokeES2_S3_EEEcvPFT_T0_DpT1_EIvS3_JS3_EEEvENKUlS3_DpT_E_clIJS3_EEEDaS3_SG_:
   31|    598|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Fuzz_SystemPvEXadL_ZN3$_38__invokeES2_S3_EEE13static_casterIS3_EcvT_IS2_EEv:
   22|    598|        {
   23|    598|            return static_cast<To>(obj);
   24|    598|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketEXadL_ZN3$_48__invokeES2_S3_EEEcvPFT_T0_DpT1_EIiPvJS3_EEEvENKUlSF_DpT_E_clIJS3_EEEDaSF_SH_:
   31|    198|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketEXadL_ZN3$_48__invokeES2_S3_EEE13static_casterIPvEcvT_IS2_EEv:
   22|    198|        {
   23|    198|            return static_cast<To>(obj);
   24|    198|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketPK12Network_AddrEXadL_ZN3$_68__invokeES2_S3_S6_EEEcvPFT_T0_DpT1_EIiPvJS3_S6_EEEvENKUlSI_DpT_E_clIJS3_S6_EEEDaSI_SK_:
   31|    198|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketPK12Network_AddrEXadL_ZN3$_68__invokeES2_S3_S6_EEE13static_casterIPvEcvT_IS2_EEv:
   22|    198|        {
   23|    198|            return static_cast<To>(obj);
   24|    198|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketPKhmPK12Network_AddrEXadL_ZN4$_138__invokeES2_S3_S5_mS8_EEEcvPFT_T0_DpT1_EIiPvJS3_S5_mS8_EEEvENKUlSK_DpT_E_clIJS3_S5_mS8_EEEDaSK_SM_:
   31|    164|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketPKhmPK12Network_AddrEXadL_ZN4$_138__invokeES2_S3_S5_mS8_EEE13static_casterIPvEcvT_IS2_EEv:
   22|    164|        {
   23|    164|            return static_cast<To>(obj);
   24|    164|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPF6SocketP11Fuzz_SystemiiiEXadL_ZN4$_148__invokeES3_iiiEEEcvPFT_T0_DpT1_EIS1_PvJiiiEEEvENKUlSF_DpT_E_clIJiiiEEEDaSF_SH_:
   31|    198|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPF6SocketP11Fuzz_SystemiiiEXadL_ZN4$_148__invokeES3_iiiEEE13static_casterIPvEcvT_IS3_EEv:
   22|    198|        {
   23|    198|            return static_cast<To>(obj);
   24|    198|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketbEXadL_ZN4$_158__invokeES2_S3_bEEEcvPFT_T0_DpT1_EIiPvJS3_bEEEvENKUlSF_DpT_E_clIJS3_bEEEDaSF_SH_:
   31|    198|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketbEXadL_ZN4$_158__invokeES2_S3_bEEE13static_casterIPvEcvT_IS2_EEv:
   22|    198|        {
   23|    198|            return static_cast<To>(obj);
   24|    198|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketiiPKvmEXadL_ZN4$_178__invokeES2_S3_iiS5_mEEEcvPFT_T0_DpT1_EIiPvJS3_iiS5_mEEEvENKUlSH_DpT_E_clIJS3_iiS5_mEEEDaSH_SJ_:
   31|    594|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketiiPKvmEXadL_ZN4$_178__invokeES2_S3_iiS5_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|    594|        {
   23|    594|            return static_cast<To>(obj);
   24|    594|        }

_ZN6SystemC2ENSt3__110unique_ptrI10Tox_SystemNS0_14default_deleteIS2_EEEENS1_I6MemoryNS3_IS6_EEEENS1_I7NetworkNS3_IS9_EEEENS1_I6RandomNS3_ISC_EEEE:
   38|    204|    : sys(std::move(in_sys))
   39|    204|    , mem(std::move(in_mem))
   40|    204|    , ns(std::move(in_ns))
   41|    204|    , rng(std::move(in_rng))
   42|    204|{
   43|    204|}
_ZN6SystemD2Ev:
   46|    204|System::~System() { }
_ZN11Fuzz_SystemC2ER9Fuzz_Data:
  232|    204|    : System{
  233|    204|        std::make_unique<Tox_System>(),
  234|    204|        std::make_unique<Memory>(Memory{&fuzz_memory_funcs, this}),
  235|    204|        std::make_unique<Network>(Network{&fuzz_network_funcs, this}),
  236|    204|        std::make_unique<Random>(Random{&fuzz_random_funcs, this}),
  237|    204|    }
  238|    204|    , data(input)
  239|    204|{
  240|    204|    sys->mono_time_callback = [](void *self) { return static_cast<Fuzz_System *>(self)->clock; };
  241|    204|    sys->mono_time_user_data = this;
  242|    204|    sys->mem = mem.get();
  243|    204|    sys->ns = ns.get();
  244|    204|    sys->rng = rng.get();
  245|    204|}
fuzz_support.cc:_ZL12report_allocPKcS0_mPv:
   79|    599|{
   80|    599|    if (Fuzz_Data::FUZZ_DEBUG) {
  ------------------
  |  Branch (80:9): [Folded - Ignored]
  ------------------
   81|      0|        printf("%s: %s(%zu): %s\n", name, func, size, ptr == nullptr ? "false" : "true");
  ------------------
  |  Branch (81:55): [True: 0, False: 0]
  ------------------
   82|      0|    }
   83|    599|    return ptr;
   84|    599|}
fuzz_support.cc:_ZNK3$_1clEP11Fuzz_Systemjj:
  103|    603|    ![](Fuzz_System *self, uint32_t nmemb, uint32_t size) {
  104|    603|        return alloc_common<decltype(std::calloc), std::calloc>(
  105|    603|            "calloc", nmemb * size, self->data, nmemb, size);
  106|    603|    },
fuzz_support.cc:_ZL12alloc_commonIDoFPvmmETnT_XadL_Z6callocEEJjjEES0_PKcmR9Fuzz_DataDpT1_:
   88|    603|{
   89|    603|    CONSUME1_OR_RETURN_VAL(
  ------------------
  |  |  122|    603|    if (INPUT.size() < sizeof(TYPE)) {                 \
  |  |  ------------------
  |  |  |  Branch (122:9): [True: 315, False: 288]
  |  |  ------------------
  |  |  123|    315|        return VAL;                                    \
  |  |  124|    315|    }                                                  \
  |  |  125|    603|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
   90|    288|        const bool, want_alloc, data, report_alloc("tox1", func, size, Func(args...)));
   91|    288|    if (!want_alloc) {
  ------------------
  |  Branch (91:9): [True: 4, False: 284]
  ------------------
   92|      4|        return nullptr;
   93|      4|    }
   94|    284|    return report_alloc("tox1", func, size, Func(args...));
   95|    288|}
fuzz_support.cc:_ZNK3$_3clEP11Fuzz_SystemPv:
  113|    598|    ![](Fuzz_System *self, void *ptr) { std::free(ptr); },
fuzz_support.cc:_ZNK3$_4clEP11Fuzz_System6Socket:
  117|    198|    /* .close = */ ![](Fuzz_System *self, Socket sock) { return 0; },
fuzz_support.cc:_ZNK3$_6clEP11Fuzz_System6SocketPK12Network_Addr:
  119|    198|    /* .bind = */ ![](Fuzz_System *self, Socket sock, const Network_Addr *addr) { return 0; },
fuzz_support.cc:_ZNK4$_13clEP11Fuzz_System6SocketPKhmPK12Network_Addr:
  157|    164|    ![](Fuzz_System *self, Socket sock, const uint8_t *buf, size_t len, const Network_Addr *addr) {
  158|    164|        assert(sock.value == 42 || sock.value == 1337);
  159|       |        // Always succeed.
  160|    164|        return static_cast<int>(len);
  161|    164|    },
fuzz_support.cc:_ZNK4$_14clEP11Fuzz_Systemiii:
  162|    198|    /* .socket = */ ![](Fuzz_System *self, int domain, int type, int proto) { return Socket{42}; },
fuzz_support.cc:_ZNK4$_15clEP11Fuzz_System6Socketb:
  163|    198|    /* .socket_nonblock = */ ![](Fuzz_System *self, Socket sock, bool nonblock) { return 0; },
fuzz_support.cc:_ZNK4$_17clEP11Fuzz_System6SocketiiPKvm:
  170|    594|    ![](Fuzz_System *self, Socket sock, int level, int optname, const void *optval, size_t optlen) {
  171|    594|        return 0;
  172|    594|    },

_ZNK9Fuzz_Data4sizeEv:
   69|  2.12k|    std::size_t size() const { return size_; }
_ZN9Fuzz_Data8consume1EPKc:
   68|    733|    Consumer consume1(const char *func) { return Consumer{func, *this}; }
_ZN9Fuzz_Data8ConsumercvT_ItEEv:
   60|    221|        {
   61|    221|            const uint8_t *bytes = fd.consume(func, sizeof(T));
   62|    221|            T val;
   63|    221|            std::memcpy(&val, bytes, sizeof(T));
   64|    221|            return val;
   65|    221|        }
_ZN9Fuzz_Data7consumeEPKcm:
   75|  1.50k|    {
   76|  1.50k|        const uint8_t *val = data_;
   77|  1.50k|        if (FUZZ_DEBUG) {
  ------------------
  |  Branch (77:13): [Folded - Ignored]
  ------------------
   78|      0|            if (pos() == TRACE_TRAP) {
  ------------------
  |  Branch (78:17): [True: 0, False: 0]
  ------------------
   79|      0|                __asm__("int $3");
   80|      0|            }
   81|      0|            if (count == 1) {
  ------------------
  |  Branch (81:17): [True: 0, False: 0]
  ------------------
   82|      0|                std::printf("consume@%zu(%s): %d (0x%02x)\n", pos(), func, val[0], val[0]);
   83|      0|            } else if (count != 0) {
  ------------------
  |  Branch (83:24): [True: 0, False: 0]
  ------------------
   84|      0|                std::printf("consume@%zu(%s): %02x..%02x[%zu]\n", pos(), func, val[0],
   85|      0|                    val[count - 1], count);
   86|      0|            }
   87|      0|        }
   88|  1.50k|        data_ += count;
   89|  1.50k|        size_ -= count;
   90|  1.50k|        return val;
   91|  1.50k|    }
forwarding_fuzz_test.cc:_Z18fuzz_select_targetIJXadL_ZN12_GLOBAL__N_122TestSendForwardRequestER9Fuzz_DataEEXadL_ZNS0_16TestForwardReplyES2_EEEEvPKhm:
  183|    224|{
  184|    224|    Fuzz_Data input{data, size};
  185|       |
  186|    224|    CONSUME1_OR_RETURN(const uint8_t, selector, input);
  ------------------
  |  |  105|    224|    if (INPUT.size() < sizeof(TYPE)) {        \
  |  |  ------------------
  |  |  |  Branch (105:9): [True: 0, False: 224]
  |  |  ------------------
  |  |  106|      0|        return;                               \
  |  |  107|      0|    }                                         \
  |  |  108|    224|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
  187|    224|    return Fuzz_Target_Selector<Args...>::select(selector, input);
  188|    224|}
_ZN9Fuzz_DataC2EPKhm:
   32|    224|        : data_(input_data)
   33|    224|        , base_(input_data)
   34|    224|        , size_(input_size)
   35|    224|    {
   36|    224|    }
_ZN9Fuzz_Data8ConsumercvT_IhEEv:
   60|    224|        {
   61|    224|            const uint8_t *bytes = fd.consume(func, sizeof(T));
   62|    224|            T val;
   63|    224|            std::memcpy(&val, bytes, sizeof(T));
   64|    224|            return val;
   65|    224|        }
forwarding_fuzz_test.cc:_ZN20Fuzz_Target_SelectorIJXadL_ZN12_GLOBAL__N_122TestSendForwardRequestER9Fuzz_DataEEXadL_ZNS0_16TestForwardReplyES2_EEEE6selectEhS2_:
  164|    224|    {
  165|    224|        if (selector == sizeof...(Args)) {
  ------------------
  |  Branch (165:13): [True: 56, False: 168]
  ------------------
  166|     56|            return Arg(input);
  167|     56|        }
  168|    168|        return Fuzz_Target_Selector<Args...>::select(selector, input);
  169|    224|    }
forwarding_fuzz_test.cc:_ZN20Fuzz_Target_SelectorIJXadL_ZN12_GLOBAL__N_116TestForwardReplyER9Fuzz_DataEEEE6selectEhS2_:
  164|    168|    {
  165|    168|        if (selector == sizeof...(Args)) {
  ------------------
  |  Branch (165:13): [True: 167, False: 1]
  ------------------
  166|    167|            return Arg(input);
  167|    167|        }
  168|      1|        return Fuzz_Target_Selector<Args...>::select(selector, input);
  169|    168|    }
_ZN20Fuzz_Target_SelectorIJEE6selectEhR9Fuzz_Data:
  175|      1|    {
  176|       |        // The selector selected no function, so we do nothing and rely on the
  177|       |        // fuzzer to come up with a better selector.
  178|      1|    }
_ZN9Fuzz_Data8ConsumercvbEv:
   46|    288|        {
   47|       |            // Special case because memcpy causes UB for bool (which can't be
   48|       |            // anything other than 0 or 1).
   49|    288|            const bool val = fd.data_[0];
   50|    288|            if (FUZZ_DEBUG) {
  ------------------
  |  Branch (50:17): [Folded - Ignored]
  ------------------
   51|      0|                std::printf("consume@%zu(%s): bool %s\n", fd.pos(), func, val ? "true" : "false");
  ------------------
  |  Branch (51:75): [True: 0, False: 0]
  ------------------
   52|      0|            }
   53|    288|            ++fd.data_;
   54|    288|            --fd.size_;
   55|    288|            return val;
   56|    288|        }

send_forward_request:
   50|     48|{
   51|     48|    if (chain_length == 0 || chain_length > MAX_FORWARD_CHAIN_LENGTH
  ------------------
  |  |   27|     95|#define MAX_FORWARD_CHAIN_LENGTH 4
  ------------------
  |  Branch (51:9): [True: 1, False: 47]
  |  Branch (51:30): [True: 1, False: 46]
  ------------------
   52|     48|            || data_length > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   25|     46|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |  111|     46|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   24|     46|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (52:16): [True: 1, False: 45]
  ------------------
   53|      3|        return false;
   54|      3|    }
   55|       |
   56|     45|    const uint16_t len = forward_chain_packet_size(chain_length, data_length);
   57|     45|    VLA(uint8_t, packet, len);
  ------------------
  |  |   59|     45|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     45|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
   58|       |
   59|     45|    return create_forward_chain_packet(chain_keys, chain_length, data, data_length, packet)
  ------------------
  |  Branch (59:12): [True: 45, False: 0]
  ------------------
   60|     45|           && sendpacket(net, forwarder, packet, len) == len;
  ------------------
  |  Branch (60:15): [True: 36, False: 9]
  ------------------
   61|     48|}
forward_chain_packet_size:
   64|     45|{
   65|     45|    return chain_length * (1 + CRYPTO_PUBLIC_KEY_SIZE) + data_length;
  ------------------
  |  |   43|     45|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   66|     45|}
create_forward_chain_packet:
   71|     45|{
   72|     45|    if (chain_length == 0 || chain_length > MAX_FORWARD_CHAIN_LENGTH
  ------------------
  |  |   27|     90|#define MAX_FORWARD_CHAIN_LENGTH 4
  ------------------
  |  Branch (72:9): [True: 0, False: 45]
  |  Branch (72:30): [True: 0, False: 45]
  ------------------
   73|     45|            || data_length > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   25|     45|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |  111|     45|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   24|     45|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (73:16): [True: 0, False: 45]
  ------------------
   74|      0|        return false;
   75|      0|    }
   76|       |
   77|     45|    uint16_t offset = 0;
   78|       |
   79|    104|    for (uint16_t j = 0; j < chain_length; ++j) {
  ------------------
  |  Branch (79:26): [True: 59, False: 45]
  ------------------
   80|     59|        packet[offset] = NET_PACKET_FORWARD_REQUEST;
   81|     59|        ++offset;
   82|     59|        memcpy(packet + offset, chain_keys + j * CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|     59|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                      memcpy(packet + offset, chain_keys + j * CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|     59|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   83|     59|        offset += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   43|     59|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   84|     59|    }
   85|       |
   86|     45|    memcpy(packet + offset, data, data_length);
   87|     45|    return true;
   88|     45|}
forward_reply:
  328|    150|{
  329|    150|    if (sendback_length > MAX_SENDBACK_SIZE ||
  ------------------
  |  |   24|    300|#define MAX_SENDBACK_SIZE (0xff - 1)
  ------------------
  |  Branch (329:9): [True: 11, False: 139]
  ------------------
  330|    150|            length > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   25|    139|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |  111|    139|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   24|    139|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (330:13): [True: 1, False: 138]
  ------------------
  331|     12|        return false;
  332|     12|    }
  333|       |
  334|    138|    const uint16_t len = 1 + 1 + sendback_length + length;
  335|    138|    VLA(uint8_t, packet, len);
  ------------------
  |  |   59|    138|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|    138|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  336|    138|    packet[0] = NET_PACKET_FORWARD_REPLY;
  337|    138|    packet[1] = (uint8_t) sendback_length;
  338|    138|    memcpy(packet + 1 + 1, sendback, sendback_length);
  339|    138|    memcpy(packet + 1 + 1 + sendback_length, data, length);
  340|    138|    return sendpacket(net, forwarder, packet, len) == len;
  341|    150|}

LLVMFuzzerTestOneInput:
   97|    224|{
   98|    224|    fuzz_select_target<TestSendForwardRequest, TestForwardReply>(data, size);
   99|    224|    return 0;
  100|    224|}
forwarding_fuzz_test.cc:_ZN12_GLOBAL__N_122TestSendForwardRequestER9Fuzz_Data:
   35|     56|{
   36|     56|    CONSUME1_OR_RETURN(const uint16_t, chain_length, input);
  ------------------
  |  |  105|     56|    if (INPUT.size() < sizeof(TYPE)) {        \
  |  |  ------------------
  |  |  |  Branch (105:9): [True: 1, False: 55]
  |  |  ------------------
  |  |  106|      1|        return;                               \
  |  |  107|      1|    }                                         \
  |  |  108|     56|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
   37|     55|    const uint16_t chain_keys_size = chain_length * CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   43|     55|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   38|     55|    CONSUME_OR_RETURN(const uint8_t *chain_keys, input, chain_keys_size);
  ------------------
  |  |  139|     55|    if (INPUT.size() < SIZE) {               \
  |  |  ------------------
  |  |  |  Branch (139:9): [True: 1, False: 54]
  |  |  ------------------
  |  |  140|      1|        return;                              \
  |  |  141|      1|    }                                        \
  |  |  142|     55|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   39|       |
   40|     54|    const auto prep = prepare(input);
   41|     54|    if (!prep.has_value()) {
  ------------------
  |  Branch (41:9): [True: 4, False: 50]
  ------------------
   42|      4|        return;
   43|      4|    }
   44|     50|    const auto [ipp, forwarder, data, data_size] = prep.value();
   45|       |
   46|       |    // rest of the fuzz data is input for malloc and network
   47|     50|    Fuzz_System sys(input);
   48|       |
   49|     50|    const Ptr<Logger> logger(logger_new(sys.mem.get()), logger_kill);
   50|     50|    if (logger == nullptr) {
  ------------------
  |  Branch (50:9): [True: 1, False: 49]
  ------------------
   51|      1|        return;
   52|      1|    }
   53|       |
   54|     49|    const Ptr<Networking_Core> net(new_networking_ex(logger.get(), sys.mem.get(), sys.ns.get(),
   55|     49|                                       &ipp.ip, ipp.port, ipp.port + 100, nullptr),
   56|     49|        kill_networking);
   57|     49|    if (net == nullptr) {
  ------------------
  |  Branch (57:9): [True: 1, False: 48]
  ------------------
   58|      1|        return;
   59|      1|    }
   60|       |
   61|     48|    send_forward_request(net.get(), &forwarder, chain_keys, chain_length, data, data_size);
   62|     48|}
forwarding_fuzz_test.cc:_ZN12_GLOBAL__N_17prepareER9Fuzz_Data:
   14|    219|{
   15|    219|    CONSUME_OR_RETURN_VAL(const uint8_t *ipp_packed, input, SIZE_IP_PORT, std::nullopt);
  ------------------
  |  |  145|    219|    if (INPUT.size() < SIZE) {                        \
  |  |  ------------------
  |  |  |  Branch (145:9): [True: 2, False: 217]
  |  |  ------------------
  |  |  146|      2|        return VAL;                                   \
  |  |  147|      2|    }                                                 \
  |  |  148|    219|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   16|    217|    IP_Port ipp{};
   17|    217|    unpack_ip_port(&ipp, ipp_packed, SIZE_IP6, true);
  ------------------
  |  |  186|    217|#define SIZE_IP6 16
  ------------------
   18|       |
   19|    217|    CONSUME_OR_RETURN_VAL(const uint8_t *forwarder_packed, input, SIZE_IP_PORT, std::nullopt);
  ------------------
  |  |  145|    217|    if (INPUT.size() < SIZE) {                        \
  |  |  ------------------
  |  |  |  Branch (145:9): [True: 5, False: 212]
  |  |  ------------------
  |  |  146|      5|        return VAL;                                   \
  |  |  147|      5|    }                                                 \
  |  |  148|    217|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   20|    212|    IP_Port forwarder{};
   21|    212|    unpack_ip_port(&forwarder, forwarder_packed, SIZE_IP6, true);
  ------------------
  |  |  186|    212|#define SIZE_IP6 16
  ------------------
   22|       |
   23|       |    // 2 bytes: size of the request
   24|    212|    CONSUME_OR_RETURN_VAL(const uint8_t *data_size_bytes, input, sizeof(uint16_t), std::nullopt);
  ------------------
  |  |  145|    212|    if (INPUT.size() < SIZE) {                        \
  |  |  ------------------
  |  |  |  Branch (145:9): [True: 6, False: 206]
  |  |  ------------------
  |  |  146|      6|        return VAL;                                   \
  |  |  147|      6|    }                                                 \
  |  |  148|    212|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   25|    206|    uint16_t data_size;
   26|    206|    std::memcpy(&data_size, data_size_bytes, sizeof(uint16_t));
   27|       |
   28|       |    // data bytes (max 64K)
   29|    206|    CONSUME_OR_RETURN_VAL(const uint8_t *data, input, data_size, std::nullopt);
  ------------------
  |  |  145|    206|    if (INPUT.size() < SIZE) {                        \
  |  |  ------------------
  |  |  |  Branch (145:9): [True: 2, False: 204]
  |  |  ------------------
  |  |  146|      2|        return VAL;                                   \
  |  |  147|      2|    }                                                 \
  |  |  148|    206|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   30|       |
   31|    204|    return {{ipp, forwarder, data, data_size}};
   32|    206|}
forwarding_fuzz_test.cc:_ZN12_GLOBAL__N_116TestForwardReplyER9Fuzz_Data:
   65|    167|{
   66|    167|    CONSUME1_OR_RETURN(const uint16_t, sendback_length, input);
  ------------------
  |  |  105|    167|    if (INPUT.size() < sizeof(TYPE)) {        \
  |  |  ------------------
  |  |  |  Branch (105:9): [True: 1, False: 166]
  |  |  ------------------
  |  |  106|      1|        return;                               \
  |  |  107|      1|    }                                         \
  |  |  108|    167|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
   67|    166|    CONSUME_OR_RETURN(const uint8_t *sendback, input, sendback_length);
  ------------------
  |  |  139|    166|    if (INPUT.size() < SIZE) {               \
  |  |  ------------------
  |  |  |  Branch (139:9): [True: 1, False: 165]
  |  |  ------------------
  |  |  140|      1|        return;                              \
  |  |  141|      1|    }                                        \
  |  |  142|    166|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   68|       |
   69|    165|    const auto prep = prepare(input);
   70|    165|    if (!prep.has_value()) {
  ------------------
  |  Branch (70:9): [True: 11, False: 154]
  ------------------
   71|     11|        return;
   72|     11|    }
   73|    154|    const auto [ipp, forwarder, data, data_size] = prep.value();
   74|       |
   75|       |    // rest of the fuzz data is input for malloc and network
   76|    154|    Fuzz_System sys(input);
   77|       |
   78|    154|    const Ptr<Logger> logger(logger_new(sys.mem.get()), logger_kill);
   79|    154|    if (logger == nullptr) {
  ------------------
  |  Branch (79:9): [True: 1, False: 153]
  ------------------
   80|      1|        return;
   81|      1|    }
   82|       |
   83|    153|    const Ptr<Networking_Core> net(new_networking_ex(logger.get(), sys.mem.get(), sys.ns.get(),
   84|    153|                                       &ipp.ip, ipp.port, ipp.port + 100, nullptr),
   85|    153|        kill_networking);
   86|    153|    if (net == nullptr) {
  ------------------
  |  Branch (86:9): [True: 3, False: 150]
  ------------------
   87|      3|        return;
   88|      3|    }
   89|       |
   90|    150|    forward_reply(net.get(), &forwarder, sendback, sendback_length, data, data_size);
   91|    150|}

logger_new:
   33|    204|{
   34|    204|    Logger *log = (Logger *)mem_alloc(mem, sizeof(Logger));
   35|       |
   36|    204|    if (log == nullptr) {
  ------------------
  |  |   63|    204|#define nullptr NULL
  ------------------
  |  Branch (36:9): [True: 2, False: 202]
  ------------------
   37|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
   38|      2|    }
   39|       |
   40|    202|    log->mem = mem;
   41|       |
   42|    202|    return log;
   43|    204|}
logger_kill:
   46|    202|{
   47|    202|    if (log == nullptr) {
  ------------------
  |  |   63|    202|#define nullptr NULL
  ------------------
  |  Branch (47:9): [True: 0, False: 202]
  ------------------
   48|      0|        return;
   49|      0|    }
   50|       |
   51|    202|    mem_delete(log->mem, log);
   52|    202|}
logger_write:
   64|      6|{
   65|      6|    if (log == nullptr) {
  ------------------
  |  |   63|      6|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 0, False: 6]
  ------------------
   66|      0|        return;
   67|      0|    }
   68|       |
   69|      6|    if (log->callback == nullptr) {
  ------------------
  |  |   63|      6|#define nullptr NULL
  ------------------
  |  Branch (69:9): [True: 6, False: 0]
  ------------------
   70|      6|        return;
   71|      6|    }
   72|       |
   73|       |    // Only pass the file name, not the entire file path, for privacy reasons.
   74|       |    // The full path may contain PII of the person compiling toxcore (their
   75|       |    // username and directory layout).
   76|      0|    const char *filename = strrchr(file, '/');
   77|      0|    file = filename != nullptr ? filename + 1 : file;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (77:12): [True: 0, False: 0]
  ------------------
   78|       |#if defined(_WIN32) || defined(__CYGWIN__)
   79|       |    // On Windows, the path separator *may* be a backslash, so we look for that
   80|       |    // one too.
   81|       |    const char *windows_filename = strrchr(file, '\\');
   82|       |    file = windows_filename != nullptr ? windows_filename + 1 : file;
   83|       |#endif /* WIN32 */
   84|       |
   85|       |    // Format message
   86|      0|    char msg[1024];
   87|      0|    va_list args;
   88|      0|    va_start(args, format);
   89|      0|    vsnprintf(msg, sizeof(msg), format, args);
   90|      0|    va_end(args);
   91|       |
   92|      0|    log->callback(log->context, level, file, line, func, msg, log->userdata);
   93|      0|}

mem_alloc:
   63|    603|{
   64|    603|    void *const ptr = mem->funcs->calloc(mem->obj, 1, size);
   65|    603|    return ptr;
   66|    603|}
mem_delete:
   93|    598|{
   94|    598|    mem->funcs->free(mem->obj, ptr);
   95|    598|}

netprof_record_packet:
   74|    164|{
   75|    164|    if (profile == nullptr) {
  ------------------
  |  |   63|    164|#define nullptr NULL
  ------------------
  |  Branch (75:9): [True: 0, False: 164]
  ------------------
   76|      0|        return;
   77|      0|    }
   78|       |
   79|    164|    if (dir == PACKET_DIRECTION_SEND) {
  ------------------
  |  Branch (79:9): [True: 164, False: 0]
  ------------------
   80|    164|        ++profile->total_packets_sent;
   81|    164|        ++profile->packets_sent[id];
   82|       |
   83|    164|        profile->total_bytes_sent += length;
   84|    164|        profile->bytes_sent[id] += length;
   85|    164|    } else {
   86|      0|        ++profile->total_packets_recv;
   87|      0|        ++profile->packets_recv[id];
   88|       |
   89|      0|        profile->total_bytes_recv += length;
   90|      0|        profile->bytes_recv[id] += length;
   91|      0|    }
   92|    164|}
netprof_new:
  141|    199|{
  142|    199|    Net_Profile *np = (Net_Profile *)mem_alloc(mem, sizeof(Net_Profile));
  143|       |
  144|    199|    if (np == nullptr) {
  ------------------
  |  |   63|    199|#define nullptr NULL
  ------------------
  |  Branch (144:9): [True: 1, False: 198]
  ------------------
  145|      1|        LOGGER_ERROR(log, "failed to allocate memory for net profiler");
  ------------------
  |  |   87|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      1|    do {                                                                         \
  |  |  |  |   77|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      1|        }                                                                        \
  |  |  |  |   80|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  146|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  147|      1|    }
  148|       |
  149|    198|    return np;
  150|    199|}
netprof_kill:
  153|    198|{
  154|    198|    if (net_profile != nullptr) {
  ------------------
  |  |   63|    198|#define nullptr NULL
  ------------------
  |  Branch (154:9): [True: 198, False: 0]
  ------------------
  155|    198|        mem_delete(mem, net_profile);
  156|    198|    }
  157|    198|}

net_socket_from_native:
  380|    198|{
  381|    198|    const Socket res = {(force Socket_Value)sock};
  382|    198|    return res;
  383|    198|}
net_invalid_socket:
  386|    198|{
  387|    198|    return net_socket_from_native(INVALID_SOCKET);
  ------------------
  |  |  371|    198|#define INVALID_SOCKET (-1)
  ------------------
  388|    198|}
net_family_ipv4:
  396|    371|{
  397|    371|    return family_ipv4;
  398|    371|}
net_family_ipv6:
  401|      3|{
  402|      3|    return family_ipv6;
  403|      3|}
net_family_tcp_ipv4:
  416|      6|{
  417|      6|    return family_tcp_ipv4;
  418|      6|}
net_family_tcp_ipv6:
  421|      5|{
  422|      5|    return family_tcp_ipv6;
  423|      5|}
net_family_is_unspec:
  436|    548|{
  437|    548|    return family.value == family_unspec.value;
  438|    548|}
net_family_is_ipv4:
  441|  1.06k|{
  442|  1.06k|    return family.value == family_ipv4.value;
  443|  1.06k|}
net_family_is_ipv6:
  446|    364|{
  447|    364|    return family.value == family_ipv6.value;
  448|    364|}
net_family_is_tcp_ipv4:
  461|      3|{
  462|      3|    return family.value == family_tcp_ipv4.value;
  463|      3|}
sock_valid:
  481|    198|{
  482|    198|    const Socket invalid_socket = net_invalid_socket();
  483|    198|    return sock.value != invalid_socket.value;
  484|    198|}
kill_sock:
  965|    198|{
  966|    198|    ns->funcs->close(ns->obj, sock);
  967|    198|}
set_socket_nonblock:
  970|    198|{
  971|    198|    return ns->funcs->socket_nonblock(ns->obj, sock, true) == 0;
  972|    198|}
set_socket_nosigpipe:
  975|    198|{
  976|       |#if defined(__APPLE__)
  977|       |    int set = 1;
  978|       |    return net_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
  979|       |#else
  980|    198|    return true;
  981|    198|#endif /* __APPLE__ */
  982|    198|}
send_packet:
 1041|    183|{
 1042|    183|    IP_Port ipp_copy = *ip_port;
 1043|       |
 1044|    183|    if (net_family_is_unspec(ip_port->ip.family)) {
  ------------------
  |  Branch (1044:9): [True: 16, False: 167]
  ------------------
 1045|       |        // TODO(iphydf): Make this an error. Currently this fails sometimes when
 1046|       |        // called from DHT.c:do_ping_and_sendnode_requests.
 1047|     16|        return -1;
 1048|     16|    }
 1049|       |
 1050|    167|    if (net_family_is_unspec(net->family)) { /* Socket not initialized */
  ------------------
  |  Branch (1050:9): [True: 0, False: 167]
  ------------------
 1051|       |        // TODO(iphydf): Make this an error. Currently, the onion client calls
 1052|       |        // this via DHT nodes requests.
 1053|      0|        LOGGER_WARNING(net->log, "attempted to send message of length %u on uninitialised socket", packet.length);
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1054|      0|        return -1;
 1055|      0|    }
 1056|       |
 1057|       |    /* socket TOX_AF_INET, but target IP NOT: can't send */
 1058|    167|    if (net_family_is_ipv4(net->family) && !net_family_is_ipv4(ipp_copy.ip.family)) {
  ------------------
  |  Branch (1058:9): [True: 167, False: 0]
  |  Branch (1058:44): [True: 3, False: 164]
  ------------------
 1059|       |        // TODO(iphydf): Make this an error. Occasionally we try to send to an
 1060|       |        // all-zero ip_port.
 1061|      3|        Ip_Ntoa ip_str;
 1062|      3|        LOGGER_WARNING(net->log, "attempted to send message with network family %d (probably IPv6) on IPv4 socket (%s)",
  ------------------
  |  |   86|      3|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      3|    do {                                                                         \
  |  |  |  |   77|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      3|        }                                                                        \
  |  |  |  |   80|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1063|      3|                       ipp_copy.ip.family.value, net_ip_ntoa(&ipp_copy.ip, &ip_str));
 1064|      3|        return -1;
 1065|      3|    }
 1066|       |
 1067|    164|    if (net_family_is_ipv4(ipp_copy.ip.family) && net_family_is_ipv6(net->family)) {
  ------------------
  |  Branch (1067:9): [True: 164, False: 0]
  |  Branch (1067:51): [True: 0, False: 164]
  ------------------
 1068|       |        /* must convert to IPV4-in-IPV6 address */
 1069|      0|        IP6 ip6;
 1070|       |
 1071|       |        /* there should be a macro for this in a standards compliant
 1072|       |         * environment, not found */
 1073|      0|        ip6.uint32[0] = 0;
 1074|      0|        ip6.uint32[1] = 0;
 1075|      0|        ip6.uint32[2] = net_htonl(0xFFFF);
 1076|      0|        ip6.uint32[3] = ipp_copy.ip.ip.v4.uint32;
 1077|       |
 1078|      0|        ipp_copy.ip.family = net_family_ipv6();
 1079|      0|        ipp_copy.ip.ip.v6 = ip6;
 1080|      0|    }
 1081|       |
 1082|    164|    Network_Addr addr;
 1083|       |
 1084|    164|    if (net_family_is_ipv4(ipp_copy.ip.family)) {
  ------------------
  |  Branch (1084:9): [True: 164, False: 0]
  ------------------
 1085|    164|        struct sockaddr_in *const addr4 = (struct sockaddr_in *)&addr.addr;
 1086|       |
 1087|    164|        addr.size = sizeof(struct sockaddr_in);
 1088|    164|        addr4->sin_family = AF_INET;
 1089|    164|        addr4->sin_port = ipp_copy.port;
 1090|    164|        fill_addr4(&ipp_copy.ip.ip.v4, &addr4->sin_addr);
 1091|    164|    } else if (net_family_is_ipv6(ipp_copy.ip.family)) {
  ------------------
  |  Branch (1091:16): [True: 0, False: 0]
  ------------------
 1092|      0|        struct sockaddr_in6 *const addr6 = (struct sockaddr_in6 *)&addr.addr;
 1093|       |
 1094|      0|        addr.size = sizeof(struct sockaddr_in6);
 1095|      0|        addr6->sin6_family = AF_INET6;
 1096|      0|        addr6->sin6_port = ipp_copy.port;
 1097|      0|        fill_addr6(&ipp_copy.ip.ip.v6, &addr6->sin6_addr);
 1098|       |
 1099|      0|        addr6->sin6_flowinfo = 0;
 1100|      0|        addr6->sin6_scope_id = 0;
 1101|      0|    } else {
 1102|      0|        LOGGER_ERROR(net->log, "unknown address type: %d", ipp_copy.ip.family.value);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1103|      0|        return -1;
 1104|      0|    }
 1105|       |
 1106|    164|    const long res = net_sendto(net->ns, net->sock, packet.data, packet.length, &addr, &ipp_copy);
 1107|    164|    loglogdata(net->log, "O=>", packet.data, packet.length, ip_port, res);
 1108|       |
 1109|    164|    assert(res <= INT_MAX);
 1110|       |
 1111|    164|    if (res == packet.length && packet.data != nullptr) {
  ------------------
  |  |   63|    164|#define nullptr NULL
  ------------------
  |  Branch (1111:9): [True: 164, False: 0]
  |  Branch (1111:33): [True: 164, False: 0]
  ------------------
 1112|    164|        netprof_record_packet(net->udp_net_profile, packet.data[0], packet.length, PACKET_DIRECTION_SEND);
 1113|    164|    }
 1114|       |
 1115|    164|    return (int)res;
 1116|    164|}
sendpacket:
 1124|    183|{
 1125|    183|    const Packet packet = {data, length};
 1126|    183|    return send_packet(net, ip_port, packet);
 1127|    183|}
new_networking_ex:
 1246|    202|{
 1247|       |    /* If both from and to are 0, use default port range
 1248|       |     * If one is 0 and the other is non-0, use the non-0 value as only port
 1249|       |     * If from > to, swap
 1250|       |     */
 1251|    202|    if (port_from == 0 && port_to == 0) {
  ------------------
  |  Branch (1251:9): [True: 13, False: 189]
  |  Branch (1251:27): [True: 0, False: 13]
  ------------------
 1252|      0|        port_from = TOX_PORTRANGE_FROM;
  ------------------
  |  |  162|      0|#define TOX_PORTRANGE_FROM 33445
  ------------------
 1253|      0|        port_to = TOX_PORTRANGE_TO;
  ------------------
  |  |  163|      0|#define TOX_PORTRANGE_TO   33545
  ------------------
 1254|    202|    } else if (port_from == 0 && port_to != 0) {
  ------------------
  |  Branch (1254:16): [True: 13, False: 189]
  |  Branch (1254:34): [True: 13, False: 0]
  ------------------
 1255|     13|        port_from = port_to;
 1256|    189|    } else if (port_from != 0 && port_to == 0) {
  ------------------
  |  Branch (1256:16): [True: 189, False: 0]
  |  Branch (1256:34): [True: 1, False: 188]
  ------------------
 1257|      1|        port_to = port_from;
 1258|    188|    } else if (port_from > port_to) {
  ------------------
  |  Branch (1258:16): [True: 1, False: 187]
  ------------------
 1259|      1|        const uint16_t temp_port = port_from;
 1260|      1|        port_from = port_to;
 1261|      1|        port_to = temp_port;
 1262|      1|    }
 1263|       |
 1264|    202|    if (error != nullptr) {
  ------------------
  |  |   63|    202|#define nullptr NULL
  ------------------
  |  Branch (1264:9): [True: 0, False: 202]
  ------------------
 1265|      0|        *error = 2;
 1266|      0|    }
 1267|       |
 1268|       |    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
 1269|    202|    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1269:9): [True: 2, False: 200]
  |  Branch (1269:44): [True: 2, False: 0]
  ------------------
 1270|      2|        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
  ------------------
  |  |   87|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      2|    do {                                                                         \
  |  |  |  |   77|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      2|        }                                                                        \
  |  |  |  |   80|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1271|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 1272|      2|    }
 1273|       |
 1274|    200|    Networking_Core *temp = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
 1275|       |
 1276|    200|    if (temp == nullptr) {
  ------------------
  |  |   63|    200|#define nullptr NULL
  ------------------
  |  Branch (1276:9): [True: 1, False: 199]
  ------------------
 1277|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 1278|      1|    }
 1279|       |
 1280|    199|    Net_Profile *np = netprof_new(log, mem);
 1281|       |
 1282|    199|    if (np == nullptr) {
  ------------------
  |  |   63|    199|#define nullptr NULL
  ------------------
  |  Branch (1282:9): [True: 1, False: 198]
  ------------------
 1283|      1|        free(temp);
 1284|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 1285|      1|    }
 1286|       |
 1287|    198|    temp->udp_net_profile = np;
 1288|    198|    temp->ns = ns;
 1289|    198|    temp->log = log;
 1290|    198|    temp->mem = mem;
 1291|    198|    temp->family = ip->family;
 1292|    198|    temp->port = 0;
 1293|       |
 1294|       |    /* Initialize our socket. */
 1295|       |    /* add log message what we're creating */
 1296|    198|    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  174|    198|#define TOX_SOCK_DGRAM 2
  ------------------
                  temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  177|    198|#define TOX_PROTO_UDP 2
  ------------------
 1297|       |
 1298|       |    /* Check for socket error. */
 1299|    198|    if (!sock_valid(temp->sock)) {
  ------------------
  |  Branch (1299:9): [True: 0, False: 198]
  ------------------
 1300|      0|        const int neterror = net_error();
 1301|      0|        Net_Strerror error_str;
 1302|      0|        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1303|      0|        netprof_kill(mem, temp->udp_net_profile);
 1304|      0|        mem_delete(mem, temp);
 1305|       |
 1306|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1306:13): [True: 0, False: 0]
  ------------------
 1307|      0|            *error = 1;
 1308|      0|        }
 1309|       |
 1310|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1311|      0|    }
 1312|       |
 1313|       |    /* Functions to increase the size of the send and receive UDP buffers.
 1314|       |     */
 1315|    198|    int n = 1024 * 1024 * 2;
 1316|       |
 1317|    198|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1317:9): [True: 0, False: 198]
  ------------------
 1318|      0|        LOGGER_WARNING(log, "failed to set socket option %d", SO_RCVBUF);
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1319|      0|    }
 1320|       |
 1321|    198|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_SNDBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1321:9): [True: 0, False: 198]
  ------------------
 1322|      0|        LOGGER_WARNING(log, "failed to set socket option %d", SO_SNDBUF);
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1323|      0|    }
 1324|       |
 1325|       |    /* Enable broadcast on socket */
 1326|    198|    int broadcast = 1;
 1327|       |
 1328|    198|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) != 0) {
  ------------------
  |  Branch (1328:9): [True: 0, False: 198]
  ------------------
 1329|      0|        LOGGER_ERROR(log, "failed to set socket option %d", SO_BROADCAST);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1330|      0|    }
 1331|       |
 1332|       |    /* iOS UDP sockets are weird and apparently can SIGPIPE */
 1333|    198|    if (!set_socket_nosigpipe(ns, temp->sock)) {
  ------------------
  |  Branch (1333:9): [True: 0, False: 198]
  ------------------
 1334|      0|        kill_networking(temp);
 1335|       |
 1336|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1336:13): [True: 0, False: 0]
  ------------------
 1337|      0|            *error = 1;
 1338|      0|        }
 1339|       |
 1340|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1341|      0|    }
 1342|       |
 1343|       |    /* Set socket nonblocking. */
 1344|    198|    if (!set_socket_nonblock(ns, temp->sock)) {
  ------------------
  |  Branch (1344:9): [True: 0, False: 198]
  ------------------
 1345|      0|        kill_networking(temp);
 1346|       |
 1347|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1347:13): [True: 0, False: 0]
  ------------------
 1348|      0|            *error = 1;
 1349|      0|        }
 1350|       |
 1351|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1352|      0|    }
 1353|       |
 1354|       |    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
 1355|    198|    uint16_t *portptr = nullptr;
  ------------------
  |  |   63|    198|#define nullptr NULL
  ------------------
 1356|    198|    Network_Addr addr = {{0}};
 1357|       |
 1358|    198|    if (net_family_is_ipv4(temp->family)) {
  ------------------
  |  Branch (1358:9): [True: 198, False: 0]
  ------------------
 1359|    198|        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr.addr;
 1360|       |
 1361|    198|        addr.size = sizeof(struct sockaddr_in);
 1362|    198|        addr4->sin_family = AF_INET;
 1363|    198|        addr4->sin_port = 0;
 1364|    198|        fill_addr4(&ip->ip.v4, &addr4->sin_addr);
 1365|       |
 1366|    198|        portptr = &addr4->sin_port;
 1367|    198|    } else if (net_family_is_ipv6(temp->family)) {
  ------------------
  |  Branch (1367:16): [True: 0, False: 0]
  ------------------
 1368|      0|        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr.addr;
 1369|       |
 1370|      0|        addr.size = sizeof(struct sockaddr_in6);
 1371|      0|        addr6->sin6_family = AF_INET6;
 1372|      0|        addr6->sin6_port = 0;
 1373|      0|        fill_addr6(&ip->ip.v6, &addr6->sin6_addr);
 1374|       |
 1375|      0|        addr6->sin6_flowinfo = 0;
 1376|      0|        addr6->sin6_scope_id = 0;
 1377|       |
 1378|      0|        portptr = &addr6->sin6_port;
 1379|      0|    } else {
 1380|      0|        mem_delete(mem, temp);
 1381|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1382|      0|    }
 1383|       |
 1384|    198|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1384:9): [True: 0, False: 198]
  ------------------
 1385|      0|        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);
 1386|       |
 1387|      0|        if (is_dualstack) {
  ------------------
  |  Branch (1387:13): [True: 0, False: 0]
  ------------------
 1388|      0|            LOGGER_TRACE(log, "Dual-stack socket: enabled");
  ------------------
  |  |   83|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1389|      0|        } else {
 1390|      0|            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1391|      0|        }
 1392|       |
 1393|      0|#ifndef ESP_PLATFORM
 1394|       |        /* multicast local nodes */
 1395|      0|        struct ipv6_mreq mreq = {{{{0}}}};
 1396|      0|        mreq.ipv6mr_multiaddr.s6_addr[0] = 0xFF;
 1397|      0|        mreq.ipv6mr_multiaddr.s6_addr[1] = 0x02;
 1398|      0|        mreq.ipv6mr_multiaddr.s6_addr[15] = 0x01;
 1399|      0|        mreq.ipv6mr_interface = 0;
 1400|       |
 1401|      0|        const int res = net_setsockopt(ns, temp->sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
 1402|       |
 1403|      0|        const int neterror = net_error();
 1404|      0|        Net_Strerror error_str;
 1405|       |
 1406|      0|        if (res < 0) {
  ------------------
  |  Branch (1406:13): [True: 0, False: 0]
  ------------------
 1407|      0|            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   85|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1408|      0|        } else {
 1409|      0|            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   83|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1410|      0|        }
 1411|      0|#endif /* ESP_PLATFORM */
 1412|      0|    }
 1413|       |
 1414|       |    /* A hanging program or a different user might block the standard port.
 1415|       |     * As long as it isn't a parameter coming from the commandline,
 1416|       |     * try a few ports after it, to see if we can find a "free" one.
 1417|       |     *
 1418|       |     * If we go on without binding, the first sendto() automatically binds to
 1419|       |     * a free port chosen by the system (i.e. anything from 1024 to 65535).
 1420|       |     *
 1421|       |     * Returning NULL after bind fails has both advantages and disadvantages:
 1422|       |     * advantage:
 1423|       |     *   we can rely on getting the port in the range 33445..33450, which
 1424|       |     *   enables us to tell joe user to open their firewall to a small range
 1425|       |     *
 1426|       |     * disadvantage:
 1427|       |     *   some clients might not test return of tox_new(), blindly assuming that
 1428|       |     *   it worked ok (which it did previously without a successful bind)
 1429|       |     */
 1430|    198|    uint16_t port_to_try = port_from;
 1431|    198|    *portptr = net_htons(port_to_try);
 1432|       |
 1433|    198|    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
  ------------------
  |  Branch (1433:38): [True: 198, False: 0]
  ------------------
 1434|    198|        const int res = net_bind(ns, temp->sock, &addr);
 1435|       |
 1436|    198|        if (res == 0) {
  ------------------
  |  Branch (1436:13): [True: 198, False: 0]
  ------------------
 1437|    198|            temp->port = *portptr;
 1438|       |
 1439|    198|            Ip_Ntoa ip_str;
 1440|    198|            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
  ------------------
  |  |   84|    198|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|    198|    do {                                                                         \
  |  |  |  |   77|    198|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    396|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|    198|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1441|    198|                         net_ntohs(temp->port));
 1442|       |
 1443|       |            /* errno isn't reset on success, only set on failure, the failed
 1444|       |             * binds with parallel clients yield a -EPERM to the outside if
 1445|       |             * errno isn't cleared here */
 1446|    198|            if (tries > 0) {
  ------------------
  |  Branch (1446:17): [True: 198, False: 0]
  ------------------
 1447|    198|                errno = 0;
 1448|    198|            }
 1449|       |
 1450|    198|            if (error != nullptr) {
  ------------------
  |  |   63|    198|#define nullptr NULL
  ------------------
  |  Branch (1450:17): [True: 0, False: 198]
  ------------------
 1451|      0|                *error = 0;
 1452|      0|            }
 1453|       |
 1454|    198|            return temp;
 1455|    198|        }
 1456|       |
 1457|      0|        ++port_to_try;
 1458|       |
 1459|      0|        if (port_to_try > port_to) {
  ------------------
  |  Branch (1459:13): [True: 0, False: 0]
  ------------------
 1460|      0|            port_to_try = port_from;
 1461|      0|        }
 1462|       |
 1463|      0|        *portptr = net_htons(port_to_try);
 1464|      0|    }
 1465|       |
 1466|      0|    Ip_Ntoa ip_str;
 1467|      0|    const int neterror = net_error();
 1468|      0|    Net_Strerror error_str;
 1469|      0|    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u",
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1470|      0|                 neterror, net_strerror(neterror, &error_str), net_ip_ntoa(ip, &ip_str), port_from, port_to);
 1471|      0|    kill_networking(temp);
 1472|       |
 1473|      0|    if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1473:9): [True: 0, False: 0]
  ------------------
 1474|      0|        *error = 1;
 1475|      0|    }
 1476|       |
 1477|      0|    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1478|    198|}
kill_networking:
 1498|    198|{
 1499|    198|    if (net == nullptr) {
  ------------------
  |  |   63|    198|#define nullptr NULL
  ------------------
  |  Branch (1499:9): [True: 0, False: 198]
  ------------------
 1500|      0|        return;
 1501|      0|    }
 1502|       |
 1503|    198|    if (!net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (1503:9): [True: 198, False: 0]
  ------------------
 1504|       |        /* Socket is initialized, so we close it. */
 1505|    198|        kill_sock(net->ns, net->sock);
 1506|    198|    }
 1507|       |
 1508|    198|    netprof_kill(net->mem, net->udp_net_profile);
 1509|    198|    mem_delete(net->mem, net);
 1510|    198|}
ipport_reset:
 1638|    385|{
 1639|    385|    if (ipport == nullptr) {
  ------------------
  |  |   63|    385|#define nullptr NULL
  ------------------
  |  Branch (1639:9): [True: 0, False: 385]
  ------------------
 1640|      0|        return;
 1641|      0|    }
 1642|       |
 1643|    385|    *ipport = empty_ip_port;
 1644|    385|}
unpack_ip_port:
 1786|    429|{
 1787|    429|    if (data == nullptr) {
  ------------------
  |  |   63|    429|#define nullptr NULL
  ------------------
  |  Branch (1787:9): [True: 0, False: 429]
  ------------------
 1788|      0|        return -1;
 1789|      0|    }
 1790|       |
 1791|    429|    bool is_ipv4;
 1792|    429|    Family host_family;
 1793|       |
 1794|    429|    if (data[0] == TOX_AF_INET) {
  ------------------
  |  |  168|    429|#define TOX_AF_INET 2
  ------------------
  |  Branch (1794:9): [True: 371, False: 58]
  ------------------
 1795|    371|        is_ipv4 = true;
 1796|    371|        host_family = net_family_ipv4();
 1797|    371|    } else if (data[0] == TOX_TCP_INET) {
  ------------------
  |  |  170|     58|#define TOX_TCP_INET 130
  ------------------
  |  Branch (1797:16): [True: 6, False: 52]
  ------------------
 1798|      6|        if (!tcp_enabled) {
  ------------------
  |  Branch (1798:13): [True: 0, False: 6]
  ------------------
 1799|      0|            return -1;
 1800|      0|        }
 1801|       |
 1802|      6|        is_ipv4 = true;
 1803|      6|        host_family = net_family_tcp_ipv4();
 1804|     52|    } else if (data[0] == TOX_AF_INET6) {
  ------------------
  |  |  169|     52|#define TOX_AF_INET6 10
  ------------------
  |  Branch (1804:16): [True: 3, False: 49]
  ------------------
 1805|      3|        is_ipv4 = false;
 1806|      3|        host_family = net_family_ipv6();
 1807|     49|    } else if (data[0] == TOX_TCP_INET6) {
  ------------------
  |  |  171|     49|#define TOX_TCP_INET6 138
  ------------------
  |  Branch (1807:16): [True: 5, False: 44]
  ------------------
 1808|      5|        if (!tcp_enabled) {
  ------------------
  |  Branch (1808:13): [True: 0, False: 5]
  ------------------
 1809|      0|            return -1;
 1810|      0|        }
 1811|       |
 1812|      5|        is_ipv4 = false;
 1813|      5|        host_family = net_family_tcp_ipv6();
 1814|     44|    } else {
 1815|     44|        return -1;
 1816|     44|    }
 1817|       |
 1818|    385|    ipport_reset(ip_port);
 1819|       |
 1820|    385|    if (is_ipv4) {
  ------------------
  |  Branch (1820:9): [True: 377, False: 8]
  ------------------
 1821|    377|        const uint32_t size = 1 + SIZE_IP4 + sizeof(uint16_t);
  ------------------
  |  |  185|    377|#define SIZE_IP4 4
  ------------------
 1822|       |
 1823|    377|        if (size > length) {
  ------------------
  |  Branch (1823:13): [True: 0, False: 377]
  ------------------
 1824|      0|            return -1;
 1825|      0|        }
 1826|       |
 1827|    377|        ip_port->ip.family = host_family;
 1828|    377|        memcpy(ip_port->ip.ip.v4.uint8, data + 1, SIZE_IP4);
  ------------------
  |  |  185|    377|#define SIZE_IP4 4
  ------------------
 1829|    377|        memcpy(&ip_port->port, data + 1 + SIZE_IP4, sizeof(uint16_t));
  ------------------
  |  |  185|    377|#define SIZE_IP4 4
  ------------------
 1830|    377|        return size;
 1831|    377|    } else {
 1832|      8|        const uint32_t size = 1 + SIZE_IP6 + sizeof(uint16_t);
  ------------------
  |  |  186|      8|#define SIZE_IP6 16
  ------------------
 1833|       |
 1834|      8|        if (size > length) {
  ------------------
  |  Branch (1834:13): [True: 8, False: 0]
  ------------------
 1835|      8|            return -1;
 1836|      8|        }
 1837|       |
 1838|      0|        ip_port->ip.family = host_family;
 1839|      0|        memcpy(ip_port->ip.ip.v6.uint8, data + 1, SIZE_IP6);
  ------------------
  |  |  186|      0|#define SIZE_IP6 16
  ------------------
 1840|      0|        memcpy(&ip_port->port, data + 1 + SIZE_IP6, sizeof(uint16_t));
  ------------------
  |  |  186|      0|#define SIZE_IP6 16
  ------------------
 1841|      0|        return size;
 1842|      8|    }
 1843|    385|}
net_ip_ntoa:
 1846|      3|{
 1847|      3|    assert(ip_str != nullptr);
 1848|       |
 1849|      3|    ip_str->ip_is_valid = false;
 1850|       |
 1851|      3|    if (ip == nullptr) {
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
  |  Branch (1851:9): [True: 0, False: 3]
  ------------------
 1852|      0|        snprintf(ip_str->buf, sizeof(ip_str->buf), "(IP invalid: NULL)");
 1853|      0|        ip_str->length = (uint16_t)strlen(ip_str->buf);
 1854|      0|        return ip_str->buf;
 1855|      0|    }
 1856|       |
 1857|      3|    if (!ip_parse_addr(ip, ip_str->buf, sizeof(ip_str->buf))) {
  ------------------
  |  Branch (1857:9): [True: 0, False: 3]
  ------------------
 1858|      0|        snprintf(ip_str->buf, sizeof(ip_str->buf), "(IP invalid, family %u)", ip->family.value);
 1859|      0|        ip_str->length = (uint16_t)strlen(ip_str->buf);
 1860|      0|        return ip_str->buf;
 1861|      0|    }
 1862|       |
 1863|       |    /* brute force protection against lacking termination */
 1864|      3|    ip_str->buf[sizeof(ip_str->buf) - 1] = '\0';
 1865|      3|    ip_str->length = (uint16_t)strlen(ip_str->buf);
 1866|      3|    ip_str->ip_is_valid = true;
 1867|       |
 1868|      3|    return ip_str->buf;
 1869|      3|}
ip_parse_addr:
 1872|      3|{
 1873|      3|    if (address == nullptr || ip == nullptr) {
  ------------------
  |  |   63|      6|#define nullptr NULL
  ------------------
                  if (address == nullptr || ip == nullptr) {
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
  |  Branch (1873:9): [True: 0, False: 3]
  |  Branch (1873:31): [True: 0, False: 3]
  ------------------
 1874|      0|        return false;
 1875|      0|    }
 1876|       |
 1877|      3|    if (net_family_is_ipv4(ip->family) || net_family_is_tcp_ipv4(ip->family)) {
  ------------------
  |  Branch (1877:9): [True: 0, False: 3]
  |  Branch (1877:43): [True: 3, False: 0]
  ------------------
 1878|      3|        struct in_addr addr;
 1879|      3|        assert(make_family(ip->family) == AF_INET);
 1880|      3|        fill_addr4(&ip->ip.v4, &addr);
 1881|      3|        return inet_ntop4(&addr, address, length) != nullptr;
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
 1882|      3|    }
 1883|       |
 1884|      0|    if (net_family_is_ipv6(ip->family) || net_family_is_tcp_ipv6(ip->family)) {
  ------------------
  |  Branch (1884:9): [True: 0, False: 0]
  |  Branch (1884:43): [True: 0, False: 0]
  ------------------
 1885|      0|        struct in6_addr addr;
 1886|      0|        assert(make_family(ip->family) == AF_INET6);
 1887|      0|        fill_addr6(&ip->ip.v6, &addr);
 1888|      0|        return inet_ntop6(&addr, address, length) != nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1889|      0|    }
 1890|       |
 1891|      0|    return false;
 1892|      0|}
net_socket:
 2252|    198|{
 2253|    198|    const int platform_domain = make_family(domain);
 2254|    198|    const int platform_type = make_socktype(type);
 2255|    198|    const int platform_prot = make_proto(protocol);
 2256|    198|    return ns->funcs->socket(ns->obj, platform_domain, platform_type, platform_prot);
 2257|    198|}
net_htons:
 2271|    198|{
 2272|    198|    return htons(hostshort);
 2273|    198|}
network.c:loglogdata:
  884|    164|{
  885|    164|    if (res < 0) { /* Windows doesn't necessarily know `%zu` */
  ------------------
  |  Branch (885:9): [True: 0, False: 164]
  ------------------
  886|      0|        Ip_Ntoa ip_str;
  887|      0|        const int error = net_error();
  888|      0|        Net_Strerror error_str;
  889|      0|        LOGGER_TRACE(log, "[%02x = %-21s] %s %3u%c %s:%u (%u: %s) | %08x%08x...%02x",
  ------------------
  |  |   83|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  890|      0|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  891|      0|                     min_u16(buflen, 999), 'E',
  892|      0|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), error,
  893|      0|                     net_strerror(error, &error_str), data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  894|    164|    } else if ((res > 0) && ((size_t)res <= buflen)) {
  ------------------
  |  Branch (894:16): [True: 164, False: 0]
  |  Branch (894:29): [True: 164, False: 0]
  ------------------
  895|    164|        Ip_Ntoa ip_str;
  896|    164|        LOGGER_TRACE(log, "[%02x = %-21s] %s %3u%c %s:%u (%u: %s) | %08x%08x...%02x",
  ------------------
  |  |   83|    164|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|    164|    do {                                                                         \
  |  |  |  |   77|    164|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    328|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (78:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|    164|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  897|    164|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  898|    164|                     min_u16(res, 999), (size_t)res < buflen ? '<' : '=',
  899|    164|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
  900|    164|                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  901|    164|    } else { /* empty or overwrite */
  902|      0|        Ip_Ntoa ip_str;
  903|      0|        LOGGER_TRACE(log, "[%02x = %-21s] %s %lu%c%u %s:%u (%u: %s) | %08x%08x...%02x",
  ------------------
  |  |   83|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (78:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  904|      0|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  905|      0|                     res, res == 0 ? '!' : '>', buflen,
  906|      0|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
  907|      0|                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  908|      0|    }
  909|    164|}
network.c:net_setsockopt:
  733|    594|{
  734|    594|    return ns->funcs->setsockopt(ns->obj, sock, level, optname, optval, optlen);
  735|    594|}
network.c:fill_addr4:
  327|    365|{
  328|    365|    addr->s_addr = ip->uint32;
  329|    365|}
network.c:net_sendto:
  928|    164|{
  929|    164|    return ns->funcs->sendto(ns->obj, sock, buf, len, addr);
  930|    164|}
network.c:net_bind:
  954|    198|{
  955|    198|    return ns->funcs->bind(ns->obj, sock, addr);
  956|    198|}
network.c:make_family:
  264|    201|{
  265|    201|    switch (tox_family.value) {
  266|    198|        case TOX_AF_INET:
  ------------------
  |  |  168|    198|#define TOX_AF_INET 2
  ------------------
  |  Branch (266:9): [True: 198, False: 3]
  ------------------
  267|    201|        case TCP_INET:
  ------------------
  |  |  181|    201|#define TCP_INET (TOX_AF_INET6 + 2)
  |  |  ------------------
  |  |  |  |  169|    201|#define TOX_AF_INET6 10
  |  |  ------------------
  ------------------
  |  Branch (267:9): [True: 3, False: 198]
  ------------------
  268|    201|            return AF_INET;
  269|       |
  270|      0|        case TOX_AF_INET6:
  ------------------
  |  |  169|      0|#define TOX_AF_INET6 10
  ------------------
  |  Branch (270:9): [True: 0, False: 201]
  ------------------
  271|      0|        case TCP_INET6:
  ------------------
  |  |  182|      0|#define TCP_INET6 (TOX_AF_INET6 + 3)
  |  |  ------------------
  |  |  |  |  169|      0|#define TOX_AF_INET6 10
  |  |  ------------------
  ------------------
  |  Branch (271:9): [True: 0, False: 201]
  ------------------
  272|      0|            return AF_INET6;
  273|       |
  274|      0|        case TOX_AF_UNSPEC:
  ------------------
  |  |  167|      0|#define TOX_AF_UNSPEC 0
  ------------------
  |  Branch (274:9): [True: 0, False: 201]
  ------------------
  275|      0|            return AF_UNSPEC;
  276|       |
  277|      0|        default:
  ------------------
  |  Branch (277:9): [True: 0, False: 201]
  ------------------
  278|      0|            return tox_family.value;
  279|    201|    }
  280|    201|}
network.c:inet_ntop4:
  123|      3|{
  124|      3|    return inet_ntop(AF_INET, addr, buf, bufsize);
  125|      3|}
network.c:make_socktype:
  250|    198|{
  251|    198|    switch (type) {
  252|      0|        case TOX_SOCK_STREAM:
  ------------------
  |  |  173|      0|#define TOX_SOCK_STREAM 1
  ------------------
  |  Branch (252:9): [True: 0, False: 198]
  ------------------
  253|      0|            return SOCK_STREAM;
  254|       |
  255|    198|        case TOX_SOCK_DGRAM:
  ------------------
  |  |  174|    198|#define TOX_SOCK_DGRAM 2
  ------------------
  |  Branch (255:9): [True: 198, False: 0]
  ------------------
  256|    198|            return SOCK_DGRAM;
  257|       |
  258|      0|        default:
  ------------------
  |  Branch (258:9): [True: 0, False: 198]
  ------------------
  259|      0|            return type;
  260|    198|    }
  261|    198|}
network.c:make_proto:
  236|    198|{
  237|    198|    switch (proto) {
  238|      0|        case TOX_PROTO_TCP:
  ------------------
  |  |  176|      0|#define TOX_PROTO_TCP 1
  ------------------
  |  Branch (238:9): [True: 0, False: 198]
  ------------------
  239|      0|            return IPPROTO_TCP;
  240|       |
  241|    198|        case TOX_PROTO_UDP:
  ------------------
  |  |  177|    198|#define TOX_PROTO_UDP 2
  ------------------
  |  Branch (241:9): [True: 198, False: 0]
  ------------------
  242|    198|            return IPPROTO_UDP;
  243|       |
  244|      0|        default:
  ------------------
  |  Branch (244:9): [True: 0, False: 198]
  ------------------
  245|      0|            return proto;
  246|    198|    }
  247|    198|}

