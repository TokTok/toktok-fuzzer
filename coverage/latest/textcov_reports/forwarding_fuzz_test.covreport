_ZN3tox4test16FakeNetworkStackC2ERNS0_15NetworkUniverseERK2IP:
   98|    136|    : universe_(universe)
   99|    136|    , node_ip_(node_ip)
  100|    136|{
  101|    136|}
_ZN3tox4test16FakeNetworkStackD2Ev:
  103|    136|FakeNetworkStack::~FakeNetworkStack() = default;
_ZN3tox4test16FakeNetworkStack9c_networkEv:
  105|    136|struct Network FakeNetworkStack::c_network() { return Network{&kNetworkVtable, this}; }
_ZN3tox4test16FakeNetworkStack6socketEiii:
  108|    229|{
  109|    229|    std::lock_guard<std::mutex> lock(mutex_);
  110|    229|    int fd = next_fd_++;
  111|       |
  112|    229|    std::unique_ptr<FakeSocket> sock;
  113|    229|    if (type == SOCK_DGRAM) {
  ------------------
  |  Branch (113:9): [True: 229, False: 0]
  ------------------
  114|    229|        if (universe_.is_verbose()) {
  ------------------
  |  Branch (114:13): [True: 0, False: 229]
  ------------------
  115|      0|            std::cerr << "[FakeNetworkStack] create UDP socket fd=" << fd << std::endl;
  116|      0|        }
  117|    229|        sock = std::make_unique<FakeUdpSocket>(universe_);
  118|    229|    } else if (type == SOCK_STREAM) {
  ------------------
  |  Branch (118:16): [True: 0, False: 0]
  ------------------
  119|      0|        if (universe_.is_verbose()) {
  ------------------
  |  Branch (119:13): [True: 0, False: 0]
  ------------------
  120|      0|            std::cerr << "[FakeNetworkStack] create TCP socket fd=" << fd << std::endl;
  121|      0|        }
  122|      0|        sock = std::make_unique<FakeTcpSocket>(universe_);
  123|      0|    } else {
  124|       |        // Unknown type
  125|      0|        return net_socket_from_native(-1);
  126|      0|    }
  127|       |
  128|    229|    sockets_[fd] = std::move(sock);
  129|    229|    sockets_[fd]->set_ip(node_ip_);
  130|    229|    return net_socket_from_native(fd);
  131|    229|}
_ZN3tox4test16FakeNetworkStack8get_sockE6Socket:
  134|    939|{
  135|    939|    std::lock_guard<std::mutex> lock(mutex_);
  136|    939|    auto it = sockets_.find(net_socket_to_native(sock));
  137|    939|    if (it != sockets_.end()) {
  ------------------
  |  Branch (137:9): [True: 939, False: 0]
  ------------------
  138|    939|        return it->second.get();
  139|    939|    }
  140|      0|    return nullptr;
  141|    939|}
_ZN3tox4test16FakeNetworkStack5closeE6Socket:
  144|    130|{
  145|    130|    std::lock_guard<std::mutex> lock(mutex_);
  146|    130|    int fd = net_socket_to_native(sock);
  147|    130|    auto it = sockets_.find(fd);
  148|    130|    if (it == sockets_.end()) {
  ------------------
  |  Branch (148:9): [True: 0, False: 130]
  ------------------
  149|      0|        errno = EBADF;
  150|      0|        return -1;
  151|      0|    }
  152|    130|    it->second->close();
  153|    130|    sockets_.erase(it);
  154|    130|    return 0;
  155|    130|}
_ZN3tox4test16FakeNetworkStack4bindE6SocketPK7IP_Port:
  159|    322|{
  160|    322|    if (auto *s = get_sock(sock)) {
  ------------------
  |  Branch (160:15): [True: 322, False: 0]
  ------------------
  161|    322|        int ret = s->bind(addr);
  162|    322|        if (universe_.is_verbose() && ret == 0) {
  ------------------
  |  Branch (162:13): [True: 0, False: 322]
  |  Branch (162:39): [True: 0, False: 0]
  ------------------
  163|      0|            char ip_str[TOX_INET_ADDRSTRLEN];
  164|      0|            ip_parse_addr(&s->ip_address(), ip_str, sizeof(ip_str));
  165|      0|            std::cerr << "[FakeNetworkStack] bound socket to " << ip_str << ":" << s->local_port()
  166|      0|                      << std::endl;
  167|      0|        }
  168|    322|        return ret;
  169|    322|    }
  170|    322|    errno = EBADF;
  171|      0|    return -1;
  172|    322|}
_ZN3tox4test16FakeNetworkStack6sendtoE6SocketPKhmPK7IP_Port:
  241|     97|{
  242|     97|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (242:15): [True: 97, False: 0]
  ------------------
  243|     97|        return s->sendto(buf, len, addr);
  244|     97|    errno = EBADF;
  245|      0|    return -1;
  246|     97|}
_ZN3tox4test16FakeNetworkStack15socket_nonblockE6Socketb:
  257|    130|{
  258|    130|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (258:15): [True: 130, False: 0]
  ------------------
  259|    130|        return s->socket_nonblock(nonblock);
  260|    130|    errno = EBADF;
  261|      0|    return -1;
  262|    130|}
_ZN3tox4test16FakeNetworkStack10setsockoptE6SocketiiPKvm:
  274|    390|{
  275|    390|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (275:15): [True: 390, False: 0]
  ------------------
  276|    390|        return s->setsockopt(level, optname, optval, optlen);
  277|    390|    errno = EBADF;
  278|      0|    return -1;
  279|    390|}
_ZN3tox4test16FakeNetworkStack21get_bound_udp_socketsEv:
  292|    136|{
  293|    136|    std::lock_guard<std::mutex> lock(mutex_);
  294|    136|    std::vector<FakeUdpSocket *> result;
  295|    136|    for (const auto &pair : sockets_) {
  ------------------
  |  Branch (295:27): [True: 99, False: 136]
  ------------------
  296|     99|        FakeSocket *s = pair.second.get();
  297|     99|        if (s->type() == SOCK_DGRAM && s->local_port() != 0) {
  ------------------
  |  Branch (297:13): [True: 99, False: 0]
  |  Branch (297:40): [True: 99, False: 0]
  ------------------
  298|     99|            result.push_back(static_cast<FakeUdpSocket *>(s));
  299|     99|        }
  300|     99|    }
  301|    136|    return result;
  302|    136|}
fake_network_stack.cc:_ZNK3tox4test3$_0clEPv6Socket:
   13|    130|                 Socket sock) { return static_cast<FakeNetworkStack *>(obj)->close(sock); },
fake_network_stack.cc:_ZNK3tox4test3$_2clEPv6SocketPK7IP_Port:
   17|    223|        [](void *_Nonnull obj, Socket sock, const IP_Port *_Nonnull addr) {
   18|    223|            return static_cast<FakeNetworkStack *>(obj)->bind(sock, addr);
   19|    223|        },
fake_network_stack.cc:_ZNK3tox4test3$_9clEPv6SocketPKhmPK7IP_Port:
   40|     97|            const IP_Port *_Nonnull addr) {
   41|     97|            return static_cast<FakeNetworkStack *>(obj)->sendto(sock, buf, len, addr);
   42|     97|        },
fake_network_stack.cc:_ZNK3tox4test4$_10clEPviii:
   45|    130|          int proto) { return static_cast<FakeNetworkStack *>(obj)->socket(domain, type, proto); },
fake_network_stack.cc:_ZNK3tox4test4$_11clEPv6Socketb:
   47|    130|        [](void *_Nonnull obj, Socket sock, bool nonblock) {
   48|    130|            return static_cast<FakeNetworkStack *>(obj)->socket_nonblock(sock, nonblock);
   49|    130|        },
fake_network_stack.cc:_ZNK3tox4test4$_13clEPv6SocketiiPKvm:
   58|    390|            size_t optlen) {
   59|    390|            return static_cast<FakeNetworkStack *>(obj)->setsockopt(
   60|    390|                sock, level, optname, optval, optlen);
   61|    390|        },

_ZN3tox4test10FakeSocketC2ERNS0_15NetworkUniverseEi:
   19|    229|    : universe_(universe)
   20|    229|    , type_(type)
   21|    229|{
   22|    229|    ip_init(&ip_, false);
   23|    229|    ip_.ip.v4.uint32 = net_htonl(0x7F000001);
   24|    229|}
_ZN3tox4test10FakeSocketD2Ev:
   26|    229|FakeSocket::~FakeSocket() = default;
_ZN3tox4test10FakeSocket10setsockoptEiiPKvm:
   39|    390|{
   40|    390|    return 0;
   41|    390|}
_ZN3tox4test10FakeSocket15socket_nonblockEb:
   43|    130|{
   44|    130|    nonblocking_ = nonblock;
   45|    130|    return 0;
   46|    130|}
_ZN3tox4test13FakeUdpSocketC2ERNS0_15NetworkUniverseE:
   51|    229|    : FakeSocket(universe, SOCK_DGRAM)
   52|    229|{
   53|    229|}
_ZN3tox4test13FakeUdpSocketD2Ev:
   55|    229|FakeUdpSocket::~FakeUdpSocket() { close_impl(); }
_ZN3tox4test13FakeUdpSocket5closeEv:
   58|    130|{
   59|    130|    std::lock_guard<std::mutex> lock(mutex_);
   60|    130|    close_impl();
   61|    130|    return 0;
   62|    130|}
_ZN3tox4test13FakeUdpSocket10close_implEv:
   65|    359|{
   66|    359|    if (local_port_ != 0) {
  ------------------
  |  Branch (66:9): [True: 228, False: 131]
  ------------------
   67|    228|        universe_.unbind_udp(ip_, local_port_);
   68|    228|        local_port_ = 0;
   69|    228|    }
   70|    359|}
_ZN3tox4test13FakeUdpSocket4bindEPK7IP_Port:
   73|    322|{
   74|    322|    std::lock_guard<std::mutex> lock(mutex_);
   75|    322|    if (local_port_ != 0)
  ------------------
  |  Branch (75:9): [True: 0, False: 322]
  ------------------
   76|      0|        return -1;  // Already bound
   77|       |
   78|    322|    uint16_t port = addr->port;
   79|    322|    if (port == 0) {
  ------------------
  |  Branch (79:9): [True: 0, False: 322]
  ------------------
   80|      0|        port = universe_.find_free_port(ip_);
   81|    322|    } else {
   82|    322|        port = net_ntohs(port);
   83|    322|    }
   84|       |
   85|    322|    if (universe_.bind_udp(ip_, port, this)) {
  ------------------
  |  Branch (85:9): [True: 228, False: 94]
  ------------------
   86|    228|        local_port_ = port;
   87|    228|        return 0;
   88|    228|    }
   89|    322|    errno = EADDRINUSE;
   90|     94|    return -1;
   91|    322|}
_ZN3tox4test13FakeUdpSocket6sendtoEPKhmPK7IP_Port:
  128|     97|{
  129|     97|    std::lock_guard<std::mutex> lock(mutex_);
  130|     97|    if (local_port_ == 0) {
  ------------------
  |  Branch (130:9): [True: 0, False: 97]
  ------------------
  131|       |        // Implicit bind
  132|      0|        uint16_t p = universe_.find_free_port(ip_);
  133|      0|        if (universe_.bind_udp(ip_, p, this)) {
  ------------------
  |  Branch (133:13): [True: 0, False: 0]
  ------------------
  134|      0|            local_port_ = p;
  135|      0|        } else {
  136|      0|            errno = EADDRINUSE;
  137|      0|            return -1;
  138|      0|        }
  139|      0|    }
  140|       |
  141|     97|    Packet p{};
  142|       |    // Source
  143|     97|    p.from.ip = ip_;
  144|     97|    p.from.port = net_htons(local_port_);
  145|     97|    p.to = *addr;
  146|     97|    p.data.assign(buf, buf + len);
  147|     97|    p.is_tcp = false;
  148|       |
  149|     97|    universe_.send_packet(p);
  150|     97|    if (universe_.is_verbose()) {
  ------------------
  |  Branch (150:9): [True: 0, False: 97]
  ------------------
  151|      0|        Ip_Ntoa ip_str;
  152|      0|        net_ip_ntoa(&addr->ip, &ip_str);
  153|      0|        std::cerr << "[FakeUdpSocket] sent " << len << " bytes from port " << local_port_ << " to "
  154|      0|                  << ip_str.buf << ":" << net_ntohs(addr->port) << std::endl;
  155|      0|    }
  156|     97|    return len;
  157|     97|}

_ZNK3tox4test10FakeSocket4typeEv:
   59|     99|    int type() const { return type_; }
_ZNK3tox4test10FakeSocket10local_portEv:
   60|     99|    uint16_t local_port() const { return local_port_; }
_ZN3tox4test10FakeSocket6set_ipERK2IP:
   63|    229|    void set_ip(const IP &ip) { ip_ = ip; }

_ZNK3tox4test15NetworkUniverse11IP_Port_KeyltERKS2_:
   35|  1.11k|{
   36|  1.11k|    if (port != other.port)
  ------------------
  |  Branch (36:9): [True: 471, False: 644]
  ------------------
   37|    471|        return port < other.port;
   38|    644|    if (ip.family.value != other.ip.family.value)
  ------------------
  |  Branch (38:9): [True: 0, False: 644]
  ------------------
   39|      0|        return ip.family.value < other.ip.family.value;
   40|       |
   41|    644|    if (net_family_is_ipv4(ip.family)) {
  ------------------
  |  Branch (41:9): [True: 644, False: 0]
  ------------------
   42|    644|        return ip.ip.v4.uint32 < other.ip.ip.v4.uint32;
   43|    644|    }
   44|       |
   45|      0|    return std::memcmp(&ip.ip.v6, &other.ip.ip.v6, sizeof(ip.ip.v6)) < 0;
   46|    644|}
_ZN3tox4test15NetworkUniverseC2Ev:
   48|    136|NetworkUniverse::NetworkUniverse() { }
_ZN3tox4test15NetworkUniverseD2Ev:
   49|    136|NetworkUniverse::~NetworkUniverse() { }
_ZN3tox4test15NetworkUniverse8bind_udpE2IPtPNS0_13FakeUdpSocketE:
   52|    322|{
   53|    322|    std::lock_guard<std::recursive_mutex> lock(mutex_);
   54|    322|    IP_Port_Key key{ip, port};
   55|    322|    if (udp_bindings_.count(key))
  ------------------
  |  Branch (55:9): [True: 94, False: 228]
  ------------------
   56|     94|        return false;
   57|    228|    udp_bindings_[key] = socket;
   58|    228|    return true;
   59|    322|}
_ZN3tox4test15NetworkUniverse10unbind_udpE2IPt:
   62|    228|{
   63|    228|    std::lock_guard<std::recursive_mutex> lock(mutex_);
   64|    228|    udp_bindings_.erase({ip, port});
   65|    228|}
_ZN3tox4test15NetworkUniverse11send_packetENS0_6PacketE:
   87|     97|{
   88|       |    // Apply filters
   89|     97|    for (const auto &filter : filters_) {
  ------------------
  |  Branch (89:29): [True: 0, False: 97]
  ------------------
   90|      0|        if (!filter(p))
  ------------------
  |  Branch (90:13): [True: 0, False: 0]
  ------------------
   91|      0|            return;
   92|      0|    }
   93|       |
   94|       |    // Notify observers
   95|     97|    for (const auto &observer : observers_) {
  ------------------
  |  Branch (95:31): [True: 0, False: 97]
  ------------------
   96|      0|        observer(p);
   97|      0|    }
   98|       |
   99|     97|    p.delivery_time += global_latency_ms_;
  100|       |
  101|     97|    std::lock_guard<std::recursive_mutex> lock(mutex_);
  102|     97|    p.sequence_number = next_packet_id_++;
  103|       |
  104|     97|    if (verbose_) {
  ------------------
  |  Branch (104:9): [True: 0, False: 97]
  ------------------
  105|      0|        Ip_Ntoa from_str, to_str;
  106|      0|        net_ip_ntoa(&p.from.ip, &from_str);
  107|      0|        net_ip_ntoa(&p.to.ip, &to_str);
  108|      0|        std::cerr << "[NetworkUniverse] Enqueued packet #" << p.sequence_number << " from "
  109|      0|                  << from_str.buf << ":" << net_ntohs(p.from.port) << " to " << to_str.buf << ":"
  110|      0|                  << net_ntohs(p.to.port);
  111|      0|        if (p.is_tcp) {
  ------------------
  |  Branch (111:13): [True: 0, False: 0]
  ------------------
  112|      0|            std::cerr << " (TCP Flags=" << TcpFlags{p.tcp_flags} << " Seq=" << p.seq
  113|      0|                      << " Ack=" << p.ack << ")";
  114|      0|        }
  115|      0|        std::cerr << " with size " << p.data.size() << std::endl;
  116|      0|    }
  117|       |
  118|     97|    event_queue_.push(std::move(p));
  119|     97|}
_ZNK3tox4test15NetworkUniverse10is_verboseEv:
  292|    784|bool NetworkUniverse::is_verbose() const { return verbose_; }

_ZNK3tox4test9Fuzz_Data4sizeEv:
  101|  1.75k|    std::size_t size() const { return size_; }
_ZN3tox4test9Fuzz_Data8consume1EPKc:
   63|    309|    Consumer consume1(const char *_Nonnull func) { return Consumer{func, *this}; }
_ZN3tox4test9Fuzz_Data8ConsumercvT_ItEEv:
   53|    153|        {
   54|    153|            if (sizeof(T) > fd.size())
  ------------------
  |  Branch (54:17): [True: 0, False: 153]
  ------------------
   55|      0|                return T{};
   56|    153|            const uint8_t *_Nonnull bytes = fd.consume(func, sizeof(T));
   57|    153|            T val;
   58|    153|            std::memcpy(&val, bytes, sizeof(T));
   59|    153|            return val;
   60|    153|        }
_ZN3tox4test9Fuzz_Data7consumeEPKcm:
  107|  1.21k|    {
  108|  1.21k|        if (count > size_)
  ------------------
  |  Branch (108:13): [True: 0, False: 1.21k]
  ------------------
  109|      0|            return nullptr;
  110|  1.21k|        const uint8_t *_Nonnull val = data_;
  111|  1.21k|        if (FUZZ_DEBUG) {
  ------------------
  |  Branch (111:13): [Folded, False: 1.21k]
  ------------------
  112|      0|            if (count == 1) {
  ------------------
  |  Branch (112:17): [True: 0, False: 0]
  ------------------
  113|      0|                std::printf("consume@%zu(%s): %d (0x%02x)\n", pos(), func, val[0], val[0]);
  114|      0|            } else if (count != 0) {
  ------------------
  |  Branch (114:24): [True: 0, False: 0]
  ------------------
  115|      0|                std::printf("consume@%zu(%s): %02x..%02x[%zu]\n", pos(), func, val[0],
  116|      0|                    val[count - 1], count);
  117|      0|            }
  118|      0|        }
  119|  1.21k|        data_ += count;
  120|  1.21k|        size_ -= count;
  121|  1.21k|        return val;
  122|  1.21k|    }
forwarding_fuzz_test.cc:_ZN3tox4test18fuzz_select_targetIJXadL_ZN12_GLOBAL__N_122TestSendForwardRequestERNS0_9Fuzz_DataEEEXadL_ZNS2_16TestForwardReplyES4_EEEEEvPKhm:
  176|    156|{
  177|    156|    Fuzz_Data input{data, size};
  178|       |
  179|    156|    CONSUME1_OR_RETURN(const uint8_t, selector, input);
  ------------------
  |  |  126|    156|    if ((INPUT).size() < sizeof(TYPE)) {      \
  |  |  ------------------
  |  |  |  Branch (126:9): [True: 0, False: 156]
  |  |  ------------------
  |  |  127|      0|        return;                               \
  |  |  128|      0|    }                                         \
  |  |  129|    156|    TYPE NAME = (INPUT).consume1(__func__)
  ------------------
  180|    156|    return Fuzz_Target_Selector<Args...>::select(selector, input);
  181|    156|}
_ZN3tox4test9Fuzz_DataC2EPKhm:
   25|    156|        : data_(input_data)
   26|    156|        , base_(input_data)
   27|    156|        , size_(input_size)
   28|    156|    {
   29|    156|    }
_ZN3tox4test9Fuzz_Data8ConsumercvT_IhEEv:
   53|    156|        {
   54|    156|            if (sizeof(T) > fd.size())
  ------------------
  |  Branch (54:17): [True: 0, False: 156]
  ------------------
   55|      0|                return T{};
   56|    156|            const uint8_t *_Nonnull bytes = fd.consume(func, sizeof(T));
   57|    156|            T val;
   58|    156|            std::memcpy(&val, bytes, sizeof(T));
   59|    156|            return val;
   60|    156|        }
forwarding_fuzz_test.cc:_ZN3tox4test20Fuzz_Target_SelectorIJXadL_ZN12_GLOBAL__N_122TestSendForwardRequestERNS0_9Fuzz_DataEEEXadL_ZNS2_16TestForwardReplyES4_EEEE6selectEhS4_:
  157|    156|    {
  158|    156|        if (selector == sizeof...(Args)) {
  ------------------
  |  Branch (158:13): [True: 78, False: 78]
  ------------------
  159|     78|            return Arg(input);
  160|     78|        }
  161|     78|        return Fuzz_Target_Selector<Args...>::select(selector, input);
  162|    156|    }
forwarding_fuzz_test.cc:_ZN3tox4test20Fuzz_Target_SelectorIJXadL_ZN12_GLOBAL__N_116TestForwardReplyERNS0_9Fuzz_DataEEEEE6selectEhS4_:
  157|     78|    {
  158|     78|        if (selector == sizeof...(Args)) {
  ------------------
  |  Branch (158:13): [True: 77, False: 1]
  ------------------
  159|     77|            return Arg(input);
  160|     77|        }
  161|      1|        return Fuzz_Target_Selector<Args...>::select(selector, input);
  162|     78|    }
_ZN3tox4test20Fuzz_Target_SelectorIJEE6selectEhRNS0_9Fuzz_DataE:
  168|      1|    {
  169|       |        // The selector selected no function, so we do nothing and rely on the
  170|       |        // fuzzer to come up with a better selector.
  171|      1|    }

_ZN3tox4test10Simulation5clockEv:
  155|    136|    FakeClock &clock() { return *clock_; }
_ZN3tox4test10Simulation3netEv:
  157|    136|    NetworkUniverse &net() { return *net_; }
_ZN3tox4test13SimulatedNode12fake_networkEv:
  201|    198|    FakeNetworkStack &fake_network() { return *network_; }
_ZN3tox4test9LogFilterC2Ev:
   51|    136|    LogFilter() = default;

_ZN3tox4test11ClockSystemD2Ev:
    5|    136|ClockSystem::~ClockSystem() = default;

_ZN3tox4test11EnvironmentD2Ev:
    5|    272|Environment::~Environment() = default;

_ZN3tox4test9FakeClockC2Em:
    6|    136|    : now_ms_(start_time_ms)
    7|    136|{
    8|    136|}

_ZN3tox4test10FakeMemoryC2Ev:
   25|    272|FakeMemory::FakeMemory() = default;
_ZN3tox4test10FakeMemoryD2Ev:
   26|    272|FakeMemory::~FakeMemory() = default;
_ZN3tox4test10FakeMemory6mallocEm:
   29|    399|{
   30|    399|    bool fail = failure_injector_ && failure_injector_(size);
  ------------------
  |  Branch (30:17): [True: 399, False: 0]
  |  Branch (30:38): [True: 4, False: 395]
  ------------------
   31|       |
   32|    399|    if (observer_) {
  ------------------
  |  Branch (32:9): [True: 0, False: 399]
  ------------------
   33|      0|        observer_(!fail);
   34|      0|    }
   35|       |
   36|    399|    if (fail) {
  ------------------
  |  Branch (36:9): [True: 4, False: 395]
  ------------------
   37|      4|        return nullptr;
   38|      4|    }
   39|       |
   40|    395|    void *ptr = std::malloc(size + sizeof(Header));
   41|    395|    if (!ptr) {
  ------------------
  |  Branch (41:9): [True: 0, False: 395]
  ------------------
   42|      0|        return nullptr;
   43|      0|    }
   44|       |
   45|    395|    Header *header = static_cast<Header *>(ptr);
   46|    395|    header->size = size;
   47|    395|    header->magic = kMagic;
   48|       |
   49|    395|    on_allocation(size);
   50|       |
   51|    395|    return header + 1;
   52|    395|}
_ZN3tox4test10FakeMemory4freeEPv:
  100|    395|{
  101|    395|    if (!ptr) {
  ------------------
  |  Branch (101:9): [True: 0, False: 395]
  ------------------
  102|      0|        return;
  103|      0|    }
  104|       |
  105|    395|    Header *header = static_cast<Header *>(ptr) - 1;
  106|    395|    if (header->magic != kMagic) {
  ------------------
  |  Branch (106:9): [True: 0, False: 395]
  ------------------
  107|      0|        if (header->magic == kFreeMagic) {
  ------------------
  |  Branch (107:13): [True: 0, False: 0]
  ------------------
  108|      0|            std::cerr << "[FakeMemory] free: Double free detected at " << ptr
  109|      0|                      << " (header=" << header << ")" << std::endl;
  110|      0|        } else {
  111|      0|            std::cerr << "[FakeMemory] free: Invalid pointer (wrong magic 0x" << std::hex
  112|      0|                      << header->magic << ") at " << ptr << " (header=" << header << ")"
  113|      0|                      << std::endl;
  114|      0|        }
  115|      0|        std::abort();
  116|      0|    }
  117|       |
  118|    395|    size_t size = header->size;
  119|    395|    on_deallocation(size);
  120|    395|    header->magic = kFreeMagic;  // Mark as free
  121|    395|    std::free(header);
  122|    395|}
_ZN3tox4test10FakeMemory20set_failure_injectorENSt3__18functionIFbmEEE:
  125|    136|{
  126|    136|    failure_injector_ = std::move(injector);
  127|    136|}
_ZN3tox4test10FakeMemory8c_memoryEv:
  131|    272|struct Memory FakeMemory::c_memory() { return Memory{&kFakeMemoryVtable, this}; }
_ZN3tox4test10FakeMemory13on_allocationEm:
  138|    395|{
  139|    395|    size_t current = current_allocation_.fetch_add(size) + size;
  140|    395|    size_t max = max_allocation_.load(std::memory_order_relaxed);
  141|    395|    while (current > max && !max_allocation_.compare_exchange_weak(max, current)) { }
  ------------------
  |  Branch (141:12): [True: 395, False: 0]
  |  Branch (141:29): [True: 0, False: 395]
  ------------------
  142|    395|}
_ZN3tox4test10FakeMemory15on_deallocationEm:
  144|    395|void FakeMemory::on_deallocation(size_t size) { current_allocation_.fetch_sub(size); }
fake_memory.cc:_ZNK3tox4test3$_0clEPvj:
   15|    399|                           uint32_t size) { return static_cast<FakeMemory *>(obj)->malloc(size); },
fake_memory.cc:_ZNK3tox4test3$_2clEPvS2_:
   20|    395|    = [](void *_Nonnull obj, void *_Nullable ptr) { static_cast<FakeMemory *>(obj)->free(ptr); },

_ZN3tox4test10FakeRandomC2Em:
   21|    272|    : rng_(seed)
   22|    272|{
   23|    272|}
_ZN3tox4test10FakeRandom8c_randomEv:
   61|    272|struct Random FakeRandom::c_random() { return Random{&kFakeRandomVtable, this}; }

_ZN3tox4test28configure_fuzz_memory_sourceERNS0_10FakeMemoryERNS0_9Fuzz_DataE:
   44|    136|{
   45|    136|    memory.set_failure_injector([&input](size_t size) -> bool {
   46|    136|        if (input.size() < 1) {
   47|       |            // Legacy behavior: if input runs out, allocation succeeds.
   48|    136|            return false;
   49|    136|        }
   50|       |
   51|    136|        const uint8_t *b = input.consume("malloc_decision", 1);
   52|    136|        bool succeed = (b && *b);
   53|    136|        return !succeed;  // Return true to fail
   54|    136|    });
   55|    136|}
fuzz_helpers.cc:_ZZN3tox4test28configure_fuzz_memory_sourceERNS0_10FakeMemoryERNS0_9Fuzz_DataEENK3$_0clEm:
   45|    399|    memory.set_failure_injector([&input](size_t size) -> bool {
   46|    399|        if (input.size() < 1) {
  ------------------
  |  Branch (46:13): [True: 210, False: 189]
  ------------------
   47|       |            // Legacy behavior: if input runs out, allocation succeeds.
   48|    210|            return false;
   49|    210|        }
   50|       |
   51|    189|        const uint8_t *b = input.consume("malloc_decision", 1);
   52|    189|        bool succeed = (b && *b);
  ------------------
  |  Branch (52:25): [True: 189, False: 0]
  |  Branch (52:30): [True: 185, False: 4]
  ------------------
   53|    189|        return !succeed;  // Return true to fail
   54|    399|    });

_ZN3tox4test12MemorySystemD2Ev:
    5|    272|MemorySystem::~MemorySystem() = default;

_ZN3tox4test13NetworkSystemD2Ev:
    5|    136|NetworkSystem::~NetworkSystem() = default;
_ZN3tox4test7make_ipEj:
    8|    272|{
    9|    272|    IP ip;
   10|    272|    ip_init(&ip, false);
   11|    272|    ip.ip.v4.uint32 = net_htonl(ipv4);
   12|    272|    return ip;
   13|    272|}
_ZN3tox4test12make_node_ipEj:
   16|    272|{
   17|       |    // Use 20.x.y.z range: 20. (id >> 16) . (id >> 8) . (id & 0xFF)
   18|    272|    return make_ip(0x14000000 | (node_id & 0x00FFFFFF));
   19|    272|}

_ZN3tox4test12RandomSystemD2Ev:
    5|    272|RandomSystem::~RandomSystem() = default;

_ZN3tox4test20SimulatedEnvironmentC2Ev:
    8|    136|    : sim_(std::make_unique<Simulation>())
    9|    136|    , global_random_(std::make_unique<FakeRandom>(12345))
   10|    136|    , global_memory_(std::make_unique<FakeMemory>())
   11|    136|{
   12|    136|}
_ZN3tox4test20SimulatedEnvironmentD2Ev:
   14|    136|SimulatedEnvironment::~SimulatedEnvironment() = default;
_ZN3tox4test20SimulatedEnvironment11fake_memoryEv:
   34|    136|FakeMemory &SimulatedEnvironment::fake_memory() { return *global_memory_; }
_ZN3tox4test20SimulatedEnvironment11create_nodeEt:
   37|    136|{
   38|    136|    auto scoped = std::make_unique<ScopedToxSystem>();
   39|    136|    scoped->node = sim_->create_node();
   40|       |
   41|       |    // Bind port
   42|    136|    if (port != 0) {
  ------------------
  |  Branch (42:9): [True: 99, False: 37]
  ------------------
   43|     99|        Socket s = scoped->node->fake_network().socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
   44|     99|        IP_Port addr;
   45|     99|        ip_init(&addr.ip, false);
   46|     99|        addr.ip.ip.v4.uint32 = 0;
   47|     99|        addr.port = net_htons(port);
   48|     99|        scoped->node->fake_network().bind(s, &addr);
   49|     99|    }
   50|       |
   51|       |    // Get Primary Endpoint for Fuzzer
   52|    136|    scoped->endpoint = scoped->node->get_primary_socket();
   53|       |
   54|       |    // Use global Random and Memory for legacy compatibility.
   55|    136|    scoped->c_random = global_random_->c_random();
   56|    136|    scoped->c_memory = global_memory_->c_memory();
   57|       |
   58|       |    // Use Node's Network
   59|    136|    scoped->c_network = scoped->node->c_network;
   60|       |
   61|       |    // Setup System
   62|    136|    scoped->system.mem = &scoped->c_memory;
   63|    136|    scoped->system.ns = &scoped->c_network;
   64|    136|    scoped->system.rng = &scoped->c_random;
   65|       |
   66|    136|    scoped->system.mono_time_user_data = &sim_->clock();
   67|    136|    scoped->system.mono_time_callback = [](void *_Nullable user_data) -> uint64_t {
   68|    136|        return static_cast<FakeClock *>(user_data)->current_time_ms();
   69|    136|    };
   70|       |
   71|    136|    return scoped;
   72|    136|}

_ZN3tox4test10SimulationC2Ev:
   97|    136|    : clock_(std::make_unique<FakeClock>())
   98|    136|    , net_(std::make_unique<NetworkUniverse>())
   99|    136|{
  100|    136|}
_ZN3tox4test10SimulationD2Ev:
  102|    136|Simulation::~Simulation() = default;
_ZN3tox4test10Simulation11create_nodeEv:
  236|    136|{
  237|    136|    auto node = std::make_unique<SimulatedNode>(*this, ++node_count_);
  238|    136|    if (net_->is_verbose()) {
  ------------------
  |  Branch (238:9): [True: 0, False: 136]
  ------------------
  239|      0|        uint32_t ip4 = net_ntohl(node->ip.ip.v4.uint32);
  240|      0|        std::cerr << "[Simulation] Created node " << node_count_ << " with IP "
  241|      0|                  << ((ip4 >> 24) & 0xFF) << "." << ((ip4 >> 16) & 0xFF) << "."
  242|      0|                  << ((ip4 >> 8) & 0xFF) << "." << (ip4 & 0xFF) << std::endl;
  243|      0|    }
  244|    136|    return node;
  245|    136|}
_ZN3tox4test13SimulatedNodeC2ERNS0_10SimulationEj:
  250|    136|    : sim_(sim)
  251|    136|    , network_(std::make_unique<FakeNetworkStack>(sim.net(), make_node_ip(node_id)))
  252|    136|    , random_(std::make_unique<FakeRandom>(12345 + node_id))  // Unique seed
  253|    136|    , memory_(std::make_unique<FakeMemory>())
  254|    136|    , c_network(network_->c_network())
  255|    136|    , c_random(random_->c_random())
  256|    136|    , c_memory(memory_->c_memory())
  257|    136|    , ip(make_node_ip(node_id))
  258|    136|{
  259|    136|}
_ZN3tox4test13SimulatedNodeD2Ev:
  261|    136|SimulatedNode::~SimulatedNode() = default;
_ZN3tox4test13SimulatedNode18get_primary_socketEv:
  331|    136|{
  332|    136|    auto sockets = network_->get_bound_udp_sockets();
  333|    136|    if (sockets.empty())
  ------------------
  |  Branch (333:9): [True: 37, False: 99]
  ------------------
  334|     37|        return nullptr;
  335|     99|    return sockets.front();  // Return the first one bound
  336|    136|}

send_forward_request:
   45|     69|{
   46|     69|    if (chain_length == 0 || chain_length > MAX_FORWARD_CHAIN_LENGTH
  ------------------
  |  |   32|    137|#define MAX_FORWARD_CHAIN_LENGTH 4
  ------------------
  |  Branch (46:9): [True: 1, False: 68]
  |  Branch (46:30): [True: 1, False: 67]
  ------------------
   47|     67|            || data_length > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   30|     67|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   28|     67|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   29|     67|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (47:16): [True: 1, False: 66]
  ------------------
   48|      3|        return false;
   49|      3|    }
   50|       |
   51|     66|    const uint16_t len = forward_chain_packet_size(chain_length, data_length);
   52|     66|    VLA(uint8_t, packet, len);
  ------------------
  |  |   59|     66|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     66|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
   53|       |
   54|     66|    return create_forward_chain_packet(chain_keys, chain_length, data, data_length, packet)
  ------------------
  |  Branch (54:12): [True: 66, False: 0]
  ------------------
   55|     66|           && sendpacket(net, forwarder, packet, len) == len;
  ------------------
  |  Branch (55:15): [True: 60, False: 6]
  ------------------
   56|     69|}
forward_chain_packet_size:
   59|     66|{
   60|     66|    return chain_length * (1 + CRYPTO_PUBLIC_KEY_SIZE) + data_length;
  ------------------
  |  |   44|     66|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   61|     66|}
create_forward_chain_packet:
   66|     66|{
   67|     66|    if (chain_length == 0 || chain_length > MAX_FORWARD_CHAIN_LENGTH
  ------------------
  |  |   32|    132|#define MAX_FORWARD_CHAIN_LENGTH 4
  ------------------
  |  Branch (67:9): [True: 0, False: 66]
  |  Branch (67:30): [True: 0, False: 66]
  ------------------
   68|     66|            || data_length > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   30|     66|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   28|     66|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   29|     66|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (68:16): [True: 0, False: 66]
  ------------------
   69|      0|        return false;
   70|      0|    }
   71|       |
   72|     66|    uint16_t offset = 0;
   73|       |
   74|    138|    for (uint16_t j = 0; j < chain_length; ++j) {
  ------------------
  |  Branch (74:26): [True: 72, False: 66]
  ------------------
   75|     72|        packet[offset] = NET_PACKET_FORWARD_REQUEST;
   76|     72|        ++offset;
   77|     72|        memcpy(packet + offset, chain_keys + j * CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     72|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                      memcpy(packet + offset, chain_keys + j * CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     72|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   78|     72|        offset += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   44|     72|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   79|     72|    }
   80|       |
   81|     66|    memcpy(packet + offset, data, data_length);
   82|       |    return true;
   83|     66|}
forward_reply:
  313|     60|{
  314|     60|    if (sendback_length > MAX_SENDBACK_SIZE ||
  ------------------
  |  |   29|    120|#define MAX_SENDBACK_SIZE (0xff - 1)
  ------------------
  |  Branch (314:9): [True: 1, False: 59]
  ------------------
  315|     59|            length > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   30|     59|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   28|     59|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   29|     59|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (315:13): [True: 1, False: 58]
  ------------------
  316|      2|        return false;
  317|      2|    }
  318|       |
  319|     58|    const uint16_t len = 1 + 1 + sendback_length + length;
  320|     58|    VLA(uint8_t, packet, len);
  ------------------
  |  |   59|     58|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     58|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  321|     58|    packet[0] = NET_PACKET_FORWARD_REPLY;
  322|     58|    packet[1] = (uint8_t) sendback_length;
  323|     58|    memcpy(packet + 1 + 1, sendback, sendback_length);
  324|     58|    memcpy(packet + 1 + 1 + sendback_length, data, length);
  325|     58|    return sendpacket(net, forwarder, packet, len) == len;
  326|     60|}

LLVMFuzzerTestOneInput:
  113|    156|{
  114|    156|    tox::test::fuzz_select_target<TestSendForwardRequest, TestForwardReply>(data, size);
  115|    156|    return 0;
  116|    156|}
forwarding_fuzz_test.cc:_ZN12_GLOBAL__N_122TestSendForwardRequestERN3tox4test9Fuzz_DataE:
   47|     78|{
   48|     78|    CONSUME1_OR_RETURN(const std::uint16_t, chain_length, input);
  ------------------
  |  |  126|     78|    if ((INPUT).size() < sizeof(TYPE)) {      \
  |  |  ------------------
  |  |  |  Branch (126:9): [True: 1, False: 77]
  |  |  ------------------
  |  |  127|      1|        return;                               \
  |  |  128|      1|    }                                         \
  |  |  129|     78|    TYPE NAME = (INPUT).consume1(__func__)
  ------------------
   49|     77|    const std::uint16_t chain_keys_size = chain_length * CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   44|     77|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   50|     77|    CONSUME_OR_RETURN(const std::uint8_t *chain_keys, input, chain_keys_size);
  ------------------
  |  |  138|     77|    if ((INPUT).size() < (SIZE)) {           \
  |  |  ------------------
  |  |  |  Branch (138:9): [True: 1, False: 76]
  |  |  ------------------
  |  |  139|      1|        return;                              \
  |  |  140|      1|    }                                        \
  |  |  141|     77|    DECL = (INPUT).consume(__func__, (SIZE))
  ------------------
   51|       |
   52|     76|    const auto prep = prepare(input);
   53|     76|    if (!prep.has_value()) {
  ------------------
  |  Branch (53:9): [True: 4, False: 72]
  ------------------
   54|      4|        return;
   55|      4|    }
   56|     72|    const auto [ipp, forwarder, data, data_size] = prep.value();
   57|       |
   58|     72|    SimulatedEnvironment env;
   59|     72|    auto node = env.create_node(ipp.port);
   60|     72|    configure_fuzz_memory_source(env.fake_memory(), input);
   61|       |
   62|     72|    const Ptr<Logger> logger(logger_new(&node->c_memory), logger_kill);
   63|     72|    if (logger == nullptr) {
  ------------------
  |  Branch (63:9): [True: 1, False: 71]
  ------------------
   64|      1|        return;
   65|      1|    }
   66|       |
   67|     71|    const Ptr<Networking_Core> net(
   68|     71|        new_networking_ex(logger.get(), &node->c_memory, &node->c_network, &ipp.ip, ipp.port,
   69|     71|            ipp.port + 100, nullptr),
   70|     71|        kill_networking);
   71|     71|    if (net == nullptr) {
  ------------------
  |  Branch (71:9): [True: 2, False: 69]
  ------------------
   72|      2|        return;
   73|      2|    }
   74|       |
   75|     69|    send_forward_request(net.get(), &forwarder, chain_keys, chain_length, data, data_size);
   76|     69|}
forwarding_fuzz_test.cc:_ZN12_GLOBAL__N_17prepareERN3tox4test9Fuzz_DataE:
   25|    151|{
   26|    151|    CONSUME_OR_RETURN_VAL(const std::uint8_t *ipp_packed, input, SIZE_IP_PORT, std::nullopt);
  ------------------
  |  |  144|    151|    if ((INPUT).size() < (SIZE)) {                    \
  |  |  ------------------
  |  |  |  Branch (144:9): [True: 2, False: 149]
  |  |  ------------------
  |  |  145|      2|        return (VAL);                                 \
  |  |  146|      2|    }                                                 \
  |  |  147|    151|    DECL = (INPUT).consume(__func__, (SIZE))
  ------------------
   27|    149|    IP_Port ipp{};
   28|    149|    unpack_ip_port(&ipp, ipp_packed, SIZE_IP6, true);
  ------------------
  |  |   26|    149|#define SIZE_IP6 16
  ------------------
   29|       |
   30|    149|    CONSUME_OR_RETURN_VAL(const std::uint8_t *forwarder_packed, input, SIZE_IP_PORT, std::nullopt);
  ------------------
  |  |  144|    149|    if ((INPUT).size() < (SIZE)) {                    \
  |  |  ------------------
  |  |  |  Branch (144:9): [True: 5, False: 144]
  |  |  ------------------
  |  |  145|      5|        return (VAL);                                 \
  |  |  146|      5|    }                                                 \
  |  |  147|    149|    DECL = (INPUT).consume(__func__, (SIZE))
  ------------------
   31|    144|    IP_Port forwarder{};
   32|    144|    unpack_ip_port(&forwarder, forwarder_packed, SIZE_IP6, true);
  ------------------
  |  |   26|    144|#define SIZE_IP6 16
  ------------------
   33|       |
   34|       |    // 2 bytes: size of the request
   35|    144|    CONSUME_OR_RETURN_VAL(
  ------------------
  |  |  144|    144|    if ((INPUT).size() < (SIZE)) {                    \
  |  |  ------------------
  |  |  |  Branch (144:9): [True: 6, False: 138]
  |  |  ------------------
  |  |  145|      6|        return (VAL);                                 \
  |  |  146|      6|    }                                                 \
  |  |  147|    144|    DECL = (INPUT).consume(__func__, (SIZE))
  ------------------
   36|    138|        const std::uint8_t *data_size_bytes, input, sizeof(std::uint16_t), std::nullopt);
   37|    138|    std::uint16_t data_size;
   38|    138|    std::memcpy(&data_size, data_size_bytes, sizeof(std::uint16_t));
   39|       |
   40|       |    // data bytes (max 64K)
   41|    138|    CONSUME_OR_RETURN_VAL(const std::uint8_t *data, input, data_size, std::nullopt);
  ------------------
  |  |  144|    138|    if ((INPUT).size() < (SIZE)) {                    \
  |  |  ------------------
  |  |  |  Branch (144:9): [True: 2, False: 136]
  |  |  ------------------
  |  |  145|      2|        return (VAL);                                 \
  |  |  146|      2|    }                                                 \
  |  |  147|    138|    DECL = (INPUT).consume(__func__, (SIZE))
  ------------------
   42|       |
   43|    136|    return {{ipp, forwarder, data, data_size}};
   44|    138|}
forwarding_fuzz_test.cc:_ZN12_GLOBAL__N_116TestForwardReplyERN3tox4test9Fuzz_DataE:
   79|     77|{
   80|     77|    CONSUME1_OR_RETURN(const std::uint16_t, sendback_length, input);
  ------------------
  |  |  126|     77|    if ((INPUT).size() < sizeof(TYPE)) {      \
  |  |  ------------------
  |  |  |  Branch (126:9): [True: 1, False: 76]
  |  |  ------------------
  |  |  127|      1|        return;                               \
  |  |  128|      1|    }                                         \
  |  |  129|     77|    TYPE NAME = (INPUT).consume1(__func__)
  ------------------
   81|     76|    CONSUME_OR_RETURN(const std::uint8_t *sendback, input, sendback_length);
  ------------------
  |  |  138|     76|    if ((INPUT).size() < (SIZE)) {           \
  |  |  ------------------
  |  |  |  Branch (138:9): [True: 1, False: 75]
  |  |  ------------------
  |  |  139|      1|        return;                              \
  |  |  140|      1|    }                                        \
  |  |  141|     76|    DECL = (INPUT).consume(__func__, (SIZE))
  ------------------
   82|       |
   83|     75|    const auto prep = prepare(input);
   84|     75|    if (!prep.has_value()) {
  ------------------
  |  Branch (84:9): [True: 11, False: 64]
  ------------------
   85|     11|        return;
   86|     11|    }
   87|     64|    const auto [ipp, forwarder, data, data_size] = prep.value();
   88|       |
   89|     64|    SimulatedEnvironment env;
   90|     64|    auto node = env.create_node(ipp.port);
   91|     64|    configure_fuzz_memory_source(env.fake_memory(), input);
   92|       |
   93|     64|    const Ptr<Logger> logger(logger_new(&node->c_memory), logger_kill);
   94|     64|    if (logger == nullptr) {
  ------------------
  |  Branch (94:9): [True: 1, False: 63]
  ------------------
   95|      1|        return;
   96|      1|    }
   97|       |
   98|     63|    const Ptr<Networking_Core> net(
   99|     63|        new_networking_ex(logger.get(), &node->c_memory, &node->c_network, &ipp.ip, ipp.port,
  100|     63|            ipp.port + 100, nullptr),
  101|     63|        kill_networking);
  102|     63|    if (net == nullptr) {
  ------------------
  |  Branch (102:9): [True: 3, False: 60]
  ------------------
  103|      3|        return;
  104|      3|    }
  105|       |
  106|     60|    forward_reply(net.get(), &forwarder, sendback, sendback_length, data, data_size);
  107|     60|}

logger_new:
   33|    136|{
   34|    136|    Logger *log = (Logger *)mem_alloc(mem, sizeof(Logger));
   35|       |
   36|    136|    if (log == nullptr) {
  ------------------
  |  |   63|    136|#define nullptr NULL
  ------------------
  |  Branch (36:9): [True: 2, False: 134]
  ------------------
   37|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
   38|      2|    }
   39|       |
   40|    134|    log->mem = mem;
   41|       |
   42|    134|    return log;
   43|    136|}
logger_kill:
   46|    134|{
   47|    134|    if (log == nullptr) {
  ------------------
  |  |   63|    134|#define nullptr NULL
  ------------------
  |  Branch (47:9): [True: 0, False: 134]
  ------------------
   48|      0|        return;
   49|      0|    }
   50|       |
   51|    134|    mem_delete(log->mem, log);
   52|    134|}
logger_write:
   64|     16|{
   65|     16|    if (log == nullptr) {
  ------------------
  |  |   63|     16|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 0, False: 16]
  ------------------
   66|      0|        return;
   67|      0|    }
   68|       |
   69|     16|    if (log->callback == nullptr) {
  ------------------
  |  |   63|     16|#define nullptr NULL
  ------------------
  |  Branch (69:9): [True: 16, False: 0]
  ------------------
   70|     16|        return;
   71|     16|    }
   72|       |
   73|       |    // Only pass the file name, not the entire file path, for privacy reasons.
   74|       |    // The full path may contain PII of the person compiling toxcore (their
   75|       |    // username and directory layout).
   76|      0|    const char *filename = strrchr(file, '/');
   77|      0|    if (filename != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (77:9): [True: 0, False: 0]
  ------------------
   78|      0|        file = &filename[1];
   79|      0|    }
   80|       |#if defined(_WIN32) || defined(__CYGWIN__)
   81|       |    // On Windows, the path separator *may* be a backslash, so we look for that
   82|       |    // one too.
   83|       |    const char *windows_filename = strrchr(file, '\\');
   84|       |    file = windows_filename != nullptr ? windows_filename + 1 : file;
   85|       |#endif /* WIN32 */
   86|       |
   87|       |    // Format message
   88|      0|    char msg[1024];
   89|      0|    va_list args;
   90|      0|    va_start(args, format);
   91|      0|    vsnprintf(msg, sizeof(msg), format, args);
   92|      0|    va_end(args);
   93|       |
   94|      0|    log->callback(log->context, level, file, line, func, msg, log->userdata);
   95|      0|}

mem_balloc:
   13|    399|{
   14|    399|    void *const ptr = mem->funcs->malloc_callback(mem->user_data, size);
   15|    399|    return ptr;
   16|    399|}
mem_alloc:
   25|    399|{
   26|    399|    void *const ptr = mem_balloc(mem, size);
   27|    399|    if (ptr != nullptr) {
  ------------------
  |  |   63|    399|#define nullptr NULL
  ------------------
  |  Branch (27:9): [True: 395, False: 4]
  ------------------
   28|    395|        memset(ptr, 0, size);
   29|    395|    }
   30|    399|    return ptr;
   31|    399|}
mem_delete:
   58|    395|{
   59|    395|    mem->funcs->dealloc_callback(mem->user_data, ptr);
   60|    395|}

net_socket_to_native:
    9|  1.06k|{
   10|  1.06k|    return (force int)sock.value;
   11|  1.06k|}
net_socket_from_native:
   14|    359|{
   15|    359|    const Socket res = {(force Socket_Value)sock};
   16|    359|    return res;
   17|    359|}
ns_close:
   20|    130|{
   21|    130|    return ns->funcs->close(ns->obj, sock);
   22|    130|}
ns_bind:
   30|    223|{
   31|    223|    return ns->funcs->bind(ns->obj, sock, addr);
   32|    223|}
ns_sendto:
   65|     97|{
   66|     97|    return ns->funcs->sendto(ns->obj, sock, buf, len, addr);
   67|     97|}
ns_socket:
   70|    130|{
   71|    130|    return ns->funcs->socket(ns->obj, domain, type, proto);
   72|    130|}
ns_socket_nonblock:
   75|    130|{
   76|    130|    return ns->funcs->socket_nonblock(ns->obj, sock, nonblock);
   77|    130|}
ns_setsockopt:
   85|    390|{
   86|    390|    return ns->funcs->setsockopt(ns->obj, sock, level, optname, optval, optlen);
   87|    390|}
net_family_ipv4:
  180|    964|{
  181|    964|    return family_ipv4;
  182|    964|}
net_family_ipv6:
  185|      3|{
  186|      3|    return family_ipv6;
  187|      3|}
net_family_tcp_ipv4:
  200|     16|{
  201|     16|    return family_tcp_ipv4;
  202|     16|}
net_family_tcp_ipv6:
  205|      5|{
  206|      5|    return family_tcp_ipv6;
  207|      5|}
net_family_is_unspec:
  220|    363|{
  221|    363|    return family.value == family_unspec.value;
  222|    363|}
net_family_is_ipv4:
  225|  1.23k|{
  226|  1.23k|    return family.value == family_ipv4.value;
  227|  1.23k|}
net_family_is_ipv6:
  230|    359|{
  231|    359|    return family.value == family_ipv6.value;
  232|    359|}
net_family_is_tcp_ipv4:
  245|     12|{
  246|     12|    return family.value == family_tcp_ipv4.value;
  247|     12|}

net_log_data:
  155|     97|{
  156|     97|    if (res < 0) { /* Windows doesn't necessarily know `%zu` */
  ------------------
  |  Branch (156:9): [True: 0, False: 97]
  ------------------
  157|      0|        Ip_Ntoa ip_str;
  158|      0|        const int error = net_error();
  159|      0|        Net_Strerror error_str;
  160|      0|        LOGGER_TRACE(log, "[%02x = %-21s] %s %3u%c %s:%u (%d: %s) | %08x%08x...%02x",
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  161|      0|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  162|      0|                     min_u16(buflen, 999), 'E',
  163|      0|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), error,
  164|      0|                     net_strerror(error, &error_str), data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  165|     97|    } else if ((res > 0) && ((size_t)res <= buflen)) {
  ------------------
  |  Branch (165:16): [True: 97, False: 0]
  |  Branch (165:29): [True: 97, False: 0]
  ------------------
  166|     97|        Ip_Ntoa ip_str;
  167|     97|        LOGGER_TRACE(log, "[%02x = %-21s] %s %3u%c %s:%u (%d: %s) | %08x%08x...%02x",
  ------------------
  |  |   76|     97|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     97|    do {                                                                         \
  |  |  |  |   70|     97|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    194|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 97]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (71:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     97|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 97]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  168|     97|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  169|     97|                     min_u16(res, 999), (size_t)res < buflen ? '<' : '=',
  170|     97|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
  171|     97|                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  172|     97|    } else { /* empty or overwrite */
  173|      0|        Ip_Ntoa ip_str;
  174|      0|        LOGGER_TRACE(log, "[%02x = %-21s] %s %ld%c%u %s:%u (%d: %s) | %08x%08x...%02x",
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (71:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  175|      0|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  176|      0|                     res, res == 0 ? '!' : '>', buflen,
  177|      0|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
  178|      0|                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  179|      0|    }
  180|     97|}

netprof_record_packet:
   72|     97|{
   73|     97|    if (profile == nullptr) {
  ------------------
  |  |   63|     97|#define nullptr NULL
  ------------------
  |  Branch (73:9): [True: 0, False: 97]
  ------------------
   74|      0|        return;
   75|      0|    }
   76|       |
   77|     97|    if (dir == PACKET_DIRECTION_SEND) {
  ------------------
  |  Branch (77:9): [True: 97, False: 0]
  ------------------
   78|     97|        ++profile->total_packets_sent;
   79|     97|        ++profile->packets_sent[id];
   80|       |
   81|     97|        profile->total_bytes_sent += length;
   82|     97|        profile->bytes_sent[id] += length;
   83|     97|    } else {
   84|      0|        ++profile->total_packets_recv;
   85|      0|        ++profile->packets_recv[id];
   86|       |
   87|      0|        profile->total_bytes_recv += length;
   88|      0|        profile->bytes_recv[id] += length;
   89|      0|    }
   90|     97|}
netprof_new:
  139|    131|{
  140|    131|    Net_Profile *np = (Net_Profile *)mem_alloc(mem, sizeof(Net_Profile));
  141|       |
  142|    131|    if (np == nullptr) {
  ------------------
  |  |   63|    131|#define nullptr NULL
  ------------------
  |  Branch (142:9): [True: 1, False: 130]
  ------------------
  143|      1|        LOGGER_ERROR(log, "failed to allocate memory for net profiler");
  ------------------
  |  |   80|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  144|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  145|      1|    }
  146|       |
  147|    130|    return np;
  148|    131|}
netprof_kill:
  151|    130|{
  152|    130|    if (net_profile != nullptr) {
  ------------------
  |  |   63|    130|#define nullptr NULL
  ------------------
  |  Branch (152:9): [True: 130, False: 0]
  ------------------
  153|    130|        mem_delete(mem, net_profile);
  154|    130|    }
  155|    130|}

sock_valid:
   56|    130|{
   57|    130|    const Socket invalid_socket = net_invalid_socket();
   58|    130|    return sock.value != invalid_socket.value;
   59|    130|}
kill_sock:
   94|    130|{
   95|    130|    ns_close(ns, sock);
   96|    130|}
set_socket_nonblock:
   99|    130|{
  100|    130|    return net_set_socket_nonblock(ns, sock);
  101|    130|}
set_socket_nosigpipe:
  104|    130|{
  105|    130|    return net_set_socket_nosigpipe(ns, sock);
  106|    130|}
net_send_packet:
  151|    124|{
  152|    124|    IP_Port ipp_copy = *ip_port;
  153|       |
  154|    124|    if (net_family_is_unspec(ip_port->ip.family)) {
  ------------------
  |  Branch (154:9): [True: 15, False: 109]
  ------------------
  155|       |        // TODO(iphydf): Make this an error. Currently this fails sometimes when
  156|       |        // called from DHT.c:do_ping_and_sendnode_requests.
  157|     15|        return -1;
  158|     15|    }
  159|       |
  160|    109|    if (net_family_is_unspec(net->family)) { /* Socket not initialized */
  ------------------
  |  Branch (160:9): [True: 0, False: 109]
  ------------------
  161|       |        // TODO(iphydf): Make this an error. Currently, the onion client calls
  162|       |        // this via DHT nodes requests.
  163|      0|        LOGGER_WARNING(net->log, "attempted to send message of length %u on uninitialised socket", packet.length);
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  164|      0|        return -1;
  165|      0|    }
  166|       |
  167|       |    /* socket TOX_AF_INET, but target IP NOT: can't send */
  168|    109|    if (net_family_is_ipv4(net->family) && !net_family_is_ipv4(ipp_copy.ip.family)) {
  ------------------
  |  Branch (168:9): [True: 109, False: 0]
  |  Branch (168:44): [True: 12, False: 97]
  ------------------
  169|       |        // TODO(iphydf): Make this an error. Occasionally we try to send to an
  170|       |        // all-zero ip_port.
  171|     12|        Ip_Ntoa ip_str;
  172|     12|        LOGGER_WARNING(net->log, "attempted to send message with network family %d (probably IPv6) on IPv4 socket (%s)",
  ------------------
  |  |   79|     12|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     12|    do {                                                                         \
  |  |  |  |   70|     12|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     24|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 12, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     12|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     12|        }                                                                        \
  |  |  |  |   73|     12|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 12]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  173|     12|                       ipp_copy.ip.family.value, net_ip_ntoa(&ipp_copy.ip, &ip_str));
  174|     12|        return -1;
  175|     12|    }
  176|       |
  177|     97|    if (net_family_is_ipv4(ipp_copy.ip.family) && net_family_is_ipv6(net->family)) {
  ------------------
  |  Branch (177:9): [True: 97, False: 0]
  |  Branch (177:51): [True: 0, False: 97]
  ------------------
  178|       |        /* must convert to IPV4-in-IPV6 address */
  179|      0|        IP6 ip6;
  180|       |
  181|       |        /* there should be a macro for this in a standards compliant
  182|       |         * environment, not found */
  183|      0|        ip6.uint32[0] = 0;
  184|      0|        ip6.uint32[1] = 0;
  185|      0|        ip6.uint32[2] = net_htonl(0xFFFF);
  186|      0|        ip6.uint32[3] = ipp_copy.ip.ip.v4.uint32;
  187|       |
  188|      0|        ipp_copy.ip.family = net_family_ipv6();
  189|      0|        ipp_copy.ip.ip.v6 = ip6;
  190|      0|    }
  191|       |
  192|     97|    const long res = ns_sendto(net->ns, net->sock, packet.data, packet.length, &ipp_copy);
  193|     97|    net_log_data(net->log, "O=>", packet.data, packet.length, ip_port, res);
  194|       |
  195|     97|    assert(res <= INT_MAX);
  ------------------
  |  Branch (195:5): [True: 97, False: 0]
  ------------------
  196|       |
  197|     97|    if (res == packet.length && packet.data != nullptr) {
  ------------------
  |  |   63|     97|#define nullptr NULL
  ------------------
  |  Branch (197:9): [True: 97, False: 0]
  |  Branch (197:33): [True: 97, False: 0]
  ------------------
  198|     97|        netprof_record_packet(net->udp_net_profile, packet.data[0], packet.length, PACKET_DIRECTION_SEND);
  199|     97|    }
  200|       |
  201|     97|    return (int)res;
  202|     97|}
sendpacket:
  210|    124|{
  211|    124|    const Net_Packet packet = {data, length};
  212|    124|    return net_send_packet(net, ip_port, packet);
  213|    124|}
new_networking_ex:
  300|    134|{
  301|       |    /* If both from and to are 0, use default port range
  302|       |     * If one is 0 and the other is non-0, use the non-0 value as only port
  303|       |     * If from > to, swap
  304|       |     */
  305|    134|    if (port_from == 0 && port_to == 0) {
  ------------------
  |  Branch (305:9): [True: 36, False: 98]
  |  Branch (305:27): [True: 0, False: 36]
  ------------------
  306|      0|        port_from = TOX_PORTRANGE_FROM;
  ------------------
  |  |   79|      0|#define TOX_PORTRANGE_FROM 33445
  ------------------
  307|      0|        port_to = TOX_PORTRANGE_TO;
  ------------------
  |  |   80|      0|#define TOX_PORTRANGE_TO   33545
  ------------------
  308|    134|    } else if (port_from == 0 && port_to != 0) {
  ------------------
  |  Branch (308:16): [True: 36, False: 98]
  |  Branch (308:34): [True: 36, False: 0]
  ------------------
  309|     36|        port_from = port_to;
  310|     98|    } else if (port_from != 0 && port_to == 0) {
  ------------------
  |  Branch (310:16): [True: 98, False: 0]
  |  Branch (310:34): [True: 1, False: 97]
  ------------------
  311|      1|        port_to = port_from;
  312|     97|    } else if (port_from > port_to) {
  ------------------
  |  Branch (312:16): [True: 3, False: 94]
  ------------------
  313|      3|        const uint16_t temp_port = port_from;
  314|      3|        port_from = port_to;
  315|      3|        port_to = temp_port;
  316|      3|    }
  317|       |
  318|    134|    if (error != nullptr) {
  ------------------
  |  |   63|    134|#define nullptr NULL
  ------------------
  |  Branch (318:9): [True: 0, False: 134]
  ------------------
  319|      0|        *error = 2;
  320|      0|    }
  321|       |
  322|       |    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
  323|    134|    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (323:9): [True: 2, False: 132]
  |  Branch (323:44): [True: 2, False: 0]
  ------------------
  324|      2|        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
  ------------------
  |  |   80|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      2|    do {                                                                         \
  |  |  |  |   70|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      2|        }                                                                        \
  |  |  |  |   73|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  325|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
  326|      2|    }
  327|       |
  328|    132|    Networking_Core *temp = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
  329|       |
  330|    132|    if (temp == nullptr) {
  ------------------
  |  |   63|    132|#define nullptr NULL
  ------------------
  |  Branch (330:9): [True: 1, False: 131]
  ------------------
  331|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  332|      1|    }
  333|       |
  334|    131|    Net_Profile *np = netprof_new(log, mem);
  335|       |
  336|    131|    if (np == nullptr) {
  ------------------
  |  |   63|    131|#define nullptr NULL
  ------------------
  |  Branch (336:9): [True: 1, False: 130]
  ------------------
  337|      1|        mem_delete(mem, temp);
  338|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  339|      1|    }
  340|       |
  341|    130|    temp->udp_net_profile = np;
  342|    130|    temp->ns = ns;
  343|    130|    temp->log = log;
  344|    130|    temp->mem = mem;
  345|    130|    temp->family = ip->family;
  346|    130|    temp->port = 0;
  347|       |
  348|       |    /* Initialize our socket. */
  349|       |    /* add log message what we're creating */
  350|    130|    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |   71|    130|#define TOX_SOCK_DGRAM 2
  ------------------
                  temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |   74|    130|#define TOX_PROTO_UDP 2
  ------------------
  351|       |
  352|       |    /* Check for socket error. */
  353|    130|    if (!sock_valid(temp->sock)) {
  ------------------
  |  Branch (353:9): [True: 0, False: 130]
  ------------------
  354|      0|        const int neterror = net_error();
  355|      0|        Net_Strerror error_str;
  356|      0|        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  357|      0|        netprof_kill(mem, temp->udp_net_profile);
  358|      0|        mem_delete(mem, temp);
  359|       |
  360|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (360:13): [True: 0, False: 0]
  ------------------
  361|      0|            *error = 1;
  362|      0|        }
  363|       |
  364|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  365|      0|    }
  366|       |
  367|       |    /* Functions to increase the size of the send and receive UDP buffers.
  368|       |     */
  369|    130|    if (!net_set_socket_buffer_size(ns, temp->sock, 1024 * 1024 * 2)) {
  ------------------
  |  Branch (369:9): [True: 0, False: 130]
  ------------------
  370|      0|        LOGGER_WARNING(log, "failed to set socket buffer size");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  371|      0|    }
  372|       |
  373|       |    /* Enable broadcast on socket */
  374|    130|    if (!net_set_socket_broadcast(ns, temp->sock)) {
  ------------------
  |  Branch (374:9): [True: 0, False: 130]
  ------------------
  375|      0|        LOGGER_ERROR(log, "failed to set socket broadcast");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  376|      0|    }
  377|       |
  378|       |    /* iOS UDP sockets are weird and apparently can SIGPIPE */
  379|    130|    if (!set_socket_nosigpipe(ns, temp->sock)) {
  ------------------
  |  Branch (379:9): [True: 0, False: 130]
  ------------------
  380|      0|        kill_networking(temp);
  381|       |
  382|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (382:13): [True: 0, False: 0]
  ------------------
  383|      0|            *error = 1;
  384|      0|        }
  385|       |
  386|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  387|      0|    }
  388|       |
  389|       |    /* Set socket nonblocking. */
  390|    130|    if (!set_socket_nonblock(ns, temp->sock)) {
  ------------------
  |  Branch (390:9): [True: 0, False: 130]
  ------------------
  391|      0|        kill_networking(temp);
  392|       |
  393|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (393:13): [True: 0, False: 0]
  ------------------
  394|      0|            *error = 1;
  395|      0|        }
  396|       |
  397|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  398|      0|    }
  399|       |
  400|       |    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
  401|    130|    uint16_t *portptr = nullptr;
  ------------------
  |  |   63|    130|#define nullptr NULL
  ------------------
  402|    130|    IP_Port addr;
  403|    130|    ip_init(&addr.ip, net_family_is_ipv6(temp->family));
  404|       |
  405|    130|    if (net_family_is_ipv4(temp->family) || net_family_is_ipv6(temp->family)) {
  ------------------
  |  Branch (405:9): [True: 130, False: 0]
  |  Branch (405:45): [True: 0, False: 0]
  ------------------
  406|    130|        ip_copy(&addr.ip, ip);
  407|    130|        addr.port = 0;
  408|    130|        portptr = &addr.port;
  409|    130|    } else {
  410|      0|        mem_delete(mem, temp);
  411|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  412|      0|    }
  413|       |
  414|    130|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (414:9): [True: 0, False: 130]
  ------------------
  415|      0|        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);
  416|       |
  417|      0|        if (is_dualstack) {
  ------------------
  |  Branch (417:13): [True: 0, False: 0]
  ------------------
  418|      0|            LOGGER_TRACE(log, "Dual-stack socket: enabled");
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  419|      0|        } else {
  420|      0|            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  421|      0|        }
  422|       |
  423|      0|        if (!net_join_multicast(ns, temp->sock, ip->family)) {
  ------------------
  |  Branch (423:13): [True: 0, False: 0]
  ------------------
  424|      0|            const int neterror = net_error();
  425|      0|            Net_Strerror error_str;
  426|      0|            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   78|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  427|      0|        } else {
  428|      0|            const int neterror = net_error();
  429|      0|            Net_Strerror error_str;
  430|      0|            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  431|      0|        }
  432|      0|    }
  433|       |
  434|       |    /* A hanging program or a different user might block the standard port.
  435|       |     * As long as it isn't a parameter coming from the commandline,
  436|       |     * try a few ports after it, to see if we can find a "free" one.
  437|       |     *
  438|       |     * If we go on without binding, the first sendto() automatically binds to
  439|       |     * a free port chosen by the system (i.e. anything from 1024 to 65535).
  440|       |     *
  441|       |     * Returning NULL after bind fails has both advantages and disadvantages:
  442|       |     * advantage:
  443|       |     *   we can rely on getting the port in the range 33445..33450, which
  444|       |     *   enables us to tell joe user to open their firewall to a small range
  445|       |     *
  446|       |     * disadvantage:
  447|       |     *   some clients might not test return of tox_new(), blindly assuming that
  448|       |     *   it worked ok (which it did previously without a successful bind)
  449|       |     */
  450|    130|    uint16_t port_to_try = port_from;
  451|    130|    *portptr = net_htons(port_to_try);
  452|       |
  453|    224|    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
  ------------------
  |  Branch (453:38): [True: 223, False: 1]
  ------------------
  454|    223|        const int res = ns_bind(ns, temp->sock, &addr);
  455|       |
  456|    223|        if (res == 0) {
  ------------------
  |  Branch (456:13): [True: 129, False: 94]
  ------------------
  457|    129|            temp->port = *portptr;
  458|       |
  459|    129|            Ip_Ntoa ip_str;
  460|    129|            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
  ------------------
  |  |   77|    129|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    129|    do {                                                                         \
  |  |  |  |   70|    129|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    258|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 129]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|    129|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 129]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  461|    129|                         net_ntohs(temp->port));
  462|       |
  463|       |            /* errno isn't reset on success, only set on failure, the failed
  464|       |             * binds with parallel clients yield a -EPERM to the outside if
  465|       |             * errno isn't cleared here */
  466|    129|            if (tries > 0) {
  ------------------
  |  Branch (466:17): [True: 129, False: 0]
  ------------------
  467|    129|                net_clear_error();
  468|    129|            }
  469|       |
  470|    129|            if (error != nullptr) {
  ------------------
  |  |   63|    129|#define nullptr NULL
  ------------------
  |  Branch (470:17): [True: 0, False: 129]
  ------------------
  471|      0|                *error = 0;
  472|      0|            }
  473|       |
  474|    129|            return temp;
  475|    129|        }
  476|       |
  477|     94|        ++port_to_try;
  478|       |
  479|     94|        if (port_to_try > port_to) {
  ------------------
  |  Branch (479:13): [True: 1, False: 93]
  ------------------
  480|      1|            port_to_try = port_from;
  481|      1|        }
  482|       |
  483|     94|        *portptr = net_htons(port_to_try);
  484|     94|    }
  485|       |
  486|      1|    Ip_Ntoa ip_str;
  487|      1|    const int neterror = net_error();
  488|      1|    Net_Strerror error_str;
  489|      1|    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u",
  ------------------
  |  |   80|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  490|      1|                 neterror, net_strerror(neterror, &error_str), net_ip_ntoa(ip, &ip_str), port_from, port_to);
  491|      1|    kill_networking(temp);
  492|       |
  493|      1|    if (error != nullptr) {
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  |  Branch (493:9): [True: 0, False: 1]
  ------------------
  494|      0|        *error = 1;
  495|      0|    }
  496|       |
  497|       |    return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  498|    130|}
kill_networking:
  518|    130|{
  519|    130|    if (net == nullptr) {
  ------------------
  |  |   63|    130|#define nullptr NULL
  ------------------
  |  Branch (519:9): [True: 0, False: 130]
  ------------------
  520|      0|        return;
  521|      0|    }
  522|       |
  523|    130|    if (!net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (523:9): [True: 130, False: 0]
  ------------------
  524|       |        /* Socket is initialized, so we close it. */
  525|    130|        kill_sock(net->ns, net->sock);
  526|    130|    }
  527|       |
  528|    130|    netprof_kill(net->mem, net->udp_net_profile);
  529|    130|    mem_delete(net->mem, net);
  530|    130|}
ip_reset:
  635|    730|{
  636|    730|    if (ip == nullptr) {
  ------------------
  |  |   63|    730|#define nullptr NULL
  ------------------
  |  Branch (636:9): [True: 0, False: 730]
  ------------------
  637|      0|        return;
  638|      0|    }
  639|       |
  640|    730|    *ip = empty_ip;
  641|    730|}
ipport_reset:
  647|    258|{
  648|    258|    if (ipport == nullptr) {
  ------------------
  |  |   63|    258|#define nullptr NULL
  ------------------
  |  Branch (648:9): [True: 0, False: 258]
  ------------------
  649|      0|        return;
  650|      0|    }
  651|       |
  652|    258|    *ipport = empty_ip_port;
  653|    258|}
ip_init:
  657|    730|{
  658|    730|    if (ip == nullptr) {
  ------------------
  |  |   63|    730|#define nullptr NULL
  ------------------
  |  Branch (658:9): [True: 0, False: 730]
  ------------------
  659|      0|        return;
  660|      0|    }
  661|       |
  662|    730|    ip_reset(ip);
  663|    730|    ip->family = ipv6enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (663:18): [True: 0, False: 730]
  ------------------
  664|    730|}
ip_copy:
  692|    130|{
  693|    130|    if (source == nullptr || target == nullptr) {
  ------------------
  |  |   63|    260|#define nullptr NULL
  ------------------
                  if (source == nullptr || target == nullptr) {
  ------------------
  |  |   63|    130|#define nullptr NULL
  ------------------
  |  Branch (693:9): [True: 0, False: 130]
  |  Branch (693:30): [True: 0, False: 130]
  ------------------
  694|      0|        return;
  695|      0|    }
  696|       |
  697|    130|    *target = *source;
  698|    130|}
unpack_ip_port:
  793|    293|{
  794|    293|    if (data == nullptr) {
  ------------------
  |  |   63|    293|#define nullptr NULL
  ------------------
  |  Branch (794:9): [True: 0, False: 293]
  ------------------
  795|      0|        return -1;
  796|      0|    }
  797|       |
  798|    293|    bool is_ipv4;
  799|    293|    Family host_family;
  800|       |
  801|    293|    if (data[0] == TOX_AF_INET) {
  ------------------
  |  |   65|    293|#define TOX_AF_INET 2
  ------------------
  |  Branch (801:9): [True: 234, False: 59]
  ------------------
  802|    234|        is_ipv4 = true;
  803|    234|        host_family = net_family_ipv4();
  804|    234|    } else if (data[0] == TOX_TCP_INET) {
  ------------------
  |  |   67|     59|#define TOX_TCP_INET 130
  ------------------
  |  Branch (804:16): [True: 16, False: 43]
  ------------------
  805|     16|        if (!tcp_enabled) {
  ------------------
  |  Branch (805:13): [True: 0, False: 16]
  ------------------
  806|      0|            return -1;
  807|      0|        }
  808|       |
  809|     16|        is_ipv4 = true;
  810|     16|        host_family = net_family_tcp_ipv4();
  811|     43|    } else if (data[0] == TOX_AF_INET6) {
  ------------------
  |  |   66|     43|#define TOX_AF_INET6 10
  ------------------
  |  Branch (811:16): [True: 3, False: 40]
  ------------------
  812|      3|        is_ipv4 = false;
  813|      3|        host_family = net_family_ipv6();
  814|     40|    } else if (data[0] == TOX_TCP_INET6) {
  ------------------
  |  |   68|     40|#define TOX_TCP_INET6 138
  ------------------
  |  Branch (814:16): [True: 5, False: 35]
  ------------------
  815|      5|        if (!tcp_enabled) {
  ------------------
  |  Branch (815:13): [True: 0, False: 5]
  ------------------
  816|      0|            return -1;
  817|      0|        }
  818|       |
  819|      5|        is_ipv4 = false;
  820|      5|        host_family = net_family_tcp_ipv6();
  821|     35|    } else {
  822|     35|        return -1;
  823|     35|    }
  824|       |
  825|    258|    ipport_reset(ip_port);
  826|       |
  827|    258|    if (is_ipv4) {
  ------------------
  |  Branch (827:9): [True: 250, False: 8]
  ------------------
  828|    250|        const uint32_t size = 1 + SIZE_IP4 + sizeof(uint16_t);
  ------------------
  |  |   25|    250|#define SIZE_IP4 4
  ------------------
  829|       |
  830|    250|        if (size > length) {
  ------------------
  |  Branch (830:13): [True: 0, False: 250]
  ------------------
  831|      0|            return -1;
  832|      0|        }
  833|       |
  834|    250|        ip_port->ip.family = host_family;
  835|    250|        memcpy(ip_port->ip.ip.v4.uint8, data + 1, SIZE_IP4);
  ------------------
  |  |   25|    250|#define SIZE_IP4 4
  ------------------
  836|    250|        memcpy(&ip_port->port, data + 1 + SIZE_IP4, sizeof(uint16_t));
  ------------------
  |  |   25|    250|#define SIZE_IP4 4
  ------------------
  837|    250|        return size;
  838|    250|    } else {
  839|      8|        const uint32_t size = 1 + SIZE_IP6 + sizeof(uint16_t);
  ------------------
  |  |   26|      8|#define SIZE_IP6 16
  ------------------
  840|       |
  841|      8|        if (size > length) {
  ------------------
  |  Branch (841:13): [True: 8, False: 0]
  ------------------
  842|      8|            return -1;
  843|      8|        }
  844|       |
  845|      0|        ip_port->ip.family = host_family;
  846|      0|        memcpy(ip_port->ip.ip.v6.uint8, data + 1, SIZE_IP6);
  ------------------
  |  |   26|      0|#define SIZE_IP6 16
  ------------------
  847|      0|        memcpy(&ip_port->port, data + 1 + SIZE_IP6, sizeof(uint16_t));
  ------------------
  |  |   26|      0|#define SIZE_IP6 16
  ------------------
  848|      0|        return size;
  849|      8|    }
  850|    258|}
net_ip_ntoa:
  853|     13|{
  854|     13|    assert(ip_str != nullptr);
  ------------------
  |  Branch (854:5): [True: 13, False: 0]
  ------------------
  855|       |
  856|     13|    ip_str->ip_is_valid = false;
  857|       |
  858|     13|    if (ip == nullptr) {
  ------------------
  |  |   63|     13|#define nullptr NULL
  ------------------
  |  Branch (858:9): [True: 0, False: 13]
  ------------------
  859|      0|        snprintf(ip_str->buf, sizeof(ip_str->buf), "(IP invalid: NULL)");
  860|      0|        ip_str->length = (uint16_t)strlen(ip_str->buf);
  861|      0|        return ip_str->buf;
  862|      0|    }
  863|       |
  864|     13|    if (!ip_parse_addr(ip, ip_str->buf, sizeof(ip_str->buf))) {
  ------------------
  |  Branch (864:9): [True: 0, False: 13]
  ------------------
  865|      0|        snprintf(ip_str->buf, sizeof(ip_str->buf), "(IP invalid, family %u)", ip->family.value);
  866|      0|        ip_str->length = (uint16_t)strlen(ip_str->buf);
  867|      0|        return ip_str->buf;
  868|      0|    }
  869|       |
  870|       |    /* brute force protection against lacking termination */
  871|     13|    ip_str->buf[sizeof(ip_str->buf) - 1] = '\0';
  872|     13|    ip_str->length = (uint16_t)strlen(ip_str->buf);
  873|     13|    ip_str->ip_is_valid = true;
  874|       |
  875|     13|    return ip_str->buf;
  876|     13|}
ip_parse_addr:
  879|     13|{
  880|     13|    if (address == nullptr || ip == nullptr) {
  ------------------
  |  |   63|     26|#define nullptr NULL
  ------------------
                  if (address == nullptr || ip == nullptr) {
  ------------------
  |  |   63|     13|#define nullptr NULL
  ------------------
  |  Branch (880:9): [True: 0, False: 13]
  |  Branch (880:31): [True: 0, False: 13]
  ------------------
  881|      0|        return false;
  882|      0|    }
  883|       |
  884|     13|    if (net_family_is_ipv4(ip->family) || net_family_is_tcp_ipv4(ip->family)) {
  ------------------
  |  Branch (884:9): [True: 1, False: 12]
  |  Branch (884:43): [True: 12, False: 0]
  ------------------
  885|     13|        return net_inet_ntop4(&ip->ip.v4, address, length) != nullptr;
  ------------------
  |  |   63|     13|#define nullptr NULL
  ------------------
  886|     13|    }
  887|       |
  888|      0|    if (net_family_is_ipv6(ip->family) || net_family_is_tcp_ipv6(ip->family)) {
  ------------------
  |  Branch (888:9): [True: 0, False: 0]
  |  Branch (888:43): [True: 0, False: 0]
  ------------------
  889|      0|        return net_inet_ntop6(&ip->ip.v6, address, length) != nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  890|      0|    }
  891|       |
  892|      0|    return false;
  893|      0|}
net_socket:
 1153|    130|{
 1154|    130|    return ns_socket(ns, domain.value, type, protocol);
 1155|    130|}

net_inet_ntop4:
  309|     13|{
  310|     13|    struct in_addr a;
  311|     13|    fill_addr4(addr, &a);
  312|     13|    return inet_ntop4(&a, buf, bufsize);
  313|     13|}
net_invalid_socket:
  586|    130|{
  587|    130|    return net_socket_from_native(INVALID_SOCKET);
  ------------------
  |  |  152|    130|#define INVALID_SOCKET (-1)
  ------------------
  588|    130|}
net_htonl:
  591|    501|{
  592|       |    return htonl(hostlong);
  593|    501|}
net_htons:
  596|    420|{
  597|       |    return htons(hostshort);
  598|    420|}
net_ntohs:
  606|    322|{
  607|       |    return ntohs(hostshort);
  608|    322|}
net_set_socket_nonblock:
  667|    130|{
  668|       |    return ns_socket_nonblock(ns, sock, true) == 0;
  669|    130|}
net_set_socket_nosigpipe:
  672|    130|{
  673|       |#if defined(__APPLE__)
  674|       |    int set = 1;
  675|       |    return ns_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
  676|       |#else
  677|       |    return true;
  678|    130|#endif /* __APPLE__ */
  679|    130|}
net_set_socket_buffer_size:
  706|    130|{
  707|    130|    bool ok = true;
  708|       |
  709|    130|    if (ns_setsockopt(ns, sock, SOL_SOCKET, SO_RCVBUF, &size, sizeof(size)) != 0) {
  ------------------
  |  Branch (709:9): [True: 0, False: 130]
  ------------------
  710|      0|        ok = false;
  711|      0|    }
  712|       |
  713|    130|    if (ns_setsockopt(ns, sock, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size)) != 0) {
  ------------------
  |  Branch (713:9): [True: 0, False: 130]
  ------------------
  714|      0|        ok = false;
  715|      0|    }
  716|       |
  717|    130|    return ok;
  718|    130|}
net_set_socket_broadcast:
  721|    130|{
  722|    130|    int broadcast = 1;
  723|    130|    return ns_setsockopt(ns, sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) == 0;
  724|    130|}
net_error:
  727|      1|{
  728|       |#ifdef OS_WIN32
  729|       |    return WSAGetLastError();
  730|       |#else
  731|       |    return errno;
  732|      1|#endif /* OS_WIN32 */
  733|      1|}
net_clear_error:
  736|    129|{
  737|       |#ifdef OS_WIN32
  738|       |    WSASetLastError(0);
  739|       |#else
  740|       |    errno = 0;
  741|    129|#endif /* OS_WIN32 */
  742|    129|}
net_strerror:
  776|      1|{
  777|      1|    errno = 0;
  778|       |
  779|      1|    const char *retstr = net_strerror_r(error, buf->data, NET_STRERROR_SIZE);
  ------------------
  |  |  192|      1|#define NET_STRERROR_SIZE 256
  ------------------
  780|      1|    const size_t retstr_len = strlen(retstr);
  781|      1|    assert(retstr_len < NET_STRERROR_SIZE);
  ------------------
  |  Branch (781:5): [True: 1, False: 0]
  ------------------
  782|      1|    buf->size = (uint16_t)retstr_len;
  783|       |
  784|      1|    return buf->data;
  785|      1|}
os_network.c:fill_addr4:
  142|     13|{
  143|     13|    addr->s_addr = ip->uint32;
  144|     13|}
os_network.c:inet_ntop4:
  211|     13|{
  212|       |    return inet_ntop(AF_INET, addr, buf, bufsize);
  213|     13|}
os_network.c:net_strerror_r:
  765|      1|{
  766|      1|    const int fmt_error = strerror_r(error, tmp, tmp_size);
  767|       |
  768|      1|    if (fmt_error != 0) {
  ------------------
  |  Branch (768:9): [True: 0, False: 1]
  ------------------
  769|      0|        snprintf(tmp, tmp_size, "error %d (strerror_r failed with error %d, errno %d)", error, fmt_error, errno);
  770|      0|    }
  771|       |
  772|      1|    return tmp;
  773|      1|}

