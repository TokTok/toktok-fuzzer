fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Fuzz_SystemjEXadL_ZN3$_08__invokeES3_jEEEcvPFT_T0_DpT1_EIS1_S1_JjEEEvENKUlS1_DpT_E_clIJjEEEDaS1_SG_:
   31|    399|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Fuzz_SystemjEXadL_ZN3$_08__invokeES3_jEEE13static_casterIS1_EcvT_IS3_EEv:
   22|    399|        {
   23|    399|            return static_cast<To>(obj);
   24|    399|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Fuzz_SystemPvEXadL_ZN3$_28__invokeES2_S3_EEEcvPFT_T0_DpT1_EIvS3_JS3_EEEvENKUlS3_DpT_E_clIJS3_EEEDaS3_SG_:
   31|    394|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Fuzz_SystemPvEXadL_ZN3$_28__invokeES2_S3_EEE13static_casterIS3_EcvT_IS2_EEv:
   22|    394|        {
   23|    394|            return static_cast<To>(obj);
   24|    394|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketEXadL_ZN3$_38__invokeES2_S3_EEEcvPFT_T0_DpT1_EIiPvJS3_EEEvENKUlSF_DpT_E_clIJS3_EEEDaSF_SH_:
   31|    130|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketEXadL_ZN3$_38__invokeES2_S3_EEE13static_casterIPvEcvT_IS2_EEv:
   22|    130|        {
   23|    130|            return static_cast<To>(obj);
   24|    130|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketPK7IP_PortEXadL_ZN3$_58__invokeES2_S3_S6_EEEcvPFT_T0_DpT1_EIiPvJS3_S6_EEEvENKUlSI_DpT_E_clIJS3_S6_EEEDaSI_SK_:
   31|    130|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketPK7IP_PortEXadL_ZN3$_58__invokeES2_S3_S6_EEE13static_casterIPvEcvT_IS2_EEv:
   22|    130|        {
   23|    130|            return static_cast<To>(obj);
   24|    130|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketPKhmPK7IP_PortEXadL_ZN4$_128__invokeES2_S3_S5_mS8_EEEcvPFT_T0_DpT1_EIiPvJS3_S5_mS8_EEEvENKUlSK_DpT_E_clIJS3_S5_mS8_EEEDaSK_SM_:
   31|      8|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketPKhmPK7IP_PortEXadL_ZN4$_128__invokeES2_S3_S5_mS8_EEE13static_casterIPvEcvT_IS2_EEv:
   22|      8|        {
   23|      8|            return static_cast<To>(obj);
   24|      8|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPF6SocketP11Fuzz_SystemiiiEXadL_ZN4$_138__invokeES3_iiiEEEcvPFT_T0_DpT1_EIS1_PvJiiiEEEvENKUlSF_DpT_E_clIJiiiEEEDaSF_SH_:
   31|    130|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPF6SocketP11Fuzz_SystemiiiEXadL_ZN4$_138__invokeES3_iiiEEE13static_casterIPvEcvT_IS3_EEv:
   22|    130|        {
   23|    130|            return static_cast<To>(obj);
   24|    130|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketbEXadL_ZN4$_148__invokeES2_S3_bEEEcvPFT_T0_DpT1_EIiPvJS3_bEEEvENKUlSF_DpT_E_clIJS3_bEEEDaSF_SH_:
   31|    130|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketbEXadL_ZN4$_148__invokeES2_S3_bEEE13static_casterIPvEcvT_IS2_EEv:
   22|    130|        {
   23|    130|            return static_cast<To>(obj);
   24|    130|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketiiPKvmEXadL_ZN4$_168__invokeES2_S3_iiS5_mEEEcvPFT_T0_DpT1_EIiPvJS3_iiS5_mEEEvENKUlSH_DpT_E_clIJS3_iiS5_mEEEDaSH_SJ_:
   31|    390|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketiiPKvmEXadL_ZN4$_168__invokeES2_S3_iiS5_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|    390|        {
   23|    390|            return static_cast<To>(obj);
   24|    390|        }

_ZN6SystemC2ENSt3__110unique_ptrI10Tox_SystemNS0_14default_deleteIS2_EEEENS1_I10Tox_MemoryNS3_IS6_EEEENS1_I7NetworkNS3_IS9_EEEENS1_I10Tox_RandomNS3_ISC_EEEE:
   34|    136|    : sys(std::move(in_sys))
   35|    136|    , mem(std::move(in_mem))
   36|    136|    , ns(std::move(in_ns))
   37|    136|    , rng(std::move(in_rng))
   38|    136|{
   39|    136|}
_ZN6SystemD2Ev:
   42|    136|System::~System() { }
_ZN11Fuzz_SystemC2ER9Fuzz_Data:
  217|    136|    : System{
  218|    136|          std::make_unique<Tox_System>(),
  219|    136|          std::make_unique<Tox_Memory>(Tox_Memory{&fuzz_memory_funcs, this}),
  220|    136|          std::make_unique<Network>(Network{&fuzz_network_funcs, this}),
  221|    136|          std::make_unique<Tox_Random>(Tox_Random{&fuzz_random_funcs, this}),
  222|    136|      }
  223|    136|    , data(input)
  224|    136|{
  225|    136|    sys->mono_time_callback = [](void *self) { return static_cast<Fuzz_System *>(self)->clock; };
  226|    136|    sys->mono_time_user_data = this;
  227|    136|    sys->mem = mem.get();
  228|    136|    sys->ns = ns.get();
  229|    136|    sys->rng = rng.get();
  230|    136|}
fuzz_support.cc:_ZNK3$_0clEP11Fuzz_Systemj:
   95|    399|    ![](Fuzz_System *self, uint32_t size) {
   96|    399|        return alloc_common<decltype(std::malloc), std::malloc>("malloc", size, self->data, size);
   97|    399|    },
fuzz_support.cc:_ZL12alloc_commonIDoFPvmETnT_XadL_Z6mallocEEJjEES0_PKcmR9Fuzz_DataDpT1_:
   84|    399|{
   85|    399|    CONSUME1_OR_RETURN_VAL(
  ------------------
  |  |  122|    399|    if (INPUT.size() < sizeof(TYPE)) {                 \
  |  |  ------------------
  |  |  |  Branch (122:9): [True: 249, False: 150]
  |  |  ------------------
  |  |  123|    249|        return VAL;                                    \
  |  |  124|    249|    }                                                  \
  |  |  125|    399|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
   86|    150|        const bool, want_alloc, data, report_alloc("tox1", func, size, Func(args...)));
   87|    150|    if (!want_alloc) {
  ------------------
  |  Branch (87:9): [True: 4, False: 146]
  ------------------
   88|      4|        return nullptr;
   89|      4|    }
   90|    146|    return report_alloc("tox1", func, size, Func(args...));
   91|    150|}
fuzz_support.cc:_ZL12report_allocPKcS0_mPv:
   75|    395|{
   76|    395|    if (Fuzz_Data::FUZZ_DEBUG) {
  ------------------
  |  Branch (76:9): [Folded, False: 395]
  ------------------
   77|      0|        printf("%s: %s(%zu): %s\n", name, func, size, ptr == nullptr ? "false" : "true");
  ------------------
  |  Branch (77:55): [True: 0, False: 0]
  ------------------
   78|      0|    }
   79|    395|    return ptr;
   80|    395|}
fuzz_support.cc:_ZNK3$_2clEP11Fuzz_SystemPv:
  104|    394|    ![](Fuzz_System *self, void *ptr) { std::free(ptr); },
fuzz_support.cc:_ZNK3$_3clEP11Fuzz_System6Socket:
  108|    130|    /* .close = */ ![](Fuzz_System *self, Socket sock) { return 0; },
fuzz_support.cc:_ZNK3$_5clEP11Fuzz_System6SocketPK7IP_Port:
  110|    130|    /* .bind = */ ![](Fuzz_System *self, Socket sock, const IP_Port *addr) { return 0; },
fuzz_support.cc:_ZNK4$_12clEP11Fuzz_System6SocketPKhmPK7IP_Port:
  142|      8|    ![](Fuzz_System *self, Socket sock, const uint8_t *buf, size_t len, const IP_Port *addr) {
  143|      8|        assert(sock.value == 42 || sock.value == 1337);
  ------------------
  |  Branch (143:9): [True: 8, False: 0]
  |  Branch (143:9): [True: 0, False: 0]
  |  Branch (143:9): [True: 8, False: 0]
  ------------------
  144|       |        // Always succeed.
  145|      8|        return static_cast<int>(len);
  146|      8|    },
fuzz_support.cc:_ZNK4$_13clEP11Fuzz_Systemiii:
  147|    130|    /* .socket = */ ![](Fuzz_System *self, int domain, int type, int proto) { return Socket{42}; },
fuzz_support.cc:_ZNK4$_14clEP11Fuzz_System6Socketb:
  148|    130|    /* .socket_nonblock = */ ![](Fuzz_System *self, Socket sock, bool nonblock) { return 0; },
fuzz_support.cc:_ZNK4$_16clEP11Fuzz_System6SocketiiPKvm:
  155|    390|    ![](Fuzz_System *self, Socket sock, int level, int optname, const void *optval, size_t optlen) {
  156|    390|        return 0;
  157|    390|    },

_ZNK9Fuzz_Data4sizeEv:
   69|  1.44k|    std::size_t size() const { return size_; }
_ZN9Fuzz_Data8consume1EPKc:
   68|    459|    Consumer consume1(const char *func) { return Consumer{func, *this}; }
_ZN9Fuzz_Data8ConsumercvT_ItEEv:
   60|    153|        {
   61|    153|            const uint8_t *bytes = fd.consume(func, sizeof(T));
   62|    153|            T val;
   63|    153|            std::memcpy(&val, bytes, sizeof(T));
   64|    153|            return val;
   65|    153|        }
_ZN9Fuzz_Data7consumeEPKcm:
   75|  1.02k|    {
   76|  1.02k|        const uint8_t *val = data_;
   77|  1.02k|        if (FUZZ_DEBUG) {
  ------------------
  |  Branch (77:13): [Folded, False: 1.02k]
  ------------------
   78|      0|            if (pos() == TRACE_TRAP) {
  ------------------
  |  Branch (78:17): [True: 0, False: 0]
  ------------------
   79|      0|                __asm__("int $3");
   80|      0|            }
   81|      0|            if (count == 1) {
  ------------------
  |  Branch (81:17): [True: 0, False: 0]
  ------------------
   82|      0|                std::printf("consume@%zu(%s): %d (0x%02x)\n", pos(), func, val[0], val[0]);
   83|      0|            } else if (count != 0) {
  ------------------
  |  Branch (83:24): [True: 0, False: 0]
  ------------------
   84|      0|                std::printf("consume@%zu(%s): %02x..%02x[%zu]\n", pos(), func, val[0],
   85|      0|                    val[count - 1], count);
   86|      0|            }
   87|      0|        }
   88|  1.02k|        data_ += count;
   89|  1.02k|        size_ -= count;
   90|  1.02k|        return val;
   91|  1.02k|    }
forwarding_fuzz_test.cc:_Z18fuzz_select_targetIJXadL_ZN12_GLOBAL__N_122TestSendForwardRequestER9Fuzz_DataEEXadL_ZNS0_16TestForwardReplyES2_EEEEvPKhm:
  183|    156|{
  184|    156|    Fuzz_Data input{data, size};
  185|       |
  186|    156|    CONSUME1_OR_RETURN(const uint8_t, selector, input);
  ------------------
  |  |  105|    156|    if (INPUT.size() < sizeof(TYPE)) {        \
  |  |  ------------------
  |  |  |  Branch (105:9): [True: 0, False: 156]
  |  |  ------------------
  |  |  106|      0|        return;                               \
  |  |  107|      0|    }                                         \
  |  |  108|    156|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
  187|    156|    return Fuzz_Target_Selector<Args...>::select(selector, input);
  188|    156|}
_ZN9Fuzz_DataC2EPKhm:
   32|    156|        : data_(input_data)
   33|    156|        , base_(input_data)
   34|    156|        , size_(input_size)
   35|    156|    {
   36|    156|    }
_ZN9Fuzz_Data8ConsumercvT_IhEEv:
   60|    156|        {
   61|    156|            const uint8_t *bytes = fd.consume(func, sizeof(T));
   62|    156|            T val;
   63|    156|            std::memcpy(&val, bytes, sizeof(T));
   64|    156|            return val;
   65|    156|        }
forwarding_fuzz_test.cc:_ZN20Fuzz_Target_SelectorIJXadL_ZN12_GLOBAL__N_122TestSendForwardRequestER9Fuzz_DataEEXadL_ZNS0_16TestForwardReplyES2_EEEE6selectEhS2_:
  164|    156|    {
  165|    156|        if (selector == sizeof...(Args)) {
  ------------------
  |  Branch (165:13): [True: 124, False: 32]
  ------------------
  166|    124|            return Arg(input);
  167|    124|        }
  168|     32|        return Fuzz_Target_Selector<Args...>::select(selector, input);
  169|    156|    }
forwarding_fuzz_test.cc:_ZN20Fuzz_Target_SelectorIJXadL_ZN12_GLOBAL__N_116TestForwardReplyER9Fuzz_DataEEEE6selectEhS2_:
  164|     32|    {
  165|     32|        if (selector == sizeof...(Args)) {
  ------------------
  |  Branch (165:13): [True: 31, False: 1]
  ------------------
  166|     31|            return Arg(input);
  167|     31|        }
  168|      1|        return Fuzz_Target_Selector<Args...>::select(selector, input);
  169|     32|    }
_ZN20Fuzz_Target_SelectorIJEE6selectEhR9Fuzz_Data:
  175|      1|    {
  176|       |        // The selector selected no function, so we do nothing and rely on the
  177|       |        // fuzzer to come up with a better selector.
  178|      1|    }
_ZN9Fuzz_Data8ConsumercvbEv:
   46|    150|        {
   47|       |            // Special case because memcpy causes UB for bool (which can't be
   48|       |            // anything other than 0 or 1).
   49|    150|            const bool val = fd.data_[0];
   50|    150|            if (FUZZ_DEBUG) {
  ------------------
  |  Branch (50:17): [Folded, False: 150]
  ------------------
   51|      0|                std::printf("consume@%zu(%s): bool %s\n", fd.pos(), func, val ? "true" : "false");
  ------------------
  |  Branch (51:75): [True: 0, False: 0]
  ------------------
   52|      0|            }
   53|    150|            ++fd.data_;
   54|    150|            --fd.size_;
   55|    150|            return val;
   56|    150|        }

send_forward_request:
   45|    116|{
   46|    116|    if (chain_length == 0 || chain_length > MAX_FORWARD_CHAIN_LENGTH
  ------------------
  |  |   27|    231|#define MAX_FORWARD_CHAIN_LENGTH 4
  ------------------
  |  Branch (46:9): [True: 1, False: 115]
  |  Branch (46:30): [True: 1, False: 114]
  ------------------
   47|    114|            || data_length > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   25|    114|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |  140|    114|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   24|    114|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (47:16): [True: 1, False: 113]
  ------------------
   48|      3|        return false;
   49|      3|    }
   50|       |
   51|    113|    const uint16_t len = forward_chain_packet_size(chain_length, data_length);
   52|    113|    VLA(uint8_t, packet, len);
  ------------------
  |  |   59|    113|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|    113|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
   53|       |
   54|    113|    return create_forward_chain_packet(chain_keys, chain_length, data, data_length, packet)
  ------------------
  |  Branch (54:12): [True: 113, False: 0]
  ------------------
   55|    113|           && sendpacket(net, forwarder, packet, len) == len;
  ------------------
  |  Branch (55:15): [True: 1, False: 112]
  ------------------
   56|    116|}
forward_chain_packet_size:
   59|    113|{
   60|    113|    return chain_length * (1 + CRYPTO_PUBLIC_KEY_SIZE) + data_length;
  ------------------
  |  |   44|    113|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   61|    113|}
create_forward_chain_packet:
   66|    113|{
   67|    113|    if (chain_length == 0 || chain_length > MAX_FORWARD_CHAIN_LENGTH
  ------------------
  |  |   27|    226|#define MAX_FORWARD_CHAIN_LENGTH 4
  ------------------
  |  Branch (67:9): [True: 0, False: 113]
  |  Branch (67:30): [True: 0, False: 113]
  ------------------
   68|    113|            || data_length > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   25|    113|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |  140|    113|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   24|    113|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (68:16): [True: 0, False: 113]
  ------------------
   69|      0|        return false;
   70|      0|    }
   71|       |
   72|    113|    uint16_t offset = 0;
   73|       |
   74|    235|    for (uint16_t j = 0; j < chain_length; ++j) {
  ------------------
  |  Branch (74:26): [True: 122, False: 113]
  ------------------
   75|    122|        packet[offset] = NET_PACKET_FORWARD_REQUEST;
   76|    122|        ++offset;
   77|    122|        memcpy(packet + offset, chain_keys + j * CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    122|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                      memcpy(packet + offset, chain_keys + j * CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    122|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   78|    122|        offset += CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   44|    122|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   79|    122|    }
   80|       |
   81|    113|    memcpy(packet + offset, data, data_length);
   82|       |    return true;
   83|    113|}
forward_reply:
  313|     14|{
  314|     14|    if (sendback_length > MAX_SENDBACK_SIZE ||
  ------------------
  |  |   24|     28|#define MAX_SENDBACK_SIZE (0xff - 1)
  ------------------
  |  Branch (314:9): [True: 1, False: 13]
  ------------------
  315|     13|            length > MAX_FORWARD_DATA_SIZE) {
  ------------------
  |  |   25|     13|#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |  140|     13|#define MAX_UDP_PACKET_SIZE 2048
  |  |  ------------------
  |  |               #define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))
  |  |  ------------------
  |  |  |  |   24|     13|#define MAX_SENDBACK_SIZE (0xff - 1)
  |  |  ------------------
  ------------------
  |  Branch (315:13): [True: 1, False: 12]
  ------------------
  316|      2|        return false;
  317|      2|    }
  318|       |
  319|     12|    const uint16_t len = 1 + 1 + sendback_length + length;
  320|     12|    VLA(uint8_t, packet, len);
  ------------------
  |  |   59|     12|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     12|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
  321|     12|    packet[0] = NET_PACKET_FORWARD_REPLY;
  322|     12|    packet[1] = (uint8_t) sendback_length;
  323|     12|    memcpy(packet + 1 + 1, sendback, sendback_length);
  324|     12|    memcpy(packet + 1 + 1 + sendback_length, data, length);
  325|     12|    return sendpacket(net, forwarder, packet, len) == len;
  326|     14|}

LLVMFuzzerTestOneInput:
   97|    156|{
   98|    156|    fuzz_select_target<TestSendForwardRequest, TestForwardReply>(data, size);
   99|    156|    return 0;
  100|    156|}
forwarding_fuzz_test.cc:_ZN12_GLOBAL__N_122TestSendForwardRequestER9Fuzz_Data:
   35|    124|{
   36|    124|    CONSUME1_OR_RETURN(const uint16_t, chain_length, input);
  ------------------
  |  |  105|    124|    if (INPUT.size() < sizeof(TYPE)) {        \
  |  |  ------------------
  |  |  |  Branch (105:9): [True: 1, False: 123]
  |  |  ------------------
  |  |  106|      1|        return;                               \
  |  |  107|      1|    }                                         \
  |  |  108|    124|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
   37|    123|    const uint16_t chain_keys_size = chain_length * CRYPTO_PUBLIC_KEY_SIZE;
  ------------------
  |  |   44|    123|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
   38|    123|    CONSUME_OR_RETURN(const uint8_t *chain_keys, input, chain_keys_size);
  ------------------
  |  |  139|    123|    if (INPUT.size() < SIZE) {               \
  |  |  ------------------
  |  |  |  Branch (139:9): [True: 1, False: 122]
  |  |  ------------------
  |  |  140|      1|        return;                              \
  |  |  141|      1|    }                                        \
  |  |  142|    123|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   39|       |
   40|    122|    const auto prep = prepare(input);
   41|    122|    if (!prep.has_value()) {
  ------------------
  |  Branch (41:9): [True: 4, False: 118]
  ------------------
   42|      4|        return;
   43|      4|    }
   44|    118|    const auto [ipp, forwarder, data, data_size] = prep.value();
   45|       |
   46|       |    // rest of the fuzz data is input for malloc and network
   47|    118|    Fuzz_System sys(input);
   48|       |
   49|    118|    const Ptr<Logger> logger(logger_new(sys.mem.get()), logger_kill);
   50|    118|    if (logger == nullptr) {
  ------------------
  |  Branch (50:9): [True: 1, False: 117]
  ------------------
   51|      1|        return;
   52|      1|    }
   53|       |
   54|    117|    const Ptr<Networking_Core> net(new_networking_ex(logger.get(), sys.mem.get(), sys.ns.get(),
   55|    117|                                       &ipp.ip, ipp.port, ipp.port + 100, nullptr),
   56|    117|        kill_networking);
   57|    117|    if (net == nullptr) {
  ------------------
  |  Branch (57:9): [True: 1, False: 116]
  ------------------
   58|      1|        return;
   59|      1|    }
   60|       |
   61|    116|    send_forward_request(net.get(), &forwarder, chain_keys, chain_length, data, data_size);
   62|    116|}
forwarding_fuzz_test.cc:_ZN12_GLOBAL__N_17prepareER9Fuzz_Data:
   14|    151|{
   15|    151|    CONSUME_OR_RETURN_VAL(const uint8_t *ipp_packed, input, SIZE_IP_PORT, std::nullopt);
  ------------------
  |  |  145|    151|    if (INPUT.size() < SIZE) {                        \
  |  |  ------------------
  |  |  |  Branch (145:9): [True: 2, False: 149]
  |  |  ------------------
  |  |  146|      2|        return VAL;                                   \
  |  |  147|      2|    }                                                 \
  |  |  148|    151|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   16|    149|    IP_Port ipp{};
   17|    149|    unpack_ip_port(&ipp, ipp_packed, SIZE_IP6, true);
  ------------------
  |  |   32|    149|#define SIZE_IP6 16
  ------------------
   18|       |
   19|    149|    CONSUME_OR_RETURN_VAL(const uint8_t *forwarder_packed, input, SIZE_IP_PORT, std::nullopt);
  ------------------
  |  |  145|    149|    if (INPUT.size() < SIZE) {                        \
  |  |  ------------------
  |  |  |  Branch (145:9): [True: 5, False: 144]
  |  |  ------------------
  |  |  146|      5|        return VAL;                                   \
  |  |  147|      5|    }                                                 \
  |  |  148|    149|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   20|    144|    IP_Port forwarder{};
   21|    144|    unpack_ip_port(&forwarder, forwarder_packed, SIZE_IP6, true);
  ------------------
  |  |   32|    144|#define SIZE_IP6 16
  ------------------
   22|       |
   23|       |    // 2 bytes: size of the request
   24|    144|    CONSUME_OR_RETURN_VAL(const uint8_t *data_size_bytes, input, sizeof(uint16_t), std::nullopt);
  ------------------
  |  |  145|    144|    if (INPUT.size() < SIZE) {                        \
  |  |  ------------------
  |  |  |  Branch (145:9): [True: 6, False: 138]
  |  |  ------------------
  |  |  146|      6|        return VAL;                                   \
  |  |  147|      6|    }                                                 \
  |  |  148|    144|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   25|    138|    uint16_t data_size;
   26|    138|    std::memcpy(&data_size, data_size_bytes, sizeof(uint16_t));
   27|       |
   28|       |    // data bytes (max 64K)
   29|    138|    CONSUME_OR_RETURN_VAL(const uint8_t *data, input, data_size, std::nullopt);
  ------------------
  |  |  145|    138|    if (INPUT.size() < SIZE) {                        \
  |  |  ------------------
  |  |  |  Branch (145:9): [True: 2, False: 136]
  |  |  ------------------
  |  |  146|      2|        return VAL;                                   \
  |  |  147|      2|    }                                                 \
  |  |  148|    138|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   30|       |
   31|    136|    return {{ipp, forwarder, data, data_size}};
   32|    138|}
forwarding_fuzz_test.cc:_ZN12_GLOBAL__N_116TestForwardReplyER9Fuzz_Data:
   65|     31|{
   66|     31|    CONSUME1_OR_RETURN(const uint16_t, sendback_length, input);
  ------------------
  |  |  105|     31|    if (INPUT.size() < sizeof(TYPE)) {        \
  |  |  ------------------
  |  |  |  Branch (105:9): [True: 1, False: 30]
  |  |  ------------------
  |  |  106|      1|        return;                               \
  |  |  107|      1|    }                                         \
  |  |  108|     31|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
   67|     30|    CONSUME_OR_RETURN(const uint8_t *sendback, input, sendback_length);
  ------------------
  |  |  139|     30|    if (INPUT.size() < SIZE) {               \
  |  |  ------------------
  |  |  |  Branch (139:9): [True: 1, False: 29]
  |  |  ------------------
  |  |  140|      1|        return;                              \
  |  |  141|      1|    }                                        \
  |  |  142|     30|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
   68|       |
   69|     29|    const auto prep = prepare(input);
   70|     29|    if (!prep.has_value()) {
  ------------------
  |  Branch (70:9): [True: 11, False: 18]
  ------------------
   71|     11|        return;
   72|     11|    }
   73|     18|    const auto [ipp, forwarder, data, data_size] = prep.value();
   74|       |
   75|       |    // rest of the fuzz data is input for malloc and network
   76|     18|    Fuzz_System sys(input);
   77|       |
   78|     18|    const Ptr<Logger> logger(logger_new(sys.mem.get()), logger_kill);
   79|     18|    if (logger == nullptr) {
  ------------------
  |  Branch (79:9): [True: 1, False: 17]
  ------------------
   80|      1|        return;
   81|      1|    }
   82|       |
   83|     17|    const Ptr<Networking_Core> net(new_networking_ex(logger.get(), sys.mem.get(), sys.ns.get(),
   84|     17|                                       &ipp.ip, ipp.port, ipp.port + 100, nullptr),
   85|     17|        kill_networking);
   86|     17|    if (net == nullptr) {
  ------------------
  |  Branch (86:9): [True: 3, False: 14]
  ------------------
   87|      3|        return;
   88|      3|    }
   89|       |
   90|     14|    forward_reply(net.get(), &forwarder, sendback, sendback_length, data, data_size);
   91|     14|}

logger_new:
   33|    136|{
   34|    136|    Logger *log = (Logger *)mem_alloc(mem, sizeof(Logger));
   35|       |
   36|    136|    if (log == nullptr) {
  ------------------
  |  |   63|    136|#define nullptr NULL
  ------------------
  |  Branch (36:9): [True: 2, False: 134]
  ------------------
   37|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
   38|      2|    }
   39|       |
   40|    134|    log->mem = mem;
   41|       |
   42|    134|    return log;
   43|    136|}
logger_kill:
   46|    134|{
   47|    134|    if (log == nullptr) {
  ------------------
  |  |   63|    134|#define nullptr NULL
  ------------------
  |  Branch (47:9): [True: 0, False: 134]
  ------------------
   48|      0|        return;
   49|      0|    }
   50|       |
   51|    134|    mem_delete(log->mem, log);
   52|    134|}
logger_write:
   64|    116|{
   65|    116|    if (log == nullptr) {
  ------------------
  |  |   63|    116|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 0, False: 116]
  ------------------
   66|      0|        return;
   67|      0|    }
   68|       |
   69|    116|    if (log->callback == nullptr) {
  ------------------
  |  |   63|    116|#define nullptr NULL
  ------------------
  |  Branch (69:9): [True: 116, False: 0]
  ------------------
   70|    116|        return;
   71|    116|    }
   72|       |
   73|       |    // Only pass the file name, not the entire file path, for privacy reasons.
   74|       |    // The full path may contain PII of the person compiling toxcore (their
   75|       |    // username and directory layout).
   76|      0|    const char *filename = strrchr(file, '/');
   77|      0|    file = filename != nullptr ? filename + 1 : file;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (77:12): [True: 0, False: 0]
  ------------------
   78|       |#if defined(_WIN32) || defined(__CYGWIN__)
   79|       |    // On Windows, the path separator *may* be a backslash, so we look for that
   80|       |    // one too.
   81|       |    const char *windows_filename = strrchr(file, '\\');
   82|       |    file = windows_filename != nullptr ? windows_filename + 1 : file;
   83|       |#endif /* WIN32 */
   84|       |
   85|       |    // Format message
   86|      0|    char msg[1024];
   87|      0|    va_list args;
   88|      0|    va_start(args, format);
   89|      0|    vsnprintf(msg, sizeof(msg), format, args);
   90|      0|    va_end(args);
   91|       |
   92|      0|    log->callback(log->context, level, file, line, func, msg, log->userdata);
   93|      0|}

mem_alloc:
   26|    399|{
   27|    399|    void *const ptr = tox_memory_malloc(mem, size);
   28|    399|    if (ptr != nullptr) {
  ------------------
  |  |   63|    399|#define nullptr NULL
  ------------------
  |  Branch (28:9): [True: 395, False: 4]
  ------------------
   29|    395|        memset(ptr, 0, size);
   30|    395|    }
   31|    399|    return ptr;
   32|    399|}
mem_delete:
   62|    394|{
   63|    394|    tox_memory_dealloc(mem, ptr);
   64|    394|}

net_log_data:
  155|      8|{
  156|      8|    if (res < 0) { /* Windows doesn't necessarily know `%zu` */
  ------------------
  |  Branch (156:9): [True: 0, False: 8]
  ------------------
  157|      0|        Ip_Ntoa ip_str;
  158|      0|        const int error = net_error();
  159|      0|        Net_Strerror error_str;
  160|      0|        LOGGER_TRACE(log, "[%02x = %-21s] %s %3u%c %s:%u (%d: %s) | %08x%08x...%02x",
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  161|      0|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  162|      0|                     min_u16(buflen, 999), 'E',
  163|      0|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), error,
  164|      0|                     net_strerror(error, &error_str), data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  165|      8|    } else if ((res > 0) && ((size_t)res <= buflen)) {
  ------------------
  |  Branch (165:16): [True: 8, False: 0]
  |  Branch (165:29): [True: 8, False: 0]
  ------------------
  166|      8|        Ip_Ntoa ip_str;
  167|      8|        LOGGER_TRACE(log, "[%02x = %-21s] %s %3u%c %s:%u (%d: %s) | %08x%08x...%02x",
  ------------------
  |  |   76|      8|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      8|    do {                                                                         \
  |  |  |  |   70|      8|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     16|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 8]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (71:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      8|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 8]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  168|      8|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  169|      8|                     min_u16(res, 999), (size_t)res < buflen ? '<' : '=',
  170|      8|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
  171|      8|                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  172|      8|    } else { /* empty or overwrite */
  173|      0|        Ip_Ntoa ip_str;
  174|      0|        LOGGER_TRACE(log, "[%02x = %-21s] %s %ld%c%u %s:%u (%d: %s) | %08x%08x...%02x",
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (71:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  175|      0|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  176|      0|                     res, res == 0 ? '!' : '>', buflen,
  177|      0|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
  178|      0|                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  179|      0|    }
  180|      8|}

netprof_record_packet:
   72|      8|{
   73|      8|    if (profile == nullptr) {
  ------------------
  |  |   63|      8|#define nullptr NULL
  ------------------
  |  Branch (73:9): [True: 0, False: 8]
  ------------------
   74|      0|        return;
   75|      0|    }
   76|       |
   77|      8|    if (dir == PACKET_DIRECTION_SEND) {
  ------------------
  |  Branch (77:9): [True: 8, False: 0]
  ------------------
   78|      8|        ++profile->total_packets_sent;
   79|      8|        ++profile->packets_sent[id];
   80|       |
   81|      8|        profile->total_bytes_sent += length;
   82|      8|        profile->bytes_sent[id] += length;
   83|      8|    } else {
   84|      0|        ++profile->total_packets_recv;
   85|      0|        ++profile->packets_recv[id];
   86|       |
   87|      0|        profile->total_bytes_recv += length;
   88|      0|        profile->bytes_recv[id] += length;
   89|      0|    }
   90|      8|}
netprof_new:
  139|    131|{
  140|    131|    Net_Profile *np = (Net_Profile *)mem_alloc(mem, sizeof(Net_Profile));
  141|       |
  142|    131|    if (np == nullptr) {
  ------------------
  |  |   63|    131|#define nullptr NULL
  ------------------
  |  Branch (142:9): [True: 1, False: 130]
  ------------------
  143|      1|        LOGGER_ERROR(log, "failed to allocate memory for net profiler");
  ------------------
  |  |   80|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  144|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  145|      1|    }
  146|       |
  147|    130|    return np;
  148|    131|}
netprof_kill:
  151|    130|{
  152|    130|    if (net_profile != nullptr) {
  ------------------
  |  |   63|    130|#define nullptr NULL
  ------------------
  |  Branch (152:9): [True: 130, False: 0]
  ------------------
  153|    130|        mem_delete(mem, net_profile);
  154|    130|    }
  155|    130|}

net_socket_from_native:
  371|    130|{
  372|    130|    const Socket res = {(force Socket_Value)sock};
  373|    130|    return res;
  374|    130|}
net_invalid_socket:
  377|    130|{
  378|    130|    return net_socket_from_native(INVALID_SOCKET);
  ------------------
  |  |  362|    130|#define INVALID_SOCKET (-1)
  ------------------
  379|    130|}
net_family_ipv4:
  387|    275|{
  388|    275|    return family_ipv4;
  389|    275|}
net_family_ipv6:
  392|      3|{
  393|      3|    return family_ipv6;
  394|      3|}
net_family_tcp_ipv4:
  407|    116|{
  408|    116|    return family_tcp_ipv4;
  409|    116|}
net_family_tcp_ipv6:
  412|      5|{
  413|      5|    return family_tcp_ipv6;
  414|      5|}
net_family_is_unspec:
  427|    376|{
  428|    376|    return family.value == family_unspec.value;
  429|    376|}
net_family_is_ipv4:
  432|    627|{
  433|    627|    return family.value == family_ipv4.value;
  434|    627|}
net_family_is_ipv6:
  437|    270|{
  438|    270|    return family.value == family_ipv6.value;
  439|    270|}
net_family_is_tcp_ipv4:
  452|    113|{
  453|    113|    return family.value == family_tcp_ipv4.value;
  454|    113|}
sock_valid:
  472|    130|{
  473|    130|    const Socket invalid_socket = net_invalid_socket();
  474|    130|    return sock.value != invalid_socket.value;
  475|    130|}
kill_sock:
  823|    130|{
  824|    130|    ns->funcs->close(ns->obj, sock);
  825|    130|}
set_socket_nonblock:
  828|    130|{
  829|       |    return ns->funcs->socket_nonblock(ns->obj, sock, true) == 0;
  830|    130|}
set_socket_nosigpipe:
  833|    130|{
  834|       |#if defined(__APPLE__)
  835|       |    int set = 1;
  836|       |    return net_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
  837|       |#else
  838|       |    return true;
  839|    130|#endif /* __APPLE__ */
  840|    130|}
net_send_packet:
  899|    125|{
  900|    125|    IP_Port ipp_copy = *ip_port;
  901|       |
  902|    125|    if (net_family_is_unspec(ip_port->ip.family)) {
  ------------------
  |  Branch (902:9): [True: 4, False: 121]
  ------------------
  903|       |        // TODO(iphydf): Make this an error. Currently this fails sometimes when
  904|       |        // called from DHT.c:do_ping_and_sendnode_requests.
  905|      4|        return -1;
  906|      4|    }
  907|       |
  908|    121|    if (net_family_is_unspec(net->family)) { /* Socket not initialized */
  ------------------
  |  Branch (908:9): [True: 0, False: 121]
  ------------------
  909|       |        // TODO(iphydf): Make this an error. Currently, the onion client calls
  910|       |        // this via DHT nodes requests.
  911|      0|        LOGGER_WARNING(net->log, "attempted to send message of length %u on uninitialised socket", packet.length);
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  912|      0|        return -1;
  913|      0|    }
  914|       |
  915|       |    /* socket TOX_AF_INET, but target IP NOT: can't send */
  916|    121|    if (net_family_is_ipv4(net->family) && !net_family_is_ipv4(ipp_copy.ip.family)) {
  ------------------
  |  Branch (916:9): [True: 121, False: 0]
  |  Branch (916:44): [True: 113, False: 8]
  ------------------
  917|       |        // TODO(iphydf): Make this an error. Occasionally we try to send to an
  918|       |        // all-zero ip_port.
  919|    113|        Ip_Ntoa ip_str;
  920|    113|        LOGGER_WARNING(net->log, "attempted to send message with network family %d (probably IPv6) on IPv4 socket (%s)",
  ------------------
  |  |   79|    113|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    113|    do {                                                                         \
  |  |  |  |   70|    113|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    226|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 113, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|    113|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|    113|        }                                                                        \
  |  |  |  |   73|    113|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 113]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  921|    113|                       ipp_copy.ip.family.value, net_ip_ntoa(&ipp_copy.ip, &ip_str));
  922|    113|        return -1;
  923|    113|    }
  924|       |
  925|      8|    if (net_family_is_ipv4(ipp_copy.ip.family) && net_family_is_ipv6(net->family)) {
  ------------------
  |  Branch (925:9): [True: 8, False: 0]
  |  Branch (925:51): [True: 0, False: 8]
  ------------------
  926|       |        /* must convert to IPV4-in-IPV6 address */
  927|      0|        IP6 ip6;
  928|       |
  929|       |        /* there should be a macro for this in a standards compliant
  930|       |         * environment, not found */
  931|      0|        ip6.uint32[0] = 0;
  932|      0|        ip6.uint32[1] = 0;
  933|      0|        ip6.uint32[2] = net_htonl(0xFFFF);
  934|      0|        ip6.uint32[3] = ipp_copy.ip.ip.v4.uint32;
  935|       |
  936|      0|        ipp_copy.ip.family = net_family_ipv6();
  937|      0|        ipp_copy.ip.ip.v6 = ip6;
  938|      0|    }
  939|       |
  940|      8|    const long res = net_sendto(net->ns, net->sock, packet.data, packet.length, &ipp_copy);
  941|      8|    net_log_data(net->log, "O=>", packet.data, packet.length, ip_port, res);
  942|       |
  943|      8|    assert(res <= INT_MAX);
  ------------------
  |  Branch (943:5): [True: 8, False: 0]
  ------------------
  944|       |
  945|      8|    if (res == packet.length && packet.data != nullptr) {
  ------------------
  |  |   63|      8|#define nullptr NULL
  ------------------
  |  Branch (945:9): [True: 8, False: 0]
  |  Branch (945:33): [True: 8, False: 0]
  ------------------
  946|      8|        netprof_record_packet(net->udp_net_profile, packet.data[0], packet.length, PACKET_DIRECTION_SEND);
  947|      8|    }
  948|       |
  949|      8|    return (int)res;
  950|      8|}
sendpacket:
  958|    125|{
  959|    125|    const Packet packet = {data, length};
  960|    125|    return net_send_packet(net, ip_port, packet);
  961|    125|}
new_networking_ex:
 1048|    134|{
 1049|       |    /* If both from and to are 0, use default port range
 1050|       |     * If one is 0 and the other is non-0, use the non-0 value as only port
 1051|       |     * If from > to, swap
 1052|       |     */
 1053|    134|    if (port_from == 0 && port_to == 0) {
  ------------------
  |  Branch (1053:9): [True: 49, False: 85]
  |  Branch (1053:27): [True: 0, False: 49]
  ------------------
 1054|      0|        port_from = TOX_PORTRANGE_FROM;
  ------------------
  |  |  191|      0|#define TOX_PORTRANGE_FROM 33445
  ------------------
 1055|      0|        port_to = TOX_PORTRANGE_TO;
  ------------------
  |  |  192|      0|#define TOX_PORTRANGE_TO   33545
  ------------------
 1056|    134|    } else if (port_from == 0 && port_to != 0) {
  ------------------
  |  Branch (1056:16): [True: 49, False: 85]
  |  Branch (1056:34): [True: 49, False: 0]
  ------------------
 1057|     49|        port_from = port_to;
 1058|     85|    } else if (port_from != 0 && port_to == 0) {
  ------------------
  |  Branch (1058:16): [True: 85, False: 0]
  |  Branch (1058:34): [True: 1, False: 84]
  ------------------
 1059|      1|        port_to = port_from;
 1060|     84|    } else if (port_from > port_to) {
  ------------------
  |  Branch (1060:16): [True: 9, False: 75]
  ------------------
 1061|      9|        const uint16_t temp_port = port_from;
 1062|      9|        port_from = port_to;
 1063|      9|        port_to = temp_port;
 1064|      9|    }
 1065|       |
 1066|    134|    if (error != nullptr) {
  ------------------
  |  |   63|    134|#define nullptr NULL
  ------------------
  |  Branch (1066:9): [True: 0, False: 134]
  ------------------
 1067|      0|        *error = 2;
 1068|      0|    }
 1069|       |
 1070|       |    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
 1071|    134|    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1071:9): [True: 2, False: 132]
  |  Branch (1071:44): [True: 2, False: 0]
  ------------------
 1072|      2|        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
  ------------------
  |  |   80|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      2|    do {                                                                         \
  |  |  |  |   70|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      2|        }                                                                        \
  |  |  |  |   73|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1073|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 1074|      2|    }
 1075|       |
 1076|    132|    Networking_Core *temp = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
 1077|       |
 1078|    132|    if (temp == nullptr) {
  ------------------
  |  |   63|    132|#define nullptr NULL
  ------------------
  |  Branch (1078:9): [True: 1, False: 131]
  ------------------
 1079|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 1080|      1|    }
 1081|       |
 1082|    131|    Net_Profile *np = netprof_new(log, mem);
 1083|       |
 1084|    131|    if (np == nullptr) {
  ------------------
  |  |   63|    131|#define nullptr NULL
  ------------------
  |  Branch (1084:9): [True: 1, False: 130]
  ------------------
 1085|      1|        free(temp);
 1086|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 1087|      1|    }
 1088|       |
 1089|    130|    temp->udp_net_profile = np;
 1090|    130|    temp->ns = ns;
 1091|    130|    temp->log = log;
 1092|    130|    temp->mem = mem;
 1093|    130|    temp->family = ip->family;
 1094|    130|    temp->port = 0;
 1095|       |
 1096|       |    /* Initialize our socket. */
 1097|       |    /* add log message what we're creating */
 1098|    130|    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  203|    130|#define TOX_SOCK_DGRAM 2
  ------------------
                  temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  206|    130|#define TOX_PROTO_UDP 2
  ------------------
 1099|       |
 1100|       |    /* Check for socket error. */
 1101|    130|    if (!sock_valid(temp->sock)) {
  ------------------
  |  Branch (1101:9): [True: 0, False: 130]
  ------------------
 1102|      0|        const int neterror = net_error();
 1103|      0|        Net_Strerror error_str;
 1104|      0|        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1105|      0|        netprof_kill(mem, temp->udp_net_profile);
 1106|      0|        mem_delete(mem, temp);
 1107|       |
 1108|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1108:13): [True: 0, False: 0]
  ------------------
 1109|      0|            *error = 1;
 1110|      0|        }
 1111|       |
 1112|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1113|      0|    }
 1114|       |
 1115|       |    /* Functions to increase the size of the send and receive UDP buffers.
 1116|       |     */
 1117|    130|    int n = 1024 * 1024 * 2;
 1118|       |
 1119|    130|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1119:9): [True: 0, False: 130]
  ------------------
 1120|      0|        LOGGER_WARNING(log, "failed to set socket option %d", SO_RCVBUF);
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1121|      0|    }
 1122|       |
 1123|    130|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_SNDBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1123:9): [True: 0, False: 130]
  ------------------
 1124|      0|        LOGGER_WARNING(log, "failed to set socket option %d", SO_SNDBUF);
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1125|      0|    }
 1126|       |
 1127|       |    /* Enable broadcast on socket */
 1128|    130|    int broadcast = 1;
 1129|       |
 1130|    130|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) != 0) {
  ------------------
  |  Branch (1130:9): [True: 0, False: 130]
  ------------------
 1131|      0|        LOGGER_ERROR(log, "failed to set socket option %d", SO_BROADCAST);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1132|      0|    }
 1133|       |
 1134|       |    /* iOS UDP sockets are weird and apparently can SIGPIPE */
 1135|    130|    if (!set_socket_nosigpipe(ns, temp->sock)) {
  ------------------
  |  Branch (1135:9): [True: 0, False: 130]
  ------------------
 1136|      0|        kill_networking(temp);
 1137|       |
 1138|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1138:13): [True: 0, False: 0]
  ------------------
 1139|      0|            *error = 1;
 1140|      0|        }
 1141|       |
 1142|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1143|      0|    }
 1144|       |
 1145|       |    /* Set socket nonblocking. */
 1146|    130|    if (!set_socket_nonblock(ns, temp->sock)) {
  ------------------
  |  Branch (1146:9): [True: 0, False: 130]
  ------------------
 1147|      0|        kill_networking(temp);
 1148|       |
 1149|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1149:13): [True: 0, False: 0]
  ------------------
 1150|      0|            *error = 1;
 1151|      0|        }
 1152|       |
 1153|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1154|      0|    }
 1155|       |
 1156|       |    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
 1157|    130|    uint16_t *portptr = nullptr;
  ------------------
  |  |   63|    130|#define nullptr NULL
  ------------------
 1158|    130|    IP_Port addr;
 1159|    130|    ip_init(&addr.ip, net_family_is_ipv6(temp->family));
 1160|       |
 1161|    130|    if (net_family_is_ipv4(temp->family) || net_family_is_ipv6(temp->family)) {
  ------------------
  |  Branch (1161:9): [True: 130, False: 0]
  |  Branch (1161:45): [True: 0, False: 0]
  ------------------
 1162|    130|        ip_copy(&addr.ip, ip);
 1163|    130|        addr.port = 0;
 1164|    130|        portptr = &addr.port;
 1165|    130|    } else {
 1166|      0|        mem_delete(mem, temp);
 1167|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1168|      0|    }
 1169|       |
 1170|    130|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1170:9): [True: 0, False: 130]
  ------------------
 1171|      0|        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);
 1172|       |
 1173|      0|        if (is_dualstack) {
  ------------------
  |  Branch (1173:13): [True: 0, False: 0]
  ------------------
 1174|      0|            LOGGER_TRACE(log, "Dual-stack socket: enabled");
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1175|      0|        } else {
 1176|      0|            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1177|      0|        }
 1178|       |
 1179|      0|#ifndef ESP_PLATFORM
 1180|       |        /* multicast local nodes */
 1181|      0|        struct ipv6_mreq mreq = {{{{0}}}};
 1182|      0|        mreq.ipv6mr_multiaddr.s6_addr[0] = 0xFF;
 1183|      0|        mreq.ipv6mr_multiaddr.s6_addr[1] = 0x02;
 1184|      0|        mreq.ipv6mr_multiaddr.s6_addr[15] = 0x01;
 1185|      0|        mreq.ipv6mr_interface = 0;
 1186|       |
 1187|      0|        const int res = net_setsockopt(ns, temp->sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
 1188|       |
 1189|      0|        const int neterror = net_error();
 1190|      0|        Net_Strerror error_str;
 1191|       |
 1192|      0|        if (res < 0) {
  ------------------
  |  Branch (1192:13): [True: 0, False: 0]
  ------------------
 1193|      0|            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   78|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1194|      0|        } else {
 1195|      0|            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1196|      0|        }
 1197|      0|#endif /* ESP_PLATFORM */
 1198|      0|    }
 1199|       |
 1200|       |    /* A hanging program or a different user might block the standard port.
 1201|       |     * As long as it isn't a parameter coming from the commandline,
 1202|       |     * try a few ports after it, to see if we can find a "free" one.
 1203|       |     *
 1204|       |     * If we go on without binding, the first sendto() automatically binds to
 1205|       |     * a free port chosen by the system (i.e. anything from 1024 to 65535).
 1206|       |     *
 1207|       |     * Returning NULL after bind fails has both advantages and disadvantages:
 1208|       |     * advantage:
 1209|       |     *   we can rely on getting the port in the range 33445..33450, which
 1210|       |     *   enables us to tell joe user to open their firewall to a small range
 1211|       |     *
 1212|       |     * disadvantage:
 1213|       |     *   some clients might not test return of tox_new(), blindly assuming that
 1214|       |     *   it worked ok (which it did previously without a successful bind)
 1215|       |     */
 1216|    130|    uint16_t port_to_try = port_from;
 1217|    130|    *portptr = net_htons(port_to_try);
 1218|       |
 1219|    130|    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
  ------------------
  |  Branch (1219:38): [True: 130, False: 0]
  ------------------
 1220|    130|        const int res = net_bind(ns, temp->sock, &addr);
 1221|       |
 1222|    130|        if (res == 0) {
  ------------------
  |  Branch (1222:13): [True: 130, False: 0]
  ------------------
 1223|    130|            temp->port = *portptr;
 1224|       |
 1225|    130|            Ip_Ntoa ip_str;
 1226|    130|            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
  ------------------
  |  |   77|    130|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    130|    do {                                                                         \
  |  |  |  |   70|    130|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    260|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 130]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|    130|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 130]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1227|    130|                         net_ntohs(temp->port));
 1228|       |
 1229|       |            /* errno isn't reset on success, only set on failure, the failed
 1230|       |             * binds with parallel clients yield a -EPERM to the outside if
 1231|       |             * errno isn't cleared here */
 1232|    130|            if (tries > 0) {
  ------------------
  |  Branch (1232:17): [True: 130, False: 0]
  ------------------
 1233|    130|                errno = 0;
 1234|    130|            }
 1235|       |
 1236|    130|            if (error != nullptr) {
  ------------------
  |  |   63|    130|#define nullptr NULL
  ------------------
  |  Branch (1236:17): [True: 0, False: 130]
  ------------------
 1237|      0|                *error = 0;
 1238|      0|            }
 1239|       |
 1240|    130|            return temp;
 1241|    130|        }
 1242|       |
 1243|      0|        ++port_to_try;
 1244|       |
 1245|      0|        if (port_to_try > port_to) {
  ------------------
  |  Branch (1245:13): [True: 0, False: 0]
  ------------------
 1246|      0|            port_to_try = port_from;
 1247|      0|        }
 1248|       |
 1249|      0|        *portptr = net_htons(port_to_try);
 1250|      0|    }
 1251|       |
 1252|      0|    Ip_Ntoa ip_str;
 1253|      0|    const int neterror = net_error();
 1254|      0|    Net_Strerror error_str;
 1255|      0|    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u",
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1256|      0|                 neterror, net_strerror(neterror, &error_str), net_ip_ntoa(ip, &ip_str), port_from, port_to);
 1257|      0|    kill_networking(temp);
 1258|       |
 1259|      0|    if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1259:9): [True: 0, False: 0]
  ------------------
 1260|      0|        *error = 1;
 1261|      0|    }
 1262|       |
 1263|       |    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1264|    130|}
kill_networking:
 1284|    130|{
 1285|    130|    if (net == nullptr) {
  ------------------
  |  |   63|    130|#define nullptr NULL
  ------------------
  |  Branch (1285:9): [True: 0, False: 130]
  ------------------
 1286|      0|        return;
 1287|      0|    }
 1288|       |
 1289|    130|    if (!net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (1289:9): [True: 130, False: 0]
  ------------------
 1290|       |        /* Socket is initialized, so we close it. */
 1291|    130|        kill_sock(net->ns, net->sock);
 1292|    130|    }
 1293|       |
 1294|    130|    netprof_kill(net->mem, net->udp_net_profile);
 1295|    130|    mem_delete(net->mem, net);
 1296|    130|}
ip_reset:
 1409|    130|{
 1410|    130|    if (ip == nullptr) {
  ------------------
  |  |   63|    130|#define nullptr NULL
  ------------------
  |  Branch (1410:9): [True: 0, False: 130]
  ------------------
 1411|      0|        return;
 1412|      0|    }
 1413|       |
 1414|    130|    *ip = empty_ip;
 1415|    130|}
ipport_reset:
 1421|    269|{
 1422|    269|    if (ipport == nullptr) {
  ------------------
  |  |   63|    269|#define nullptr NULL
  ------------------
  |  Branch (1422:9): [True: 0, False: 269]
  ------------------
 1423|      0|        return;
 1424|      0|    }
 1425|       |
 1426|    269|    *ipport = empty_ip_port;
 1427|    269|}
ip_init:
 1431|    130|{
 1432|    130|    if (ip == nullptr) {
  ------------------
  |  |   63|    130|#define nullptr NULL
  ------------------
  |  Branch (1432:9): [True: 0, False: 130]
  ------------------
 1433|      0|        return;
 1434|      0|    }
 1435|       |
 1436|    130|    ip_reset(ip);
 1437|    130|    ip->family = ipv6enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (1437:18): [True: 0, False: 130]
  ------------------
 1438|    130|}
ip_copy:
 1466|    130|{
 1467|    130|    if (source == nullptr || target == nullptr) {
  ------------------
  |  |   63|    260|#define nullptr NULL
  ------------------
                  if (source == nullptr || target == nullptr) {
  ------------------
  |  |   63|    130|#define nullptr NULL
  ------------------
  |  Branch (1467:9): [True: 0, False: 130]
  |  Branch (1467:30): [True: 0, False: 130]
  ------------------
 1468|      0|        return;
 1469|      0|    }
 1470|       |
 1471|    130|    *target = *source;
 1472|    130|}
unpack_ip_port:
 1567|    293|{
 1568|    293|    if (data == nullptr) {
  ------------------
  |  |   63|    293|#define nullptr NULL
  ------------------
  |  Branch (1568:9): [True: 0, False: 293]
  ------------------
 1569|      0|        return -1;
 1570|      0|    }
 1571|       |
 1572|    293|    bool is_ipv4;
 1573|    293|    Family host_family;
 1574|       |
 1575|    293|    if (data[0] == TOX_AF_INET) {
  ------------------
  |  |  197|    293|#define TOX_AF_INET 2
  ------------------
  |  Branch (1575:9): [True: 145, False: 148]
  ------------------
 1576|    145|        is_ipv4 = true;
 1577|    145|        host_family = net_family_ipv4();
 1578|    148|    } else if (data[0] == TOX_TCP_INET) {
  ------------------
  |  |  199|    148|#define TOX_TCP_INET 130
  ------------------
  |  Branch (1578:16): [True: 116, False: 32]
  ------------------
 1579|    116|        if (!tcp_enabled) {
  ------------------
  |  Branch (1579:13): [True: 0, False: 116]
  ------------------
 1580|      0|            return -1;
 1581|      0|        }
 1582|       |
 1583|    116|        is_ipv4 = true;
 1584|    116|        host_family = net_family_tcp_ipv4();
 1585|    116|    } else if (data[0] == TOX_AF_INET6) {
  ------------------
  |  |  198|     32|#define TOX_AF_INET6 10
  ------------------
  |  Branch (1585:16): [True: 3, False: 29]
  ------------------
 1586|      3|        is_ipv4 = false;
 1587|      3|        host_family = net_family_ipv6();
 1588|     29|    } else if (data[0] == TOX_TCP_INET6) {
  ------------------
  |  |  200|     29|#define TOX_TCP_INET6 138
  ------------------
  |  Branch (1588:16): [True: 5, False: 24]
  ------------------
 1589|      5|        if (!tcp_enabled) {
  ------------------
  |  Branch (1589:13): [True: 0, False: 5]
  ------------------
 1590|      0|            return -1;
 1591|      0|        }
 1592|       |
 1593|      5|        is_ipv4 = false;
 1594|      5|        host_family = net_family_tcp_ipv6();
 1595|     24|    } else {
 1596|     24|        return -1;
 1597|     24|    }
 1598|       |
 1599|    269|    ipport_reset(ip_port);
 1600|       |
 1601|    269|    if (is_ipv4) {
  ------------------
  |  Branch (1601:9): [True: 261, False: 8]
  ------------------
 1602|    261|        const uint32_t size = 1 + SIZE_IP4 + sizeof(uint16_t);
  ------------------
  |  |   31|    261|#define SIZE_IP4 4
  ------------------
 1603|       |
 1604|    261|        if (size > length) {
  ------------------
  |  Branch (1604:13): [True: 0, False: 261]
  ------------------
 1605|      0|            return -1;
 1606|      0|        }
 1607|       |
 1608|    261|        ip_port->ip.family = host_family;
 1609|    261|        memcpy(ip_port->ip.ip.v4.uint8, data + 1, SIZE_IP4);
  ------------------
  |  |   31|    261|#define SIZE_IP4 4
  ------------------
 1610|    261|        memcpy(&ip_port->port, data + 1 + SIZE_IP4, sizeof(uint16_t));
  ------------------
  |  |   31|    261|#define SIZE_IP4 4
  ------------------
 1611|    261|        return size;
 1612|    261|    } else {
 1613|      8|        const uint32_t size = 1 + SIZE_IP6 + sizeof(uint16_t);
  ------------------
  |  |   32|      8|#define SIZE_IP6 16
  ------------------
 1614|       |
 1615|      8|        if (size > length) {
  ------------------
  |  Branch (1615:13): [True: 8, False: 0]
  ------------------
 1616|      8|            return -1;
 1617|      8|        }
 1618|       |
 1619|      0|        ip_port->ip.family = host_family;
 1620|      0|        memcpy(ip_port->ip.ip.v6.uint8, data + 1, SIZE_IP6);
  ------------------
  |  |   32|      0|#define SIZE_IP6 16
  ------------------
 1621|      0|        memcpy(&ip_port->port, data + 1 + SIZE_IP6, sizeof(uint16_t));
  ------------------
  |  |   32|      0|#define SIZE_IP6 16
  ------------------
 1622|      0|        return size;
 1623|      8|    }
 1624|    269|}
net_ip_ntoa:
 1627|    113|{
 1628|    113|    assert(ip_str != nullptr);
  ------------------
  |  Branch (1628:5): [True: 113, False: 0]
  ------------------
 1629|       |
 1630|    113|    ip_str->ip_is_valid = false;
 1631|       |
 1632|    113|    if (ip == nullptr) {
  ------------------
  |  |   63|    113|#define nullptr NULL
  ------------------
  |  Branch (1632:9): [True: 0, False: 113]
  ------------------
 1633|      0|        snprintf(ip_str->buf, sizeof(ip_str->buf), "(IP invalid: NULL)");
 1634|      0|        ip_str->length = (uint16_t)strlen(ip_str->buf);
 1635|      0|        return ip_str->buf;
 1636|      0|    }
 1637|       |
 1638|    113|    if (!ip_parse_addr(ip, ip_str->buf, sizeof(ip_str->buf))) {
  ------------------
  |  Branch (1638:9): [True: 0, False: 113]
  ------------------
 1639|      0|        snprintf(ip_str->buf, sizeof(ip_str->buf), "(IP invalid, family %u)", ip->family.value);
 1640|      0|        ip_str->length = (uint16_t)strlen(ip_str->buf);
 1641|      0|        return ip_str->buf;
 1642|      0|    }
 1643|       |
 1644|       |    /* brute force protection against lacking termination */
 1645|    113|    ip_str->buf[sizeof(ip_str->buf) - 1] = '\0';
 1646|    113|    ip_str->length = (uint16_t)strlen(ip_str->buf);
 1647|    113|    ip_str->ip_is_valid = true;
 1648|       |
 1649|    113|    return ip_str->buf;
 1650|    113|}
ip_parse_addr:
 1653|    113|{
 1654|    113|    if (address == nullptr || ip == nullptr) {
  ------------------
  |  |   63|    226|#define nullptr NULL
  ------------------
                  if (address == nullptr || ip == nullptr) {
  ------------------
  |  |   63|    113|#define nullptr NULL
  ------------------
  |  Branch (1654:9): [True: 0, False: 113]
  |  Branch (1654:31): [True: 0, False: 113]
  ------------------
 1655|      0|        return false;
 1656|      0|    }
 1657|       |
 1658|    113|    if (net_family_is_ipv4(ip->family) || net_family_is_tcp_ipv4(ip->family)) {
  ------------------
  |  Branch (1658:9): [True: 0, False: 113]
  |  Branch (1658:43): [True: 113, False: 0]
  ------------------
 1659|    113|        struct in_addr addr;
 1660|    113|        assert(make_family(ip->family) == AF_INET);
  ------------------
  |  Branch (1660:9): [True: 113, False: 0]
  ------------------
 1661|    113|        fill_addr4(&ip->ip.v4, &addr);
 1662|    113|        return inet_ntop4(&addr, address, length) != nullptr;
  ------------------
  |  |   63|    113|#define nullptr NULL
  ------------------
 1663|    113|    }
 1664|       |
 1665|      0|    if (net_family_is_ipv6(ip->family) || net_family_is_tcp_ipv6(ip->family)) {
  ------------------
  |  Branch (1665:9): [True: 0, False: 0]
  |  Branch (1665:43): [True: 0, False: 0]
  ------------------
 1666|      0|        struct in6_addr addr;
 1667|      0|        assert(make_family(ip->family) == AF_INET6);
  ------------------
  |  Branch (1667:9): [True: 0, False: 0]
  ------------------
 1668|      0|        fill_addr6(&ip->ip.v6, &addr);
 1669|      0|        return inet_ntop6(&addr, address, length) != nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1670|      0|    }
 1671|       |
 1672|      0|    return false;
 1673|      0|}
net_socket:
 1940|    130|{
 1941|    130|    const int platform_domain = make_family(domain);
 1942|    130|    const int platform_type = make_socktype(type);
 1943|    130|    const int platform_prot = make_proto(protocol);
 1944|    130|    return ns->funcs->socket(ns->obj, platform_domain, platform_type, platform_prot);
 1945|    130|}
net_htons:
 1959|    130|{
 1960|       |    return htons(hostshort);
 1961|    130|}
network.c:net_setsockopt:
  766|    390|{
  767|    390|    return ns->funcs->setsockopt(ns->obj, sock, level, optname, optval, optlen);
  768|    390|}
network.c:net_sendto:
  789|      8|{
  790|      8|    return ns->funcs->sendto(ns->obj, sock, buf, len, ip_port);
  791|      8|}
network.c:net_bind:
  812|    130|{
  813|    130|    return ns->funcs->bind(ns->obj, sock, addr);
  814|    130|}
network.c:fill_addr4:
  319|    113|{
  320|    113|    addr->s_addr = ip->uint32;
  321|    113|}
network.c:make_family:
  257|    243|{
  258|    243|    switch (tox_family.value) {
  259|    130|        case TOX_AF_INET:
  ------------------
  |  |  197|    130|#define TOX_AF_INET 2
  ------------------
  |  Branch (259:9): [True: 130, False: 113]
  ------------------
  260|    243|        case TCP_INET:
  ------------------
  |  |  210|    243|#define TCP_INET (TOX_AF_INET6 + 2)
  |  |  ------------------
  |  |  |  |  198|    243|#define TOX_AF_INET6 10
  |  |  ------------------
  ------------------
  |  Branch (260:9): [True: 113, False: 130]
  ------------------
  261|    243|            return AF_INET;
  262|       |
  263|      0|        case TOX_AF_INET6:
  ------------------
  |  |  198|      0|#define TOX_AF_INET6 10
  ------------------
  |  Branch (263:9): [True: 0, False: 243]
  ------------------
  264|      0|        case TCP_INET6:
  ------------------
  |  |  211|      0|#define TCP_INET6 (TOX_AF_INET6 + 3)
  |  |  ------------------
  |  |  |  |  198|      0|#define TOX_AF_INET6 10
  |  |  ------------------
  ------------------
  |  Branch (264:9): [True: 0, False: 243]
  ------------------
  265|      0|            return AF_INET6;
  266|       |
  267|      0|        case TOX_AF_UNSPEC:
  ------------------
  |  |  196|      0|#define TOX_AF_UNSPEC 0
  ------------------
  |  Branch (267:9): [True: 0, False: 243]
  ------------------
  268|      0|            return AF_UNSPEC;
  269|       |
  270|      0|        default:
  ------------------
  |  Branch (270:9): [True: 0, False: 243]
  ------------------
  271|      0|            return tox_family.value;
  272|    243|    }
  273|    243|}
network.c:inet_ntop4:
  123|    113|{
  124|       |    return inet_ntop(AF_INET, addr, buf, bufsize);
  125|    113|}
network.c:make_socktype:
  243|    130|{
  244|    130|    switch (type) {
  245|      0|        case TOX_SOCK_STREAM:
  ------------------
  |  |  202|      0|#define TOX_SOCK_STREAM 1
  ------------------
  |  Branch (245:9): [True: 0, False: 130]
  ------------------
  246|      0|            return SOCK_STREAM;
  247|       |
  248|    130|        case TOX_SOCK_DGRAM:
  ------------------
  |  |  203|    130|#define TOX_SOCK_DGRAM 2
  ------------------
  |  Branch (248:9): [True: 130, False: 0]
  ------------------
  249|    130|            return SOCK_DGRAM;
  250|       |
  251|      0|        default:
  ------------------
  |  Branch (251:9): [True: 0, False: 130]
  ------------------
  252|      0|            return type;
  253|    130|    }
  254|    130|}
network.c:make_proto:
  229|    130|{
  230|    130|    switch (proto) {
  231|      0|        case TOX_PROTO_TCP:
  ------------------
  |  |  205|      0|#define TOX_PROTO_TCP 1
  ------------------
  |  Branch (231:9): [True: 0, False: 130]
  ------------------
  232|      0|            return IPPROTO_TCP;
  233|       |
  234|    130|        case TOX_PROTO_UDP:
  ------------------
  |  |  206|    130|#define TOX_PROTO_UDP 2
  ------------------
  |  Branch (234:9): [True: 130, False: 0]
  ------------------
  235|    130|            return IPPROTO_UDP;
  236|       |
  237|      0|        default:
  ------------------
  |  Branch (237:9): [True: 0, False: 130]
  ------------------
  238|      0|            return proto;
  239|    130|    }
  240|    130|}

tox_memory_malloc:
   37|    399|{
   38|    399|    void *const ptr = mem->funcs->malloc_callback(mem->user_data, size);
   39|    399|    return ptr;
   40|    399|}
tox_memory_dealloc:
   58|    394|{
   59|    394|    mem->funcs->dealloc_callback(mem->user_data, ptr);
   60|    394|}

