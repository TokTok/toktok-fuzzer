LLVMFuzzerTestOneInput:
  226|    225|{
  227|    225|    Fuzz_Data input{data, size};
  228|    225|    TestBootstrap(input);
  229|    225|    return 0;  // Non-zero return values are reserved for future use.
  230|    225|}
bootstrap_fuzz_test.cc:_ZN12_GLOBAL__N_113TestBootstrapERN3tox4test9Fuzz_DataE:
  111|    225|{
  112|    225|    SimulatedEnvironment env;
  113|    225|    env.fake_clock().advance(1000000000);  // Match legacy behavior
  114|    225|    auto node = env.create_node(33445);
  115|    225|    configure_fuzz_memory_source(env.fake_memory(), input);
  116|    225|    configure_fuzz_packet_source(*node->endpoint, input);
  117|       |
  118|       |    // Create a second null system for tox_events_equal check
  119|    225|    SimulatedEnvironment null_env;
  120|    225|    auto null_node = null_env.create_node(0);  // Port 0 (unbound/irrelevant)
  121|       |
  122|    225|    Ptr<Tox_Options> opts(tox_options_new(nullptr), tox_options_free);
  123|    225|    assert(opts != nullptr);
  ------------------
  |  Branch (123:5): [True: 225, False: 0]
  ------------------
  124|       |
  125|    225|    tox_options_set_log_callback(opts.get(),
  126|    225|        [](Tox *tox, Tox_Log_Level level, const char *file, uint32_t line, const char *func,
  127|    225|            const char *message, void *user_data) {
  128|       |            // Log to stdout.
  129|    225|            if (Fuzz_Data::FUZZ_DEBUG) {
  130|       |                // Approximate level name mapping
  131|    225|                char level_char = '?';
  132|    225|                switch (level) {
  133|    225|                case TOX_LOG_LEVEL_TRACE:
  134|    225|                    level_char = 'T';
  135|    225|                    break;
  136|    225|                case TOX_LOG_LEVEL_DEBUG:
  137|    225|                    level_char = 'D';
  138|    225|                    break;
  139|    225|                case TOX_LOG_LEVEL_INFO:
  140|    225|                    level_char = 'I';
  141|    225|                    break;
  142|    225|                case TOX_LOG_LEVEL_WARNING:
  143|    225|                    level_char = 'W';
  144|    225|                    break;
  145|    225|                case TOX_LOG_LEVEL_ERROR:
  146|    225|                    level_char = 'E';
  147|    225|                    break;
  148|    225|                }
  149|    225|                std::printf("[tox1] %c %s:%u(%s): %s\n", level_char, file, line, func, message);
  150|    225|            }
  151|    225|        });
  152|       |
  153|    225|    CONSUME1_OR_RETURN(const uint8_t, proxy_type, input);
  ------------------
  |  |  126|    225|    if ((INPUT).size() < sizeof(TYPE)) {      \
  |  |  ------------------
  |  |  |  Branch (126:9): [True: 0, False: 225]
  |  |  ------------------
  |  |  127|      0|        return;                               \
  |  |  128|      0|    }                                         \
  |  |  129|    225|    TYPE NAME = (INPUT).consume1(__func__)
  ------------------
  154|    225|    if (proxy_type == 0) {
  ------------------
  |  Branch (154:9): [True: 13, False: 212]
  ------------------
  155|     13|        tox_options_set_proxy_type(opts.get(), TOX_PROXY_TYPE_NONE);
  156|    212|    } else if (proxy_type == 1) {
  ------------------
  |  Branch (156:16): [True: 74, False: 138]
  ------------------
  157|     74|        tox_options_set_proxy_type(opts.get(), TOX_PROXY_TYPE_SOCKS5);
  158|     74|        tox_options_set_proxy_host(opts.get(), "127.0.0.1");
  159|     74|        tox_options_set_proxy_port(opts.get(), 8080);
  160|    138|    } else if (proxy_type == 2) {
  ------------------
  |  Branch (160:16): [True: 52, False: 86]
  ------------------
  161|     52|        tox_options_set_proxy_type(opts.get(), TOX_PROXY_TYPE_HTTP);
  162|     52|        tox_options_set_proxy_host(opts.get(), "127.0.0.1");
  163|     52|        tox_options_set_proxy_port(opts.get(), 8080);
  164|     52|    }
  165|       |
  166|    225|    CONSUME1_OR_RETURN(const uint8_t, tcp_relay_enabled, input);
  ------------------
  |  |  126|    225|    if ((INPUT).size() < sizeof(TYPE)) {      \
  |  |  ------------------
  |  |  |  Branch (126:9): [True: 4, False: 221]
  |  |  ------------------
  |  |  127|      4|        return;                               \
  |  |  128|      4|    }                                         \
  |  |  129|    225|    TYPE NAME = (INPUT).consume1(__func__)
  ------------------
  167|    221|    if (tcp_relay_enabled >= (UINT8_MAX / 2)) {
  ------------------
  |  Branch (167:9): [True: 164, False: 57]
  ------------------
  168|    164|        tox_options_set_tcp_port(opts.get(), 33445);
  169|    164|    }
  170|       |
  171|    221|    Tox_Options_Testing tox_options_testing;
  172|    221|    tox_options_testing.operating_system = &node->system;
  173|       |
  174|    221|    Tox_Err_New error_new;
  175|    221|    Tox_Err_New_Testing error_new_testing;
  176|    221|    Tox *tox = tox_new_testing(opts.get(), &error_new, &tox_options_testing, &error_new_testing);
  177|       |
  178|    221|    if (tox == nullptr) {
  ------------------
  |  Branch (178:9): [True: 155, False: 66]
  ------------------
  179|       |        // It might fail, because some I/O happens in tox_new, and the fuzzer
  180|       |        // might do things that make that I/O fail.
  181|    155|        return;
  182|    155|    }
  183|       |
  184|    221|    assert(error_new == TOX_ERR_NEW_OK);
  ------------------
  |  Branch (184:5): [True: 66, False: 0]
  ------------------
  185|     66|    assert(error_new_testing == TOX_ERR_NEW_TESTING_OK);
  ------------------
  |  Branch (185:5): [True: 66, False: 0]
  ------------------
  186|       |
  187|     66|    uint8_t pub_key[TOX_PUBLIC_KEY_SIZE] = {0};
  188|       |
  189|       |    // These may fail, but that's ok. We ignore their return values.
  190|     66|    tox_bootstrap(tox, "127.0.0.2", 33446, pub_key, nullptr);
  191|     66|    tox_add_tcp_relay(tox, "127.0.0.2", 33446, pub_key, nullptr);
  192|       |
  193|     66|    tox_events_init(tox);
  194|       |
  195|     66|    Tox_Dispatch *dispatch = tox_dispatch_new(nullptr);
  196|     66|    assert(dispatch != nullptr);
  ------------------
  |  Branch (196:5): [True: 66, False: 0]
  ------------------
  197|     66|    setup_callbacks(dispatch);
  198|       |
  199|     66|    size_t input_size = input.size();
  200|    102|    while (!input.empty()) {
  ------------------
  |  Branch (200:12): [True: 82, False: 20]
  ------------------
  201|     82|        Tox_Err_Events_Iterate error_iterate;
  202|     82|        Tox_Events *events = tox_events_iterate(tox, true, &error_iterate);
  203|     82|        assert(tox_events_equal(&null_node->system, events, events));
  ------------------
  |  Branch (203:9): [True: 82, False: 0]
  ------------------
  204|       |
  205|     82|        tox_dispatch_invoke(dispatch, events, tox);
  206|     82|        tox_events_free(events);
  207|       |
  208|     82|        env.advance_time(200);
  209|       |
  210|       |        // If no input was consumed, stop.
  211|     82|        if (input_size == input.size()) {
  ------------------
  |  Branch (211:13): [True: 46, False: 36]
  ------------------
  212|     46|            break;
  213|     46|        }
  214|       |
  215|     36|        input_size = input.size();
  216|     36|    }
  217|       |
  218|     66|    tox_dispatch_free(dispatch);
  219|     66|    tox_kill(tox);
  220|     66|}
bootstrap_fuzz_test.cc:_ZZN12_GLOBAL__N_113TestBootstrapERN3tox4test9Fuzz_DataEENK3$_0clEP3Tox13Tox_Log_LevelPKcjS9_S9_Pv:
  127|    323|            const char *message, void *user_data) {
  128|       |            // Log to stdout.
  129|    323|            if (Fuzz_Data::FUZZ_DEBUG) {
  ------------------
  |  Branch (129:17): [Folded, False: 323]
  ------------------
  130|       |                // Approximate level name mapping
  131|      0|                char level_char = '?';
  132|      0|                switch (level) {
  ------------------
  |  Branch (132:25): [True: 0, False: 0]
  ------------------
  133|      0|                case TOX_LOG_LEVEL_TRACE:
  ------------------
  |  Branch (133:17): [True: 0, False: 0]
  ------------------
  134|      0|                    level_char = 'T';
  135|      0|                    break;
  136|      0|                case TOX_LOG_LEVEL_DEBUG:
  ------------------
  |  Branch (136:17): [True: 0, False: 0]
  ------------------
  137|      0|                    level_char = 'D';
  138|      0|                    break;
  139|      0|                case TOX_LOG_LEVEL_INFO:
  ------------------
  |  Branch (139:17): [True: 0, False: 0]
  ------------------
  140|      0|                    level_char = 'I';
  141|      0|                    break;
  142|      0|                case TOX_LOG_LEVEL_WARNING:
  ------------------
  |  Branch (142:17): [True: 0, False: 0]
  ------------------
  143|      0|                    level_char = 'W';
  144|      0|                    break;
  145|      0|                case TOX_LOG_LEVEL_ERROR:
  ------------------
  |  Branch (145:17): [True: 0, False: 0]
  ------------------
  146|      0|                    level_char = 'E';
  147|      0|                    break;
  148|      0|                }
  149|      0|                std::printf("[tox1] %c %s:%u(%s): %s\n", level_char, file, line, func, message);
  150|      0|            }
  151|    323|        });
bootstrap_fuzz_test.cc:_ZN12_GLOBAL__N_115setup_callbacksEP12Tox_Dispatch:
   25|     66|{
   26|     66|    tox_events_callback_conference_connected(
   27|     66|        dispatch, [](const Tox_Event_Conference_Connected *event, void *user_data) {
   28|     66|            assert(event == nullptr);
   29|     66|        });
   30|     66|    tox_events_callback_conference_connected(
   31|     66|        dispatch, [](const Tox_Event_Conference_Connected *event, void *user_data) {
   32|     66|            assert(event == nullptr);
   33|     66|        });
   34|     66|    tox_events_callback_conference_invite(
   35|     66|        dispatch, [](const Tox_Event_Conference_Invite *event, void *user_data) {
   36|     66|            assert(event == nullptr);
   37|     66|        });
   38|     66|    tox_events_callback_conference_message(
   39|     66|        dispatch, [](const Tox_Event_Conference_Message *event, void *user_data) {
   40|     66|            assert(event == nullptr);
   41|     66|        });
   42|     66|    tox_events_callback_conference_peer_list_changed(
   43|     66|        dispatch, [](const Tox_Event_Conference_Peer_List_Changed *event, void *user_data) {
   44|     66|            assert(event == nullptr);
   45|     66|        });
   46|     66|    tox_events_callback_conference_peer_name(
   47|     66|        dispatch, [](const Tox_Event_Conference_Peer_Name *event, void *user_data) {
   48|     66|            assert(event == nullptr);
   49|     66|        });
   50|     66|    tox_events_callback_conference_title(dispatch,
   51|     66|        [](const Tox_Event_Conference_Title *event, void *user_data) { assert(event == nullptr); });
   52|     66|    tox_events_callback_file_chunk_request(
   53|     66|        dispatch, [](const Tox_Event_File_Chunk_Request *event, void *user_data) {
   54|     66|            assert(event == nullptr);
   55|     66|        });
   56|     66|    tox_events_callback_file_recv(dispatch,
   57|     66|        [](const Tox_Event_File_Recv *event, void *user_data) { assert(event == nullptr); });
   58|     66|    tox_events_callback_file_recv_chunk(dispatch,
   59|     66|        [](const Tox_Event_File_Recv_Chunk *event, void *user_data) { assert(event == nullptr); });
   60|     66|    tox_events_callback_file_recv_control(
   61|     66|        dispatch, [](const Tox_Event_File_Recv_Control *event, void *user_data) {
   62|     66|            assert(event == nullptr);
   63|     66|        });
   64|     66|    tox_events_callback_friend_connection_status(
   65|     66|        dispatch, [](const Tox_Event_Friend_Connection_Status *event, void *user_data) {
   66|     66|            assert(event == nullptr);
   67|     66|        });
   68|     66|    tox_events_callback_friend_lossless_packet(
   69|     66|        dispatch, [](const Tox_Event_Friend_Lossless_Packet *event, void *user_data) {
   70|     66|            assert(event == nullptr);
   71|     66|        });
   72|     66|    tox_events_callback_friend_lossy_packet(
   73|     66|        dispatch, [](const Tox_Event_Friend_Lossy_Packet *event, void *user_data) {
   74|     66|            assert(event == nullptr);
   75|     66|        });
   76|     66|    tox_events_callback_friend_message(dispatch,
   77|     66|        [](const Tox_Event_Friend_Message *event, void *user_data) { assert(event == nullptr); });
   78|     66|    tox_events_callback_friend_name(dispatch,
   79|     66|        [](const Tox_Event_Friend_Name *event, void *user_data) { assert(event == nullptr); });
   80|     66|    tox_events_callback_friend_read_receipt(
   81|     66|        dispatch, [](const Tox_Event_Friend_Read_Receipt *event, void *user_data) {
   82|     66|            assert(event == nullptr);
   83|     66|        });
   84|     66|    tox_events_callback_friend_request(
   85|     66|        dispatch, [](const Tox_Event_Friend_Request *event, void *user_data) {
   86|     66|            Tox *tox = static_cast<Tox *>(user_data);
   87|     66|            Tox_Err_Friend_Add err;
   88|     66|            tox_friend_add_norequest(tox, tox_event_friend_request_get_public_key(event), &err);
   89|     66|            if (!(err == TOX_ERR_FRIEND_ADD_OK || err == TOX_ERR_FRIEND_ADD_OWN_KEY
   90|     66|                    || err == TOX_ERR_FRIEND_ADD_ALREADY_SENT
   91|     66|                    || err == TOX_ERR_FRIEND_ADD_BAD_CHECKSUM
   92|     66|                    || err == TOX_ERR_FRIEND_ADD_MALLOC)) {
   93|     66|                printf("unexpected error: %s\n", tox_err_friend_add_to_string(err));
   94|     66|            }
   95|     66|        });
   96|     66|    tox_events_callback_friend_status(dispatch,
   97|     66|        [](const Tox_Event_Friend_Status *event, void *user_data) { assert(event == nullptr); });
   98|     66|    tox_events_callback_friend_status_message(
   99|     66|        dispatch, [](const Tox_Event_Friend_Status_Message *event, void *user_data) {
  100|     66|            assert(event == nullptr);
  101|     66|        });
  102|     66|    tox_events_callback_friend_typing(dispatch,
  103|     66|        [](const Tox_Event_Friend_Typing *event, void *user_data) { assert(event == nullptr); });
  104|     66|    tox_events_callback_self_connection_status(
  105|     66|        dispatch, [](const Tox_Event_Self_Connection_Status *event, void *user_data) {
  106|     66|            assert(event == nullptr);
  107|     66|        });
  108|     66|}

_ZN3tox4test16FakeNetworkStackC2ERNS0_15NetworkUniverseERK2IP:
   98|    450|    : universe_(universe)
   99|    450|    , node_ip_(node_ip)
  100|    450|{
  101|    450|}
_ZN3tox4test16FakeNetworkStackD2Ev:
  103|    450|FakeNetworkStack::~FakeNetworkStack() = default;
_ZN3tox4test16FakeNetworkStack9c_networkEv:
  105|    450|struct Network FakeNetworkStack::c_network() { return Network{&kNetworkVtable, this}; }
_ZN3tox4test16FakeNetworkStack6socketEiii:
  108|    529|{
  109|    529|    std::lock_guard<std::mutex> lock(mutex_);
  110|    529|    int fd = next_fd_++;
  111|       |
  112|    529|    std::unique_ptr<FakeSocket> sock;
  113|    529|    if (type == SOCK_DGRAM) {
  ------------------
  |  Branch (113:9): [True: 316, False: 213]
  ------------------
  114|    316|        if (universe_.is_verbose()) {
  ------------------
  |  Branch (114:13): [True: 0, False: 316]
  ------------------
  115|      0|            std::cerr << "[FakeNetworkStack] create UDP socket fd=" << fd << std::endl;
  116|      0|        }
  117|    316|        sock = std::make_unique<FakeUdpSocket>(universe_);
  118|    316|    } else if (type == SOCK_STREAM) {
  ------------------
  |  Branch (118:16): [True: 213, False: 0]
  ------------------
  119|    213|        if (universe_.is_verbose()) {
  ------------------
  |  Branch (119:13): [True: 0, False: 213]
  ------------------
  120|      0|            std::cerr << "[FakeNetworkStack] create TCP socket fd=" << fd << std::endl;
  121|      0|        }
  122|    213|        sock = std::make_unique<FakeTcpSocket>(universe_);
  123|    213|    } else {
  124|       |        // Unknown type
  125|      0|        return net_socket_from_native(-1);
  126|      0|    }
  127|       |
  128|    529|    sockets_[fd] = std::move(sock);
  129|    529|    sockets_[fd]->set_ip(node_ip_);
  130|    529|    return net_socket_from_native(fd);
  131|    529|}
_ZN3tox4test16FakeNetworkStack8get_sockE6Socket:
  134|  2.48k|{
  135|  2.48k|    std::lock_guard<std::mutex> lock(mutex_);
  136|  2.48k|    auto it = sockets_.find(net_socket_to_native(sock));
  137|  2.48k|    if (it != sockets_.end()) {
  ------------------
  |  Branch (137:9): [True: 2.48k, False: 0]
  ------------------
  138|  2.48k|        return it->second.get();
  139|  2.48k|    }
  140|      0|    return nullptr;
  141|  2.48k|}
_ZN3tox4test16FakeNetworkStack5closeE6Socket:
  144|    205|{
  145|    205|    std::lock_guard<std::mutex> lock(mutex_);
  146|    205|    int fd = net_socket_to_native(sock);
  147|    205|    auto it = sockets_.find(fd);
  148|    205|    if (it == sockets_.end()) {
  ------------------
  |  Branch (148:9): [True: 0, False: 205]
  ------------------
  149|      0|        errno = EBADF;
  150|      0|        return -1;
  151|      0|    }
  152|    205|    it->second->close();
  153|    205|    sockets_.erase(it);
  154|    205|    return 0;
  155|    205|}
_ZN3tox4test16FakeNetworkStack4bindE6SocketPK7IP_Port:
  159|    542|{
  160|    542|    if (auto *s = get_sock(sock)) {
  ------------------
  |  Branch (160:15): [True: 542, False: 0]
  ------------------
  161|    542|        int ret = s->bind(addr);
  162|    542|        if (universe_.is_verbose() && ret == 0) {
  ------------------
  |  Branch (162:13): [True: 0, False: 542]
  |  Branch (162:39): [True: 0, False: 0]
  ------------------
  163|      0|            char ip_str[TOX_INET_ADDRSTRLEN];
  164|      0|            ip_parse_addr(&s->ip_address(), ip_str, sizeof(ip_str));
  165|      0|            std::cerr << "[FakeNetworkStack] bound socket to " << ip_str << ":" << s->local_port()
  166|      0|                      << std::endl;
  167|      0|        }
  168|    542|        return ret;
  169|    542|    }
  170|    542|    errno = EBADF;
  171|      0|    return -1;
  172|    542|}
_ZN3tox4test16FakeNetworkStack6listenE6Socketi:
  183|    135|{
  184|    135|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (184:15): [True: 135, False: 0]
  ------------------
  185|    135|        return s->listen(backlog);
  186|    135|    errno = EBADF;
  187|      0|    return -1;
  188|    135|}
_ZN3tox4test16FakeNetworkStack4sendE6SocketPKhm:
  217|     88|{
  218|     88|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (218:15): [True: 88, False: 0]
  ------------------
  219|     88|        return s->send(buf, len);
  220|     88|    errno = EBADF;
  221|      0|    return -1;
  222|     88|}
_ZN3tox4test16FakeNetworkStack6sendtoE6SocketPKhmPK7IP_Port:
  241|    625|{
  242|    625|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (242:15): [True: 625, False: 0]
  ------------------
  243|    625|        return s->sendto(buf, len, addr);
  244|    625|    errno = EBADF;
  245|      0|    return -1;
  246|    625|}
_ZN3tox4test16FakeNetworkStack8recvfromE6SocketPhmP7IP_Port:
  249|     65|{
  250|     65|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (250:15): [True: 65, False: 0]
  ------------------
  251|     65|        return s->recvfrom(buf, len, addr);
  252|     65|    errno = EBADF;
  253|      0|    return -1;
  254|     65|}
_ZN3tox4test16FakeNetworkStack15socket_nonblockE6Socketb:
  257|    304|{
  258|    304|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (258:15): [True: 304, False: 0]
  ------------------
  259|    304|        return s->socket_nonblock(nonblock);
  260|    304|    errno = EBADF;
  261|      0|    return -1;
  262|    304|}
_ZN3tox4test16FakeNetworkStack10getsockoptE6SocketiiPvPm:
  265|    226|{
  266|    226|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (266:15): [True: 226, False: 0]
  ------------------
  267|    226|        return s->getsockopt(level, optname, optval, optlen);
  268|    226|    errno = EBADF;
  269|      0|    return -1;
  270|    226|}
_ZN3tox4test16FakeNetworkStack10setsockoptE6SocketiiPKvm:
  274|    499|{
  275|    499|    if (auto *s = get_sock(sock))
  ------------------
  |  Branch (275:15): [True: 499, False: 0]
  ------------------
  276|    499|        return s->setsockopt(level, optname, optval, optlen);
  277|    499|    errno = EBADF;
  278|      0|    return -1;
  279|    499|}
_ZN3tox4test16FakeNetworkStack21get_bound_udp_socketsEv:
  292|    450|{
  293|    450|    std::lock_guard<std::mutex> lock(mutex_);
  294|    450|    std::vector<FakeUdpSocket *> result;
  295|    450|    for (const auto &pair : sockets_) {
  ------------------
  |  Branch (295:27): [True: 225, False: 450]
  ------------------
  296|    225|        FakeSocket *s = pair.second.get();
  297|    225|        if (s->type() == SOCK_DGRAM && s->local_port() != 0) {
  ------------------
  |  Branch (297:13): [True: 225, False: 0]
  |  Branch (297:40): [True: 225, False: 0]
  ------------------
  298|    225|            result.push_back(static_cast<FakeUdpSocket *>(s));
  299|    225|        }
  300|    225|    }
  301|    450|    return result;
  302|    450|}
fake_network_stack.cc:_ZNK3tox4test3$_0clEPv6Socket:
   13|    205|                 Socket sock) { return static_cast<FakeNetworkStack *>(obj)->close(sock); },
fake_network_stack.cc:_ZNK3tox4test3$_2clEPv6SocketPK7IP_Port:
   17|    317|        [](void *_Nonnull obj, Socket sock, const IP_Port *_Nonnull addr) {
   18|    317|            return static_cast<FakeNetworkStack *>(obj)->bind(sock, addr);
   19|    317|        },
fake_network_stack.cc:_ZNK3tox4test3$_3clEPv6Socketi:
   22|    135|          int backlog) { return static_cast<FakeNetworkStack *>(obj)->listen(sock, backlog); },
fake_network_stack.cc:_ZNK3tox4test3$_7clEPv6SocketPhmP7IP_Port:
   33|     65|            IP_Port *_Nonnull addr) {
   34|     65|            return static_cast<FakeNetworkStack *>(obj)->recvfrom(sock, buf, len, addr);
   35|     65|        },
fake_network_stack.cc:_ZNK3tox4test3$_8clEPv6SocketPKhm:
   37|     88|                size_t len) { return static_cast<FakeNetworkStack *>(obj)->send(sock, buf, len); },
fake_network_stack.cc:_ZNK3tox4test3$_9clEPv6SocketPKhmPK7IP_Port:
   40|    625|            const IP_Port *_Nonnull addr) {
   41|    625|            return static_cast<FakeNetworkStack *>(obj)->sendto(sock, buf, len, addr);
   42|    625|        },
fake_network_stack.cc:_ZNK3tox4test4$_10clEPviii:
   45|    304|          int proto) { return static_cast<FakeNetworkStack *>(obj)->socket(domain, type, proto); },
fake_network_stack.cc:_ZNK3tox4test4$_11clEPv6Socketb:
   47|    304|        [](void *_Nonnull obj, Socket sock, bool nonblock) {
   48|    304|            return static_cast<FakeNetworkStack *>(obj)->socket_nonblock(sock, nonblock);
   49|    304|        },
fake_network_stack.cc:_ZNK3tox4test4$_12clEPv6SocketiiS2_Pm:
   52|    226|            size_t *_Nonnull optlen) {
   53|    226|            return static_cast<FakeNetworkStack *>(obj)->getsockopt(
   54|    226|                sock, level, optname, optval, optlen);
   55|    226|        },
fake_network_stack.cc:_ZNK3tox4test4$_13clEPv6SocketiiPKvm:
   58|    499|            size_t optlen) {
   59|    499|            return static_cast<FakeNetworkStack *>(obj)->setsockopt(
   60|    499|                sock, level, optname, optval, optlen);
   61|    499|        },

_ZN3tox4test10FakeSocketC2ERNS0_15NetworkUniverseEi:
   19|    529|    : universe_(universe)
   20|    529|    , type_(type)
   21|    529|{
   22|    529|    ip_init(&ip_, false);
   23|    529|    ip_.ip.v4.uint32 = net_htonl(0x7F000001);
   24|    529|}
_ZN3tox4test10FakeSocketD2Ev:
   26|    529|FakeSocket::~FakeSocket() = default;
_ZN3tox4test10FakeSocket10getsockoptEiiPvPm:
   35|     91|{
   36|     91|    return 0;
   37|     91|}
_ZN3tox4test10FakeSocket10setsockoptEiiPKvm:
   39|    499|{
   40|    499|    return 0;
   41|    499|}
_ZN3tox4test10FakeSocket15socket_nonblockEb:
   43|    304|{
   44|    304|    nonblocking_ = nonblock;
   45|    304|    return 0;
   46|    304|}
_ZN3tox4test13FakeUdpSocketC2ERNS0_15NetworkUniverseE:
   51|    316|    : FakeSocket(universe, SOCK_DGRAM)
   52|    316|{
   53|    316|}
_ZN3tox4test13FakeUdpSocketD2Ev:
   55|    316|FakeUdpSocket::~FakeUdpSocket() { close_impl(); }
_ZN3tox4test13FakeUdpSocket5closeEv:
   58|     91|{
   59|     91|    std::lock_guard<std::mutex> lock(mutex_);
   60|     91|    close_impl();
   61|     91|    return 0;
   62|     91|}
_ZN3tox4test13FakeUdpSocket10close_implEv:
   65|    407|{
   66|    407|    if (local_port_ != 0) {
  ------------------
  |  Branch (66:9): [True: 316, False: 91]
  ------------------
   67|    316|        universe_.unbind_udp(ip_, local_port_);
   68|    316|        local_port_ = 0;
   69|    316|    }
   70|    407|}
_ZN3tox4test13FakeUdpSocket4bindEPK7IP_Port:
   73|    407|{
   74|    407|    std::lock_guard<std::mutex> lock(mutex_);
   75|    407|    if (local_port_ != 0)
  ------------------
  |  Branch (75:9): [True: 0, False: 407]
  ------------------
   76|      0|        return -1;  // Already bound
   77|       |
   78|    407|    uint16_t port = addr->port;
   79|    407|    if (port == 0) {
  ------------------
  |  Branch (79:9): [True: 0, False: 407]
  ------------------
   80|      0|        port = universe_.find_free_port(ip_);
   81|    407|    } else {
   82|    407|        port = net_ntohs(port);
   83|    407|    }
   84|       |
   85|    407|    if (universe_.bind_udp(ip_, port, this)) {
  ------------------
  |  Branch (85:9): [True: 316, False: 91]
  ------------------
   86|    316|        local_port_ = port;
   87|    316|        return 0;
   88|    316|    }
   89|    407|    errno = EADDRINUSE;
   90|     91|    return -1;
   91|    407|}
_ZN3tox4test13FakeUdpSocket6sendtoEPKhmPK7IP_Port:
  128|    625|{
  129|    625|    std::lock_guard<std::mutex> lock(mutex_);
  130|    625|    if (local_port_ == 0) {
  ------------------
  |  Branch (130:9): [True: 0, False: 625]
  ------------------
  131|       |        // Implicit bind
  132|      0|        uint16_t p = universe_.find_free_port(ip_);
  133|      0|        if (universe_.bind_udp(ip_, p, this)) {
  ------------------
  |  Branch (133:13): [True: 0, False: 0]
  ------------------
  134|      0|            local_port_ = p;
  135|      0|        } else {
  136|      0|            errno = EADDRINUSE;
  137|      0|            return -1;
  138|      0|        }
  139|      0|    }
  140|       |
  141|    625|    Packet p{};
  142|       |    // Source
  143|    625|    p.from.ip = ip_;
  144|    625|    p.from.port = net_htons(local_port_);
  145|    625|    p.to = *addr;
  146|    625|    p.data.assign(buf, buf + len);
  147|    625|    p.is_tcp = false;
  148|       |
  149|    625|    universe_.send_packet(p);
  150|    625|    if (universe_.is_verbose()) {
  ------------------
  |  Branch (150:9): [True: 0, False: 625]
  ------------------
  151|      0|        Ip_Ntoa ip_str;
  152|      0|        net_ip_ntoa(&addr->ip, &ip_str);
  153|      0|        std::cerr << "[FakeUdpSocket] sent " << len << " bytes from port " << local_port_ << " to "
  154|      0|                  << ip_str.buf << ":" << net_ntohs(addr->port) << std::endl;
  155|      0|    }
  156|    625|    return len;
  157|    625|}
_ZN3tox4test13FakeUdpSocket8recvfromEPhmP7IP_Port:
  160|     65|{
  161|     65|    RecvObserver observer_copy;
  162|     65|    std::vector<uint8_t> data_copy;
  163|     65|    IP_Port from_copy;
  164|     65|    size_t copy_len = 0;
  165|       |
  166|     65|    {
  167|     65|        std::lock_guard<std::mutex> lock(mutex_);
  168|       |
  169|     65|        if (recv_queue_.empty() && packet_source_) {
  ------------------
  |  Branch (169:13): [True: 65, False: 0]
  |  Branch (169:36): [True: 0, False: 65]
  ------------------
  170|       |            // NOTE: We call packet_source_ with lock held.
  171|       |            // Be careful not to call back into socket methods from packet_source_.
  172|      0|            std::vector<uint8_t> data;
  173|      0|            IP_Port from;
  174|      0|            if (packet_source_(data, from)) {
  ------------------
  |  Branch (174:17): [True: 0, False: 0]
  ------------------
  175|      0|                recv_queue_.push_back({std::move(data), from});
  176|      0|            }
  177|      0|        }
  178|       |
  179|     65|        if (recv_queue_.empty()) {
  ------------------
  |  Branch (179:13): [True: 65, False: 0]
  ------------------
  180|     65|            errno = EWOULDBLOCK;
  181|     65|            return -1;
  182|     65|        }
  183|       |
  184|      0|        auto &p = recv_queue_.front();
  185|      0|        copy_len = std::min(len, p.data.size());
  186|      0|        std::memcpy(buf, p.data.data(), copy_len);
  187|      0|        *addr = p.from;
  188|       |
  189|      0|        if (recv_observer_) {
  ------------------
  |  Branch (189:13): [True: 0, False: 0]
  ------------------
  190|      0|            observer_copy = recv_observer_;
  191|      0|            data_copy = p.data;
  192|      0|            from_copy = p.from;
  193|      0|        }
  194|       |
  195|      0|        recv_queue_.pop_front();
  196|      0|    }
  197|       |
  198|      0|    if (observer_copy) {
  ------------------
  |  Branch (198:9): [True: 0, False: 0]
  ------------------
  199|      0|        observer_copy(data_copy, from_copy);
  200|      0|    }
  201|       |
  202|      0|    if (universe_.is_verbose()) {
  ------------------
  |  Branch (202:9): [True: 0, False: 0]
  ------------------
  203|      0|        std::cerr << "[FakeUdpSocket] recv " << copy_len << " bytes at port " << local_port_
  204|      0|                  << " from port " << net_ntohs(addr->port) << std::endl;
  205|      0|    }
  206|       |
  207|      0|    return copy_len;
  208|     65|}
_ZN3tox4test13FakeUdpSocket17set_packet_sourceENSt3__18functionIFbRNS2_6vectorIhNS2_9allocatorIhEEEER7IP_PortEEE:
  226|    225|{
  227|    225|    std::lock_guard<std::mutex> lock(mutex_);
  228|    225|    packet_source_ = std::move(source);
  229|    225|}
_ZN3tox4test13FakeTcpSocketC2ERNS0_15NetworkUniverseE:
  240|    213|    : FakeSocket(universe, SOCK_STREAM)
  241|    213|{
  242|    213|    ipport_reset(&remote_addr_);
  243|    213|}
_ZN3tox4test13FakeTcpSocketD2Ev:
  245|    213|FakeTcpSocket::~FakeTcpSocket() { close_impl(); }
_ZN3tox4test13FakeTcpSocket5closeEv:
  248|    114|{
  249|    114|    std::lock_guard<std::mutex> lock(mutex_);
  250|    114|    if (state_ == ESTABLISHED || state_ == SYN_SENT || state_ == SYN_RECEIVED
  ------------------
  |  Branch (250:9): [True: 0, False: 114]
  |  Branch (250:34): [True: 0, False: 114]
  |  Branch (250:56): [True: 0, False: 114]
  ------------------
  251|    114|        || state_ == CLOSE_WAIT) {
  ------------------
  |  Branch (251:12): [True: 0, False: 114]
  ------------------
  252|       |        // Send RST to peer
  253|      0|        Packet p{};
  254|      0|        p.from.ip = ip_;
  255|      0|        p.from.port = net_htons(local_port_);
  256|      0|        p.to = remote_addr_;
  257|      0|        p.is_tcp = true;
  258|      0|        p.tcp_flags = 0x04;  // RST
  259|      0|        universe_.send_packet(p);
  260|      0|    }
  261|    114|    close_impl();
  262|    114|    return 0;
  263|    114|}
_ZN3tox4test13FakeTcpSocket10close_implEv:
  266|    327|{
  267|    327|    if (local_port_ != 0) {
  ------------------
  |  Branch (267:9): [True: 135, False: 192]
  ------------------
  268|    135|        universe_.unbind_tcp(ip_, local_port_, this);
  269|    135|        local_port_ = 0;
  270|    135|    }
  271|    327|    state_ = CLOSED;
  272|    327|}
_ZN3tox4test13FakeTcpSocket4bindEPK7IP_Port:
  275|    135|{
  276|    135|    std::lock_guard<std::mutex> lock(mutex_);
  277|    135|    if (local_port_ != 0)
  ------------------
  |  Branch (277:9): [True: 0, False: 135]
  ------------------
  278|      0|        return -1;
  279|       |
  280|    135|    uint16_t port = addr->port;
  281|    135|    if (port == 0) {
  ------------------
  |  Branch (281:9): [True: 0, False: 135]
  ------------------
  282|      0|        port = universe_.find_free_port(ip_);
  283|    135|    } else {
  284|    135|        port = net_ntohs(port);
  285|    135|    }
  286|       |
  287|    135|    if (universe_.bind_tcp(ip_, port, this)) {
  ------------------
  |  Branch (287:9): [True: 135, False: 0]
  ------------------
  288|    135|        local_port_ = port;
  289|    135|        return 0;
  290|    135|    }
  291|    135|    errno = EADDRINUSE;
  292|      0|    return -1;
  293|    135|}
_ZN3tox4test13FakeTcpSocket6listenEi:
  296|    135|{
  297|    135|    std::lock_guard<std::mutex> lock(mutex_);
  298|    135|    state_ = LISTEN;
  299|    135|    backlog_ = backlog;
  300|    135|    return 0;
  301|    135|}
_ZN3tox4test13FakeTcpSocket4sendEPKhm:
  374|     88|{
  375|     88|    std::lock_guard<std::mutex> lock(mutex_);
  376|     88|    if (state_ != ESTABLISHED) {
  ------------------
  |  Branch (376:9): [True: 88, False: 0]
  ------------------
  377|     88|        if (universe_.is_verbose()) {
  ------------------
  |  Branch (377:13): [True: 0, False: 88]
  ------------------
  378|      0|            std::cerr << "[FakeTcpSocket] send failed: state " << state_ << " port " << local_port_
  379|      0|                      << std::endl;
  380|      0|        }
  381|     88|        if (state_ == SYN_SENT || state_ == SYN_RECEIVED) {
  ------------------
  |  Branch (381:13): [True: 0, False: 88]
  |  Branch (381:35): [True: 0, False: 88]
  ------------------
  382|      0|            errno = EWOULDBLOCK;
  383|     88|        } else {
  384|     88|            errno = ENOTCONN;
  385|     88|        }
  386|     88|        return -1;
  387|     88|    }
  388|       |
  389|       |    // Wrap as TCP packet
  390|      0|    Packet p{};
  391|       |    // Source
  392|      0|    p.from.ip = ip_;
  393|      0|    p.from.port = net_htons(local_port_);
  394|      0|    p.to = remote_addr_;
  395|      0|    p.data.assign(buf, buf + len);
  396|      0|    p.is_tcp = true;
  397|      0|    p.tcp_flags = 0x10;  // ACK (Data packets usually have ACK)
  398|      0|    p.seq = next_seq_;
  399|      0|    p.ack = last_ack_;
  400|       |
  401|      0|    next_seq_ += len;
  402|      0|    universe_.send_packet(p);
  403|      0|    return len;
  404|     88|}
_ZN3tox4test13FakeTcpSocket10getsockoptEiiPvPm:
  466|    135|{
  467|    135|    if (universe_.is_verbose()) {
  ------------------
  |  Branch (467:9): [True: 0, False: 135]
  ------------------
  468|      0|        std::cerr << "[FakeTcpSocket] getsockopt level=" << level << " optname=" << optname
  469|      0|                  << " state=" << state_ << std::endl;
  470|      0|    }
  471|    135|    if (level == SOL_SOCKET && optname == SO_ERROR) {
  ------------------
  |  Branch (471:9): [True: 0, False: 135]
  |  Branch (471:32): [True: 0, False: 0]
  ------------------
  472|      0|        int error = 0;
  473|      0|        if (state_ == SYN_SENT || state_ == SYN_RECEIVED) {
  ------------------
  |  Branch (473:13): [True: 0, False: 0]
  |  Branch (473:35): [True: 0, False: 0]
  ------------------
  474|      0|            error = EINPROGRESS;
  475|      0|        } else if (state_ == CLOSED) {
  ------------------
  |  Branch (475:20): [True: 0, False: 0]
  ------------------
  476|      0|            error = ECONNREFUSED;
  477|      0|        }
  478|       |
  479|      0|        if (*optlen >= sizeof(int)) {
  ------------------
  |  Branch (479:13): [True: 0, False: 0]
  ------------------
  480|      0|            *static_cast<int *>(optval) = error;
  481|      0|            *optlen = sizeof(int);
  482|      0|        }
  483|      0|        if (universe_.is_verbose()) {
  ------------------
  |  Branch (483:13): [True: 0, False: 0]
  ------------------
  484|      0|            std::cerr << "[FakeTcpSocket] getsockopt SO_ERROR returning error=" << error
  485|      0|                      << std::endl;
  486|      0|        }
  487|      0|        return 0;
  488|      0|    }
  489|    135|    return 0;
  490|    135|}

_ZNK3tox4test10FakeSocket4typeEv:
   59|    225|    int type() const { return type_; }
_ZNK3tox4test10FakeSocket10local_portEv:
   60|    225|    uint16_t local_port() const { return local_port_; }
_ZN3tox4test10FakeSocket6set_ipERK2IP:
   63|    529|    void set_ip(const IP &ip) { ip_ = ip; }

_ZNK3tox4test15NetworkUniverse11IP_Port_KeyltERKS2_:
   35|  5.24k|{
   36|  5.24k|    if (port != other.port)
  ------------------
  |  Branch (36:9): [True: 3.72k, False: 1.52k]
  ------------------
   37|  3.72k|        return port < other.port;
   38|  1.52k|    if (ip.family.value != other.ip.family.value)
  ------------------
  |  Branch (38:9): [True: 272, False: 1.24k]
  ------------------
   39|    272|        return ip.family.value < other.ip.family.value;
   40|       |
   41|  1.24k|    if (net_family_is_ipv4(ip.family)) {
  ------------------
  |  Branch (41:9): [True: 1.24k, False: 0]
  ------------------
   42|  1.24k|        return ip.ip.v4.uint32 < other.ip.ip.v4.uint32;
   43|  1.24k|    }
   44|       |
   45|      0|    return std::memcmp(&ip.ip.v6, &other.ip.ip.v6, sizeof(ip.ip.v6)) < 0;
   46|  1.24k|}
_ZN3tox4test15NetworkUniverseC2Ev:
   48|    450|NetworkUniverse::NetworkUniverse() { }
_ZN3tox4test15NetworkUniverseD2Ev:
   49|    450|NetworkUniverse::~NetworkUniverse() { }
_ZN3tox4test15NetworkUniverse8bind_udpE2IPtPNS0_13FakeUdpSocketE:
   52|    407|{
   53|    407|    std::lock_guard<std::recursive_mutex> lock(mutex_);
   54|    407|    IP_Port_Key key{ip, port};
   55|    407|    if (udp_bindings_.count(key))
  ------------------
  |  Branch (55:9): [True: 91, False: 316]
  ------------------
   56|     91|        return false;
   57|    316|    udp_bindings_[key] = socket;
   58|    316|    return true;
   59|    407|}
_ZN3tox4test15NetworkUniverse10unbind_udpE2IPt:
   62|    316|{
   63|    316|    std::lock_guard<std::recursive_mutex> lock(mutex_);
   64|    316|    udp_bindings_.erase({ip, port});
   65|    316|}
_ZN3tox4test15NetworkUniverse8bind_tcpE2IPtPNS0_13FakeTcpSocketE:
   68|    135|{
   69|    135|    std::lock_guard<std::recursive_mutex> lock(mutex_);
   70|    135|    tcp_bindings_.insert({{ip, port}, socket});
   71|    135|    return true;
   72|    135|}
_ZN3tox4test15NetworkUniverse10unbind_tcpE2IPtPNS0_13FakeTcpSocketE:
   75|    135|{
   76|    135|    std::lock_guard<std::recursive_mutex> lock(mutex_);
   77|    135|    auto range = tcp_bindings_.equal_range({ip, port});
   78|    135|    for (auto it = range.first; it != range.second; ++it) {
  ------------------
  |  Branch (78:33): [True: 135, False: 0]
  ------------------
   79|    135|        if (it->second == socket) {
  ------------------
  |  Branch (79:13): [True: 135, False: 0]
  ------------------
   80|    135|            tcp_bindings_.erase(it);
   81|    135|            break;
   82|    135|        }
   83|    135|    }
   84|    135|}
_ZN3tox4test15NetworkUniverse11send_packetENS0_6PacketE:
   87|    625|{
   88|       |    // Apply filters
   89|    625|    for (const auto &filter : filters_) {
  ------------------
  |  Branch (89:29): [True: 0, False: 625]
  ------------------
   90|      0|        if (!filter(p))
  ------------------
  |  Branch (90:13): [True: 0, False: 0]
  ------------------
   91|      0|            return;
   92|      0|    }
   93|       |
   94|       |    // Notify observers
   95|    625|    for (const auto &observer : observers_) {
  ------------------
  |  Branch (95:31): [True: 0, False: 625]
  ------------------
   96|      0|        observer(p);
   97|      0|    }
   98|       |
   99|    625|    p.delivery_time += global_latency_ms_;
  100|       |
  101|    625|    std::lock_guard<std::recursive_mutex> lock(mutex_);
  102|    625|    p.sequence_number = next_packet_id_++;
  103|       |
  104|    625|    if (verbose_) {
  ------------------
  |  Branch (104:9): [True: 0, False: 625]
  ------------------
  105|      0|        Ip_Ntoa from_str, to_str;
  106|      0|        net_ip_ntoa(&p.from.ip, &from_str);
  107|      0|        net_ip_ntoa(&p.to.ip, &to_str);
  108|      0|        std::cerr << "[NetworkUniverse] Enqueued packet #" << p.sequence_number << " from "
  109|      0|                  << from_str.buf << ":" << net_ntohs(p.from.port) << " to " << to_str.buf << ":"
  110|      0|                  << net_ntohs(p.to.port);
  111|      0|        if (p.is_tcp) {
  ------------------
  |  Branch (111:13): [True: 0, False: 0]
  ------------------
  112|      0|            std::cerr << " (TCP Flags=" << TcpFlags{p.tcp_flags} << " Seq=" << p.seq
  113|      0|                      << " Ack=" << p.ack << ")";
  114|      0|        }
  115|      0|        std::cerr << " with size " << p.data.size() << std::endl;
  116|      0|    }
  117|       |
  118|    625|    event_queue_.push(std::move(p));
  119|    625|}
_ZN3tox4test11is_loopbackERK2IP:
  144|    622|{
  145|    622|    if (net_family_is_ipv4(ip.family)) {
  ------------------
  |  Branch (145:9): [True: 0, False: 622]
  ------------------
  146|      0|        return ip.ip.v4.uint32 == net_htonl(0x7F000001);
  147|      0|    }
  148|    622|    if (net_family_is_ipv6(ip.family)) {
  ------------------
  |  Branch (148:9): [True: 622, False: 0]
  ------------------
  149|    622|        const uint8_t *b = ip.ip.v6.uint8;
  150|  3.87k|        for (int i = 0; i < 15; ++i) {
  ------------------
  |  Branch (150:25): [True: 3.87k, False: 0]
  ------------------
  151|  3.87k|            if (b[i] != 0) {
  ------------------
  |  Branch (151:17): [True: 622, False: 3.25k]
  ------------------
  152|    622|                return false;
  153|    622|            }
  154|  3.87k|        }
  155|      0|        return b[15] == 1;
  156|    622|    }
  157|      0|    return false;
  158|    622|}
_ZN3tox4test15NetworkUniverse14process_eventsEm:
  161|     82|{
  162|    704|    while (true) {
  ------------------
  |  Branch (162:12): [True: 704, Folded]
  ------------------
  163|    704|        Packet p;
  164|    704|        std::vector<FakeTcpSocket *> tcp_targets;
  165|    704|        FakeUdpSocket *udp_target = nullptr;
  166|    704|        bool has_packet = false;
  167|       |
  168|    704|        {
  169|    704|            std::lock_guard<std::recursive_mutex> lock(mutex_);
  170|    704|            if (!event_queue_.empty()) {
  ------------------
  |  Branch (170:17): [True: 622, False: 82]
  ------------------
  171|    622|                const Packet &top = event_queue_.top();
  172|    622|                if (verbose_) {
  ------------------
  |  Branch (172:21): [True: 0, False: 622]
  ------------------
  173|      0|                    std::cerr << "[NetworkUniverse] Peek packet: time=" << top.delivery_time
  174|      0|                              << " current=" << current_time_ms << " tcp=" << top.is_tcp
  175|      0|                              << std::endl;
  176|      0|                }
  177|    622|            }
  178|       |
  179|    704|            if (!event_queue_.empty() && event_queue_.top().delivery_time <= current_time_ms) {
  ------------------
  |  Branch (179:17): [True: 622, False: 82]
  |  Branch (179:42): [True: 622, False: 0]
  ------------------
  180|    622|                p = event_queue_.top();
  181|    622|                event_queue_.pop();
  182|    622|                has_packet = true;
  183|       |
  184|    622|                if (verbose_) {
  ------------------
  |  Branch (184:21): [True: 0, False: 622]
  ------------------
  185|      0|                    Ip_Ntoa from_str, to_str;
  186|      0|                    net_ip_ntoa(&p.from.ip, &from_str);
  187|      0|                    net_ip_ntoa(&p.to.ip, &to_str);
  188|      0|                    std::cerr << "[NetworkUniverse] Processing packet #" << p.sequence_number
  189|      0|                              << " from " << from_str.buf << ":" << net_ntohs(p.from.port) << " to "
  190|      0|                              << to_str.buf << ":" << net_ntohs(p.to.port)
  191|      0|                              << " (TCP=" << (p.is_tcp ? "true" : "false");
  ------------------
  |  Branch (191:47): [True: 0, False: 0]
  ------------------
  192|      0|                    if (p.is_tcp) {
  ------------------
  |  Branch (192:25): [True: 0, False: 0]
  ------------------
  193|      0|                        std::cerr << " Flags=" << TcpFlags{p.tcp_flags} << " Seq=" << p.seq
  194|      0|                                  << " Ack=" << p.ack;
  195|      0|                    }
  196|      0|                    std::cerr << " Size=" << p.data.size() << ")" << std::endl;
  197|      0|                }
  198|       |
  199|    622|                IP target_ip = p.to.ip;
  200|       |
  201|    622|                if (p.is_tcp) {
  ------------------
  |  Branch (201:21): [True: 0, False: 622]
  ------------------
  202|      0|                    if (is_loopback(target_ip)
  ------------------
  |  Branch (202:25): [True: 0, False: 0]
  |  Branch (202:25): [True: 0, False: 0]
  ------------------
  203|      0|                        && tcp_bindings_.count({target_ip, net_ntohs(p.to.port)}) == 0) {
  ------------------
  |  Branch (203:28): [True: 0, False: 0]
  ------------------
  204|      0|                        if (verbose_) {
  ------------------
  |  Branch (204:29): [True: 0, False: 0]
  ------------------
  205|      0|                            std::cerr << "[NetworkUniverse] Loopback packet to "
  206|      0|                                      << static_cast<int>(target_ip.ip.v4.uint8[3])
  207|      0|                                      << " redirected to "
  208|      0|                                      << static_cast<int>(p.from.ip.ip.v4.uint8[3]) << std::endl;
  209|      0|                        }
  210|      0|                        target_ip = p.from.ip;
  211|      0|                    }
  212|       |
  213|      0|                    auto range = tcp_bindings_.equal_range({target_ip, net_ntohs(p.to.port)});
  214|      0|                    FakeTcpSocket *listen_match = nullptr;
  215|       |
  216|      0|                    for (auto it = range.first; it != range.second; ++it) {
  ------------------
  |  Branch (216:49): [True: 0, False: 0]
  ------------------
  217|      0|                        FakeTcpSocket *s = it->second;
  218|      0|                        if (s->state() == FakeTcpSocket::LISTEN) {
  ------------------
  |  Branch (218:29): [True: 0, False: 0]
  ------------------
  219|      0|                            listen_match = s;
  220|      0|                        } else {
  221|      0|                            const IP_Port &remote = s->remote_addr();
  222|      0|                            if (net_ntohs(p.from.port) == net_ntohs(remote.port)) {
  ------------------
  |  Branch (222:33): [True: 0, False: 0]
  ------------------
  223|      0|                                if (ip_equal(&p.from.ip, &remote.ip)
  ------------------
  |  Branch (223:37): [True: 0, False: 0]
  ------------------
  224|      0|                                    || (is_loopback(p.from.ip) && ip_equal(&remote.ip, &target_ip))
  ------------------
  |  Branch (224:41): [True: 0, False: 0]
  |  Branch (224:67): [True: 0, False: 0]
  ------------------
  225|      0|                                    || (is_loopback(remote.ip)
  ------------------
  |  Branch (225:41): [True: 0, False: 0]
  ------------------
  226|      0|                                        && ip_equal(&p.from.ip, &target_ip))) {
  ------------------
  |  Branch (226:44): [True: 0, False: 0]
  ------------------
  227|      0|                                    tcp_targets.push_back(s);
  228|      0|                                }
  229|      0|                            }
  230|      0|                        }
  231|      0|                    }
  232|       |
  233|      0|                    if (listen_match && (p.tcp_flags & 0x02)) {
  ------------------
  |  Branch (233:25): [True: 0, False: 0]
  |  Branch (233:41): [True: 0, False: 0]
  ------------------
  234|      0|                        tcp_targets.push_back(listen_match);
  235|      0|                    }
  236|       |
  237|      0|                    if (verbose_) {
  ------------------
  |  Branch (237:25): [True: 0, False: 0]
  ------------------
  238|      0|                        std::cerr << "[NetworkUniverse] Routing TCP to "
  239|      0|                                  << static_cast<int>(target_ip.ip.v4.uint8[0]) << "."
  240|      0|                                  << static_cast<int>(target_ip.ip.v4.uint8[3]) << ":"
  241|      0|                                  << net_ntohs(p.to.port)
  242|      0|                                  << ". Targets found: " << tcp_targets.size() << std::endl;
  243|      0|                    }
  244|      0|                    if (tcp_targets.empty()) {
  ------------------
  |  Branch (244:25): [True: 0, False: 0]
  ------------------
  245|      0|                        if (verbose_) {
  ------------------
  |  Branch (245:29): [True: 0, False: 0]
  ------------------
  246|      0|                            std::cerr << "[NetworkUniverse] WARNING: No TCP targets for "
  247|      0|                                      << static_cast<int>(target_ip.ip.v4.uint8[0]) << "."
  248|      0|                                      << static_cast<int>(target_ip.ip.v4.uint8[3]) << ":"
  249|      0|                                      << net_ntohs(p.to.port) << std::endl;
  250|      0|                        }
  251|      0|                    }
  252|    622|                } else {
  253|    622|                    if (is_loopback(target_ip)
  ------------------
  |  Branch (253:25): [True: 0, False: 622]
  |  Branch (253:25): [True: 0, False: 622]
  ------------------
  254|      0|                        && udp_bindings_.count({target_ip, net_ntohs(p.to.port)}) == 0) {
  ------------------
  |  Branch (254:28): [True: 0, False: 0]
  ------------------
  255|      0|                        target_ip = p.from.ip;
  256|      0|                    }
  257|       |
  258|    622|                    if (udp_bindings_.count({target_ip, net_ntohs(p.to.port)})) {
  ------------------
  |  Branch (258:25): [True: 0, False: 622]
  ------------------
  259|      0|                        udp_target = udp_bindings_[{target_ip, net_ntohs(p.to.port)}];
  260|    622|                    } else if (is_ipv4_mapped(target_ip)) {
  ------------------
  |  Branch (260:32): [True: 325, False: 297]
  ------------------
  261|    325|                        IP ip4 = extract_ipv4(target_ip);
  262|    325|                        if (udp_bindings_.count({ip4, net_ntohs(p.to.port)})) {
  ------------------
  |  Branch (262:29): [True: 0, False: 325]
  ------------------
  263|      0|                            udp_target = udp_bindings_[{ip4, net_ntohs(p.to.port)}];
  264|      0|                        }
  265|    325|                    }
  266|    622|                }
  267|    622|            }
  268|    704|        }
  269|       |
  270|    704|        if (!has_packet) {
  ------------------
  |  Branch (270:13): [True: 82, False: 622]
  ------------------
  271|     82|            break;
  272|     82|        }
  273|       |
  274|    622|        if (p.is_tcp) {
  ------------------
  |  Branch (274:13): [True: 0, False: 622]
  ------------------
  275|      0|            for (auto *it : tcp_targets) {
  ------------------
  |  Branch (275:27): [True: 0, False: 0]
  ------------------
  276|      0|                if (it->handle_packet(p)) {
  ------------------
  |  Branch (276:21): [True: 0, False: 0]
  ------------------
  277|      0|                    break;
  278|      0|                }
  279|      0|            }
  280|    622|        } else {
  281|    622|            if (udp_target) {
  ------------------
  |  Branch (281:17): [True: 0, False: 622]
  ------------------
  282|      0|                udp_target->push_packet(std::move(p.data), p.from);
  283|      0|            }
  284|    622|        }
  285|    622|    }
  286|     82|}
_ZNK3tox4test15NetworkUniverse10is_verboseEv:
  292|  2.36k|bool NetworkUniverse::is_verbose() const { return verbose_; }
network_universe.cc:_ZN3tox4testL14is_ipv4_mappedERK2IP:
  122|    622|{
  123|    622|    if (!net_family_is_ipv6(ip.family))
  ------------------
  |  Branch (123:9): [True: 0, False: 622]
  ------------------
  124|      0|        return false;
  125|    622|    const uint8_t *b = ip.ip.v6.uint8;
  126|  3.87k|    for (int i = 0; i < 10; ++i)
  ------------------
  |  Branch (126:21): [True: 3.54k, False: 325]
  ------------------
  127|  3.54k|        if (b[i] != 0)
  ------------------
  |  Branch (127:13): [True: 297, False: 3.25k]
  ------------------
  128|    297|            return false;
  129|    325|    if (b[10] != 0xFF || b[11] != 0xFF)
  ------------------
  |  Branch (129:9): [True: 0, False: 325]
  |  Branch (129:26): [True: 0, False: 325]
  ------------------
  130|      0|        return false;
  131|    325|    return true;
  132|    325|}
network_universe.cc:_ZN3tox4testL12extract_ipv4ERK2IP:
  135|    325|{
  136|    325|    IP ip4;
  137|    325|    ip_init(&ip4, false);
  138|    325|    const uint8_t *b = ip.ip.v6.uint8;
  139|    325|    std::memcpy(ip4.ip.v4.uint8, b + 12, 4);
  140|    325|    return ip4;
  141|    325|}

_ZNK3tox4test6PacketgtERKS1_:
   39|  2.54k|    {
   40|  2.54k|        if (delivery_time != other.delivery_time) {
  ------------------
  |  Branch (40:13): [True: 0, False: 2.54k]
  ------------------
   41|      0|            return delivery_time > other.delivery_time;
   42|      0|        }
   43|  2.54k|        return sequence_number > other.sequence_number;
   44|  2.54k|    }

_ZN3tox4test9Fuzz_DataC2EPKhm:
   25|    225|        : data_(input_data)
   26|    225|        , base_(input_data)
   27|    225|        , size_(input_size)
   28|    225|    {
   29|    225|    }
_ZNK3tox4test9Fuzz_Data4sizeEv:
  101|  11.4k|    std::size_t size() const { return size_; }
_ZN3tox4test9Fuzz_Data8consume1EPKc:
   63|    446|    Consumer consume1(const char *_Nonnull func) { return Consumer{func, *this}; }
_ZN3tox4test9Fuzz_Data8ConsumercvT_IhEEv:
   53|    446|        {
   54|    446|            if (sizeof(T) > fd.size())
  ------------------
  |  Branch (54:17): [True: 0, False: 446]
  ------------------
   55|      0|                return T{};
   56|    446|            const uint8_t *_Nonnull bytes = fd.consume(func, sizeof(T));
   57|    446|            T val;
   58|    446|            std::memcpy(&val, bytes, sizeof(T));
   59|    446|            return val;
   60|    446|        }
_ZN3tox4test9Fuzz_Data7consumeEPKcm:
  107|  9.96k|    {
  108|  9.96k|        if (count > size_)
  ------------------
  |  Branch (108:13): [True: 0, False: 9.96k]
  ------------------
  109|      0|            return nullptr;
  110|  9.96k|        const uint8_t *_Nonnull val = data_;
  111|  9.96k|        if (FUZZ_DEBUG) {
  ------------------
  |  Branch (111:13): [Folded, False: 9.96k]
  ------------------
  112|      0|            if (count == 1) {
  ------------------
  |  Branch (112:17): [True: 0, False: 0]
  ------------------
  113|      0|                std::printf("consume@%zu(%s): %d (0x%02x)\n", pos(), func, val[0], val[0]);
  114|      0|            } else if (count != 0) {
  ------------------
  |  Branch (114:24): [True: 0, False: 0]
  ------------------
  115|      0|                std::printf("consume@%zu(%s): %02x..%02x[%zu]\n", pos(), func, val[0],
  116|      0|                    val[count - 1], count);
  117|      0|            }
  118|      0|        }
  119|  9.96k|        data_ += count;
  120|  9.96k|        size_ -= count;
  121|  9.96k|        return val;
  122|  9.96k|    }
_ZNK3tox4test9Fuzz_Data5emptyEv:
  104|    102|    bool empty() const { return size_ == 0; }

_ZN3tox4test10Simulation5clockEv:
  155|    675|    FakeClock &clock() { return *clock_; }
_ZN3tox4test10Simulation3netEv:
  157|    450|    NetworkUniverse &net() { return *net_; }
_ZN3tox4test13SimulatedNode12fake_networkEv:
  201|    450|    FakeNetworkStack &fake_network() { return *network_; }
_ZN3tox4test9LogFilterC2Ev:
   51|    450|    LogFilter() = default;

_ZN3tox4test11ClockSystemD2Ev:
    5|    450|ClockSystem::~ClockSystem() = default;

_ZN3tox4test11EnvironmentD2Ev:
    5|    900|Environment::~Environment() = default;

_ZN3tox4test9FakeClockC2Em:
    6|    450|    : now_ms_(start_time_ms)
    7|    450|{
    8|    450|}
_ZNK3tox4test9FakeClock15current_time_msEv:
   10|    463|uint64_t FakeClock::current_time_ms() const { return now_ms_; }
_ZN3tox4test9FakeClock7advanceEm:
   14|    307|void FakeClock::advance(uint64_t ms) { now_ms_ += ms; }

_ZN3tox4test10FakeMemoryC2Ev:
   25|    900|FakeMemory::FakeMemory() = default;
_ZN3tox4test10FakeMemoryD2Ev:
   26|    900|FakeMemory::~FakeMemory() = default;
_ZN3tox4test10FakeMemory6mallocEm:
   29|  9.84k|{
   30|  9.84k|    bool fail = failure_injector_ && failure_injector_(size);
  ------------------
  |  Branch (30:17): [True: 9.68k, False: 164]
  |  Branch (30:38): [True: 298, False: 9.38k]
  ------------------
   31|       |
   32|  9.84k|    if (observer_) {
  ------------------
  |  Branch (32:9): [True: 0, False: 9.84k]
  ------------------
   33|      0|        observer_(!fail);
   34|      0|    }
   35|       |
   36|  9.84k|    if (fail) {
  ------------------
  |  Branch (36:9): [True: 298, False: 9.54k]
  ------------------
   37|    298|        return nullptr;
   38|    298|    }
   39|       |
   40|  9.54k|    void *ptr = std::malloc(size + sizeof(Header));
   41|  9.54k|    if (!ptr) {
  ------------------
  |  Branch (41:9): [True: 0, False: 9.54k]
  ------------------
   42|      0|        return nullptr;
   43|      0|    }
   44|       |
   45|  9.54k|    Header *header = static_cast<Header *>(ptr);
   46|  9.54k|    header->size = size;
   47|  9.54k|    header->magic = kMagic;
   48|       |
   49|  9.54k|    on_allocation(size);
   50|       |
   51|  9.54k|    return header + 1;
   52|  9.54k|}
_ZN3tox4test10FakeMemory7reallocEPvm:
   55|  1.40k|{
   56|  1.40k|    if (!ptr) {
  ------------------
  |  Branch (56:9): [True: 729, False: 671]
  ------------------
   57|    729|        return malloc(size);
   58|    729|    }
   59|       |
   60|    671|    Header *old_header = static_cast<Header *>(ptr) - 1;
   61|    671|    if (old_header->magic != kMagic) {
  ------------------
  |  Branch (61:9): [True: 0, False: 671]
  ------------------
   62|      0|        if (old_header->magic == kFreeMagic) {
  ------------------
  |  Branch (62:13): [True: 0, False: 0]
  ------------------
   63|      0|            std::cerr << "[FakeMemory] realloc: Double realloc/free detected at " << ptr
   64|      0|                      << " (header=" << old_header << ")" << std::endl;
   65|      0|        } else {
   66|      0|            std::cerr << "[FakeMemory] realloc: Invalid pointer (wrong magic 0x" << std::hex
   67|      0|                      << old_header->magic << ") at " << ptr << " (header=" << old_header << ")"
   68|      0|                      << std::endl;
   69|      0|        }
   70|      0|        std::abort();
   71|      0|    }
   72|       |
   73|    671|    bool fail = failure_injector_ && failure_injector_(size);
  ------------------
  |  Branch (73:17): [True: 671, False: 0]
  |  Branch (73:38): [True: 87, False: 584]
  ------------------
   74|       |
   75|    671|    if (observer_) {
  ------------------
  |  Branch (75:9): [True: 0, False: 671]
  ------------------
   76|      0|        observer_(!fail);
   77|      0|    }
   78|       |
   79|    671|    if (fail) {
  ------------------
  |  Branch (79:9): [True: 87, False: 584]
  ------------------
   80|     87|        return nullptr;
   81|     87|    }
   82|       |
   83|    584|    size_t old_size = old_header->size;
   84|    584|    void *new_ptr = std::realloc(old_header, size + sizeof(Header));
   85|    584|    if (!new_ptr) {
  ------------------
  |  Branch (85:9): [True: 0, False: 584]
  ------------------
   86|      0|        return nullptr;
   87|      0|    }
   88|       |
   89|    584|    on_deallocation(old_size);
   90|    584|    on_allocation(size);
   91|       |
   92|    584|    Header *header = static_cast<Header *>(new_ptr);
   93|    584|    header->size = size;
   94|    584|    header->magic = kMagic;
   95|       |
   96|    584|    return header + 1;
   97|    584|}
_ZN3tox4test10FakeMemory4freeEPv:
  100|  55.8k|{
  101|  55.8k|    if (!ptr) {
  ------------------
  |  Branch (101:9): [True: 46.2k, False: 9.54k]
  ------------------
  102|  46.2k|        return;
  103|  46.2k|    }
  104|       |
  105|  9.54k|    Header *header = static_cast<Header *>(ptr) - 1;
  106|  9.54k|    if (header->magic != kMagic) {
  ------------------
  |  Branch (106:9): [True: 0, False: 9.54k]
  ------------------
  107|      0|        if (header->magic == kFreeMagic) {
  ------------------
  |  Branch (107:13): [True: 0, False: 0]
  ------------------
  108|      0|            std::cerr << "[FakeMemory] free: Double free detected at " << ptr
  109|      0|                      << " (header=" << header << ")" << std::endl;
  110|      0|        } else {
  111|      0|            std::cerr << "[FakeMemory] free: Invalid pointer (wrong magic 0x" << std::hex
  112|      0|                      << header->magic << ") at " << ptr << " (header=" << header << ")"
  113|      0|                      << std::endl;
  114|      0|        }
  115|      0|        std::abort();
  116|      0|    }
  117|       |
  118|  9.54k|    size_t size = header->size;
  119|  9.54k|    on_deallocation(size);
  120|  9.54k|    header->magic = kFreeMagic;  // Mark as free
  121|  9.54k|    std::free(header);
  122|  9.54k|}
_ZN3tox4test10FakeMemory20set_failure_injectorENSt3__18functionIFbmEEE:
  125|    225|{
  126|    225|    failure_injector_ = std::move(injector);
  127|    225|}
_ZN3tox4test10FakeMemory8c_memoryEv:
  131|    900|struct Memory FakeMemory::c_memory() { return Memory{&kFakeMemoryVtable, this}; }
_ZN3tox4test10FakeMemory13on_allocationEm:
  138|  10.1k|{
  139|  10.1k|    size_t current = current_allocation_.fetch_add(size) + size;
  140|  10.1k|    size_t max = max_allocation_.load(std::memory_order_relaxed);
  141|  10.1k|    while (current > max && !max_allocation_.compare_exchange_weak(max, current)) { }
  ------------------
  |  Branch (141:12): [True: 9.97k, False: 159]
  |  Branch (141:29): [True: 0, False: 9.97k]
  ------------------
  142|  10.1k|}
_ZN3tox4test10FakeMemory15on_deallocationEm:
  144|  10.1k|void FakeMemory::on_deallocation(size_t size) { current_allocation_.fetch_sub(size); }
fake_memory.cc:_ZNK3tox4test3$_0clEPvj:
   15|  9.11k|                           uint32_t size) { return static_cast<FakeMemory *>(obj)->malloc(size); },
fake_memory.cc:_ZNK3tox4test3$_1clEPvS2_j:
   18|  1.40k|          uint32_t size) { return static_cast<FakeMemory *>(obj)->realloc(ptr, size); },
fake_memory.cc:_ZNK3tox4test3$_2clEPvS2_:
   20|  55.8k|    = [](void *_Nonnull obj, void *_Nullable ptr) { static_cast<FakeMemory *>(obj)->free(ptr); },

_ZN3tox4test10FakeRandomC2Em:
   21|    900|    : rng_(seed)
   22|    900|{
   23|    900|}
_ZN3tox4test10FakeRandom5bytesEPhm:
   48|  2.82k|{
   49|  2.82k|    if (entropy_source_) {
  ------------------
  |  Branch (49:9): [True: 0, False: 2.82k]
  ------------------
   50|      0|        entropy_source_(out, count);
   51|  2.82k|    } else {
   52|  2.82k|        std::uniform_int_distribution<uint16_t> dist(0, 255);
   53|  2.82k|        std::generate_n(out, count, [&]() { return static_cast<uint8_t>(dist(rng_)); });
   54|  2.82k|    }
   55|       |
   56|  2.82k|    if (observer_) {
  ------------------
  |  Branch (56:9): [True: 0, False: 2.82k]
  ------------------
   57|      0|        observer_(out, count);
   58|      0|    }
   59|  2.82k|}
_ZN3tox4test10FakeRandom8c_randomEv:
   61|    900|struct Random FakeRandom::c_random() { return Random{&kFakeRandomVtable, this}; }
fake_random.cc:_ZZN3tox4test10FakeRandom5bytesEPhmENK3$_0clEv:
   53|  75.7k|        std::generate_n(out, count, [&]() { return static_cast<uint8_t>(dist(rng_)); });
fake_random.cc:_ZNK3tox4test3$_1clEPvPhj:
   14|  2.82k|          uint32_t length) { static_cast<FakeRandom *>(obj)->bytes(bytes, length); },

_ZN3tox4test28configure_fuzz_packet_sourceERNS0_13FakeUdpSocketERNS0_9Fuzz_DataE:
   10|    225|{
   11|    225|    socket.set_packet_source([&input](std::vector<uint8_t> &data, IP_Port &from) -> bool {
   12|    225|        if (input.size() < 2)
   13|    225|            return false;
   14|       |
   15|    225|        const uint8_t *len_bytes = input.consume("recv_len", 2);
   16|    225|        if (!len_bytes)
   17|    225|            return false;
   18|       |
   19|    225|        uint16_t len = (len_bytes[0] << 8) | len_bytes[1];
   20|       |
   21|    225|        if (len == 0xffff) {
   22|       |            // EWOULDBLOCK simulation. Return false implies "no packet".
   23|    225|            return false;
   24|    225|        }
   25|       |
   26|    225|        size_t actual_len = std::min(static_cast<size_t>(len), input.size());
   27|    225|        const uint8_t *payload = input.consume("recv_payload", actual_len);
   28|       |
   29|    225|        if (!payload && actual_len > 0)
   30|    225|            return false;
   31|       |
   32|    225|        data.assign(payload, payload + actual_len);
   33|       |
   34|       |        // Dummy address (legacy Fuzz_System used 127.0.0.2:33446)
   35|    225|        ip_init(&from.ip, false);  // IPv4
   36|    225|        from.ip.ip.v4.uint32 = net_htonl(0x7F000002);  // 127.0.0.2
   37|    225|        from.port = net_htons(33446);
   38|       |
   39|    225|        return true;
   40|    225|    });
   41|    225|}
_ZN3tox4test28configure_fuzz_memory_sourceERNS0_10FakeMemoryERNS0_9Fuzz_DataE:
   44|    225|{
   45|    225|    memory.set_failure_injector([&input](size_t size) -> bool {
   46|    225|        if (input.size() < 1) {
   47|       |            // Legacy behavior: if input runs out, allocation succeeds.
   48|    225|            return false;
   49|    225|        }
   50|       |
   51|    225|        const uint8_t *b = input.consume("malloc_decision", 1);
   52|    225|        bool succeed = (b && *b);
   53|    225|        return !succeed;  // Return true to fail
   54|    225|    });
   55|    225|}
fuzz_helpers.cc:_ZZN3tox4test28configure_fuzz_memory_sourceERNS0_10FakeMemoryERNS0_9Fuzz_DataEENK3$_0clEm:
   45|  10.3k|    memory.set_failure_injector([&input](size_t size) -> bool {
   46|  10.3k|        if (input.size() < 1) {
  ------------------
  |  Branch (46:13): [True: 831, False: 9.52k]
  ------------------
   47|       |            // Legacy behavior: if input runs out, allocation succeeds.
   48|    831|            return false;
   49|    831|        }
   50|       |
   51|  9.52k|        const uint8_t *b = input.consume("malloc_decision", 1);
   52|  9.52k|        bool succeed = (b && *b);
  ------------------
  |  Branch (52:25): [True: 9.52k, False: 0]
  |  Branch (52:30): [True: 9.13k, False: 385]
  ------------------
   53|  9.52k|        return !succeed;  // Return true to fail
   54|  10.3k|    });

_ZN3tox4test12MemorySystemD2Ev:
    5|    900|MemorySystem::~MemorySystem() = default;

_ZN3tox4test13NetworkSystemD2Ev:
    5|    450|NetworkSystem::~NetworkSystem() = default;
_ZN3tox4test7make_ipEj:
    8|    900|{
    9|    900|    IP ip;
   10|    900|    ip_init(&ip, false);
   11|    900|    ip.ip.v4.uint32 = net_htonl(ipv4);
   12|    900|    return ip;
   13|    900|}
_ZN3tox4test12make_node_ipEj:
   16|    900|{
   17|       |    // Use 20.x.y.z range: 20. (id >> 16) . (id >> 8) . (id & 0xFF)
   18|    900|    return make_ip(0x14000000 | (node_id & 0x00FFFFFF));
   19|    900|}

_ZN3tox4test12RandomSystemD2Ev:
    5|    900|RandomSystem::~RandomSystem() = default;

_ZN3tox4test20SimulatedEnvironmentC2Ev:
    8|    450|    : sim_(std::make_unique<Simulation>())
    9|    450|    , global_random_(std::make_unique<FakeRandom>(12345))
   10|    450|    , global_memory_(std::make_unique<FakeMemory>())
   11|    450|{
   12|    450|}
_ZN3tox4test20SimulatedEnvironmentD2Ev:
   14|    450|SimulatedEnvironment::~SimulatedEnvironment() = default;
_ZN3tox4test20SimulatedEnvironment10fake_clockEv:
   32|    225|FakeClock &SimulatedEnvironment::fake_clock() { return sim_->clock(); }
_ZN3tox4test20SimulatedEnvironment11fake_memoryEv:
   34|    225|FakeMemory &SimulatedEnvironment::fake_memory() { return *global_memory_; }
_ZN3tox4test20SimulatedEnvironment11create_nodeEt:
   37|    450|{
   38|    450|    auto scoped = std::make_unique<ScopedToxSystem>();
   39|    450|    scoped->node = sim_->create_node();
   40|       |
   41|       |    // Bind port
   42|    450|    if (port != 0) {
  ------------------
  |  Branch (42:9): [True: 225, False: 225]
  ------------------
   43|    225|        Socket s = scoped->node->fake_network().socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
   44|    225|        IP_Port addr;
   45|    225|        ip_init(&addr.ip, false);
   46|    225|        addr.ip.ip.v4.uint32 = 0;
   47|    225|        addr.port = net_htons(port);
   48|    225|        scoped->node->fake_network().bind(s, &addr);
   49|    225|    }
   50|       |
   51|       |    // Get Primary Endpoint for Fuzzer
   52|    450|    scoped->endpoint = scoped->node->get_primary_socket();
   53|       |
   54|       |    // Use global Random and Memory for legacy compatibility.
   55|    450|    scoped->c_random = global_random_->c_random();
   56|    450|    scoped->c_memory = global_memory_->c_memory();
   57|       |
   58|       |    // Use Node's Network
   59|    450|    scoped->c_network = scoped->node->c_network;
   60|       |
   61|       |    // Setup System
   62|    450|    scoped->system.mem = &scoped->c_memory;
   63|    450|    scoped->system.ns = &scoped->c_network;
   64|    450|    scoped->system.rng = &scoped->c_random;
   65|       |
   66|    450|    scoped->system.mono_time_user_data = &sim_->clock();
   67|    450|    scoped->system.mono_time_callback = [](void *_Nullable user_data) -> uint64_t {
   68|    450|        return static_cast<FakeClock *>(user_data)->current_time_ms();
   69|    450|    };
   70|       |
   71|    450|    return scoped;
   72|    450|}
_ZN3tox4test20SimulatedEnvironment12advance_timeEm:
   74|     82|void SimulatedEnvironment::advance_time(uint64_t ms) { sim_->advance_time(ms); }
simulated_environment.cc:_ZZN3tox4test20SimulatedEnvironment11create_nodeEtENK3$_0clEPv:
   67|    381|    scoped->system.mono_time_callback = [](void *_Nullable user_data) -> uint64_t {
   68|    381|        return static_cast<FakeClock *>(user_data)->current_time_ms();
   69|    381|    };

_ZN3tox4test10SimulationC2Ev:
   97|    450|    : clock_(std::make_unique<FakeClock>())
   98|    450|    , net_(std::make_unique<NetworkUniverse>())
   99|    450|{
  100|    450|}
_ZN3tox4test10SimulationD2Ev:
  102|    450|Simulation::~Simulation() = default;
_ZN3tox4test10Simulation12advance_timeEm:
  105|     82|{
  106|     82|    clock_->advance(ms);
  107|     82|    net_->process_events(clock_->current_time_ms());
  108|     82|}
_ZN3tox4test10Simulation11create_nodeEv:
  236|    450|{
  237|    450|    auto node = std::make_unique<SimulatedNode>(*this, ++node_count_);
  238|    450|    if (net_->is_verbose()) {
  ------------------
  |  Branch (238:9): [True: 0, False: 450]
  ------------------
  239|      0|        uint32_t ip4 = net_ntohl(node->ip.ip.v4.uint32);
  240|      0|        std::cerr << "[Simulation] Created node " << node_count_ << " with IP "
  241|      0|                  << ((ip4 >> 24) & 0xFF) << "." << ((ip4 >> 16) & 0xFF) << "."
  242|      0|                  << ((ip4 >> 8) & 0xFF) << "." << (ip4 & 0xFF) << std::endl;
  243|      0|    }
  244|    450|    return node;
  245|    450|}
_ZN3tox4test13SimulatedNodeC2ERNS0_10SimulationEj:
  250|    450|    : sim_(sim)
  251|    450|    , network_(std::make_unique<FakeNetworkStack>(sim.net(), make_node_ip(node_id)))
  252|    450|    , random_(std::make_unique<FakeRandom>(12345 + node_id))  // Unique seed
  253|    450|    , memory_(std::make_unique<FakeMemory>())
  254|    450|    , c_network(network_->c_network())
  255|    450|    , c_random(random_->c_random())
  256|    450|    , c_memory(memory_->c_memory())
  257|    450|    , ip(make_node_ip(node_id))
  258|    450|{
  259|    450|}
_ZN3tox4test13SimulatedNodeD2Ev:
  261|    450|SimulatedNode::~SimulatedNode() = default;
_ZN3tox4test13SimulatedNode18get_primary_socketEv:
  331|    450|{
  332|    450|    auto sockets = network_->get_bound_udp_sockets();
  333|    450|    if (sockets.empty())
  ------------------
  |  Branch (333:9): [True: 225, False: 225]
  ------------------
  334|    225|        return nullptr;
  335|    225|    return sockets.front();  // Return the first one bound
  336|    450|}

cmp_init:
  837|    400|                                         cmp_writer *write) {
  838|    400|  ctx->error = CMP_ERROR_NONE;
  839|    400|  ctx->buf = buf;
  840|    400|  ctx->read = read;
  841|    400|  ctx->skip = skip;
  842|    400|  ctx->write = write;
  843|    400|}
cmp_write_fixarray:
 1302|    328|bool cmp_write_fixarray(cmp_ctx_t *ctx, uint8_t size) {
 1303|    328|  if (size <= FIXARRAY_SIZE)
  ------------------
  |  Branch (1303:7): [True: 328, False: 0]
  ------------------
 1304|    328|    return write_fixed_value(ctx, FIXARRAY_MARKER | size);
 1305|       |
 1306|      0|  ctx->error = CMP_ERROR_INPUT_VALUE_TOO_LARGE;
 1307|       |  return false;
 1308|    328|}
cmp_write_array:
 1336|    328|bool cmp_write_array(cmp_ctx_t *ctx, uint32_t size) {
 1337|    328|  if (size <= FIXARRAY_SIZE)
  ------------------
  |  Branch (1337:7): [True: 328, False: 0]
  ------------------
 1338|    328|    return cmp_write_fixarray(ctx, (uint8_t)size);
 1339|      0|  if (size <= 0xFFFF)
  ------------------
  |  Branch (1339:7): [True: 0, False: 0]
  ------------------
 1340|      0|    return cmp_write_array16(ctx, (uint16_t)size);
 1341|       |
 1342|      0|  return cmp_write_array32(ctx, size);
 1343|      0|}
cmp.c:write_fixed_value:
  245|    328|static bool write_fixed_value(cmp_ctx_t *ctx, uint8_t value) {
  246|    328|  if (write_byte(ctx, value))
  ------------------
  |  Branch (246:7): [True: 328, False: 0]
  ------------------
  247|    328|    return true;
  248|       |
  249|      0|  ctx->error = CMP_ERROR_FIXED_VALUE_WRITING;
  250|       |  return false;
  251|    328|}
cmp.c:write_byte:
  207|    328|static bool write_byte(cmp_ctx_t *ctx, uint8_t x) {
  208|    328|  return ctx->write(ctx, &x, sizeof(uint8_t)) == sizeof(uint8_t);
  209|    328|}

dht_friend_client:
  154|    752|{
  155|    752|    return &dht_friend->client_list[index];
  156|    752|}
dht_get_self_public_key:
  159|    583|{
  160|    583|    return dht->self_public_key;
  161|    583|}
dht_get_self_secret_key:
  163|    884|{
  164|    884|    return dht->self_secret_key;
  165|    884|}
dht_get_close_client:
  185|  48.1k|{
  186|  48.1k|    assert(client_num < sizeof(dht->close_clientlist) / sizeof(dht->close_clientlist[0]));
  ------------------
  |  Branch (186:5): [True: 48.1k, False: 0]
  ------------------
  187|  48.1k|    return &dht->close_clientlist[client_num];
  188|  48.1k|}
dht_get_num_friends:
  190|     94|{
  191|     94|    return dht->num_friends;
  192|     94|}
dht_get_friend:
  195|     94|{
  196|     94|    assert(friend_num < dht->num_friends);
  ------------------
  |  Branch (196:5): [True: 94, False: 0]
  ------------------
  197|     94|    return &dht->friends_list[friend_num];
  198|     94|}
dht_get_shared_key_sent:
  283|     34|{
  284|     34|    return shared_key_cache_lookup(dht->shared_keys_sent, public_key);
  285|     34|}
dht_create_packet:
  378|     34|{
  379|     34|    uint8_t nonce[CRYPTO_NONCE_SIZE];
  380|     34|    uint8_t *encrypted = (uint8_t *)mem_balloc(mem, plain_length + CRYPTO_MAC_SIZE);
  ------------------
  |  |   65|     34|#define CRYPTO_MAC_SIZE                16
  ------------------
  381|       |
  382|     34|    if (encrypted == nullptr) {
  ------------------
  |  |   63|     34|#define nullptr NULL
  ------------------
  |  Branch (382:9): [True: 3, False: 31]
  ------------------
  383|      3|        return -1;
  384|      3|    }
  385|       |
  386|     31|    random_nonce(rng, nonce);
  387|       |
  388|     31|    const int encrypted_length = encrypt_data_symmetric(mem, shared_key, nonce, plain, plain_length, encrypted);
  389|       |
  390|     31|    if (encrypted_length < 0) {
  ------------------
  |  Branch (390:9): [True: 0, False: 31]
  ------------------
  391|      0|        mem_delete(mem, encrypted);
  392|      0|        return -1;
  393|      0|    }
  394|       |
  395|     31|    if (length < 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + (size_t)encrypted_length) {
  ------------------
  |  |   44|     31|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  if (length < 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + (size_t)encrypted_length) {
  ------------------
  |  |   70|     31|#define CRYPTO_NONCE_SIZE              24
  ------------------
  |  Branch (395:9): [True: 0, False: 31]
  ------------------
  396|      0|        mem_delete(mem, encrypted);
  397|      0|        return -1;
  398|      0|    }
  399|       |
  400|     31|    packet[0] = type;
  401|     31|    memcpy(packet + 1, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     31|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  402|     31|    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   44|     31|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   70|     31|#define CRYPTO_NONCE_SIZE              24
  ------------------
  403|     31|    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, encrypted, encrypted_length);
  ------------------
  |  |   44|     31|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, encrypted, encrypted_length);
  ------------------
  |  |   70|     31|#define CRYPTO_NONCE_SIZE              24
  ------------------
  404|       |
  405|     31|    mem_delete(mem, encrypted);
  406|     31|    return 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + encrypted_length;
  ------------------
  |  |   44|     31|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  return 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + encrypted_length;
  ------------------
  |  |   70|     31|#define CRYPTO_NONCE_SIZE              24
  ------------------
  407|     31|}
pack_nodes:
  421|     36|{
  422|     36|    const uint32_t size = bin_pack_obj_array_b_size(bin_pack_node_handler, nodes, number, logger);
  423|     36|    if (!bin_pack_obj_array_b(bin_pack_node_handler, nodes, number, logger, data, length)) {
  ------------------
  |  Branch (423:9): [True: 0, False: 36]
  ------------------
  424|      0|        return -1;
  425|      0|    }
  426|     36|    return size;
  427|     36|}
get_close_nodes:
  752|    401|{
  753|    401|    return get_somewhat_close_nodes(
  754|    401|               dht->cur_time, public_key, nodes_list,
  755|    401|               sa_family, dht->close_clientlist,
  756|    401|               dht->friends_list, dht->num_friends,
  757|    401|               is_lan, want_announce);
  758|    401|}
dht_send_nodes_request:
 1286|     36|{
 1287|       |    /* Check if packet is going to be sent to ourself. */
 1288|     36|    if (pk_equal(public_key, dht->self_public_key)) {
  ------------------
  |  Branch (1288:9): [True: 0, False: 36]
  ------------------
 1289|      0|        return false;
 1290|      0|    }
 1291|       |
 1292|     36|    uint8_t plain_message[sizeof(Node_format) * 2] = {0};
 1293|       |
 1294|     36|    Node_format receiver;
 1295|     36|    memcpy(receiver.public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     36|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1296|     36|    receiver.ip_port = *ip_port;
 1297|       |
 1298|     36|    if (pack_nodes(dht->log, plain_message, sizeof(plain_message), &receiver, 1) == -1) {
  ------------------
  |  Branch (1298:9): [True: 0, False: 36]
  ------------------
 1299|      0|        return false;
 1300|      0|    }
 1301|       |
 1302|     36|    uint64_t ping_id = 0;
 1303|       |
 1304|     36|    ping_id = ping_array_add(dht->dht_ping_array, dht->mono_time, dht->rng, plain_message, sizeof(receiver));
 1305|       |
 1306|     36|    if (ping_id == 0) {
  ------------------
  |  Branch (1306:9): [True: 2, False: 34]
  ------------------
 1307|      2|        LOGGER_ERROR(dht->log, "adding ping id failed");
  ------------------
  |  |   80|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      2|    do {                                                                         \
  |  |  |  |   70|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      2|        }                                                                        \
  |  |  |  |   73|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1308|      2|        return false;
 1309|      2|    }
 1310|       |
 1311|     34|    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + sizeof(ping_id)];
 1312|     34|    uint8_t data[1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE];
 1313|       |
 1314|     34|    memcpy(plain, client_id, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     34|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1315|     34|    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, &ping_id, sizeof(ping_id));
  ------------------
  |  |   44|     34|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1316|       |
 1317|     34|    const uint8_t *shared_key = dht_get_shared_key_sent(dht, public_key);
 1318|       |
 1319|     34|    const int len = dht_create_packet(dht->mem, dht->rng,
 1320|     34|                                      dht->self_public_key, shared_key, NET_PACKET_NODES_REQUEST,
 1321|     34|                                      plain, sizeof(plain), data, sizeof(data));
 1322|       |
 1323|     34|    if (len != sizeof(data)) {
  ------------------
  |  Branch (1323:9): [True: 3, False: 31]
  ------------------
 1324|      3|        LOGGER_ERROR(dht->log, "nodes request packet encryption failed");
  ------------------
  |  |   80|      3|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      3|    do {                                                                         \
  |  |  |  |   70|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 3, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      3|        }                                                                        \
  |  |  |  |   73|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 3]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1325|      3|        return false;
 1326|      3|    }
 1327|       |
 1328|     31|    return sendpacket(dht->net, ip_port, data, len) > 0;
 1329|     34|}
dht_addfriend:
 1590|    403|{
 1591|    403|    const uint32_t friend_num = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);
 1592|       |
 1593|    403|    if (friend_num != UINT32_MAX) { /* Is friend already in DHT? */
  ------------------
  |  Branch (1593:9): [True: 0, False: 403]
  ------------------
 1594|      0|        DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
 1595|      0|        const uint32_t tmp_lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1596|       |
 1597|      0|        if (tmp_lock_token == 0) {
  ------------------
  |  Branch (1597:13): [True: 0, False: 0]
  ------------------
 1598|      0|            return -1;
 1599|      0|        }
 1600|       |
 1601|      0|        return 0;
 1602|      0|    }
 1603|       |
 1604|    403|    DHT_Friend *const temp = (DHT_Friend *)mem_vrealloc(dht->mem, dht->friends_list, dht->num_friends + 1, sizeof(DHT_Friend));
 1605|       |
 1606|    403|    if (temp == nullptr) {
  ------------------
  |  |   63|    403|#define nullptr NULL
  ------------------
  |  Branch (1606:9): [True: 2, False: 401]
  ------------------
 1607|      2|        return -1;
 1608|      2|    }
 1609|       |
 1610|    401|    dht->friends_list = temp;
 1611|    401|    DHT_Friend *const dht_friend = &dht->friends_list[dht->num_friends];
 1612|    401|    *dht_friend = empty_dht_friend;
 1613|    401|    memcpy(dht_friend->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    401|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1614|       |
 1615|    401|    dht_friend->nat.nat_ping_id = random_u64(dht->rng);
 1616|    401|    ++dht->num_friends;
 1617|       |
 1618|    401|    *lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1619|    401|    assert(*lock_token != 0); // Friend was newly allocated
  ------------------
  |  Branch (1619:5): [True: 401, False: 0]
  ------------------
 1620|       |
 1621|    401|    dht_friend->num_to_bootstrap = get_close_nodes(dht, dht_friend->public_key, dht_friend->to_bootstrap, net_family_unspec(),
 1622|    401|                                   true, false);
 1623|       |
 1624|    401|    return 0;
 1625|    401|}
dht_bootstrap:
 1841|     36|{
 1842|     36|    if (pk_equal(public_key, dht->self_public_key)) {
  ------------------
  |  Branch (1842:9): [True: 0, False: 36]
  ------------------
 1843|       |        // Bootstrapping off ourselves is ok (onion paths are still set up).
 1844|      0|        return true;
 1845|      0|    }
 1846|       |
 1847|     36|    return dht_send_nodes_request(dht, ip_port, public_key, dht->self_public_key);
 1848|     36|}
randfriends_nodes:
 2395|     47|{
 2396|     47|    if (max_num == 0) {
  ------------------
  |  Branch (2396:9): [True: 0, False: 47]
  ------------------
 2397|      0|        return 0;
 2398|      0|    }
 2399|       |
 2400|     47|    uint16_t count = 0;
 2401|     47|    const uint32_t r = random_u32(dht->rng);
 2402|       |
 2403|     47|    assert(DHT_FAKE_FRIEND_NUMBER <= dht->num_friends);
  ------------------
  |  Branch (2403:5): [True: 47, False: 0]
  ------------------
 2404|       |
 2405|       |    // Only gather nodes from the initial 2 fake friends.
 2406|    141|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
  ------------------
  |  |   64|    141|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2406:26): [True: 94, False: 47]
  ------------------
 2407|     94|        count += list_nodes(dht->rng, dht->friends_list[(i + r) % DHT_FAKE_FRIEND_NUMBER].client_list,
  ------------------
  |  |   64|     94|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
 2408|     94|                            MAX_FRIEND_CLIENTS, dht->cur_time,
  ------------------
  |  |   32|     94|#define MAX_FRIEND_CLIENTS 8
  ------------------
 2409|     94|                            nodes + count, max_num - count);
 2410|       |
 2411|     94|        if (count >= max_num) {
  ------------------
  |  Branch (2411:13): [True: 0, False: 94]
  ------------------
 2412|      0|            break;
 2413|      0|        }
 2414|     94|    }
 2415|       |
 2416|     47|    return count;
 2417|     47|}
cryptopacket_registerhandler:
 2431|    801|{
 2432|    801|    dht->cryptopackethandlers[byte].function = cb;
 2433|    801|    dht->cryptopackethandlers[byte].object = object;
 2434|    801|}
dht_callback_nodes_response:
 2479|     66|{
 2480|     66|    dht->nodes_response_callback = function;
 2481|     66|}
new_dht:
 2508|    212|{
 2509|    212|    if (net == nullptr) {
  ------------------
  |  |   63|    212|#define nullptr NULL
  ------------------
  |  Branch (2509:9): [True: 0, False: 212]
  ------------------
 2510|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2511|      0|    }
 2512|       |
 2513|    212|    DHT *const dht = (DHT *)mem_alloc(mem, sizeof(DHT));
 2514|       |
 2515|    212|    if (dht == nullptr) {
  ------------------
  |  |   63|    212|#define nullptr NULL
  ------------------
  |  Branch (2515:9): [True: 2, False: 210]
  ------------------
 2516|      2|        LOGGER_ERROR(log, "failed to allocate DHT struct (%lu bytes)", (unsigned long)sizeof(DHT));
  ------------------
  |  |   80|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      2|    do {                                                                         \
  |  |  |  |   70|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      2|        }                                                                        \
  |  |  |  |   73|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2517|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 2518|      2|    }
 2519|       |
 2520|    210|    dht->ns = ns;
 2521|    210|    dht->mono_time = mono_time;
 2522|    210|    dht->cur_time = mono_time_get(mono_time);
 2523|    210|    dht->log = log;
 2524|    210|    dht->net = net;
 2525|    210|    dht->rng = rng;
 2526|    210|    dht->mem = mem;
 2527|       |
 2528|    210|    dht->hole_punching_enabled = hole_punching_enabled;
 2529|    210|    dht->lan_discovery_enabled = lan_discovery_enabled;
 2530|       |
 2531|    210|    struct Ping *temp_ping = ping_new(mem, mono_time, rng, dht, net);
 2532|       |
 2533|    210|    if (temp_ping == nullptr) {
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
  |  Branch (2533:9): [True: 3, False: 207]
  ------------------
 2534|      3|        LOGGER_ERROR(log, "failed to initialise ping");
  ------------------
  |  |   80|      3|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      3|    do {                                                                         \
  |  |  |  |   70|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 3, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      3|        }                                                                        \
  |  |  |  |   73|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 3]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2535|      3|        kill_dht(dht);
 2536|      3|        return nullptr;
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
 2537|      3|    }
 2538|       |
 2539|    207|    dht->ping = temp_ping;
 2540|       |
 2541|    207|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, &handle_nodes_request, dht);
 2542|    207|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, &handle_nodes_response, dht);
 2543|    207|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, &cryptopacket_handle, dht);
 2544|    207|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, &handle_lan_discovery, dht);
 2545|    207|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, &handle_nat_ping, dht);
  ------------------
  |  |   71|    207|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
 2546|       |
 2547|    207|#ifdef CHECK_ANNOUNCE_NODE
 2548|    207|    networking_registerhandler(dht->net, NET_PACKET_DATA_SEARCH_RESPONSE, &handle_data_search_response, dht);
 2549|    207|#endif /* CHECK_ANNOUNCE_NODE */
 2550|       |
 2551|    207|    crypto_new_keypair(rng, dht->self_public_key, dht->self_secret_key);
 2552|       |
 2553|    207|    Shared_Key_Cache *const temp_shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|    207|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   55|    207|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2554|       |
 2555|    207|    if (temp_shared_keys_recv == nullptr) {
  ------------------
  |  |   63|    207|#define nullptr NULL
  ------------------
  |  Branch (2555:9): [True: 2, False: 205]
  ------------------
 2556|      2|        LOGGER_ERROR(log, "failed to initialise shared key cache");
  ------------------
  |  |   80|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      2|    do {                                                                         \
  |  |  |  |   70|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      2|        }                                                                        \
  |  |  |  |   73|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2557|      2|        kill_dht(dht);
 2558|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 2559|      2|    }
 2560|       |
 2561|    205|    dht->shared_keys_recv = temp_shared_keys_recv;
 2562|       |
 2563|    205|    Shared_Key_Cache *const temp_shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|    205|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   55|    205|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2564|       |
 2565|    205|    if (temp_shared_keys_sent == nullptr) {
  ------------------
  |  |   63|    205|#define nullptr NULL
  ------------------
  |  Branch (2565:9): [True: 2, False: 203]
  ------------------
 2566|      2|        LOGGER_ERROR(log, "failed to initialise shared key cache");
  ------------------
  |  |   80|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      2|    do {                                                                         \
  |  |  |  |   70|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      2|        }                                                                        \
  |  |  |  |   73|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2567|      2|        kill_dht(dht);
 2568|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 2569|      2|    }
 2570|       |
 2571|    203|    dht->shared_keys_sent = temp_shared_keys_sent;
 2572|       |
 2573|    203|    Ping_Array *const temp_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   49|    203|#define DHT_PING_ARRAY_SIZE 512
  ------------------
                  Ping_Array *const temp_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   46|    203|#define PING_TIMEOUT 5
  ------------------
 2574|       |
 2575|    203|    if (temp_ping_array == nullptr) {
  ------------------
  |  |   63|    203|#define nullptr NULL
  ------------------
  |  Branch (2575:9): [True: 1, False: 202]
  ------------------
 2576|      1|        LOGGER_ERROR(log, "failed to initialise ping array");
  ------------------
  |  |   80|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2577|      1|        kill_dht(dht);
 2578|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 2579|      1|    }
 2580|       |
 2581|    202|    dht->dht_ping_array = temp_ping_array;
 2582|       |
 2583|    603|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
  ------------------
  |  |   64|    603|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2583:26): [True: 403, False: 200]
  ------------------
 2584|    403|        uint8_t random_public_key_bytes[CRYPTO_PUBLIC_KEY_SIZE];
 2585|    403|        uint8_t random_secret_key_bytes[CRYPTO_SECRET_KEY_SIZE];
 2586|       |
 2587|    403|        crypto_new_keypair(rng, random_public_key_bytes, random_secret_key_bytes);
 2588|       |
 2589|    403|        uint32_t token; // We don't intend to delete these ever, but need to pass the token
 2590|    403|        if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|    403|#define nullptr NULL
  ------------------
                      if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|    403|#define nullptr NULL
  ------------------
  |  Branch (2590:13): [True: 2, False: 401]
  ------------------
 2591|      2|            LOGGER_ERROR(log, "failed to add initial random seed DHT friends");
  ------------------
  |  |   80|      2|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      2|    do {                                                                         \
  |  |  |  |   70|      2|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      4|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 2, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      2|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      2|        }                                                                        \
  |  |  |  |   73|      2|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2592|      2|            kill_dht(dht);
 2593|      2|            return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 2594|      2|        }
 2595|    403|    }
 2596|       |
 2597|    200|    if (dht->num_friends != DHT_FAKE_FRIEND_NUMBER) {
  ------------------
  |  |   64|    200|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2597:9): [True: 0, False: 200]
  ------------------
 2598|      0|        LOGGER_ERROR(log, "the RNG provided seems to be broken: it generated the same keypair twice");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2599|      0|        kill_dht(dht);
 2600|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2601|      0|    }
 2602|       |
 2603|    200|    return dht;
 2604|    200|}
do_dht:
 2607|     65|{
 2608|     65|    const uint64_t cur_time = mono_time_get(dht->mono_time);
 2609|       |
 2610|     65|    if (dht->cur_time == cur_time) {
  ------------------
  |  Branch (2610:9): [True: 65, False: 0]
  ------------------
 2611|     65|        return;
 2612|     65|    }
 2613|       |
 2614|      0|    dht->cur_time = cur_time;
 2615|       |
 2616|       |    // Load friends/clients if first call to do_dht
 2617|      0|    if (dht->loaded_num_nodes > 0) {
  ------------------
  |  Branch (2617:9): [True: 0, False: 0]
  ------------------
 2618|      0|        dht_connect_after_load(dht);
 2619|      0|    }
 2620|       |
 2621|      0|    do_close(dht);
 2622|      0|    do_dht_friends(dht);
 2623|      0|    do_nat(dht);
 2624|      0|    ping_iterate(dht->ping);
 2625|      0|}
kill_dht:
 2628|    210|{
 2629|    210|    if (dht == nullptr) {
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
  |  Branch (2629:9): [True: 0, False: 210]
  ------------------
 2630|      0|        return;
 2631|      0|    }
 2632|       |
 2633|    210|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
 2634|    210|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
 2635|    210|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
 2636|    210|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
 2637|    210|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   71|    210|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
 2638|       |
 2639|    210|    shared_key_cache_free(dht->shared_keys_recv);
 2640|    210|    shared_key_cache_free(dht->shared_keys_sent);
 2641|    210|    ping_array_kill(dht->dht_ping_array);
 2642|    210|    ping_kill(dht->mem, dht->ping);
 2643|    210|    mem_delete(dht->mem, dht->friends_list);
 2644|    210|    mem_delete(dht->mem, dht->loaded_nodes_list);
 2645|    210|    crypto_memzero(dht->self_secret_key, sizeof(dht->self_secret_key));
 2646|    210|    mem_delete(dht->mem, dht);
 2647|    210|}
dht_non_lan_connected:
 2868|     47|{
 2869|  48.1k|    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
  ------------------
  |  |   38|  48.1k|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   35|  48.1k|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   34|  48.1k|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   32|  48.1k|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2869:26): [True: 48.1k, False: 47]
  ------------------
 2870|  48.1k|        const Client_data *const client = &dht->close_clientlist[i];
 2871|       |
 2872|  48.1k|        if (!assoc_timeout(dht->cur_time, &client->assoc4)
  ------------------
  |  Branch (2872:13): [True: 0, False: 48.1k]
  ------------------
 2873|      0|                && !ip_is_lan(&client->assoc4.ip_port.ip)) {
  ------------------
  |  Branch (2873:20): [True: 0, False: 0]
  ------------------
 2874|      0|            return true;
 2875|      0|        }
 2876|       |
 2877|  48.1k|        if (!assoc_timeout(dht->cur_time, &client->assoc6)
  ------------------
  |  Branch (2877:13): [True: 0, False: 48.1k]
  ------------------
 2878|      0|                && !ip_is_lan(&client->assoc6.ip_port.ip)) {
  ------------------
  |  Branch (2878:20): [True: 0, False: 0]
  ------------------
 2879|      0|            return true;
 2880|      0|        }
 2881|  48.1k|    }
 2882|       |
 2883|     47|    return false;
 2884|     47|}
DHT.c:bin_pack_node_handler:
  414|     72|{
  415|     72|    const Node_format *nodes = (const Node_format *)arr;
  416|     72|    return bin_pack_ip_port(bp, logger, &nodes[index].ip_port)
  ------------------
  |  Branch (416:12): [True: 72, False: 0]
  ------------------
  417|     72|           && bin_pack_bin_b(bp, nodes[index].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     72|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (417:15): [True: 72, False: 0]
  ------------------
  418|     72|}
DHT.c:get_somewhat_close_nodes:
  723|    401|{
  724|  2.00k|    for (uint16_t i = 0; i < MAX_SENT_NODES; ++i) {
  ------------------
  |  |   43|  2.00k|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (724:26): [True: 1.60k, False: 401]
  ------------------
  725|  1.60k|        nodes_list[i] = empty_node_format;
  726|  1.60k|    }
  727|       |
  728|    401|    uint32_t num_nodes = 0;
  729|    401|    get_close_nodes_inner(
  730|    401|        cur_time, public_key,
  731|    401|        nodes_list, &num_nodes,
  732|    401|        sa_family, close_clientlist, LCLIENT_LIST,
  ------------------
  |  |   38|    401|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   35|    401|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   34|    401|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   32|    401|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  733|    401|        is_lan, want_announce);
  734|       |
  735|  1.00k|    for (uint16_t i = 0; i < friends_list_size; ++i) {
  ------------------
  |  Branch (735:26): [True: 601, False: 401]
  ------------------
  736|    601|        const DHT_Friend *dht_friend = &friends_list[i];
  737|       |
  738|    601|        get_close_nodes_inner(
  739|    601|            cur_time, public_key,
  740|    601|            nodes_list, &num_nodes,
  741|    601|            sa_family, dht_friend->client_list, MAX_FRIEND_CLIENTS,
  ------------------
  |  |   32|    601|#define MAX_FRIEND_CLIENTS 8
  ------------------
  742|    601|            is_lan, want_announce);
  743|    601|    }
  744|       |
  745|    401|    return num_nodes;
  746|    401|}
DHT.c:get_close_nodes_inner:
  657|  1.00k|{
  658|  1.00k|    if (!net_family_is_ipv4(sa_family) && !net_family_is_ipv6(sa_family) && !net_family_is_unspec(sa_family)) {
  ------------------
  |  Branch (658:9): [True: 1.00k, False: 0]
  |  Branch (658:43): [True: 1.00k, False: 0]
  |  Branch (658:77): [True: 0, False: 1.00k]
  ------------------
  659|      0|        return;
  660|      0|    }
  661|       |
  662|  1.00k|    uint32_t num_nodes = *num_nodes_ptr;
  663|       |
  664|   416k|    for (uint32_t i = 0; i < client_list_length; ++i) {
  ------------------
  |  Branch (664:26): [True: 415k, False: 1.00k]
  ------------------
  665|   415k|        const Client_data *const client = &client_list[i];
  666|   415k|        const IPPTsPng *ipptp;
  667|       |
  668|   415k|        if (net_family_is_ipv4(sa_family)) {
  ------------------
  |  Branch (668:13): [True: 0, False: 415k]
  ------------------
  669|      0|            ipptp = &client->assoc4;
  670|   415k|        } else if (net_family_is_ipv6(sa_family)) {
  ------------------
  |  Branch (670:20): [True: 0, False: 415k]
  ------------------
  671|      0|            ipptp = &client->assoc6;
  672|   415k|        } else if (client->assoc4.timestamp >= client->assoc6.timestamp) {
  ------------------
  |  Branch (672:20): [True: 415k, False: 0]
  ------------------
  673|   415k|            ipptp = &client->assoc4;
  674|   415k|        } else {
  675|      0|            ipptp = &client->assoc6;
  676|      0|        }
  677|       |
  678|       |        /* node not in a good condition? */
  679|   415k|        if (assoc_timeout(cur_time, ipptp)) {
  ------------------
  |  Branch (679:13): [True: 415k, False: 0]
  ------------------
  680|   415k|            continue;
  681|   415k|        }
  682|       |
  683|       |        /* don't send LAN ips to non LAN peers */
  684|      0|        if (ip_is_lan(&ipptp->ip_port.ip) && !is_lan) {
  ------------------
  |  Branch (684:13): [True: 0, False: 0]
  |  Branch (684:46): [True: 0, False: 0]
  ------------------
  685|      0|            continue;
  686|      0|        }
  687|       |
  688|      0|#ifdef CHECK_ANNOUNCE_NODE
  689|       |
  690|      0|        if (want_announce && !client->announce_node) {
  ------------------
  |  Branch (690:13): [True: 0, False: 0]
  |  Branch (690:30): [True: 0, False: 0]
  ------------------
  691|      0|            continue;
  692|      0|        }
  693|       |
  694|      0|#endif /* CHECK_ANNOUNCE_NODE */
  695|       |
  696|       |        /* node already in list? */
  697|      0|        if (index_of_node_pk(nodes_list, num_nodes, client->public_key) != UINT32_MAX) {
  ------------------
  |  Branch (697:13): [True: 0, False: 0]
  ------------------
  698|      0|            continue;
  699|      0|        }
  700|       |
  701|      0|        if (num_nodes < MAX_SENT_NODES) {
  ------------------
  |  |   43|      0|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (701:13): [True: 0, False: 0]
  ------------------
  702|      0|            memcpy(nodes_list[num_nodes].public_key, client->public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  703|      0|            nodes_list[num_nodes].ip_port = ipptp->ip_port;
  704|      0|            ++num_nodes;
  705|      0|        } else {
  706|       |            // TODO(zugz): this could be made significantly more efficient by
  707|       |            // using a version of add_to_list which works with a sorted list.
  708|      0|            add_to_list(nodes_list, MAX_SENT_NODES, client->public_key, &ipptp->ip_port, public_key);
  ------------------
  |  |   43|      0|#define MAX_SENT_NODES 4
  ------------------
  709|      0|        }
  710|      0|    }
  711|       |
  712|  1.00k|    *num_nodes_ptr = num_nodes;
  713|  1.00k|}
DHT.c:index_of_friend_pk:
  486|    403|{
  487|    403|    assert(size == 0 || array != nullptr);
  ------------------
  |  Branch (487:5): [True: 202, False: 201]
  |  Branch (487:5): [True: 201, False: 0]
  ------------------
  488|    604|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (488:26): [True: 201, False: 403]
  ------------------
  489|    201|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (489:13): [True: 0, False: 201]
  ------------------
  490|      0|            return i;
  491|      0|        }
  492|    201|    }
  493|       |
  494|    403|    return UINT32_MAX;
  495|    403|}
DHT.c:dht_friend_lock:
 1536|    401|{
 1537|       |    // find first free slot
 1538|    401|    uint8_t lock_num;
 1539|    401|    uint32_t lock_token = 0;
 1540|    401|    for (lock_num = 0; lock_num < DHT_FRIEND_MAX_LOCKS; ++lock_num) {
  ------------------
  |  |   52|    401|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1540:24): [True: 401, False: 0]
  ------------------
 1541|    401|        lock_token = UINT32_C(1) << lock_num;
 1542|    401|        if ((dht_friend->lock_flags & lock_token) == 0) {
  ------------------
  |  Branch (1542:13): [True: 401, False: 0]
  ------------------
 1543|    401|            break;
 1544|    401|        }
 1545|    401|    }
 1546|       |
 1547|       |    // One of the conditions would be enough, but static analyzers don't get that
 1548|    401|    if (lock_token == 0 || lock_num == DHT_FRIEND_MAX_LOCKS) {
  ------------------
  |  |   52|    401|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1548:9): [True: 0, False: 401]
  |  Branch (1548:28): [True: 0, False: 401]
  ------------------
 1549|      0|        return 0;
 1550|      0|    }
 1551|       |
 1552|       |    // Claim that slot
 1553|    401|    dht_friend->lock_flags |= lock_token;
 1554|       |
 1555|    401|    dht_friend->callbacks[lock_num].ip_callback = ip_callback;
 1556|    401|    dht_friend->callbacks[lock_num].data = data;
 1557|    401|    dht_friend->callbacks[lock_num].number = number;
 1558|       |
 1559|    401|    return lock_token;
 1560|    401|}
DHT.c:assoc_timeout:
  206|   513k|{
  207|   513k|    return (assoc->timestamp + BAD_NODE_TIMEOUT) <= cur_time;
  ------------------
  |  |   57|   513k|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   52|   513k|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   55|   513k|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   52|   513k|#define PING_INTERVAL 60
  |  |  ------------------
  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  ------------------
  |  |  |  |   56|   513k|#define PING_ROUNDTRIP 2
  |  |  ------------------
  ------------------
  208|   513k|}
DHT.c:list_nodes:
 2353|     94|{
 2354|     94|    if (max_num == 0) {
  ------------------
  |  Branch (2354:9): [True: 0, False: 94]
  ------------------
 2355|      0|        return 0;
 2356|      0|    }
 2357|       |
 2358|     94|    uint16_t count = 0;
 2359|       |
 2360|    846|    for (size_t i = length; i != 0; --i) {
  ------------------
  |  Branch (2360:29): [True: 752, False: 94]
  ------------------
 2361|    752|        const IPPTsPng *assoc = nullptr;
  ------------------
  |  |   63|    752|#define nullptr NULL
  ------------------
 2362|       |
 2363|    752|        if (!assoc_timeout(cur_time, &list[i - 1].assoc4)) {
  ------------------
  |  Branch (2363:13): [True: 0, False: 752]
  ------------------
 2364|      0|            assoc = &list[i - 1].assoc4;
 2365|      0|        }
 2366|       |
 2367|    752|        if (!assoc_timeout(cur_time, &list[i - 1].assoc6)) {
  ------------------
  |  Branch (2367:13): [True: 0, False: 752]
  ------------------
 2368|      0|            if (assoc == nullptr || (random_u08(rng) % 2) != 0) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (2368:17): [True: 0, False: 0]
  |  Branch (2368:37): [True: 0, False: 0]
  ------------------
 2369|      0|                assoc = &list[i - 1].assoc6;
 2370|      0|            }
 2371|      0|        }
 2372|       |
 2373|    752|        if (assoc != nullptr) {
  ------------------
  |  |   63|    752|#define nullptr NULL
  ------------------
  |  Branch (2373:13): [True: 0, False: 752]
  ------------------
 2374|      0|            memcpy(nodes[count].public_key, list[i - 1].public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2375|      0|            nodes[count].ip_port = assoc->ip_port;
 2376|      0|            ++count;
 2377|       |
 2378|      0|            if (count >= max_num) {
  ------------------
  |  Branch (2378:17): [True: 0, False: 0]
  ------------------
 2379|      0|                return count;
 2380|      0|            }
 2381|      0|        }
 2382|    752|    }
 2383|       |
 2384|     94|    return count;
 2385|     94|}

lan_discovery_send:
  370|    407|{
  371|    407|    if (broadcast == nullptr) {
  ------------------
  |  |   63|    407|#define nullptr NULL
  ------------------
  |  Branch (371:9): [True: 0, False: 407]
  ------------------
  372|      0|        return false;
  373|      0|    }
  374|       |
  375|    407|    uint8_t data[CRYPTO_PUBLIC_KEY_SIZE + 1];
  376|    407|    data[0] = NET_PACKET_LAN_DISCOVERY;
  377|    407|    pk_copy(data + 1, dht_pk);
  378|       |
  379|    407|    send_broadcasts(net, broadcast, port, data, 1 + CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    407|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  380|       |
  381|    407|    bool res = false;
  382|    407|    IP_Port ip_port;
  383|    407|    ip_port.port = port;
  384|       |
  385|       |    /* IPv6 multicast */
  386|    407|    if (net_family_is_ipv6(net_family(net))) {
  ------------------
  |  Branch (386:9): [True: 297, False: 110]
  ------------------
  387|    297|        ip_port.ip = broadcast_ip(net_family_ipv6(), net_family_ipv6());
  388|       |
  389|    297|        if (ip_isset(&ip_port.ip) && sendpacket(net, &ip_port, data, 1 + CRYPTO_PUBLIC_KEY_SIZE) > 0) {
  ------------------
  |  |   44|    297|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (389:13): [True: 297, False: 0]
  |  Branch (389:38): [True: 297, False: 0]
  ------------------
  390|    297|            res = true;
  391|    297|        }
  392|    297|    }
  393|       |
  394|       |    /* IPv4 broadcast (has to be IPv4-in-IPv6 mapping if socket is IPv6 */
  395|    407|    ip_port.ip = broadcast_ip(net_family(net), net_family_ipv4());
  396|       |
  397|    407|    if (ip_isset(&ip_port.ip) && sendpacket(net, &ip_port, data, 1 + CRYPTO_PUBLIC_KEY_SIZE) > 0) {
  ------------------
  |  |   44|    297|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  |  Branch (397:9): [True: 297, False: 110]
  |  Branch (397:34): [True: 297, False: 0]
  ------------------
  398|    297|        res = true;
  399|    297|    }
  400|       |
  401|    407|    return res;
  402|    407|}
lan_discovery_init:
  405|    191|{
  406|    191|    return fetch_broadcast_info(mem, ns);
  407|    191|}
lan_discovery_kill:
  410|    191|{
  411|    191|    if (broadcast == nullptr) {
  ------------------
  |  |   63|    191|#define nullptr NULL
  ------------------
  |  Branch (411:9): [True: 31, False: 160]
  ------------------
  412|     31|        return;
  413|     31|    }
  414|       |
  415|    160|    mem_delete(broadcast->mem, broadcast);
  416|    160|}
LAN_discovery.c:send_broadcasts:
  243|    407|{
  244|    407|    if (broadcast->count == 0) {
  ------------------
  |  Branch (244:9): [True: 407, False: 0]
  ------------------
  245|    407|        return false;
  246|    407|    }
  247|       |
  248|      0|    for (uint32_t i = 0; i < broadcast->count; ++i) {
  ------------------
  |  Branch (248:26): [True: 0, False: 0]
  ------------------
  249|      0|        IP_Port ip_port;
  250|      0|        ip_port.ip = broadcast->ips[i];
  251|      0|        ip_port.port = port;
  252|      0|        sendpacket(net, &ip_port, data, length);
  253|      0|    }
  254|       |
  255|       |    return true;
  256|    407|}
LAN_discovery.c:broadcast_ip:
  260|    704|{
  261|    704|    IP ip;
  262|    704|    ip_reset(&ip);
  263|       |
  264|    704|    if (net_family_is_ipv6(family_socket)) {
  ------------------
  |  Branch (264:9): [True: 594, False: 110]
  ------------------
  265|    594|        if (net_family_is_ipv6(family_broadcast)) {
  ------------------
  |  Branch (265:13): [True: 297, False: 297]
  ------------------
  266|    297|            ip.family = net_family_ipv6();
  267|       |            /* `FF02::1` is - according to RFC 4291 - multicast all-nodes link-local */
  268|       |            /* `FE80::*:` MUST be exact, for that we would need to look over all
  269|       |             * interfaces and check in which status they are */
  270|    297|            ip.ip.v6.uint8[0] = 0xFF;
  271|    297|            ip.ip.v6.uint8[1] = 0x02;
  272|    297|            ip.ip.v6.uint8[15] = 0x01;
  273|    297|        } else if (net_family_is_ipv4(family_broadcast)) {
  ------------------
  |  Branch (273:20): [True: 297, False: 0]
  ------------------
  274|    297|            ip.family = net_family_ipv6();
  275|    297|            ip.ip.v6 = get_ip6_broadcast();
  276|    297|        }
  277|    594|    } else if (net_family_is_ipv4(family_socket) && net_family_is_ipv4(family_broadcast)) {
  ------------------
  |  Branch (277:16): [True: 0, False: 110]
  |  Branch (277:53): [True: 0, False: 0]
  ------------------
  278|      0|        ip.family = net_family_ipv4();
  279|      0|        ip.ip.v4 = get_ip4_broadcast();
  280|      0|    }
  281|       |
  282|    704|    return ip;
  283|    704|}
LAN_discovery.c:fetch_broadcast_info:
  223|    191|{
  224|    191|    Broadcast_Info *broadcast = (Broadcast_Info *)mem_alloc(mem, sizeof(Broadcast_Info));
  225|       |
  226|    191|    if (broadcast == nullptr) {
  ------------------
  |  |   63|    191|#define nullptr NULL
  ------------------
  |  Branch (226:9): [True: 31, False: 160]
  ------------------
  227|     31|        return nullptr;
  ------------------
  |  |   63|     31|#define nullptr NULL
  ------------------
  228|     31|    }
  229|       |
  230|    160|    broadcast->mem = mem;
  231|       |
  232|    160|    return broadcast;
  233|    191|}

m_callback_friendrequest:
  983|     66|{
  984|     66|    m->friend_request = function;
  985|     66|}
m_callback_friendmessage:
  989|     66|{
  990|     66|    m->friend_message = function;
  991|     66|}
m_callback_namechange:
  994|     66|{
  995|     66|    m->friend_namechange = function;
  996|     66|}
m_callback_statusmessage:
  999|     66|{
 1000|     66|    m->friend_statusmessagechange = function;
 1001|     66|}
m_callback_userstatus:
 1004|     66|{
 1005|     66|    m->friend_userstatuschange = function;
 1006|     66|}
m_callback_typingchange:
 1009|     66|{
 1010|     66|    m->friend_typingchange = function;
 1011|     66|}
m_callback_read_receipt:
 1014|     66|{
 1015|     66|    m->read_receipt = function;
 1016|     66|}
m_callback_connectionstatus:
 1019|     66|{
 1020|     66|    m->friend_connectionstatuschange = function;
 1021|     66|}
m_callback_core_connection:
 1024|     66|{
 1025|     66|    m->core_connection_change = function;
 1026|     66|}
m_callback_conference_invite:
 1084|    132|{
 1085|    132|    m->conference_invite = function;
 1086|    132|}
m_callback_group_invite:
 1090|     66|{
 1091|     66|    m->group_invite = function;
 1092|     66|}
callback_file_sendrequest:
 1117|     66|{
 1118|     66|    m->file_sendrequest = function;
 1119|     66|}
callback_file_control:
 1123|     66|{
 1124|     66|    m->file_filecontrol = function;
 1125|     66|}
callback_file_data:
 1129|     66|{
 1130|     66|    m->file_filedata = function;
 1131|     66|}
callback_file_reqchunk:
 1135|     66|{
 1136|     66|    m->file_reqchunk = function;
 1137|     66|}
custom_lossy_packet_registerhandler:
 1869|     66|{
 1870|     66|    m->lossy_packethandler = lossy_packethandler;
 1871|     66|}
custom_lossless_packet_registerhandler:
 1922|     66|{
 1923|     66|    m->lossless_packethandler = lossless_packethandler;
 1924|     66|}
do_messenger:
 2547|     82|{
 2548|       |    // Add the TCP relays, but only if this is the first time calling do_messenger
 2549|     82|    if (!m->has_added_relays) {
  ------------------
  |  Branch (2549:9): [True: 47, False: 35]
  ------------------
 2550|     47|        m->has_added_relays = true;
 2551|       |
 2552|     47|        for (uint16_t i = 0; i < m->num_loaded_relays; ++i) {
  ------------------
  |  Branch (2552:30): [True: 0, False: 47]
  ------------------
 2553|      0|            add_tcp_relay(m->net_crypto, &m->loaded_relays[i].ip_port, m->loaded_relays[i].public_key);
 2554|      0|        }
 2555|       |
 2556|     47|        m->num_loaded_relays = 0;
 2557|       |
 2558|     47|        if (m->tcp_server != nullptr) {
  ------------------
  |  |   63|     47|#define nullptr NULL
  ------------------
  |  Branch (2558:13): [True: 36, False: 11]
  ------------------
 2559|       |            /* Add self tcp server. */
 2560|     36|            IP_Port local_ip_port;
 2561|     36|            local_ip_port.port = net_htons(m->options.tcp_server_port);
 2562|     36|            local_ip_port.ip.family = net_family_ipv4();
 2563|     36|            local_ip_port.ip.ip.v4 = get_ip4_loopback();
 2564|     36|            add_tcp_relay(m->net_crypto, &local_ip_port, tcp_server_public_key(m->tcp_server));
 2565|     36|        }
 2566|     47|    }
 2567|       |
 2568|     82|    if (!m->options.udp_disabled) {
  ------------------
  |  Branch (2568:9): [True: 65, False: 17]
  ------------------
 2569|     65|        networking_poll(m->net, userdata);
 2570|     65|        do_dht(m->dht);
 2571|     65|    }
 2572|       |
 2573|     82|    if (m->tcp_server != nullptr) {
  ------------------
  |  |   63|     82|#define nullptr NULL
  ------------------
  |  Branch (2573:9): [True: 71, False: 11]
  ------------------
 2574|     71|        do_tcp_server(m->tcp_server, m->mono_time);
 2575|     71|    }
 2576|       |
 2577|     82|    do_net_crypto(m->net_crypto, userdata);
 2578|     82|    do_onion_client(m->onion_c);
 2579|     82|    do_friend_connections(m->fr_c, userdata);
 2580|     82|    do_friends(m, userdata);
 2581|     82|    do_gc(m->group_handler, userdata);
 2582|     82|    do_gca(m->mono_time, m->group_announce);
 2583|     82|    do_gc_onion_friends(m);
 2584|     82|    m_connection_status_callback(m, userdata);
 2585|       |
 2586|     82|    if (mono_time_get(m->mono_time) > m->lastdump + DUMPING_CLIENTS_FRIENDS_EVERY_N_SECONDS) {
  ------------------
  |  | 2425|     82|#define DUMPING_CLIENTS_FRIENDS_EVERY_N_SECONDS 60UL
  ------------------
  |  Branch (2586:9): [True: 47, False: 35]
  ------------------
 2587|     47|        m->lastdump = mono_time_get(m->mono_time);
 2588|     47|        uint32_t last_pinged;
 2589|       |
 2590|  48.1k|        for (uint32_t client = 0; client < LCLIENT_LIST; ++client) {
  ------------------
  |  |   38|  48.1k|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   35|  48.1k|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   34|  48.1k|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   32|  48.1k|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2590:35): [True: 48.1k, False: 47]
  ------------------
 2591|  48.1k|            const Client_data *cptr = dht_get_close_client(m->dht, client);
 2592|  48.1k|            const IPPTsPng *const assocs[] = { &cptr->assoc4, &cptr->assoc6, nullptr };
  ------------------
  |  |   63|  48.1k|#define nullptr NULL
  ------------------
 2593|       |
 2594|   144k|            for (const IPPTsPng * const *it = assocs; *it != nullptr; ++it) {
  ------------------
  |  |   63|   144k|#define nullptr NULL
  ------------------
  |  Branch (2594:55): [True: 96.2k, False: 48.1k]
  ------------------
 2595|  96.2k|                const IPPTsPng *const assoc = *it;
 2596|       |
 2597|  96.2k|                if (ip_isset(&assoc->ip_port.ip)) {
  ------------------
  |  Branch (2597:21): [True: 0, False: 96.2k]
  ------------------
 2598|      0|                    last_pinged = m->lastdump - assoc->last_pinged;
 2599|       |
 2600|      0|                    if (last_pinged > 999) {
  ------------------
  |  Branch (2600:25): [True: 0, False: 0]
  ------------------
 2601|      0|                        last_pinged = 999;
 2602|      0|                    }
 2603|       |
 2604|      0|                    Ip_Ntoa ip_str;
 2605|      0|                    char id_str[IDSTRING_LEN];
 2606|      0|                    LOGGER_TRACE(m->log, "C[%2u] %s:%u [%3u] %s",
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2607|      0|                                 client, net_ip_ntoa(&assoc->ip_port.ip, &ip_str),
 2608|      0|                                 net_ntohs(assoc->ip_port.port), last_pinged,
 2609|      0|                                 id_to_string(cptr->public_key, id_str, sizeof(id_str)));
 2610|      0|                }
 2611|  96.2k|            }
 2612|  48.1k|        }
 2613|       |
 2614|       |        /* dht contains additional "friends" (requests) */
 2615|     47|        const uint32_t num_dhtfriends = dht_get_num_friends(m->dht);
 2616|     47|        VLA(int32_t, m2dht, num_dhtfriends);
  ------------------
  |  |   59|     47|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     47|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 2617|     47|        VLA(int32_t, dht2m, num_dhtfriends);
  ------------------
  |  |   59|     47|#define VLA ALLOC_VLA
  |  |  ------------------
  |  |  |  |   28|     47|#define ALLOC_VLA(type, name, size) type name[size]
  |  |  ------------------
  ------------------
 2618|       |
 2619|    141|        for (uint32_t friend_idx = 0; friend_idx < num_dhtfriends; ++friend_idx) {
  ------------------
  |  Branch (2619:39): [True: 94, False: 47]
  ------------------
 2620|     94|            m2dht[friend_idx] = -1;
 2621|     94|            dht2m[friend_idx] = -1;
 2622|       |
 2623|     94|            if (friend_idx >= m->numfriends) {
  ------------------
  |  Branch (2623:17): [True: 94, False: 0]
  ------------------
 2624|     94|                continue;
 2625|     94|            }
 2626|       |
 2627|      0|            for (uint32_t dhtfriend = 0; dhtfriend < dht_get_num_friends(m->dht); ++dhtfriend) {
  ------------------
  |  Branch (2627:42): [True: 0, False: 0]
  ------------------
 2628|      0|                if (pk_equal(m->friendlist[friend_idx].real_pk, dht_get_friend_public_key(m->dht, dhtfriend))) {
  ------------------
  |  Branch (2628:21): [True: 0, False: 0]
  ------------------
 2629|      0|                    assert(dhtfriend < INT32_MAX);
  ------------------
  |  Branch (2629:21): [True: 0, False: 0]
  ------------------
 2630|      0|                    m2dht[friend_idx] = (int32_t)dhtfriend;
 2631|      0|                    break;
 2632|      0|                }
 2633|      0|            }
 2634|      0|        }
 2635|       |
 2636|    141|        for (uint32_t friend_idx = 0; friend_idx < num_dhtfriends; ++friend_idx) {
  ------------------
  |  Branch (2636:39): [True: 94, False: 47]
  ------------------
 2637|     94|            if (m2dht[friend_idx] >= 0) {
  ------------------
  |  Branch (2637:17): [True: 0, False: 94]
  ------------------
 2638|      0|                assert(friend_idx < INT32_MAX);
  ------------------
  |  Branch (2638:17): [True: 0, False: 0]
  ------------------
 2639|      0|                dht2m[m2dht[friend_idx]] = (int32_t)friend_idx;
 2640|      0|            }
 2641|     94|        }
 2642|       |
 2643|     47|        if (m->numfriends != dht_get_num_friends(m->dht)) {
  ------------------
  |  Branch (2643:13): [True: 47, False: 0]
  ------------------
 2644|     47|            LOGGER_TRACE(m->log, "Friend num in DHT %u != friend num in msger %u", dht_get_num_friends(m->dht), m->numfriends);
  ------------------
  |  |   76|     47|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     47|    do {                                                                         \
  |  |  |  |   70|     47|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     94|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 47]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     47|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 47]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2645|     47|        }
 2646|       |
 2647|    141|        for (uint32_t friend_idx = 0; friend_idx < num_dhtfriends; ++friend_idx) {
  ------------------
  |  Branch (2647:39): [True: 94, False: 47]
  ------------------
 2648|     94|            const Friend *const msgfptr = dht2m[friend_idx] >= 0 ?  &m->friendlist[dht2m[friend_idx]] : nullptr;
  ------------------
  |  |   63|     94|#define nullptr NULL
  ------------------
  |  Branch (2648:43): [True: 0, False: 94]
  ------------------
 2649|     94|            const DHT_Friend *const dhtfptr = dht_get_friend(m->dht, friend_idx);
 2650|       |
 2651|     94|            if (msgfptr != nullptr) {
  ------------------
  |  |   63|     94|#define nullptr NULL
  ------------------
  |  Branch (2651:17): [True: 0, False: 94]
  ------------------
 2652|      0|                char id_str[IDSTRING_LEN];
 2653|      0|                LOGGER_TRACE(m->log, "F[%2d:%2u] <%s> %s",
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2654|      0|                             dht2m[friend_idx], friend_idx, msgfptr->name,
 2655|      0|                             id_to_string(msgfptr->real_pk, id_str, sizeof(id_str)));
 2656|     94|            } else {
 2657|     94|                char id_str[IDSTRING_LEN];
 2658|     94|                LOGGER_TRACE(m->log, "F[--:%2u] %s", friend_idx,
  ------------------
  |  |   76|     94|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     94|    do {                                                                         \
  |  |  |  |   70|     94|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    188|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 94]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     94|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 94]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2659|     94|                             id_to_string(dht_friend_public_key(dhtfptr), id_str, sizeof(id_str)));
 2660|     94|            }
 2661|       |
 2662|    846|            for (uint32_t client = 0; client < MAX_FRIEND_CLIENTS; ++client) {
  ------------------
  |  |   32|    846|#define MAX_FRIEND_CLIENTS 8
  ------------------
  |  Branch (2662:39): [True: 752, False: 94]
  ------------------
 2663|    752|                const Client_data *cptr = dht_friend_client(dhtfptr, client);
 2664|    752|                const IPPTsPng *const assocs[] = {&cptr->assoc4, &cptr->assoc6};
 2665|       |
 2666|  2.25k|                for (size_t a = 0; a < sizeof(assocs) / sizeof(assocs[0]); ++a) {
  ------------------
  |  Branch (2666:36): [True: 1.50k, False: 752]
  ------------------
 2667|  1.50k|                    const IPPTsPng *const assoc = assocs[a];
 2668|       |
 2669|  1.50k|                    if (ip_isset(&assoc->ip_port.ip)) {
  ------------------
  |  Branch (2669:25): [True: 0, False: 1.50k]
  ------------------
 2670|      0|                        last_pinged = m->lastdump - assoc->last_pinged;
 2671|       |
 2672|      0|                        if (last_pinged > 999) {
  ------------------
  |  Branch (2672:29): [True: 0, False: 0]
  ------------------
 2673|      0|                            last_pinged = 999;
 2674|      0|                        }
 2675|       |
 2676|      0|                        Ip_Ntoa ip_str;
 2677|      0|                        char id_str[IDSTRING_LEN];
 2678|      0|                        LOGGER_TRACE(m->log, "F[%2u] => C[%2u] %s:%u [%3u] %s",
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2679|      0|                                     friend_idx, client, net_ip_ntoa(&assoc->ip_port.ip, &ip_str),
 2680|      0|                                     net_ntohs(assoc->ip_port.port), last_pinged,
 2681|      0|                                     id_to_string(cptr->public_key, id_str, sizeof(id_str)));
 2682|      0|                    }
 2683|  1.50k|                }
 2684|    752|            }
 2685|     94|        }
 2686|     47|    }
 2687|     82|}
m_register_state_plugin:
 2840|    536|{
 2841|    536|    const uint32_t new_length = m->options.state_plugins_length + 1;
 2842|    536|    Messenger_State_Plugin *temp = (Messenger_State_Plugin *)mem_vrealloc(
 2843|    536|                                       m->mem, m->options.state_plugins, new_length, sizeof(Messenger_State_Plugin));
 2844|       |
 2845|    536|    if (temp == nullptr) {
  ------------------
  |  |   63|    536|#define nullptr NULL
  ------------------
  |  Branch (2845:9): [True: 102, False: 434]
  ------------------
 2846|    102|        return false;
 2847|    102|    }
 2848|       |
 2849|    434|    m->options.state_plugins = temp;
 2850|    434|    m->options.state_plugins_length = new_length;
 2851|       |
 2852|    434|    const uint8_t index = m->options.state_plugins_length - 1;
 2853|    434|    m->options.state_plugins[index].type = type;
 2854|    434|    m->options.state_plugins[index].size = size_callback;
 2855|    434|    m->options.state_plugins[index].load = load_callback;
 2856|    434|    m->options.state_plugins[index].save = save_callback;
 2857|       |
 2858|       |    return true;
 2859|    536|}
new_messenger:
 3405|    217|{
 3406|    217|    if (options == nullptr) {
  ------------------
  |  |   63|    217|#define nullptr NULL
  ------------------
  |  Branch (3406:9): [True: 0, False: 217]
  ------------------
 3407|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3408|      0|    }
 3409|       |
 3410|    217|    if (error != nullptr) {
  ------------------
  |  |   63|    217|#define nullptr NULL
  ------------------
  |  Branch (3410:9): [True: 217, False: 0]
  ------------------
 3411|    217|        *error = MESSENGER_ERROR_OTHER;
 3412|    217|    }
 3413|       |
 3414|    217|    Messenger *m = (Messenger *)mem_alloc(mem, sizeof(Messenger));
 3415|       |
 3416|    217|    if (m == nullptr) {
  ------------------
  |  |   63|    217|#define nullptr NULL
  ------------------
  |  Branch (3416:9): [True: 1, False: 216]
  ------------------
 3417|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 3418|      1|    }
 3419|       |
 3420|    216|    m->log = options->log;
 3421|    216|    m->mono_time = mono_time;
 3422|    216|    m->mem = mem;
 3423|    216|    m->rng = rng;
 3424|    216|    m->ns = ns;
 3425|    216|    m->forwarding = nullptr;
  ------------------
  |  |   63|    216|#define nullptr NULL
  ------------------
 3426|    216|    m->announce = nullptr;
  ------------------
  |  |   63|    216|#define nullptr NULL
  ------------------
 3427|    216|    m->tcp_server = nullptr;
  ------------------
  |  |   63|    216|#define nullptr NULL
  ------------------
 3428|       |
 3429|    216|    Friend_Requests *fr = friendreq_new(mem);
 3430|    216|    if (fr == nullptr) {
  ------------------
  |  |   63|    216|#define nullptr NULL
  ------------------
  |  Branch (3430:9): [True: 1, False: 215]
  ------------------
 3431|      1|        mem_delete(mem, m);
 3432|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 3433|      1|    }
 3434|    215|    m->fr = fr;
 3435|       |
 3436|    215|    unsigned int net_err = 0;
 3437|       |
 3438|    215|    if (!options->udp_disabled && options->proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (3438:9): [True: 215, False: 0]
  |  Branch (3438:35): [True: 122, False: 93]
  ------------------
 3439|       |        // We don't currently support UDP over proxy.
 3440|    122|        LOGGER_INFO(m->log, "UDP enabled and proxy set: disabling UDP");
  ------------------
  |  |   78|    122|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    122|    do {                                                                         \
  |  |  |  |   70|    122|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    244|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 122, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|    122|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|    122|        }                                                                        \
  |  |  |  |   73|    122|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 122]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3441|    122|        options->udp_disabled = true;
 3442|    122|    }
 3443|       |
 3444|    215|    Networking_Core *net;
 3445|    215|    if (options->udp_disabled) {
  ------------------
  |  Branch (3445:9): [True: 122, False: 93]
  ------------------
 3446|    122|        net = new_networking_no_udp(m->log, m->mem, m->ns);
 3447|    122|    } else {
 3448|     93|        IP ip;
 3449|     93|        ip_init(&ip, options->ipv6enabled);
 3450|     93|        net = new_networking_ex(m->log, m->mem, m->ns, &ip, options->port_range[0], options->port_range[1], &net_err);
 3451|     93|    }
 3452|       |
 3453|    215|    if (net == nullptr) {
  ------------------
  |  |   63|    215|#define nullptr NULL
  ------------------
  |  Branch (3453:9): [True: 3, False: 212]
  ------------------
 3454|      3|        friendreq_kill(m->fr);
 3455|       |
 3456|      3|        if (error != nullptr && net_err == 1) {
  ------------------
  |  |   63|      6|#define nullptr NULL
  ------------------
  |  Branch (3456:13): [True: 3, False: 0]
  |  Branch (3456:33): [True: 0, False: 3]
  ------------------
 3457|      0|            LOGGER_WARNING(m->log, "network initialisation failed (no ports available)");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3458|      0|            *error = MESSENGER_ERROR_PORT;
 3459|      0|        }
 3460|       |
 3461|      3|        mem_delete(mem, m);
 3462|      3|        return nullptr;
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
 3463|      3|    }
 3464|    212|    m->net = net;
 3465|       |
 3466|    212|    DHT *dht = new_dht(m->log, m->mem, m->rng, m->ns, m->mono_time, m->net, options->hole_punching_enabled, options->local_discovery_enabled);
 3467|    212|    if (dht == nullptr) {
  ------------------
  |  |   63|    212|#define nullptr NULL
  ------------------
  |  Branch (3467:9): [True: 12, False: 200]
  ------------------
 3468|     12|        kill_networking(m->net);
 3469|     12|        friendreq_kill(m->fr);
 3470|     12|        mem_delete(mem, m);
 3471|     12|        return nullptr;
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
 3472|     12|    }
 3473|    200|    m->dht = dht;
 3474|       |
 3475|    200|    Net_Profile *tcp_np = netprof_new(m->log, mem);
 3476|    200|    if (tcp_np == nullptr) {
  ------------------
  |  |   63|    200|#define nullptr NULL
  ------------------
  |  Branch (3476:9): [True: 1, False: 199]
  ------------------
 3477|      1|        LOGGER_WARNING(m->log, "TCP netprof initialisation failed");
  ------------------
  |  |   79|      1|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3478|      1|        kill_dht(m->dht);
 3479|      1|        kill_networking(m->net);
 3480|      1|        friendreq_kill(m->fr);
 3481|      1|        mem_delete(mem, m);
 3482|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 3483|      1|    }
 3484|    199|    m->tcp_np = tcp_np;
 3485|       |
 3486|    199|    Net_Crypto *net_crypto = new_net_crypto(m->log, m->mem, m->rng, m->ns, m->mono_time, m->net, m->dht, &m_dht_funcs, &options->proxy_info, m->tcp_np);
 3487|       |
 3488|    199|    if (net_crypto == nullptr) {
  ------------------
  |  |   63|    199|#define nullptr NULL
  ------------------
  |  Branch (3488:9): [True: 3, False: 196]
  ------------------
 3489|      3|        LOGGER_WARNING(m->log, "net_crypto initialisation failed");
  ------------------
  |  |   79|      3|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      3|    do {                                                                         \
  |  |  |  |   70|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 3, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      3|        }                                                                        \
  |  |  |  |   73|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 3]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3490|       |
 3491|      3|        netprof_kill(mem, m->tcp_np);
 3492|      3|        kill_dht(m->dht);
 3493|      3|        kill_networking(m->net);
 3494|      3|        friendreq_kill(m->fr);
 3495|      3|        mem_delete(mem, m);
 3496|      3|        return nullptr;
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
 3497|      3|    }
 3498|    196|    m->net_crypto = net_crypto;
 3499|       |
 3500|    196|    GC_Announces_List *group_announce = new_gca_list(m->mem);
 3501|    196|    if (group_announce == nullptr) {
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
  |  Branch (3501:9): [True: 1, False: 195]
  ------------------
 3502|      1|        LOGGER_WARNING(m->log, "DHT group chats initialisation failed");
  ------------------
  |  |   79|      1|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3503|       |
 3504|      1|        kill_net_crypto(m->net_crypto);
 3505|      1|        netprof_kill(mem, m->tcp_np);
 3506|      1|        kill_dht(m->dht);
 3507|      1|        kill_networking(m->net);
 3508|      1|        friendreq_kill(m->fr);
 3509|      1|        mem_delete(mem, m);
 3510|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 3511|      1|    }
 3512|    195|    m->group_announce = group_announce;
 3513|       |
 3514|    195|    if (options->dht_announcements_enabled) {
  ------------------
  |  Branch (3514:9): [True: 195, False: 0]
  ------------------
 3515|    195|        m->forwarding = new_forwarding(m->log, m->mem, m->rng, m->mono_time, m->dht, m->net);
 3516|    195|        if (m->forwarding != nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (3516:13): [True: 177, False: 18]
  ------------------
 3517|    177|            m->announce = new_announcements(m->log, m->mem, m->rng, m->mono_time, m->forwarding, m->dht, m->net);
 3518|    177|        }
 3519|    195|    }
 3520|       |
 3521|    195|    Onion *onion = new_onion(m->log, m->mem, m->mono_time, m->rng, m->dht, m->net);
 3522|    195|    Onion_Announce *onion_a = new_onion_announce(m->log, m->mem, m->rng, m->mono_time, m->dht, m->net);
 3523|    195|    Onion_Client *onion_c = new_onion_client(m->log, m->mem, m->rng, m->mono_time, m->net_crypto, m->dht, m->net);
 3524|    195|    Friend_Connections *fr_c = nullptr;
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
 3525|       |
 3526|    195|    if (onion_c != nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (3526:9): [True: 192, False: 3]
  ------------------
 3527|    192|        fr_c = new_friend_connections(m->log, m->mem, m->mono_time, m->ns, onion_c, m->dht, m->net_crypto, m->net, options->local_discovery_enabled);
 3528|    192|    }
 3529|       |
 3530|    195|    if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   63|    390|#define nullptr NULL
  ------------------
                  if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   63|    177|#define nullptr NULL
  ------------------
  |  Branch (3530:10): [True: 195, False: 0]
  |  Branch (3530:49): [True: 18, False: 177]
  |  Branch (3530:77): [True: 3, False: 174]
  ------------------
 3531|    174|            onion == nullptr || onion_a == nullptr || onion_c == nullptr || fr_c == nullptr) {
  ------------------
  |  |   63|    369|#define nullptr NULL
  ------------------
                          onion == nullptr || onion_a == nullptr || onion_c == nullptr || fr_c == nullptr) {
  ------------------
  |  |   63|    368|#define nullptr NULL
  ------------------
                          onion == nullptr || onion_a == nullptr || onion_c == nullptr || fr_c == nullptr) {
  ------------------
  |  |   63|    367|#define nullptr NULL
  ------------------
                          onion == nullptr || onion_a == nullptr || onion_c == nullptr || fr_c == nullptr) {
  ------------------
  |  |   63|    171|#define nullptr NULL
  ------------------
  |  Branch (3531:13): [True: 1, False: 173]
  |  Branch (3531:33): [True: 1, False: 172]
  |  Branch (3531:55): [True: 1, False: 171]
  |  Branch (3531:77): [True: 1, False: 170]
  ------------------
 3532|     25|        LOGGER_WARNING(m->log, "onion initialisation failed");
  ------------------
  |  |   79|     25|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     25|    do {                                                                         \
  |  |  |  |   70|     25|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     50|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 25, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     25|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     25|        }                                                                        \
  |  |  |  |   73|     25|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 25]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3533|       |
 3534|     25|        kill_onion(onion);
 3535|     25|        kill_onion_announce(onion_a);
 3536|     25|        kill_onion_client(onion_c);
 3537|     25|        kill_gca(m->group_announce);
 3538|     25|        kill_friend_connections(fr_c);
 3539|     25|        kill_announcements(m->announce);
 3540|     25|        kill_forwarding(m->forwarding);
 3541|     25|        kill_net_crypto(m->net_crypto);
 3542|     25|        netprof_kill(mem, m->tcp_np);
 3543|     25|        kill_dht(m->dht);
 3544|     25|        kill_networking(m->net);
 3545|     25|        friendreq_kill(m->fr);
 3546|     25|        mem_delete(mem, m);
 3547|     25|        return nullptr;
  ------------------
  |  |   63|     25|#define nullptr NULL
  ------------------
 3548|     25|    }
 3549|    170|    m->onion = onion;
 3550|    170|    m->onion_a = onion_a;
 3551|    170|    m->onion_c = onion_c;
 3552|    170|    m->fr_c = fr_c;
 3553|       |
 3554|    170|    gca_onion_init(m->group_announce, m->onion_a);
 3555|       |
 3556|    170|    GC_Session *group_handler = new_dht_groupchats(m);
 3557|    170|    if (group_handler == nullptr) {
  ------------------
  |  |   63|    170|#define nullptr NULL
  ------------------
  |  Branch (3557:9): [True: 1, False: 169]
  ------------------
 3558|      1|        LOGGER_WARNING(m->log, "conferences initialisation failed");
  ------------------
  |  |   79|      1|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3559|       |
 3560|      1|        kill_onion(m->onion);
 3561|      1|        kill_onion_announce(m->onion_a);
 3562|      1|        kill_onion_client(m->onion_c);
 3563|      1|        kill_gca(m->group_announce);
 3564|      1|        kill_friend_connections(m->fr_c);
 3565|      1|        kill_announcements(m->announce);
 3566|      1|        kill_forwarding(m->forwarding);
 3567|      1|        kill_net_crypto(m->net_crypto);
 3568|      1|        netprof_kill(mem, m->tcp_np);
 3569|      1|        kill_dht(m->dht);
 3570|      1|        kill_networking(m->net);
 3571|      1|        friendreq_kill(m->fr);
 3572|      1|        mem_delete(mem, m);
 3573|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 3574|      1|    }
 3575|    169|    m->group_handler = group_handler;
 3576|       |
 3577|    169|    if (options->tcp_server_port != 0) {
  ------------------
  |  Branch (3577:9): [True: 138, False: 31]
  ------------------
 3578|    138|        m->tcp_server = new_tcp_server(m->log, m->mem, m->rng, m->ns, options->ipv6enabled, 1,
 3579|    138|                                       &options->tcp_server_port, dht_get_self_secret_key(m->dht),
 3580|    138|                                       m->onion, m->forwarding);
 3581|       |
 3582|    138|        if (m->tcp_server == nullptr) {
  ------------------
  |  |   63|    138|#define nullptr NULL
  ------------------
  |  Branch (3582:13): [True: 102, False: 36]
  ------------------
 3583|    102|            LOGGER_WARNING(m->log, "TCP server initialisation failed");
  ------------------
  |  |   79|    102|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    102|    do {                                                                         \
  |  |  |  |   70|    102|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    204|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 102, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|    102|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|    102|        }                                                                        \
  |  |  |  |   73|    102|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 102]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3584|       |
 3585|    102|            kill_onion(m->onion);
 3586|    102|            kill_onion_announce(m->onion_a);
 3587|    102|            kill_dht_groupchats(m->group_handler);
 3588|    102|            kill_friend_connections(m->fr_c);
 3589|    102|            kill_onion_client(m->onion_c);
 3590|    102|            kill_gca(m->group_announce);
 3591|    102|            kill_announcements(m->announce);
 3592|    102|            kill_forwarding(m->forwarding);
 3593|    102|            kill_net_crypto(m->net_crypto);
 3594|    102|            netprof_kill(mem, m->tcp_np);
 3595|    102|            kill_dht(m->dht);
 3596|    102|            kill_networking(m->net);
 3597|    102|            friendreq_kill(m->fr);
 3598|    102|            mem_delete(mem, m);
 3599|       |
 3600|    102|            if (error != nullptr) {
  ------------------
  |  |   63|    102|#define nullptr NULL
  ------------------
  |  Branch (3600:17): [True: 102, False: 0]
  ------------------
 3601|    102|                *error = MESSENGER_ERROR_TCP_SERVER;
 3602|    102|            }
 3603|       |
 3604|    102|            return nullptr;
  ------------------
  |  |   63|    102|#define nullptr NULL
  ------------------
 3605|    102|        }
 3606|    138|    }
 3607|       |
 3608|     67|    m->options = *options;
 3609|     67|    friendreq_init(m->fr, m->fr_c);
 3610|     67|    set_nospam(m->fr, random_u32(m->rng));
 3611|     67|    set_filter_function(m->fr, &friend_already_added, m);
 3612|       |
 3613|     67|    m->lastdump = 0;
 3614|     67|    m->is_receiving_file = 0;
 3615|       |
 3616|     67|    m_register_default_plugins(m);
 3617|     67|    callback_friendrequest(m->fr, m_handle_friend_request, m);
 3618|       |
 3619|     67|    if (error != nullptr) {
  ------------------
  |  |   63|     67|#define nullptr NULL
  ------------------
  |  Branch (3619:9): [True: 67, False: 0]
  ------------------
 3620|     67|        *error = MESSENGER_ERROR_NONE;
 3621|     67|    }
 3622|       |
 3623|     67|    return m;
 3624|    169|}
kill_messenger:
 3631|     67|{
 3632|     67|    if (m == nullptr) {
  ------------------
  |  |   63|     67|#define nullptr NULL
  ------------------
  |  Branch (3632:9): [True: 0, False: 67]
  ------------------
 3633|      0|        return;
 3634|      0|    }
 3635|       |
 3636|     67|    if (m->tcp_server != nullptr) {
  ------------------
  |  |   63|     67|#define nullptr NULL
  ------------------
  |  Branch (3636:9): [True: 36, False: 31]
  ------------------
 3637|     36|        kill_tcp_server(m->tcp_server);
 3638|     36|    }
 3639|       |
 3640|     67|    kill_onion(m->onion);
 3641|     67|    kill_onion_announce(m->onion_a);
 3642|     67|    kill_dht_groupchats(m->group_handler);
 3643|     67|    kill_friend_connections(m->fr_c);
 3644|     67|    kill_onion_client(m->onion_c);
 3645|     67|    kill_gca(m->group_announce);
 3646|     67|    kill_announcements(m->announce);
 3647|     67|    kill_forwarding(m->forwarding);
 3648|     67|    kill_net_crypto(m->net_crypto);
 3649|     67|    netprof_kill(m->mem, m->tcp_np);
 3650|     67|    kill_dht(m->dht);
 3651|     67|    kill_networking(m->net);
 3652|       |
 3653|     67|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (3653:26): [True: 0, False: 67]
  ------------------
 3654|      0|        clear_receipts(m, i);
 3655|      0|    }
 3656|       |
 3657|     67|    mem_delete(m->mem, m->friendlist);
 3658|     67|    friendreq_kill(m->fr);
 3659|       |
 3660|     67|    mem_delete(m->mem, m->options.state_plugins);
 3661|     67|    mem_delete(m->mem, m);
 3662|     67|}
Messenger.c:do_friends:
 2357|     82|{
 2358|     82|    const uint64_t temp_time = mono_time_get(m->mono_time);
 2359|     82|    for (uint32_t i = 0; i < m->numfriends; ++i) {
  ------------------
  |  Branch (2359:26): [True: 0, False: 82]
  ------------------
 2360|      0|        if (m->friendlist[i].status == FRIEND_ADDED) {
  ------------------
  |  Branch (2360:13): [True: 0, False: 0]
  ------------------
 2361|      0|            const int fr = send_friend_request_packet(m->fr_c, m->friendlist[i].friendcon_id, m->friendlist[i].friendrequest_nospam,
 2362|      0|                           m->friendlist[i].info,
 2363|      0|                           m->friendlist[i].info_size);
 2364|       |
 2365|      0|            if (fr >= 0) {
  ------------------
  |  Branch (2365:17): [True: 0, False: 0]
  ------------------
 2366|      0|                set_friend_status(m, i, FRIEND_REQUESTED, userdata);
 2367|      0|                m->friendlist[i].friendrequest_lastsent = temp_time;
 2368|      0|            }
 2369|      0|        }
 2370|       |
 2371|      0|        if (m->friendlist[i].status == FRIEND_REQUESTED) {
  ------------------
  |  Branch (2371:13): [True: 0, False: 0]
  ------------------
 2372|       |            /* If we didn't connect to friend after successfully sending him a friend
 2373|       |             * request the request is deemed unsuccessful so we set the status back to
 2374|       |             * FRIEND_ADDED and try again.
 2375|       |             */
 2376|      0|            check_friend_request_timed_out(m, i, temp_time, userdata);
 2377|      0|        }
 2378|       |
 2379|      0|        if (m->friendlist[i].status == FRIEND_ONLINE) { /* friend is online. */
  ------------------
  |  Branch (2379:13): [True: 0, False: 0]
  ------------------
 2380|      0|            if (!m->friendlist[i].name_sent) {
  ------------------
  |  Branch (2380:17): [True: 0, False: 0]
  ------------------
 2381|      0|                if (m_sendname(m, i, m->name, m->name_length)) {
  ------------------
  |  Branch (2381:21): [True: 0, False: 0]
  ------------------
 2382|      0|                    m->friendlist[i].name_sent = true;
 2383|      0|                }
 2384|      0|            }
 2385|       |
 2386|      0|            if (!m->friendlist[i].statusmessage_sent) {
  ------------------
  |  Branch (2386:17): [True: 0, False: 0]
  ------------------
 2387|      0|                if (send_statusmessage(m, i, m->statusmessage, m->statusmessage_length)) {
  ------------------
  |  Branch (2387:21): [True: 0, False: 0]
  ------------------
 2388|      0|                    m->friendlist[i].statusmessage_sent = true;
 2389|      0|                }
 2390|      0|            }
 2391|       |
 2392|      0|            if (!m->friendlist[i].userstatus_sent) {
  ------------------
  |  Branch (2392:17): [True: 0, False: 0]
  ------------------
 2393|      0|                if (send_userstatus(m, i, m->userstatus)) {
  ------------------
  |  Branch (2393:21): [True: 0, False: 0]
  ------------------
 2394|      0|                    m->friendlist[i].userstatus_sent = true;
 2395|      0|                }
 2396|      0|            }
 2397|       |
 2398|      0|            if (!m->friendlist[i].user_istyping_sent) {
  ------------------
  |  Branch (2398:17): [True: 0, False: 0]
  ------------------
 2399|      0|                if (send_user_istyping(m, i, m->friendlist[i].user_istyping)) {
  ------------------
  |  Branch (2399:21): [True: 0, False: 0]
  ------------------
 2400|      0|                    m->friendlist[i].user_istyping_sent = true;
 2401|      0|                }
 2402|      0|            }
 2403|       |
 2404|      0|            check_friend_tcp_udp(m, i, userdata);
 2405|      0|            do_receipts(m, i, userdata);
 2406|      0|            do_reqchunk_filecb(m, i, userdata);
 2407|       |
 2408|       |            m->friendlist[i].last_seen_time = (uint64_t) time(nullptr);
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2409|      0|        }
 2410|      0|    }
 2411|     82|}
Messenger.c:do_gc_onion_friends:
 2523|     82|{
 2524|     82|    const uint16_t num_friends = onion_get_friend_count(m->onion_c);
 2525|       |
 2526|     82|    for (uint16_t i = 0; i < num_friends; ++i) {
  ------------------
  |  Branch (2526:26): [True: 0, False: 82]
  ------------------
 2527|      0|        Onion_Friend *onion_friend = onion_get_friend(m->onion_c, i);
 2528|       |
 2529|      0|        if (!onion_friend_is_groupchat(onion_friend)) {
  ------------------
  |  Branch (2529:13): [True: 0, False: 0]
  ------------------
 2530|      0|            continue;
 2531|      0|        }
 2532|       |
 2533|      0|        GC_Chat *chat = gc_get_group_by_public_key(m->group_handler, onion_friend_get_gc_public_key(onion_friend));
 2534|       |
 2535|      0|        if (chat == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (2535:13): [True: 0, False: 0]
  ------------------
 2536|      0|            continue;
 2537|      0|        }
 2538|       |
 2539|      0|        if (chat->update_self_announces) {
  ------------------
  |  Branch (2539:13): [True: 0, False: 0]
  ------------------
 2540|      0|            self_announce_group(m, chat, onion_friend);
 2541|      0|        }
 2542|      0|    }
 2543|     82|}
Messenger.c:m_connection_status_callback:
 2414|     82|{
 2415|     82|    const Onion_Connection_Status conn_status = onion_connection_status(m->onion_c);
 2416|     82|    if (conn_status != m->last_connection_status) {
  ------------------
  |  Branch (2416:9): [True: 0, False: 82]
  ------------------
 2417|      0|        if (m->core_connection_change != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (2417:13): [True: 0, False: 0]
  ------------------
 2418|      0|            m->core_connection_change(m, conn_status, userdata);
 2419|      0|        }
 2420|       |
 2421|      0|        m->last_connection_status = conn_status;
 2422|      0|    }
 2423|     82|}
Messenger.c:nc_dht_get_self_secret_key_wrapper:
   63|    198|{
   64|    198|    const DHT *dht = (const DHT *)obj;
   65|    198|    return dht_get_self_secret_key(dht);
   66|    198|}
Messenger.c:m_register_default_plugins:
 3307|     67|{
 3308|     67|    m_register_state_plugin(m, STATE_TYPE_NOSPAMKEYS, nospam_keys_size, load_nospam_keys, save_nospam_keys);
 3309|     67|    m_register_state_plugin(m, STATE_TYPE_DHT, m_dht_size, m_dht_load, save_dht);
 3310|     67|    m_register_state_plugin(m, STATE_TYPE_FRIENDS, saved_friendslist_size, friends_list_load, friends_list_save);
 3311|     67|    m_register_state_plugin(m, STATE_TYPE_NAME, name_size, load_name, save_name);
 3312|     67|    m_register_state_plugin(m, STATE_TYPE_STATUSMESSAGE, status_message_size, load_status_message,
 3313|     67|                            save_status_message);
 3314|     67|    m_register_state_plugin(m, STATE_TYPE_STATUS, status_size, load_status, save_status);
 3315|     67|    if (m->options.groups_persistence_enabled) {
  ------------------
  |  Branch (3315:9): [True: 0, False: 67]
  ------------------
 3316|      0|        m_register_state_plugin(m, STATE_TYPE_GROUPS, saved_groups_size, groups_load, groups_save);
 3317|      0|    }
 3318|     67|    m_register_state_plugin(m, STATE_TYPE_TCP_RELAY, tcp_relay_size, load_tcp_relays, save_tcp_relays);
 3319|     67|    m_register_state_plugin(m, STATE_TYPE_PATH_NODE, path_node_size, load_path_nodes, save_path_nodes);
 3320|     67|}

tcp_con_public_key:
   76|     23|{
   77|     23|    return con->public_key;
   78|     23|}
tcp_con_status:
   86|    176|{
   87|    176|    return con->status;
   88|    176|}
new_tcp_connection:
  600|     78|{
  601|     78|    assert(logger != nullptr);
  ------------------
  |  Branch (601:5): [True: 78, False: 0]
  ------------------
  602|     78|    assert(mem != nullptr);
  ------------------
  |  Branch (602:5): [True: 78, False: 0]
  ------------------
  603|     78|    assert(mono_time != nullptr);
  ------------------
  |  Branch (603:5): [True: 78, False: 0]
  ------------------
  604|     78|    assert(rng != nullptr);
  ------------------
  |  Branch (604:5): [True: 78, False: 0]
  ------------------
  605|     78|    assert(ns != nullptr);
  ------------------
  |  Branch (605:5): [True: 78, False: 0]
  ------------------
  606|       |
  607|     78|    if (!net_family_is_ipv4(ip_port->ip.family) && !net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (607:9): [True: 0, False: 78]
  |  Branch (607:52): [True: 0, False: 0]
  ------------------
  608|      0|        LOGGER_ERROR(logger, "Invalid IP family: %d", ip_port->ip.family.value);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  609|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  610|      0|    }
  611|       |
  612|     78|    const TCP_Proxy_Info default_proxyinfo = {{{{0}}}};
  613|       |
  614|     78|    if (proxy_info == nullptr) {
  ------------------
  |  |   63|     78|#define nullptr NULL
  ------------------
  |  Branch (614:9): [True: 0, False: 78]
  ------------------
  615|      0|        proxy_info = &default_proxyinfo;
  616|      0|    }
  617|       |
  618|     78|    Family family = ip_port->ip.family;
  619|       |
  620|     78|    if (proxy_info->proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (620:9): [True: 23, False: 55]
  ------------------
  621|     23|        family = proxy_info->ip_port.ip.family;
  622|     23|    }
  623|       |
  624|     78|    const Socket sock = net_socket(ns, family, TOX_SOCK_STREAM, TOX_PROTO_TCP);
  ------------------
  |  |   70|     78|#define TOX_SOCK_STREAM 1
  ------------------
                  const Socket sock = net_socket(ns, family, TOX_SOCK_STREAM, TOX_PROTO_TCP);
  ------------------
  |  |   73|     78|#define TOX_PROTO_TCP 1
  ------------------
  625|       |
  626|     78|    if (!sock_valid(sock)) {
  ------------------
  |  Branch (626:9): [True: 0, False: 78]
  ------------------
  627|      0|        LOGGER_ERROR(logger, "Failed to create TCP socket with family %d", family.value);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  628|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  629|      0|    }
  630|       |
  631|     78|    if (!set_socket_nosigpipe(ns, sock)) {
  ------------------
  |  Branch (631:9): [True: 0, False: 78]
  ------------------
  632|      0|        LOGGER_ERROR(logger, "Failed to set TCP socket to ignore SIGPIPE");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  633|      0|        kill_sock(ns, sock);
  634|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  635|      0|    }
  636|       |
  637|     78|    if (!set_socket_nonblock(ns, sock)) {
  ------------------
  |  Branch (637:9): [True: 0, False: 78]
  ------------------
  638|      0|        LOGGER_ERROR(logger, "Failed to set TCP socket to non-blocking");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  639|      0|        kill_sock(ns, sock);
  640|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  641|      0|    }
  642|       |
  643|     78|    if (!connect_sock_to(ns, logger, mem, sock, ip_port, proxy_info)) {
  ------------------
  |  Branch (643:9): [True: 0, False: 78]
  ------------------
  644|      0|        Ip_Ntoa ip_ntoa;
  645|      0|        LOGGER_WARNING(logger, "Failed to connect TCP socket to %s:%u",
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  646|      0|                       net_ip_ntoa(&ip_port->ip, &ip_ntoa), net_ntohs(ip_port->port));
  647|      0|        kill_sock(ns, sock);
  648|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  649|      0|    }
  650|       |
  651|     78|    TCP_Client_Connection *temp = (TCP_Client_Connection *)mem_alloc(mem, sizeof(TCP_Client_Connection));
  652|       |
  653|     78|    if (temp == nullptr) {
  ------------------
  |  |   63|     78|#define nullptr NULL
  ------------------
  |  Branch (653:9): [True: 15, False: 63]
  ------------------
  654|     15|        LOGGER_ERROR(logger, "Failed to allocate memory for TCP_Client_Connection");
  ------------------
  |  |   80|     15|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     15|    do {                                                                         \
  |  |  |  |   70|     15|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     30|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 15, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     15|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     15|        }                                                                        \
  |  |  |  |   73|     15|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 15]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  655|     15|        kill_sock(ns, sock);
  656|     15|        return nullptr;
  ------------------
  |  |   63|     15|#define nullptr NULL
  ------------------
  657|     15|    }
  658|       |
  659|     63|    temp->con.ns = ns;
  660|     63|    temp->con.mem = mem;
  661|     63|    temp->con.rng = rng;
  662|     63|    temp->con.sock = sock;
  663|     63|    temp->con.ip_port = *ip_port;
  664|     63|    temp->con.net_profile = net_profile;
  665|     63|    memcpy(temp->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     63|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  666|     63|    memcpy(temp->self_public_key, self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     63|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  667|     63|    encrypt_precompute(temp->public_key, self_secret_key, temp->con.shared_key);
  668|     63|    temp->ip_port = *ip_port;
  669|     63|    temp->proxy_info = *proxy_info;
  670|       |
  671|     63|    switch (proxy_info->proxy_type) {
  ------------------
  |  Branch (671:13): [True: 63, False: 0]
  ------------------
  672|     11|        case TCP_PROXY_HTTP: {
  ------------------
  |  Branch (672:9): [True: 11, False: 52]
  ------------------
  673|     11|            temp->status = TCP_CLIENT_PROXY_HTTP_CONNECTING;
  674|     11|            proxy_http_generate_connection_request(temp);
  675|     11|            break;
  676|      0|        }
  677|       |
  678|      7|        case TCP_PROXY_SOCKS5: {
  ------------------
  |  Branch (678:9): [True: 7, False: 56]
  ------------------
  679|      7|            temp->status = TCP_CLIENT_PROXY_SOCKS5_CONNECTING;
  680|      7|            proxy_socks5_generate_greetings(temp);
  681|      7|            break;
  682|      0|        }
  683|       |
  684|     45|        case TCP_PROXY_NONE: {
  ------------------
  |  Branch (684:9): [True: 45, False: 18]
  ------------------
  685|     45|            temp->status = TCP_CLIENT_CONNECTING;
  686|       |
  687|     45|            if (generate_handshake(temp) == -1) {
  ------------------
  |  Branch (687:17): [True: 0, False: 45]
  ------------------
  688|      0|                LOGGER_ERROR(logger, "Failed to generate handshake");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  689|      0|                kill_sock(ns, sock);
  690|      0|                mem_delete(mem, temp);
  691|      0|                return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  692|      0|            }
  693|       |
  694|     45|            break;
  695|     45|        }
  696|     63|    }
  697|       |
  698|     63|    temp->kill_at = mono_time_get(mono_time) + TCP_CONNECTION_TIMEOUT;
  ------------------
  |  |   29|     63|#define TCP_CONNECTION_TIMEOUT 10
  ------------------
  699|       |
  700|     63|    return temp;
  701|     63|}
do_tcp_connection:
  954|     88|{
  955|     88|    if (tcp_connection->status == TCP_CLIENT_DISCONNECTED) {
  ------------------
  |  Branch (955:9): [True: 0, False: 88]
  ------------------
  956|      0|        return;
  957|      0|    }
  958|       |
  959|     88|    if (tcp_connection->status == TCP_CLIENT_PROXY_HTTP_CONNECTING) {
  ------------------
  |  Branch (959:9): [True: 3, False: 85]
  ------------------
  960|      3|        if (send_pending_data(logger, &tcp_connection->con) == 0) {
  ------------------
  |  Branch (960:13): [True: 0, False: 3]
  ------------------
  961|      0|            const int ret = proxy_http_read_connection_response(logger, tcp_connection);
  962|       |
  963|      0|            if (ret == -1) {
  ------------------
  |  Branch (963:17): [True: 0, False: 0]
  ------------------
  964|      0|                tcp_connection->kill_at = 0;
  965|      0|                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
  966|      0|            }
  967|       |
  968|      0|            if (ret == 1) {
  ------------------
  |  Branch (968:17): [True: 0, False: 0]
  ------------------
  969|      0|                generate_handshake(tcp_connection);
  970|      0|                tcp_connection->status = TCP_CLIENT_CONNECTING;
  971|      0|            }
  972|      0|        }
  973|      3|    }
  974|       |
  975|     88|    if (tcp_connection->status == TCP_CLIENT_PROXY_SOCKS5_CONNECTING) {
  ------------------
  |  Branch (975:9): [True: 9, False: 79]
  ------------------
  976|      9|        if (send_pending_data(logger, &tcp_connection->con) == 0) {
  ------------------
  |  Branch (976:13): [True: 0, False: 9]
  ------------------
  977|      0|            const int ret = socks5_read_handshake_response(logger, tcp_connection);
  978|       |
  979|      0|            if (ret == -1) {
  ------------------
  |  Branch (979:17): [True: 0, False: 0]
  ------------------
  980|      0|                tcp_connection->kill_at = 0;
  981|      0|                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
  982|      0|            }
  983|       |
  984|      0|            if (ret == 1) {
  ------------------
  |  Branch (984:17): [True: 0, False: 0]
  ------------------
  985|      0|                proxy_socks5_generate_connection_request(tcp_connection);
  986|      0|                tcp_connection->status = TCP_CLIENT_PROXY_SOCKS5_UNCONFIRMED;
  987|      0|            }
  988|      0|        }
  989|      9|    }
  990|       |
  991|     88|    if (tcp_connection->status == TCP_CLIENT_PROXY_SOCKS5_UNCONFIRMED) {
  ------------------
  |  Branch (991:9): [True: 0, False: 88]
  ------------------
  992|      0|        if (send_pending_data(logger, &tcp_connection->con) == 0) {
  ------------------
  |  Branch (992:13): [True: 0, False: 0]
  ------------------
  993|      0|            const int ret = proxy_socks5_read_connection_response(logger, tcp_connection);
  994|       |
  995|      0|            if (ret == -1) {
  ------------------
  |  Branch (995:17): [True: 0, False: 0]
  ------------------
  996|      0|                tcp_connection->kill_at = 0;
  997|      0|                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
  998|      0|            }
  999|       |
 1000|      0|            if (ret == 1) {
  ------------------
  |  Branch (1000:17): [True: 0, False: 0]
  ------------------
 1001|      0|                generate_handshake(tcp_connection);
 1002|      0|                tcp_connection->status = TCP_CLIENT_CONNECTING;
 1003|      0|            }
 1004|      0|        }
 1005|      0|    }
 1006|       |
 1007|     88|    if (tcp_connection->status == TCP_CLIENT_CONNECTING) {
  ------------------
  |  Branch (1007:9): [True: 76, False: 12]
  ------------------
 1008|     76|        if (send_pending_data(logger, &tcp_connection->con) == 0) {
  ------------------
  |  Branch (1008:13): [True: 0, False: 76]
  ------------------
 1009|      0|            tcp_connection->status = TCP_CLIENT_UNCONFIRMED;
 1010|      0|        }
 1011|     76|    }
 1012|       |
 1013|     88|    if (tcp_connection->status == TCP_CLIENT_UNCONFIRMED) {
  ------------------
  |  Branch (1013:9): [True: 0, False: 88]
  ------------------
 1014|      0|        uint8_t data[TCP_SERVER_HANDSHAKE_SIZE];
 1015|      0|        const TCP_Connection *con = &tcp_connection->con;
 1016|      0|        const int len = read_tcp_packet(logger, con->mem, con->ns, con->sock, data, sizeof(data), &con->ip_port);
 1017|       |
 1018|      0|        if (sizeof(data) == len) {
  ------------------
  |  Branch (1018:13): [True: 0, False: 0]
  ------------------
 1019|      0|            if (handle_handshake(tcp_connection, data) == 0) {
  ------------------
  |  Branch (1019:17): [True: 0, False: 0]
  ------------------
 1020|      0|                tcp_connection->kill_at = UINT64_MAX;
 1021|      0|                tcp_connection->status = TCP_CLIENT_CONFIRMED;
 1022|      0|            } else {
 1023|      0|                tcp_connection->kill_at = 0;
 1024|      0|                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
 1025|      0|            }
 1026|      0|        }
 1027|      0|    }
 1028|       |
 1029|     88|    if (tcp_connection->status == TCP_CLIENT_CONFIRMED) {
  ------------------
  |  Branch (1029:9): [True: 0, False: 88]
  ------------------
 1030|      0|        do_confirmed_tcp(logger, tcp_connection, mono_time, userdata);
 1031|      0|    }
 1032|       |
 1033|     88|    if (tcp_connection->kill_at <= mono_time_get(mono_time)) {
  ------------------
  |  Branch (1033:9): [True: 0, False: 88]
  ------------------
 1034|      0|        tcp_connection->status = TCP_CLIENT_DISCONNECTED;
 1035|      0|    }
 1036|     88|}
kill_tcp_connection:
 1040|     72|{
 1041|     72|    if (tcp_connection == nullptr) {
  ------------------
  |  |   63|     72|#define nullptr NULL
  ------------------
  |  Branch (1041:9): [True: 9, False: 63]
  ------------------
 1042|      9|        return;
 1043|      9|    }
 1044|       |
 1045|     63|    const Memory *mem = tcp_connection->con.mem;
 1046|       |
 1047|     63|    wipe_priority_list(tcp_connection->con.mem, tcp_connection->con.priority_queue_start);
 1048|     63|    kill_sock(tcp_connection->con.ns, tcp_connection->con.sock);
 1049|     63|    crypto_memzero(tcp_connection, sizeof(TCP_Client_Connection));
 1050|     63|    mem_delete(mem, tcp_connection);
 1051|     63|}
TCP_client.c:connect_sock_to:
  112|     78|{
  113|     78|    Net_Err_Connect err;
  114|     78|    if (proxy_info->proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (114:9): [True: 23, False: 55]
  ------------------
  115|     23|        net_connect(ns, mem, logger, sock, &proxy_info->ip_port, &err);
  116|     55|    } else {
  117|     55|        net_connect(ns, mem, logger, sock, ip_port, &err);
  118|     55|    }
  119|     78|    switch (err) {
  ------------------
  |  Branch (119:13): [True: 78, False: 0]
  ------------------
  120|     78|        case NET_ERR_CONNECT_OK:
  ------------------
  |  Branch (120:9): [True: 78, False: 0]
  ------------------
  121|     78|        case NET_ERR_CONNECT_FAILED: {
  ------------------
  |  Branch (121:9): [True: 0, False: 78]
  ------------------
  122|       |            /* nonblocking socket, connect will never return success */
  123|     78|            return true;
  124|     78|        }
  125|      0|        case NET_ERR_CONNECT_INVALID_FAMILY:
  ------------------
  |  Branch (125:9): [True: 0, False: 78]
  ------------------
  126|      0|            return false;
  127|     78|    }
  128|      0|    LOGGER_ERROR(logger, "unexpected error code %s from net_connect", net_err_connect_to_string(err));
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  129|       |    return false;
  130|     78|}
TCP_client.c:proxy_http_generate_connection_request:
  137|     11|{
  138|     11|    const char one[] = "CONNECT ";
  139|     11|    const char two[] = " HTTP/1.1\nHost: ";
  140|     11|    const char three[] = "\r\n\r\n";
  141|       |
  142|     11|    char ip[TOX_INET6_ADDRSTRLEN];
  143|       |
  144|     11|    if (!ip_parse_addr(&tcp_conn->ip_port.ip, ip, sizeof(ip))) {
  ------------------
  |  Branch (144:9): [True: 0, False: 11]
  ------------------
  145|      0|        return 0;
  146|      0|    }
  147|       |
  148|     11|    const uint16_t port = net_ntohs(tcp_conn->ip_port.port);
  149|     11|    const int written = snprintf((char *)tcp_conn->con.last_packet, MAX_PACKET_SIZE, "%s%s:%hu%s%s:%hu%s", one, ip, port,
  ------------------
  |  |   64|     11|#define MAX_PACKET_SIZE 2048
  ------------------
  150|     11|                                 two, ip, port, three);
  151|       |
  152|     11|    if (written < 0 || MAX_PACKET_SIZE < written) {
  ------------------
  |  |   64|     11|#define MAX_PACKET_SIZE 2048
  ------------------
  |  Branch (152:9): [True: 0, False: 11]
  |  Branch (152:24): [True: 0, False: 11]
  ------------------
  153|      0|        return 0;
  154|      0|    }
  155|       |
  156|     11|    tcp_conn->con.last_packet_length = written;
  157|     11|    tcp_conn->con.last_packet_sent = 0;
  158|     11|    return 1;
  159|     11|}
TCP_client.c:proxy_socks5_generate_greetings:
  216|      7|{
  217|      7|    tcp_conn->con.last_packet[0] = TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5;
  218|      7|    tcp_conn->con.last_packet[1] = TCP_SOCKS5_PROXY_HS_AUTH_METHODS_SUPPORTED;
  219|      7|    tcp_conn->con.last_packet[2] = TCP_SOCKS5_PROXY_HS_NO_AUTH;
  220|       |
  221|      7|    tcp_conn->con.last_packet_length = 3;
  222|      7|    tcp_conn->con.last_packet_sent = 0;
  223|      7|}
TCP_client.c:generate_handshake:
  314|     45|{
  315|     45|    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE];
  316|     45|    crypto_new_keypair(tcp_conn->con.rng, plain, tcp_conn->temp_secret_key);
  317|     45|    random_nonce(tcp_conn->con.rng, tcp_conn->con.sent_nonce);
  318|     45|    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, tcp_conn->con.sent_nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   44|     45|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, tcp_conn->con.sent_nonce, CRYPTO_NONCE_SIZE);
  ------------------
  |  |   70|     45|#define CRYPTO_NONCE_SIZE              24
  ------------------
  319|     45|    memcpy(tcp_conn->con.last_packet, tcp_conn->self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     45|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  320|     45|    random_nonce(tcp_conn->con.rng, tcp_conn->con.last_packet + CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     45|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  321|     45|    const int len = encrypt_data_symmetric(tcp_conn->con.mem, tcp_conn->con.shared_key, tcp_conn->con.last_packet + CRYPTO_PUBLIC_KEY_SIZE, plain,
  ------------------
  |  |   44|     45|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  322|     45|                                           sizeof(plain), tcp_conn->con.last_packet + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   44|     45|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                                                         sizeof(plain), tcp_conn->con.last_packet + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);
  ------------------
  |  |   70|     45|#define CRYPTO_NONCE_SIZE              24
  ------------------
  323|       |
  324|     45|    if (len != sizeof(plain) + CRYPTO_MAC_SIZE) {
  ------------------
  |  |   65|     45|#define CRYPTO_MAC_SIZE                16
  ------------------
  |  Branch (324:9): [True: 0, False: 45]
  ------------------
  325|      0|        return -1;
  326|      0|    }
  327|       |
  328|     45|    tcp_conn->con.last_packet_length = CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE;
  ------------------
  |  |   44|     45|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
                  tcp_conn->con.last_packet_length = CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE;
  ------------------
  |  |   70|     45|#define CRYPTO_NONCE_SIZE              24
  ------------------
                  tcp_conn->con.last_packet_length = CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE;
  ------------------
  |  |   65|     45|#define CRYPTO_MAC_SIZE                16
  ------------------
  329|     45|    tcp_conn->con.last_packet_sent = 0;
  330|     45|    return 0;
  331|     45|}

wipe_priority_list:
   18|     63|{
   19|     63|    while (p != nullptr) {
  ------------------
  |  |   63|     63|#define nullptr NULL
  ------------------
  |  Branch (19:12): [True: 0, False: 63]
  ------------------
   20|      0|        TCP_Priority_List *pp = p;
   21|      0|        p = p->next;
   22|      0|        mem_delete(mem, pp->data);
   23|      0|        mem_delete(mem, pp);
   24|      0|    }
   25|     63|}
send_pending_data_nonpriority:
   32|     88|{
   33|     88|    if (con->last_packet_length == 0) {
  ------------------
  |  Branch (33:9): [True: 0, False: 88]
  ------------------
   34|      0|        return 0;
   35|      0|    }
   36|       |
   37|     88|    const uint16_t left = con->last_packet_length - con->last_packet_sent;
   38|     88|    const int len = net_send(con->ns, logger, con->sock, con->last_packet + con->last_packet_sent, left, &con->ip_port,
   39|     88|                             con->net_profile);
   40|       |
   41|     88|    if (len <= 0) {
  ------------------
  |  Branch (41:9): [True: 88, False: 0]
  ------------------
   42|     88|        return -1;
   43|     88|    }
   44|       |
   45|      0|    if (len == left) {
  ------------------
  |  Branch (45:9): [True: 0, False: 0]
  ------------------
   46|      0|        con->last_packet_length = 0;
   47|      0|        con->last_packet_sent = 0;
   48|      0|        return 0;
   49|      0|    }
   50|       |
   51|      0|    con->last_packet_sent += len;
   52|      0|    return -1;
   53|      0|}
send_pending_data:
   60|     88|{
   61|       |    /* finish sending current non-priority packet */
   62|     88|    if (send_pending_data_nonpriority(logger, con) == -1) {
  ------------------
  |  Branch (62:9): [True: 88, False: 0]
  ------------------
   63|     88|        return -1;
   64|     88|    }
   65|       |
   66|      0|    TCP_Priority_List *p = con->priority_queue_start;
   67|       |
   68|      0|    while (p != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (68:12): [True: 0, False: 0]
  ------------------
   69|      0|        const uint16_t left = p->size - p->sent;
   70|      0|        const int len = net_send(con->ns, logger, con->sock, p->data + p->sent, left, &con->ip_port, con->net_profile);
   71|       |
   72|      0|        if (len != left) {
  ------------------
  |  Branch (72:13): [True: 0, False: 0]
  ------------------
   73|      0|            if (len > 0) {
  ------------------
  |  Branch (73:17): [True: 0, False: 0]
  ------------------
   74|      0|                p->sent += len;
   75|      0|            }
   76|       |
   77|      0|            break;
   78|      0|        }
   79|       |
   80|      0|        TCP_Priority_List *pp = p;
   81|      0|        p = p->next;
   82|      0|        mem_delete(con->mem, pp->data);
   83|      0|        mem_delete(con->mem, pp);
   84|      0|    }
   85|       |
   86|      0|    con->priority_queue_start = p;
   87|       |
   88|      0|    if (p == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (88:9): [True: 0, False: 0]
  ------------------
   89|      0|        con->priority_queue_end = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   90|      0|        return 0;
   91|      0|    }
   92|       |
   93|      0|    return -1;
   94|      0|}

set_packet_tcp_connection_callback:
  571|    196|{
  572|    196|    tcp_c->tcp_data_callback = tcp_data_callback;
  573|    196|    tcp_c->tcp_data_callback_object = object;
  574|    196|}
set_oob_packet_tcp_connection_callback:
  578|    196|{
  579|    196|    tcp_c->tcp_oob_callback = tcp_oob_callback;
  580|    196|    tcp_c->tcp_oob_callback_object = object;
  581|    196|}
set_onion_packet_tcp_connection_callback:
  585|    384|{
  586|    384|    tcp_c->tcp_onion_callback = tcp_onion_callback;
  587|    384|    tcp_c->tcp_onion_callback_object = object;
  588|    384|}
add_tcp_relay_global:
 1360|     95|{
 1361|     95|    const int tcp_connections_number = find_tcp_connection_relay(tcp_c, relay_pk);
 1362|       |
 1363|     95|    if (tcp_connections_number != -1) {
  ------------------
  |  Branch (1363:9): [True: 0, False: 95]
  ------------------
 1364|      0|        return -1;
 1365|      0|    }
 1366|       |
 1367|     95|    if (add_tcp_relay_instance(tcp_c, ip_port, relay_pk) == -1) {
  ------------------
  |  Branch (1367:9): [True: 32, False: 63]
  ------------------
 1368|     32|        return -1;
 1369|     32|    }
 1370|       |
 1371|     63|    return 0;
 1372|     95|}
set_tcp_onion_status:
 1556|     47|{
 1557|     47|    if (tcp_c->onion_status == status) {
  ------------------
  |  Branch (1557:9): [True: 0, False: 47]
  ------------------
 1558|      0|        return -1;
 1559|      0|    }
 1560|       |
 1561|     47|    if (status) {
  ------------------
  |  Branch (1561:9): [True: 47, False: 0]
  ------------------
 1562|    103|        for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1562:30): [True: 56, False: 47]
  ------------------
 1563|     56|            TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1564|       |
 1565|     56|            if (tcp_con != nullptr) {
  ------------------
  |  |   63|     56|#define nullptr NULL
  ------------------
  |  Branch (1565:17): [True: 47, False: 9]
  ------------------
 1566|     47|                if (tcp_con->status == TCP_CONN_CONNECTED && !tcp_con->onion) {
  ------------------
  |  |   33|     94|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (1566:21): [True: 0, False: 47]
  |  Branch (1566:62): [True: 0, False: 0]
  ------------------
 1567|      0|                    ++tcp_c->onion_num_conns;
 1568|      0|                    tcp_con->onion = true;
 1569|      0|                }
 1570|     47|            }
 1571|       |
 1572|     56|            if (tcp_c->onion_num_conns >= NUM_ONION_TCP_CONNECTIONS) {
  ------------------
  |  |   53|     56|#define NUM_ONION_TCP_CONNECTIONS RECOMMENDED_FRIEND_TCP_CONNECTIONS
  |  |  ------------------
  |  |  |  |   50|     56|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   42|     56|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1572:17): [True: 0, False: 56]
  ------------------
 1573|      0|                break;
 1574|      0|            }
 1575|     56|        }
 1576|       |
 1577|     47|        if (tcp_c->onion_num_conns < NUM_ONION_TCP_CONNECTIONS) {
  ------------------
  |  |   53|     47|#define NUM_ONION_TCP_CONNECTIONS RECOMMENDED_FRIEND_TCP_CONNECTIONS
  |  |  ------------------
  |  |  |  |   50|     47|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   42|     47|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1577:13): [True: 47, False: 0]
  ------------------
 1578|     47|            const unsigned int wakeup = NUM_ONION_TCP_CONNECTIONS - tcp_c->onion_num_conns;
  ------------------
  |  |   53|     47|#define NUM_ONION_TCP_CONNECTIONS RECOMMENDED_FRIEND_TCP_CONNECTIONS
  |  |  ------------------
  |  |  |  |   50|     47|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  |  |  ------------------
  |  |  |  |  |  |   42|     47|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1579|       |
 1580|    103|            for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1580:34): [True: 56, False: 47]
  ------------------
 1581|     56|                TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1582|       |
 1583|     56|                if (tcp_con != nullptr) {
  ------------------
  |  |   63|     56|#define nullptr NULL
  ------------------
  |  Branch (1583:21): [True: 47, False: 9]
  ------------------
 1584|     47|                    if (tcp_con->status == TCP_CONN_SLEEPING) {
  ------------------
  |  |   36|     47|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (1584:25): [True: 0, False: 47]
  ------------------
 1585|      0|                        tcp_con->unsleep = true;
 1586|      0|                    }
 1587|     47|                }
 1588|       |
 1589|     56|                if (wakeup == 0) {
  ------------------
  |  Branch (1589:21): [True: 0, False: 56]
  ------------------
 1590|      0|                    break;
 1591|      0|                }
 1592|     56|            }
 1593|     47|        }
 1594|       |
 1595|     47|        tcp_c->onion_status = true;
 1596|     47|    } else {
 1597|      0|        for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1597:30): [True: 0, False: 0]
  ------------------
 1598|      0|            TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1599|       |
 1600|      0|            if (tcp_con != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1600:17): [True: 0, False: 0]
  ------------------
 1601|      0|                if (tcp_con->onion) {
  ------------------
  |  Branch (1601:21): [True: 0, False: 0]
  ------------------
 1602|      0|                    --tcp_c->onion_num_conns;
 1603|      0|                    tcp_con->onion = false;
 1604|      0|                }
 1605|      0|            }
 1606|      0|        }
 1607|       |
 1608|      0|        tcp_c->onion_status = false;
 1609|      0|    }
 1610|       |
 1611|     47|    return 0;
 1612|     47|}
new_tcp_connections:
 1623|    198|{
 1624|    198|    assert(logger != nullptr);
  ------------------
  |  Branch (1624:5): [True: 198, False: 0]
  ------------------
 1625|    198|    assert(mem != nullptr);
  ------------------
  |  Branch (1625:5): [True: 198, False: 0]
  ------------------
 1626|    198|    assert(rng != nullptr);
  ------------------
  |  Branch (1626:5): [True: 198, False: 0]
  ------------------
 1627|    198|    assert(ns != nullptr);
  ------------------
  |  Branch (1627:5): [True: 198, False: 0]
  ------------------
 1628|    198|    assert(mono_time != nullptr);
  ------------------
  |  Branch (1628:5): [True: 198, False: 0]
  ------------------
 1629|       |
 1630|    198|    if (secret_key == nullptr) {
  ------------------
  |  |   63|    198|#define nullptr NULL
  ------------------
  |  Branch (1630:9): [True: 0, False: 198]
  ------------------
 1631|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1632|      0|    }
 1633|       |
 1634|    198|    TCP_Connections *temp = (TCP_Connections *)mem_alloc(mem, sizeof(TCP_Connections));
 1635|       |
 1636|    198|    if (temp == nullptr) {
  ------------------
  |  |   63|    198|#define nullptr NULL
  ------------------
  |  Branch (1636:9): [True: 2, False: 196]
  ------------------
 1637|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 1638|      2|    }
 1639|       |
 1640|    196|    temp->net_profile = tcp_np;
 1641|    196|    temp->logger = logger;
 1642|    196|    temp->mem = mem;
 1643|    196|    temp->rng = rng;
 1644|    196|    temp->mono_time = mono_time;
 1645|    196|    temp->ns = ns;
 1646|       |
 1647|    196|    memcpy(temp->self_secret_key, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   49|    196|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 1648|    196|    crypto_derive_public_key(temp->self_public_key, temp->self_secret_key);
 1649|    196|    temp->proxy_info = *proxy_info;
 1650|       |
 1651|    196|    return temp;
 1652|    198|}
do_tcp_connections:
 1751|     82|{
 1752|     82|    do_tcp_conns(logger, tcp_c, userdata);
 1753|     82|    kill_nonused_tcp(tcp_c);
 1754|     82|}
kill_tcp_connections:
 1757|    196|{
 1758|    196|    if (tcp_c == nullptr) {
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
  |  Branch (1758:9): [True: 0, False: 196]
  ------------------
 1759|      0|        return;
 1760|      0|    }
 1761|       |
 1762|    268|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1762:26): [True: 72, False: 196]
  ------------------
 1763|     72|        kill_tcp_connection(tcp_c->tcp_connections[i].connection);
 1764|     72|    }
 1765|       |
 1766|    196|    crypto_memzero(tcp_c->self_secret_key, sizeof(tcp_c->self_secret_key));
 1767|       |
 1768|    196|    mem_delete(tcp_c->mem, tcp_c->tcp_connections);
 1769|    196|    mem_delete(tcp_c->mem, tcp_c->connections);
 1770|    196|    mem_delete(tcp_c->mem, tcp_c);
 1771|    196|}
TCP_connection.c:get_tcp_connection:
  273|    333|{
  274|    333|    if (!tcp_connections_number_is_valid(tcp_c, tcp_connections_number)) {
  ------------------
  |  Branch (274:9): [True: 40, False: 293]
  ------------------
  275|     40|        return nullptr;
  ------------------
  |  |   63|     40|#define nullptr NULL
  ------------------
  276|     40|    }
  277|       |
  278|    293|    return &tcp_c->tcp_connections[tcp_connections_number];
  279|    333|}
TCP_connection.c:tcp_connections_number_is_valid:
  142|    333|{
  143|    333|    if ((uint32_t)tcp_connections_number >= tcp_c->tcp_connections_length) {
  ------------------
  |  Branch (143:9): [True: 0, False: 333]
  ------------------
  144|      0|        return false;
  145|      0|    }
  146|       |
  147|    333|    if (tcp_c->tcp_connections == nullptr) {
  ------------------
  |  |   63|    333|#define nullptr NULL
  ------------------
  |  Branch (147:9): [True: 0, False: 333]
  ------------------
  148|      0|        return false;
  149|      0|    }
  150|       |
  151|    333|    return tcp_c->tcp_connections[tcp_connections_number].status != TCP_CONN_NONE;
  ------------------
  |  |   29|    333|#define TCP_CONN_NONE 0
  ------------------
  152|    333|}
TCP_connection.c:find_tcp_connection_relay:
  648|     95|{
  649|    124|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (649:26): [True: 29, False: 95]
  ------------------
  650|     29|        const TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
  651|       |
  652|     29|        if (tcp_con != nullptr) {
  ------------------
  |  |   63|     29|#define nullptr NULL
  ------------------
  |  Branch (652:13): [True: 23, False: 6]
  ------------------
  653|     23|            if (tcp_con->status == TCP_CONN_SLEEPING) {
  ------------------
  |  |   36|     23|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (653:17): [True: 0, False: 23]
  ------------------
  654|      0|                if (pk_equal(tcp_con->relay_pk, relay_pk)) {
  ------------------
  |  Branch (654:21): [True: 0, False: 0]
  ------------------
  655|      0|                    return i;
  656|      0|                }
  657|     23|            } else {
  658|     23|                if (tcp_con->connection == nullptr) {
  ------------------
  |  |   63|     23|#define nullptr NULL
  ------------------
  |  Branch (658:21): [True: 0, False: 23]
  ------------------
  659|      0|                    LOGGER_ERROR(tcp_c->logger, "TCP connection is null for tcp_con");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  660|      0|                    return -1;
  661|      0|                }
  662|     23|                if (pk_equal(tcp_con_public_key(tcp_con->connection), relay_pk)) {
  ------------------
  |  Branch (662:21): [True: 0, False: 23]
  ------------------
  663|      0|                    return i;
  664|      0|                }
  665|     23|            }
  666|     23|        }
  667|     29|    }
  668|       |
  669|     95|    return -1;
  670|     95|}
TCP_connection.c:realloc_tcp_con:
  104|     89|{
  105|     89|    if (num == 0) {
  ------------------
  |  Branch (105:9): [True: 0, False: 89]
  ------------------
  106|      0|        mem_delete(mem, *array);
  107|      0|        *array = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  108|      0|        return 0;
  109|      0|    }
  110|       |
  111|     89|    TCP_con *temp_pointer = (TCP_con *)mem_vrealloc(mem, *array, num, sizeof(TCP_con));
  112|       |
  113|     89|    if (temp_pointer == nullptr) {
  ------------------
  |  |   63|     89|#define nullptr NULL
  ------------------
  |  Branch (113:9): [True: 17, False: 72]
  ------------------
  114|     17|        return -1;
  115|     17|    }
  116|       |
  117|     72|    *array = temp_pointer;
  118|       |
  119|     72|    return 0;
  120|     89|}
TCP_connection.c:add_tcp_relay_instance:
 1320|     95|{
 1321|     95|    IP_Port ipp_copy = *ip_port;
 1322|       |
 1323|     95|    if (net_family_is_tcp_ipv4(ipp_copy.ip.family)) {
  ------------------
  |  Branch (1323:9): [True: 0, False: 95]
  ------------------
 1324|      0|        ipp_copy.ip.family = net_family_ipv4();
 1325|     95|    } else if (net_family_is_tcp_ipv6(ipp_copy.ip.family)) {
  ------------------
  |  Branch (1325:16): [True: 0, False: 95]
  ------------------
 1326|      0|        ipp_copy.ip.family = net_family_ipv6();
 1327|      0|    }
 1328|       |
 1329|     95|    if (!net_family_is_ipv4(ipp_copy.ip.family) && !net_family_is_ipv6(ipp_copy.ip.family)) {
  ------------------
  |  Branch (1329:9): [True: 0, False: 95]
  |  Branch (1329:52): [True: 0, False: 0]
  ------------------
 1330|      0|        return -1;
 1331|      0|    }
 1332|       |
 1333|     95|    const int tcp_connections_number = create_tcp_connection(tcp_c);
 1334|       |
 1335|     95|    if (tcp_connections_number == -1) {
  ------------------
  |  Branch (1335:9): [True: 17, False: 78]
  ------------------
 1336|     17|        return -1;
 1337|     17|    }
 1338|       |
 1339|     78|    TCP_con *tcp_con = &tcp_c->tcp_connections[tcp_connections_number];
 1340|       |
 1341|     78|    tcp_con->connection = new_tcp_connection(
 1342|     78|                              tcp_c->logger, tcp_c->mem, tcp_c->mono_time, tcp_c->rng, tcp_c->ns, &ipp_copy,
 1343|     78|                              relay_pk, tcp_c->self_public_key, tcp_c->self_secret_key, &tcp_c->proxy_info, tcp_c->net_profile);
 1344|       |
 1345|     78|    if (tcp_con->connection == nullptr) {
  ------------------
  |  |   63|     78|#define nullptr NULL
  ------------------
  |  Branch (1345:9): [True: 15, False: 63]
  ------------------
 1346|     15|        return -1;
 1347|     15|    }
 1348|       |
 1349|     63|    tcp_con->status = TCP_CONN_VALID;
  ------------------
  |  |   30|     63|#define TCP_CONN_VALID 1
  ------------------
 1350|       |
 1351|     63|    return tcp_connections_number;
 1352|     78|}
TCP_connection.c:create_tcp_connection:
  184|     95|{
  185|    118|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (185:26): [True: 29, False: 89]
  ------------------
  186|     29|        if (tcp_c->tcp_connections[i].status == TCP_CONN_NONE) {
  ------------------
  |  |   29|     29|#define TCP_CONN_NONE 0
  ------------------
  |  Branch (186:13): [True: 6, False: 23]
  ------------------
  187|      6|            return i;
  188|      6|        }
  189|     29|    }
  190|       |
  191|     89|    int id = -1;
  192|       |
  193|     89|    if (realloc_tcp_con(tcp_c->mem, &tcp_c->tcp_connections, tcp_c->tcp_connections_length + 1) == 0) {
  ------------------
  |  Branch (193:9): [True: 72, False: 17]
  ------------------
  194|     72|        id = tcp_c->tcp_connections_length;
  195|     72|        ++tcp_c->tcp_connections_length;
  196|     72|        tcp_c->tcp_connections[id] = empty_tcp_con;
  197|     72|    }
  198|       |
  199|     89|    return id;
  200|     95|}
TCP_connection.c:do_tcp_conns:
 1655|     82|{
 1656|    186|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
  ------------------
  |  Branch (1656:26): [True: 104, False: 82]
  ------------------
 1657|    104|        TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1658|    104|        if (tcp_con == nullptr) {
  ------------------
  |  |   63|    104|#define nullptr NULL
  ------------------
  |  Branch (1658:13): [True: 16, False: 88]
  ------------------
 1659|     16|            continue;
 1660|     16|        }
 1661|       |
 1662|     88|        if (tcp_con->status != TCP_CONN_SLEEPING) {
  ------------------
  |  |   36|     88|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (1662:13): [True: 88, False: 0]
  ------------------
 1663|     88|            if (tcp_con->connection == nullptr) {
  ------------------
  |  |   63|     88|#define nullptr NULL
  ------------------
  |  Branch (1663:17): [True: 0, False: 88]
  ------------------
 1664|      0|                LOGGER_ERROR(logger, "TCP connection is null for tcp_con");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1665|      0|                continue;
 1666|      0|            }
 1667|     88|            do_tcp_connection(logger, tcp_c->mono_time, tcp_con->connection, userdata);
 1668|       |
 1669|       |            /* callbacks can change TCP connection address. */
 1670|     88|            tcp_con = get_tcp_connection(tcp_c, i);
 1671|       |
 1672|       |            // Make sure the TCP connection wasn't dropped in any of the callbacks.
 1673|     88|            assert(tcp_con != nullptr);
  ------------------
  |  Branch (1673:13): [True: 88, False: 0]
  ------------------
 1674|       |
 1675|     88|            if (tcp_con->connection == nullptr) {
  ------------------
  |  |   63|     88|#define nullptr NULL
  ------------------
  |  Branch (1675:17): [True: 0, False: 88]
  ------------------
 1676|      0|                LOGGER_ERROR(logger, "TCP connection is null for tcp_con");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1677|      0|                continue;
 1678|      0|            }
 1679|     88|            if (tcp_con_status(tcp_con->connection) == TCP_CLIENT_DISCONNECTED) {
  ------------------
  |  Branch (1679:17): [True: 0, False: 88]
  ------------------
 1680|      0|                if (tcp_con->status == TCP_CONN_CONNECTED) {
  ------------------
  |  |   33|      0|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (1680:21): [True: 0, False: 0]
  ------------------
 1681|      0|                    reconnect_tcp_relay_connection(tcp_c, i);
 1682|      0|                } else {
 1683|      0|                    kill_tcp_relay_connection(tcp_c, i);
 1684|      0|                }
 1685|       |
 1686|      0|                continue;
 1687|      0|            }
 1688|       |
 1689|     88|            if (tcp_con->connection == nullptr) {
  ------------------
  |  |   63|     88|#define nullptr NULL
  ------------------
  |  Branch (1689:17): [True: 0, False: 88]
  ------------------
 1690|      0|                LOGGER_ERROR(logger, "TCP connection is null for tcp_con");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1691|      0|                continue;
 1692|      0|            }
 1693|     88|            if (tcp_con->status == TCP_CONN_VALID && tcp_con_status(tcp_con->connection) == TCP_CLIENT_CONFIRMED) {
  ------------------
  |  |   30|    176|#define TCP_CONN_VALID 1
  ------------------
  |  Branch (1693:17): [True: 88, False: 0]
  |  Branch (1693:54): [True: 0, False: 88]
  ------------------
 1694|      0|                tcp_relay_on_online(tcp_c, i);
 1695|      0|            }
 1696|       |
 1697|     88|            if (tcp_con->status == TCP_CONN_CONNECTED
  ------------------
  |  |   33|    176|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (1697:17): [True: 0, False: 88]
  ------------------
 1698|      0|                    && !tcp_con->onion && tcp_con->lock_count > 0
  ------------------
  |  Branch (1698:24): [True: 0, False: 0]
  |  Branch (1698:43): [True: 0, False: 0]
  ------------------
 1699|      0|                    && tcp_con->lock_count == tcp_con->sleep_count
  ------------------
  |  Branch (1699:24): [True: 0, False: 0]
  ------------------
 1700|      0|                    && mono_time_is_timeout(tcp_c->mono_time, tcp_con->connected_time, TCP_CONNECTION_ANNOUNCE_TIMEOUT)) {
  ------------------
  |  |   45|      0|#define TCP_CONNECTION_ANNOUNCE_TIMEOUT TCP_CONNECTION_TIMEOUT
  |  |  ------------------
  |  |  |  |   29|      0|#define TCP_CONNECTION_TIMEOUT 10
  |  |  ------------------
  ------------------
  |  Branch (1700:24): [True: 0, False: 0]
  ------------------
 1701|      0|                sleep_tcp_relay_connection(tcp_c, i);
 1702|      0|            }
 1703|     88|        }
 1704|       |
 1705|     88|        if (tcp_con->status == TCP_CONN_SLEEPING && tcp_con->unsleep) {
  ------------------
  |  |   36|    176|#define TCP_CONN_SLEEPING 3
  ------------------
  |  Branch (1705:13): [True: 0, False: 88]
  |  Branch (1705:53): [True: 0, False: 0]
  ------------------
 1706|      0|            unsleep_tcp_relay_connection(tcp_c, i);
 1707|      0|        }
 1708|     88|    }
 1709|     82|}
TCP_connection.c:kill_nonused_tcp:
 1712|     82|{
 1713|     82|    if (tcp_c == nullptr) {
  ------------------
  |  |   63|     82|#define nullptr NULL
  ------------------
  |  Branch (1713:9): [True: 0, False: 82]
  ------------------
 1714|      0|        return;
 1715|      0|    }
 1716|       |
 1717|     82|    if (tcp_c->tcp_connections_length <= RECOMMENDED_FRIEND_TCP_CONNECTIONS) {
  ------------------
  |  |   50|     82|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  ------------------
  |  |  |  |   42|     82|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  ------------------
  ------------------
  |  Branch (1717:9): [True: 82, False: 0]
  ------------------
 1718|     82|        return;
 1719|     82|    }
 1720|       |
 1721|      0|    const uint32_t num_online = tcp_connected_relays_count(tcp_c);
 1722|       |
 1723|      0|    if (num_online <= RECOMMENDED_FRIEND_TCP_CONNECTIONS) {
  ------------------
  |  |   50|      0|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  ------------------
  |  |  |  |   42|      0|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  ------------------
  ------------------
  |  Branch (1723:9): [True: 0, False: 0]
  ------------------
 1724|      0|        return;
 1725|      0|    }
 1726|       |
 1727|      0|    const uint32_t max_kill_count = num_online - RECOMMENDED_FRIEND_TCP_CONNECTIONS;
  ------------------
  |  |   50|      0|#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)
  |  |  ------------------
  |  |  |  |   42|      0|#define MAX_FRIEND_TCP_CONNECTIONS 6
  |  |  ------------------
  ------------------
 1728|      0|    uint32_t kill_count = 0;
 1729|       |
 1730|      0|    for (uint32_t i = 0; i < tcp_c->tcp_connections_length && kill_count < max_kill_count; ++i) {
  ------------------
  |  Branch (1730:26): [True: 0, False: 0]
  |  Branch (1730:63): [True: 0, False: 0]
  ------------------
 1731|      0|        const TCP_con *tcp_con = get_tcp_connection(tcp_c, i);
 1732|       |
 1733|      0|        if (tcp_con == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1733:13): [True: 0, False: 0]
  ------------------
 1734|      0|            continue;
 1735|      0|        }
 1736|       |
 1737|      0|        if (tcp_con->status == TCP_CONN_CONNECTED) {
  ------------------
  |  |   33|      0|#define TCP_CONN_CONNECTED 2
  ------------------
  |  Branch (1737:13): [True: 0, False: 0]
  ------------------
 1738|      0|            if (tcp_con->onion || tcp_con->lock_count > 0) {  // connection is in use so we skip it
  ------------------
  |  Branch (1738:17): [True: 0, False: 0]
  |  Branch (1738:35): [True: 0, False: 0]
  ------------------
 1739|      0|                continue;
 1740|      0|            }
 1741|       |
 1742|      0|            if (mono_time_is_timeout(tcp_c->mono_time, tcp_con->connected_time, TCP_CONNECTION_ANNOUNCE_TIMEOUT)) {
  ------------------
  |  |   45|      0|#define TCP_CONNECTION_ANNOUNCE_TIMEOUT TCP_CONNECTION_TIMEOUT
  |  |  ------------------
  |  |  |  |   29|      0|#define TCP_CONNECTION_TIMEOUT 10
  |  |  ------------------
  ------------------
  |  Branch (1742:17): [True: 0, False: 0]
  ------------------
 1743|      0|                kill_tcp_relay_connection(tcp_c, i);
 1744|      0|                ++kill_count;
 1745|      0|            }
 1746|      0|        }
 1747|      0|    }
 1748|      0|}

tcp_server_public_key:
  104|     36|{
  105|     36|    return tcp_server->public_key;
  106|     36|}
new_tcp_server:
  934|    138|{
  935|    138|    if (num_sockets == 0 || ports == nullptr) {
  ------------------
  |  |   63|    138|#define nullptr NULL
  ------------------
  |  Branch (935:9): [True: 0, False: 138]
  |  Branch (935:29): [True: 0, False: 138]
  ------------------
  936|      0|        LOGGER_ERROR(logger, "no sockets");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  937|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  938|      0|    }
  939|       |
  940|    138|    if (ns == nullptr) {
  ------------------
  |  |   63|    138|#define nullptr NULL
  ------------------
  |  Branch (940:9): [True: 0, False: 138]
  ------------------
  941|      0|        LOGGER_ERROR(logger, "NULL network");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  942|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  943|      0|    }
  944|       |
  945|    138|    TCP_Server *temp = (TCP_Server *)mem_alloc(mem, sizeof(TCP_Server));
  946|       |
  947|    138|    if (temp == nullptr) {
  ------------------
  |  |   63|    138|#define nullptr NULL
  ------------------
  |  Branch (947:9): [True: 1, False: 137]
  ------------------
  948|      1|        LOGGER_ERROR(logger, "TCP server allocation failed");
  ------------------
  |  |   80|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  949|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  950|      1|    }
  951|       |
  952|    137|    Net_Profile *np = netprof_new(logger, mem);
  953|       |
  954|    137|    if (np == nullptr) {
  ------------------
  |  |   63|    137|#define nullptr NULL
  ------------------
  |  Branch (954:9): [True: 1, False: 136]
  ------------------
  955|      1|        mem_delete(mem, temp);
  956|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  957|      1|    }
  958|       |
  959|    136|    temp->net_profile = np;
  960|    136|    temp->logger = logger;
  961|    136|    temp->mem = mem;
  962|    136|    temp->ns = ns;
  963|    136|    temp->rng = rng;
  964|       |
  965|    136|    Socket *socks_listening = (Socket *)mem_valloc(mem, num_sockets, sizeof(Socket));
  966|       |
  967|    136|    if (socks_listening == nullptr) {
  ------------------
  |  |   63|    136|#define nullptr NULL
  ------------------
  |  Branch (967:9): [True: 1, False: 135]
  ------------------
  968|      1|        LOGGER_ERROR(logger, "socket allocation failed");
  ------------------
  |  |   80|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      1|    do {                                                                         \
  |  |  |  |   70|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 1, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      1|        }                                                                        \
  |  |  |  |   73|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  969|      1|        netprof_kill(mem, temp->net_profile);
  970|      1|        mem_delete(mem, temp);
  971|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  972|      1|    }
  973|       |
  974|    135|    temp->socks_listening = socks_listening;
  975|       |
  976|    135|#ifdef TCP_SERVER_USE_EPOLL
  977|    135|    temp->efd = epoll_create1(EPOLL_CLOEXEC);
  978|       |
  979|    135|    if (temp->efd == -1) {
  ------------------
  |  Branch (979:9): [True: 0, False: 135]
  ------------------
  980|      0|        LOGGER_ERROR(logger, "epoll initialisation failed");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  981|      0|        netprof_kill(mem, temp->net_profile);
  982|      0|        mem_delete(mem, socks_listening);
  983|      0|        mem_delete(mem, temp);
  984|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  985|      0|    }
  986|       |
  987|    135|#endif /* TCP_SERVER_USE_EPOLL */
  988|       |
  989|    135|    const Family family = ipv6_enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (989:27): [True: 135, False: 0]
  ------------------
  990|       |
  991|    270|    for (uint32_t i = 0; i < num_sockets; ++i) {
  ------------------
  |  Branch (991:26): [True: 135, False: 135]
  ------------------
  992|    135|        const Socket sock = new_listening_tcp_socket(logger, mem, ns, family, ports[i]);
  993|       |
  994|    135|        if (!sock_valid(sock)) {
  ------------------
  |  Branch (994:13): [True: 0, False: 135]
  ------------------
  995|      0|            continue;
  996|      0|        }
  997|       |
  998|    135|#ifdef TCP_SERVER_USE_EPOLL
  999|    135|        struct epoll_event ev;
 1000|       |
 1001|    135|        ev.events = EPOLLIN | EPOLLET;
 1002|    135|        ev.data.u64 = net_socket_to_native(sock) | ((uint64_t)TCP_SOCKET_LISTENING << 32);
  ------------------
  |  |   35|    135|#define TCP_SOCKET_LISTENING 0
  ------------------
 1003|       |
 1004|    135|        if (epoll_ctl(temp->efd, EPOLL_CTL_ADD, net_socket_to_native(sock), &ev) == -1) {
  ------------------
  |  Branch (1004:13): [True: 99, False: 36]
  ------------------
 1005|     99|            continue;
 1006|     99|        }
 1007|       |
 1008|     36|#endif /* TCP_SERVER_USE_EPOLL */
 1009|       |
 1010|     36|        temp->socks_listening[temp->num_listening_socks] = sock;
 1011|     36|        ++temp->num_listening_socks;
 1012|     36|    }
 1013|       |
 1014|    135|    if (temp->num_listening_socks == 0) {
  ------------------
  |  Branch (1014:9): [True: 99, False: 36]
  ------------------
 1015|     99|        netprof_kill(mem, temp->net_profile);
 1016|     99|        mem_delete(mem, temp->socks_listening);
 1017|     99|        mem_delete(mem, temp);
 1018|     99|        return nullptr;
  ------------------
  |  |   63|     99|#define nullptr NULL
  ------------------
 1019|     99|    }
 1020|       |
 1021|     36|    if (onion != nullptr) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (1021:9): [True: 36, False: 0]
  ------------------
 1022|     36|        temp->onion = onion;
 1023|     36|        set_callback_handle_recv_1(onion, &handle_onion_recv_1, temp);
 1024|     36|    }
 1025|       |
 1026|     36|    if (forwarding != nullptr) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (1026:9): [True: 36, False: 0]
  ------------------
 1027|     36|        temp->forwarding = forwarding;
 1028|     36|        set_callback_forward_reply(forwarding, &handle_forward_reply_tcp, temp);
 1029|     36|    }
 1030|       |
 1031|     36|    memcpy(temp->secret_key, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   49|     36|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
 1032|     36|    crypto_derive_public_key(temp->public_key, temp->secret_key);
 1033|       |
 1034|     36|    bs_list_init(&temp->accepted_key_list, mem, CRYPTO_PUBLIC_KEY_SIZE, 8, memcmp);
  ------------------
  |  |   44|     36|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1035|       |
 1036|     36|    return temp;
 1037|    135|}
do_tcp_server:
 1360|     71|{
 1361|     71|#ifdef TCP_SERVER_USE_EPOLL
 1362|     71|    do_tcp_epoll(tcp_server, mono_time);
 1363|       |
 1364|       |#else
 1365|       |    do_tcp_accept_new(tcp_server);
 1366|       |    do_tcp_incoming(tcp_server);
 1367|       |    do_tcp_unconfirmed(tcp_server, mono_time);
 1368|       |#endif /* TCP_SERVER_USE_EPOLL */
 1369|       |
 1370|     71|    do_tcp_confirmed(tcp_server, mono_time);
 1371|     71|}
kill_tcp_server:
 1374|     36|{
 1375|     36|    if (tcp_server == nullptr) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (1375:9): [True: 0, False: 36]
  ------------------
 1376|      0|        return;
 1377|      0|    }
 1378|       |
 1379|     72|    for (uint32_t i = 0; i < tcp_server->num_listening_socks; ++i) {
  ------------------
  |  Branch (1379:26): [True: 36, False: 36]
  ------------------
 1380|     36|        kill_sock(tcp_server->ns, tcp_server->socks_listening[i]);
 1381|     36|    }
 1382|       |
 1383|     36|    if (tcp_server->onion != nullptr) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (1383:9): [True: 36, False: 0]
  ------------------
 1384|     36|        set_callback_handle_recv_1(tcp_server->onion, nullptr, nullptr);
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
                      set_callback_handle_recv_1(tcp_server->onion, nullptr, nullptr);
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
 1385|     36|    }
 1386|       |
 1387|     36|    if (tcp_server->forwarding != nullptr) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (1387:9): [True: 36, False: 0]
  ------------------
 1388|     36|        set_callback_forward_reply(tcp_server->forwarding, nullptr, nullptr);
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
                      set_callback_forward_reply(tcp_server->forwarding, nullptr, nullptr);
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
 1389|     36|    }
 1390|       |
 1391|     36|    bs_list_free(&tcp_server->accepted_key_list);
 1392|       |
 1393|     36|#ifdef TCP_SERVER_USE_EPOLL
 1394|     36|    close(tcp_server->efd);
 1395|     36|#endif /* TCP_SERVER_USE_EPOLL */
 1396|       |
 1397|  9.25k|    for (uint32_t i = 0; i < MAX_INCOMING_CONNECTIONS; ++i) {
  ------------------
  |  |   31|  9.25k|#define MAX_INCOMING_CONNECTIONS 256
  ------------------
  |  Branch (1397:26): [True: 9.21k, False: 36]
  ------------------
 1398|  9.21k|        wipe_secure_connection(&tcp_server->incoming_connection_queue[i]);
 1399|  9.21k|        wipe_secure_connection(&tcp_server->unconfirmed_connection_queue[i]);
 1400|  9.21k|    }
 1401|       |
 1402|     36|    free_accepted_connection_array(tcp_server);
 1403|       |
 1404|     36|    crypto_memzero(tcp_server->secret_key, sizeof(tcp_server->secret_key));
 1405|       |
 1406|     36|    netprof_kill(tcp_server->mem, tcp_server->net_profile);
 1407|     36|    mem_delete(tcp_server->mem, tcp_server->socks_listening);
 1408|     36|    mem_delete(tcp_server->mem, tcp_server);
 1409|     36|}
TCP_server.c:new_listening_tcp_socket:
  899|    135|{
  900|    135|    const Socket sock = net_socket(ns, family, TOX_SOCK_STREAM, TOX_PROTO_TCP);
  ------------------
  |  |   70|    135|#define TOX_SOCK_STREAM 1
  ------------------
                  const Socket sock = net_socket(ns, family, TOX_SOCK_STREAM, TOX_PROTO_TCP);
  ------------------
  |  |   73|    135|#define TOX_PROTO_TCP 1
  ------------------
  901|       |
  902|    135|    if (!sock_valid(sock)) {
  ------------------
  |  Branch (902:9): [True: 0, False: 135]
  ------------------
  903|      0|        LOGGER_ERROR(logger, "TCP socket creation failed (family = %d)", family.value);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  904|      0|        return net_invalid_socket();
  905|      0|    }
  906|       |
  907|    135|    bool ok = set_socket_nonblock(ns, sock);
  908|       |
  909|    135|    if (ok && net_family_is_ipv6(family)) {
  ------------------
  |  Branch (909:9): [True: 135, False: 0]
  |  Branch (909:15): [True: 135, False: 0]
  ------------------
  910|    135|        ok = set_socket_dualstack(ns, sock);
  911|    135|    }
  912|       |
  913|    135|    if (ok) {
  ------------------
  |  Branch (913:9): [True: 135, False: 0]
  ------------------
  914|    135|        ok = set_socket_reuseaddr(ns, sock);
  915|    135|    }
  916|       |
  917|    135|    ok = ok && bind_to_port(ns, sock, family, port) && (net_listen(ns, sock, TCP_MAX_BACKLOG) == 0);
  ------------------
  |  |   33|    135|#define TCP_MAX_BACKLOG MAX_INCOMING_CONNECTIONS
  |  |  ------------------
  |  |  |  |   31|    135|#define MAX_INCOMING_CONNECTIONS 256
  |  |  ------------------
  ------------------
  |  Branch (917:10): [True: 135, False: 0]
  |  Branch (917:16): [True: 135, False: 0]
  |  Branch (917:56): [True: 135, False: 0]
  ------------------
  918|       |
  919|    135|    if (!ok) {
  ------------------
  |  Branch (919:9): [True: 0, False: 135]
  ------------------
  920|      0|        Net_Strerror error_str;
  921|      0|        LOGGER_WARNING(logger, "could not bind to TCP port %d (family = %d): %s",
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  922|      0|                       port, family.value, net_strerror(net_error(), &error_str));
  923|      0|        kill_sock(ns, sock);
  924|      0|        return net_invalid_socket();
  925|      0|    }
  926|       |
  927|    135|    LOGGER_DEBUG(logger, "successfully bound to TCP port %d", port);
  ------------------
  |  |   77|    135|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    135|    do {                                                                         \
  |  |  |  |   70|    135|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    270|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 135]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|    135|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 135]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  928|    135|    return sock;
  929|    135|}
TCP_server.c:do_tcp_epoll:
 1351|     71|{
 1352|     71|    while (tcp_epoll_process(tcp_server, mono_time)) {
  ------------------
  |  Branch (1352:12): [True: 0, False: 71]
  ------------------
 1353|       |        // Keep processing packets until there are no more FDs ready for reading.
 1354|      0|        continue;
 1355|      0|    }
 1356|     71|}
TCP_server.c:tcp_epoll_process:
 1226|     71|{
 1227|     71|#define MAX_EVENTS 16
 1228|     71|    struct epoll_event events[MAX_EVENTS];
 1229|     71|    const int nfds = epoll_wait(tcp_server->efd, events, MAX_EVENTS, 0);
  ------------------
  |  | 1227|     71|#define MAX_EVENTS 16
  ------------------
 1230|     71|#undef MAX_EVENTS
 1231|       |
 1232|     71|    for (int n = 0; n < nfds; ++n) {
  ------------------
  |  Branch (1232:21): [True: 0, False: 71]
  ------------------
 1233|      0|        const Socket sock = net_socket_from_native((int)(events[n].data.u64 & 0xFFFFFFFF));
 1234|      0|        const int status = (events[n].data.u64 >> 32) & 0xFF;
 1235|      0|        const int index = events[n].data.u64 >> 40;
 1236|       |
 1237|      0|        if ((events[n].events & EPOLLERR) != 0 || (events[n].events & EPOLLHUP) != 0 || (events[n].events & EPOLLRDHUP) != 0) {
  ------------------
  |  Branch (1237:13): [True: 0, False: 0]
  |  Branch (1237:51): [True: 0, False: 0]
  |  Branch (1237:89): [True: 0, False: 0]
  ------------------
 1238|      0|            switch (status) {
  ------------------
  |  Branch (1238:21): [True: 0, False: 0]
  ------------------
 1239|      0|                case TCP_SOCKET_LISTENING: {
  ------------------
  |  |   35|      0|#define TCP_SOCKET_LISTENING 0
  ------------------
  |  Branch (1239:17): [True: 0, False: 0]
  ------------------
 1240|       |                    // should never happen
 1241|      0|                    LOGGER_ERROR(tcp_server->logger, "connection %d was in listening state", index);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1242|      0|                    break;
 1243|      0|                }
 1244|       |
 1245|      0|                case TCP_SOCKET_INCOMING: {
  ------------------
  |  |   36|      0|#define TCP_SOCKET_INCOMING 1
  ------------------
  |  Branch (1245:17): [True: 0, False: 0]
  ------------------
 1246|      0|                    LOGGER_TRACE(tcp_server->logger, "incoming connection %d dropped", index);
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1247|      0|                    kill_tcp_secure_connection(&tcp_server->incoming_connection_queue[index]);
 1248|      0|                    break;
 1249|      0|                }
 1250|       |
 1251|      0|                case TCP_SOCKET_UNCONFIRMED: {
  ------------------
  |  |   37|      0|#define TCP_SOCKET_UNCONFIRMED 2
  ------------------
  |  Branch (1251:17): [True: 0, False: 0]
  ------------------
 1252|      0|                    LOGGER_TRACE(tcp_server->logger, "unconfirmed connection %d dropped", index);
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1253|      0|                    kill_tcp_secure_connection(&tcp_server->unconfirmed_connection_queue[index]);
 1254|      0|                    break;
 1255|      0|                }
 1256|       |
 1257|      0|                case TCP_SOCKET_CONFIRMED: {
  ------------------
  |  |   38|      0|#define TCP_SOCKET_CONFIRMED 3
  ------------------
  |  Branch (1257:17): [True: 0, False: 0]
  ------------------
 1258|      0|                    LOGGER_TRACE(tcp_server->logger, "confirmed connection %d dropped", index);
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1259|      0|                    kill_accepted(tcp_server, index);
 1260|      0|                    break;
 1261|      0|                }
 1262|      0|            }
 1263|       |
 1264|      0|            continue;
 1265|      0|        }
 1266|       |
 1267|      0|        if ((events[n].events & EPOLLIN) == 0) {
  ------------------
  |  Branch (1267:13): [True: 0, False: 0]
  ------------------
 1268|      0|            continue;
 1269|      0|        }
 1270|       |
 1271|      0|        switch (status) {
  ------------------
  |  Branch (1271:17): [True: 0, False: 0]
  ------------------
 1272|      0|            case TCP_SOCKET_LISTENING: {
  ------------------
  |  |   35|      0|#define TCP_SOCKET_LISTENING 0
  ------------------
  |  Branch (1272:13): [True: 0, False: 0]
  ------------------
 1273|       |                // socket is from socks_listening, accept connection
 1274|      0|                while (true) {
  ------------------
  |  Branch (1274:24): [True: 0, Folded]
  ------------------
 1275|      0|                    const Socket sock_new = net_accept(tcp_server->ns, sock);
 1276|       |
 1277|      0|                    if (!sock_valid(sock_new)) {
  ------------------
  |  Branch (1277:25): [True: 0, False: 0]
  ------------------
 1278|      0|                        break;
 1279|      0|                    }
 1280|       |
 1281|      0|                    const int index_new = accept_connection(tcp_server, sock_new);
 1282|       |
 1283|      0|                    if (index_new == -1) {
  ------------------
  |  Branch (1283:25): [True: 0, False: 0]
  ------------------
 1284|      0|                        continue;
 1285|      0|                    }
 1286|       |
 1287|      0|                    struct epoll_event ev;
 1288|       |
 1289|      0|                    ev.events = EPOLLIN | EPOLLET | EPOLLRDHUP;
 1290|       |
 1291|      0|                    ev.data.u64 = net_socket_to_native(sock_new) | ((uint64_t)TCP_SOCKET_INCOMING << 32) | ((uint64_t)index_new << 40);
  ------------------
  |  |   36|      0|#define TCP_SOCKET_INCOMING 1
  ------------------
 1292|       |
 1293|      0|                    if (epoll_ctl(tcp_server->efd, EPOLL_CTL_ADD, net_socket_to_native(sock_new), &ev) == -1) {
  ------------------
  |  Branch (1293:25): [True: 0, False: 0]
  ------------------
 1294|      0|                        LOGGER_DEBUG(tcp_server->logger, "new connection %d was dropped due to epoll error %d", index, net_error());
  ------------------
  |  |   77|      0|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1295|      0|                        kill_tcp_secure_connection(&tcp_server->incoming_connection_queue[index_new]);
 1296|      0|                        continue;
 1297|      0|                    }
 1298|      0|                }
 1299|       |
 1300|      0|                break;
 1301|      0|            }
 1302|       |
 1303|      0|            case TCP_SOCKET_INCOMING: {
  ------------------
  |  |   36|      0|#define TCP_SOCKET_INCOMING 1
  ------------------
  |  Branch (1303:13): [True: 0, False: 0]
  ------------------
 1304|      0|                const int index_new = do_incoming(tcp_server, index);
 1305|       |
 1306|      0|                if (index_new != -1) {
  ------------------
  |  Branch (1306:21): [True: 0, False: 0]
  ------------------
 1307|      0|                    LOGGER_TRACE(tcp_server->logger, "incoming connection %d was accepted as %d", index, index_new);
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1308|      0|                    events[n].events = EPOLLIN | EPOLLET | EPOLLRDHUP;
 1309|      0|                    events[n].data.u64 = net_socket_to_native(sock) | ((uint64_t)TCP_SOCKET_UNCONFIRMED << 32) | ((uint64_t)index_new << 40);
  ------------------
  |  |   37|      0|#define TCP_SOCKET_UNCONFIRMED 2
  ------------------
 1310|       |
 1311|      0|                    if (epoll_ctl(tcp_server->efd, EPOLL_CTL_MOD, net_socket_to_native(sock), &events[n]) == -1) {
  ------------------
  |  Branch (1311:25): [True: 0, False: 0]
  ------------------
 1312|      0|                        LOGGER_DEBUG(tcp_server->logger, "incoming connection %d was dropped due to epoll error %d", index, net_error());
  ------------------
  |  |   77|      0|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1313|      0|                        kill_tcp_secure_connection(&tcp_server->unconfirmed_connection_queue[index_new]);
 1314|      0|                        break;
 1315|      0|                    }
 1316|      0|                }
 1317|       |
 1318|      0|                break;
 1319|      0|            }
 1320|       |
 1321|      0|            case TCP_SOCKET_UNCONFIRMED: {
  ------------------
  |  |   37|      0|#define TCP_SOCKET_UNCONFIRMED 2
  ------------------
  |  Branch (1321:13): [True: 0, False: 0]
  ------------------
 1322|      0|                const int index_new = do_unconfirmed(tcp_server, mono_time, index);
 1323|       |
 1324|      0|                if (index_new != -1) {
  ------------------
  |  Branch (1324:21): [True: 0, False: 0]
  ------------------
 1325|      0|                    LOGGER_TRACE(tcp_server->logger, "unconfirmed connection %d was confirmed as %d", index, index_new);
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1326|      0|                    events[n].events = EPOLLIN | EPOLLET | EPOLLRDHUP;
 1327|      0|                    events[n].data.u64 = net_socket_to_native(sock) | ((uint64_t)TCP_SOCKET_CONFIRMED << 32) | ((uint64_t)index_new << 40);
  ------------------
  |  |   38|      0|#define TCP_SOCKET_CONFIRMED 3
  ------------------
 1328|       |
 1329|      0|                    if (epoll_ctl(tcp_server->efd, EPOLL_CTL_MOD, net_socket_to_native(sock), &events[n]) == -1) {
  ------------------
  |  Branch (1329:25): [True: 0, False: 0]
  ------------------
 1330|       |                        // remove from confirmed connections
 1331|      0|                        LOGGER_DEBUG(tcp_server->logger, "unconfirmed connection %d was dropped due to epoll error %d", index, net_error());
  ------------------
  |  |   77|      0|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1332|      0|                        kill_accepted(tcp_server, index_new);
 1333|      0|                        break;
 1334|      0|                    }
 1335|      0|                }
 1336|       |
 1337|      0|                break;
 1338|      0|            }
 1339|       |
 1340|      0|            case TCP_SOCKET_CONFIRMED: {
  ------------------
  |  |   38|      0|#define TCP_SOCKET_CONFIRMED 3
  ------------------
  |  Branch (1340:13): [True: 0, False: 0]
  ------------------
 1341|      0|                do_confirmed_recv(tcp_server, index);
 1342|      0|                break;
 1343|      0|            }
 1344|      0|        }
 1345|      0|    }
 1346|       |
 1347|     71|    return nfds > 0;
 1348|     71|}
TCP_server.c:do_tcp_confirmed:
 1169|     71|{
 1170|     71|#ifdef TCP_SERVER_USE_EPOLL
 1171|       |
 1172|     71|    if (tcp_server->last_run_pinged == mono_time_get(mono_time)) {
  ------------------
  |  Branch (1172:9): [True: 35, False: 36]
  ------------------
 1173|     35|        return;
 1174|     35|    }
 1175|       |
 1176|     36|    tcp_server->last_run_pinged = mono_time_get(mono_time);
 1177|     36|#endif /* TCP_SERVER_USE_EPOLL */
 1178|       |
 1179|     36|    for (uint32_t i = 0; i < tcp_server->size_accepted_connections; ++i) {
  ------------------
  |  Branch (1179:26): [True: 0, False: 36]
  ------------------
 1180|      0|        TCP_Secure_Connection *conn = &tcp_server->accepted_connection_array[i];
 1181|       |
 1182|      0|        if (conn->status != TCP_STATUS_CONFIRMED) {
  ------------------
  |  Branch (1182:13): [True: 0, False: 0]
  ------------------
 1183|      0|            continue;
 1184|      0|        }
 1185|       |
 1186|      0|        if (mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_FREQUENCY)) {
  ------------------
  |  |   61|      0|#define TCP_PING_FREQUENCY 30
  ------------------
  |  Branch (1186:13): [True: 0, False: 0]
  ------------------
 1187|      0|            uint8_t ping[1 + sizeof(uint64_t)];
 1188|      0|            ping[0] = TCP_PACKET_PING;
 1189|      0|            uint64_t ping_id = random_u64(conn->con.rng);
 1190|       |
 1191|      0|            if (ping_id == 0) {
  ------------------
  |  Branch (1191:17): [True: 0, False: 0]
  ------------------
 1192|      0|                ++ping_id;
 1193|      0|            }
 1194|       |
 1195|      0|            memcpy(ping + 1, &ping_id, sizeof(uint64_t));
 1196|      0|            const int ret = write_packet_tcp_secure_connection(tcp_server->logger, &conn->con, ping, sizeof(ping), true);
 1197|       |
 1198|      0|            if (ret == 1) {
  ------------------
  |  Branch (1198:17): [True: 0, False: 0]
  ------------------
 1199|      0|                conn->last_pinged = mono_time_get(mono_time);
 1200|      0|                conn->ping_id = ping_id;
 1201|      0|            } else {
 1202|      0|                if (mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_FREQUENCY + TCP_PING_TIMEOUT)) {
  ------------------
  |  |   61|      0|#define TCP_PING_FREQUENCY 30
  ------------------
                              if (mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_FREQUENCY + TCP_PING_TIMEOUT)) {
  ------------------
  |  |   62|      0|#define TCP_PING_TIMEOUT 10
  ------------------
  |  Branch (1202:21): [True: 0, False: 0]
  ------------------
 1203|      0|                    kill_accepted(tcp_server, i);
 1204|      0|                    continue;
 1205|      0|                }
 1206|      0|            }
 1207|      0|        }
 1208|       |
 1209|      0|        if (conn->ping_id != 0 && mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_TIMEOUT)) {
  ------------------
  |  |   62|      0|#define TCP_PING_TIMEOUT 10
  ------------------
  |  Branch (1209:13): [True: 0, False: 0]
  |  Branch (1209:35): [True: 0, False: 0]
  ------------------
 1210|      0|            kill_accepted(tcp_server, i);
 1211|      0|            continue;
 1212|      0|        }
 1213|       |
 1214|      0|        send_pending_data(tcp_server->logger, &conn->con);
 1215|       |
 1216|       |#ifndef TCP_SERVER_USE_EPOLL
 1217|       |
 1218|       |        do_confirmed_recv(tcp_server, i);
 1219|       |
 1220|       |#endif /* TCP_SERVER_USE_EPOLL */
 1221|      0|    }
 1222|     36|}
TCP_server.c:wipe_secure_connection:
  152|  18.4k|{
  153|  18.4k|    if (con->status != 0) {
  ------------------
  |  Branch (153:9): [True: 0, False: 18.4k]
  ------------------
  154|      0|        wipe_priority_list(con->con.mem, con->con.priority_queue_start);
  155|      0|        crypto_memzero(con, sizeof(TCP_Secure_Connection));
  156|      0|    }
  157|  18.4k|}
TCP_server.c:free_accepted_connection_array:
  166|     36|{
  167|     36|    if (tcp_server->accepted_connection_array == nullptr) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (167:9): [True: 36, False: 0]
  ------------------
  168|     36|        return;
  169|     36|    }
  170|       |
  171|      0|    for (uint32_t i = 0; i < tcp_server->size_accepted_connections; ++i) {
  ------------------
  |  Branch (171:26): [True: 0, False: 0]
  ------------------
  172|      0|        wipe_secure_connection(&tcp_server->accepted_connection_array[i]);
  173|      0|    }
  174|       |
  175|      0|    mem_delete(tcp_server->mem, tcp_server->accepted_connection_array);
  176|       |    tcp_server->accepted_connection_array = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  177|      0|    tcp_server->size_accepted_connections = 0;
  178|      0|}

new_announcements:
  625|    177|{
  626|    177|    if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   63|    354|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   63|    354|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
  ------------------
  |  |   63|    177|#define nullptr NULL
  ------------------
  |  Branch (626:9): [True: 0, False: 177]
  |  Branch (626:27): [True: 0, False: 177]
  |  Branch (626:51): [True: 0, False: 177]
  ------------------
  627|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  628|      0|    }
  629|       |
  630|    177|    Announcements *announce = (Announcements *)mem_alloc(mem, sizeof(Announcements));
  631|       |
  632|    177|    if (announce == nullptr) {
  ------------------
  |  |   63|    177|#define nullptr NULL
  ------------------
  |  Branch (632:9): [True: 1, False: 176]
  ------------------
  633|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  634|      1|    }
  635|       |
  636|    176|    announce->log = log;
  637|    176|    announce->mem = mem;
  638|    176|    announce->rng = rng;
  639|    176|    announce->forwarding = forwarding;
  640|    176|    announce->mono_time = mono_time;
  641|    176|    announce->dht = dht;
  642|    176|    announce->net = net;
  643|    176|    announce->public_key = dht_get_self_public_key(announce->dht);
  644|    176|    announce->secret_key = dht_get_self_secret_key(announce->dht);
  645|    176|    new_hmac_key(announce->rng, announce->hmac_key);
  646|    176|    Shared_Key_Cache *const shared_keys = shared_key_cache_new(log, mono_time, mem, announce->secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   30|    176|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const shared_keys = shared_key_cache_new(log, mono_time, mem, announce->secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   29|    176|#define MAX_KEYS_PER_SLOT 4
  ------------------
  647|    176|    if (shared_keys == nullptr) {
  ------------------
  |  |   63|    176|#define nullptr NULL
  ------------------
  |  Branch (647:9): [True: 2, False: 174]
  ------------------
  648|      2|        mem_delete(announce->mem, announce);
  649|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
  650|      2|    }
  651|    174|    announce->shared_keys = shared_keys;
  652|       |
  653|    174|    announce->start_time = mono_time_get(announce->mono_time);
  654|       |
  655|    174|    set_callback_forwarded_request(forwarding, forwarded_request_callback, announce);
  656|       |
  657|    174|    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, handle_dht_announce_request, announce);
  658|    174|    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, handle_dht_announce_request, announce);
  659|    174|    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, handle_dht_announce_request, announce);
  660|       |
  661|    174|    return announce;
  662|    176|}
kill_announcements:
  665|    195|{
  666|    195|    if (announce == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (666:9): [True: 21, False: 174]
  ------------------
  667|     21|        return;
  668|     21|    }
  669|       |
  670|    174|    set_callback_forwarded_request(announce->forwarding, nullptr, nullptr);
  ------------------
  |  |   63|    174|#define nullptr NULL
  ------------------
                  set_callback_forwarded_request(announce->forwarding, nullptr, nullptr);
  ------------------
  |  |   63|    174|#define nullptr NULL
  ------------------
  671|       |
  672|    174|    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    174|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    174|#define nullptr NULL
  ------------------
  673|    174|    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    174|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    174|#define nullptr NULL
  ------------------
  674|    174|    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    174|#define nullptr NULL
  ------------------
                  networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    174|#define nullptr NULL
  ------------------
  675|       |
  676|    174|    crypto_memzero(announce->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  125|    174|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  677|    174|    shared_key_cache_free(announce->shared_keys);
  678|       |
  679|  44.7k|    for (uint32_t i = 0; i < ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   67|  44.7k|#define ANNOUNCE_BUCKETS 32 // ANNOUNCE_BUCKETS = 2 ** ANNOUNCE_BUCKET_PREFIX_LENGTH
  ------------------
                  for (uint32_t i = 0; i < ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE; ++i) {
  ------------------
  |  |   65|  44.7k|#define ANNOUNCE_BUCKET_SIZE 8
  ------------------
  |  Branch (679:26): [True: 44.5k, False: 174]
  ------------------
  680|  44.5k|        mem_delete(announce->mem, announce->entries[i].data);
  681|  44.5k|    }
  682|       |
  683|    174|    mem_delete(announce->mem, announce);
  684|    174|}

bin_pack_obj_size:
   72|    164|{
   73|    164|    Bin_Pack bp;
   74|    164|    bin_pack_init(&bp, nullptr, 0);
  ------------------
  |  |   63|    164|#define nullptr NULL
  ------------------
   75|    164|    if (!callback(obj, logger, &bp)) {
  ------------------
  |  Branch (75:9): [True: 0, False: 164]
  ------------------
   76|      0|        return UINT32_MAX;
   77|      0|    }
   78|    164|    return bp.bytes_pos;
   79|    164|}
bin_pack_obj:
   82|    164|{
   83|    164|    Bin_Pack bp;
   84|    164|    bin_pack_init(&bp, buf, buf_size);
   85|    164|    return callback(obj, logger, &bp);
   86|    164|}
bin_pack_obj_array_b_size:
   89|     36|{
   90|     36|    Bin_Pack bp;
   91|     36|    bin_pack_init(&bp, nullptr, 0);
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
   92|     36|    if (arr == nullptr) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (92:9): [True: 0, False: 36]
  ------------------
   93|      0|        assert(arr_size == 0);
  ------------------
  |  Branch (93:9): [True: 0, False: 0]
  ------------------
   94|      0|    }
   95|     72|    for (uint32_t i = 0; i < arr_size; ++i) {
  ------------------
  |  Branch (95:26): [True: 36, False: 36]
  ------------------
   96|     36|        if (!callback(arr, i, logger, &bp)) {
  ------------------
  |  Branch (96:13): [True: 0, False: 36]
  ------------------
   97|      0|            return UINT32_MAX;
   98|      0|        }
   99|     36|    }
  100|     36|    return bp.bytes_pos;
  101|     36|}
bin_pack_obj_array_b:
  104|     36|{
  105|     36|    Bin_Pack bp;
  106|     36|    bin_pack_init(&bp, buf, buf_size);
  107|     36|    if (arr == nullptr) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (107:9): [True: 0, False: 36]
  ------------------
  108|      0|        assert(arr_size == 0);
  ------------------
  |  Branch (108:9): [True: 0, False: 0]
  ------------------
  109|      0|    }
  110|     72|    for (uint32_t i = 0; i < arr_size; ++i) {
  ------------------
  |  Branch (110:26): [True: 36, False: 36]
  ------------------
  111|     36|        if (!callback(arr, i, logger, &bp)) {
  ------------------
  |  Branch (111:13): [True: 0, False: 36]
  ------------------
  112|      0|            return false;
  113|      0|        }
  114|     36|    }
  115|     36|    return true;
  116|     36|}
bin_pack_obj_array:
  119|    328|{
  120|    328|    if (arr == nullptr) {
  ------------------
  |  |   63|    328|#define nullptr NULL
  ------------------
  |  Branch (120:9): [True: 328, False: 0]
  ------------------
  121|    328|        assert(arr_size == 0);
  ------------------
  |  Branch (121:9): [True: 328, False: 0]
  ------------------
  122|    328|        return bin_pack_array(bp, 0);
  123|    328|    }
  124|       |
  125|      0|    if (!bin_pack_array(bp, arr_size)) {
  ------------------
  |  Branch (125:9): [True: 0, False: 0]
  ------------------
  126|      0|        return false;
  127|      0|    }
  128|       |
  129|      0|    for (uint32_t i = 0; i < arr_size; ++i) {
  ------------------
  |  Branch (129:26): [True: 0, False: 0]
  ------------------
  130|      0|        if (!callback(arr, i, logger, bp)) {
  ------------------
  |  Branch (130:13): [True: 0, False: 0]
  ------------------
  131|      0|            return false;
  132|      0|        }
  133|      0|    }
  134|       |
  135|      0|    return true;
  136|      0|}
bin_pack_array:
  139|    328|{
  140|    328|    return cmp_write_array(&bp->ctx, size);
  141|    328|}
bin_pack_u08_b:
  205|    216|{
  206|    216|    return bp->ctx.write(&bp->ctx, &val, 1) == 1;
  207|    216|}
bin_pack_u16_b:
  210|     72|{
  211|     72|    return bin_pack_u08_b(bp, (val >> 8) & 0xff)
  ------------------
  |  Branch (211:12): [True: 72, False: 0]
  ------------------
  212|     72|           && bin_pack_u08_b(bp, val & 0xff);
  ------------------
  |  Branch (212:15): [True: 72, False: 0]
  ------------------
  213|     72|}
bin_pack_bin_b:
  228|    144|{
  229|    144|    if (length > 0 && data == nullptr) {
  ------------------
  |  |   63|    144|#define nullptr NULL
  ------------------
  |  Branch (229:9): [True: 144, False: 0]
  |  Branch (229:23): [True: 0, False: 144]
  ------------------
  230|      0|        return false;
  231|      0|    }
  232|       |
  233|    144|    return bp->ctx.write(&bp->ctx, data, length) == length;
  234|    144|}
bin_pack.c:bin_pack_init:
   64|    400|{
   65|    400|    bp->bytes = buf;
   66|    400|    bp->bytes_size = buf_size;
   67|    400|    bp->bytes_pos = 0;
   68|    400|    cmp_init(&bp->ctx, bp, null_reader, null_skipper, buf_writer);
   69|    400|}
bin_pack.c:buf_writer:
   35|    688|{
   36|    688|    const uint8_t *const bytes = (const uint8_t *)data;
   37|       |
   38|    688|    if (count == 0) {
  ------------------
  |  Branch (38:9): [True: 0, False: 688]
  ------------------
   39|      0|        return 0;
   40|      0|    }
   41|       |
   42|    688|    if (bytes == nullptr) {
  ------------------
  |  |   63|    688|#define nullptr NULL
  ------------------
  |  Branch (42:9): [True: 0, False: 688]
  ------------------
   43|      0|        return 0;
   44|      0|    }
   45|    688|    Bin_Pack *const bp = (Bin_Pack *)ctx->buf;
   46|    688|    assert(bp != nullptr);
  ------------------
  |  Branch (46:5): [True: 688, False: 0]
  ------------------
   47|    688|    const uint32_t new_pos = bp->bytes_pos + count;
   48|    688|    if (new_pos < bp->bytes_pos) {
  ------------------
  |  Branch (48:9): [True: 0, False: 688]
  ------------------
   49|       |        // 32 bit overflow.
   50|      0|        return 0;
   51|      0|    }
   52|    688|    if (bp->bytes != nullptr) {
  ------------------
  |  |   63|    688|#define nullptr NULL
  ------------------
  |  Branch (52:9): [True: 344, False: 344]
  ------------------
   53|    344|        if (new_pos > bp->bytes_size) {
  ------------------
  |  Branch (53:13): [True: 0, False: 344]
  ------------------
   54|       |            // Buffer too small.
   55|      0|            return 0;
   56|      0|        }
   57|    344|        memcpy(&bp->bytes[bp->bytes_pos], bytes, count);
   58|    344|    }
   59|    688|    bp->bytes_pos += count;
   60|    688|    return count;
   61|    688|}

crypto_memzero:
  115|  2.91k|{
  116|  2.91k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  117|  2.91k|    memzero((uint8_t *)data, length);
  118|       |#else
  119|       |    sodium_memzero(data, length);
  120|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  121|  2.91k|}
crypto_memlock:
  124|  1.30k|{
  125|  1.30k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  126|  1.30k|    return false;
  127|       |#else
  128|       |
  129|       |    return sodium_mlock(data, length) == 0;
  130|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  131|  1.30k|}
crypto_memunlock:
  134|  1.30k|{
  135|  1.30k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  136|  1.30k|    return false;
  137|       |#else
  138|       |
  139|       |    return sodium_munlock(data, length) == 0;
  140|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  141|  1.30k|}
pk_equal:
  144|    353|{
  145|    353|    return memcmp(pk1, pk2, CRYPTO_PUBLIC_KEY_SIZE) == 0;
  ------------------
  |  |   44|    353|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  146|    353|}
pk_copy:
  149|    407|{
  150|    407|    memcpy(dest, src, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|    407|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  151|    407|}
random_u32:
  183|    114|{
  184|    114|    uint32_t randnum;
  185|    114|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  186|    114|    return randnum;
  187|    114|}
random_u64:
  190|    435|{
  191|    435|    uint64_t randnum;
  192|    435|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  193|    435|    return randnum;
  194|    435|}
encrypt_precompute:
  224|     97|{
  225|     97|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  226|     97|    memcpy(shared_key, public_key, CRYPTO_SHARED_KEY_SIZE);
  ------------------
  |  |   54|     97|#define CRYPTO_SHARED_KEY_SIZE         32
  ------------------
  227|     97|    return 0;
  228|       |#else
  229|       |    return crypto_box_beforenm(shared_key, public_key, secret_key);
  230|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  231|     97|}
encrypt_data_symmetric:
  237|     76|{
  238|     76|    if (length == 0 || shared_key == nullptr || nonce == nullptr || plain == nullptr || encrypted == nullptr) {
  ------------------
  |  |   63|    152|#define nullptr NULL
  ------------------
                  if (length == 0 || shared_key == nullptr || nonce == nullptr || plain == nullptr || encrypted == nullptr) {
  ------------------
  |  |   63|    152|#define nullptr NULL
  ------------------
                  if (length == 0 || shared_key == nullptr || nonce == nullptr || plain == nullptr || encrypted == nullptr) {
  ------------------
  |  |   63|    152|#define nullptr NULL
  ------------------
                  if (length == 0 || shared_key == nullptr || nonce == nullptr || plain == nullptr || encrypted == nullptr) {
  ------------------
  |  |   63|     76|#define nullptr NULL
  ------------------
  |  Branch (238:9): [True: 0, False: 76]
  |  Branch (238:24): [True: 0, False: 76]
  |  Branch (238:49): [True: 0, False: 76]
  |  Branch (238:69): [True: 0, False: 76]
  |  Branch (238:89): [True: 0, False: 76]
  ------------------
  239|      0|        return -1;
  240|      0|    }
  241|       |
  242|     76|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  243|       |    // Don't encrypt anything.
  244|     76|    memcpy(encrypted, plain, length);
  245|       |    // Zero MAC to avoid uninitialized memory reads.
  246|     76|    memzero(encrypted + length, crypto_box_MACBYTES);
  247|       |#else
  248|       |
  249|       |    const size_t size_temp_plain = length + crypto_box_ZEROBYTES;
  250|       |    const size_t size_temp_encrypted = length + crypto_box_MACBYTES + crypto_box_BOXZEROBYTES;
  251|       |
  252|       |    uint8_t *temp_plain = crypto_malloc(mem, size_temp_plain);
  253|       |    uint8_t *temp_encrypted = crypto_malloc(mem, size_temp_encrypted);
  254|       |
  255|       |    if (temp_plain == nullptr || temp_encrypted == nullptr) {
  256|       |        crypto_free(mem, temp_plain, size_temp_plain);
  257|       |        crypto_free(mem, temp_encrypted, size_temp_encrypted);
  258|       |        return -1;
  259|       |    }
  260|       |
  261|       |    // crypto_box_afternm requires the entire range of the output array be
  262|       |    // initialised with something. It doesn't matter what it's initialised with,
  263|       |    // so we'll pick 0x00.
  264|       |    memzero(temp_encrypted, size_temp_encrypted);
  265|       |
  266|       |    memzero(temp_plain, crypto_box_ZEROBYTES);
  267|       |    // Pad the message with 32 0 bytes.
  268|       |    memcpy(temp_plain + crypto_box_ZEROBYTES, plain, length);
  269|       |
  270|       |    if (crypto_box_afternm(temp_encrypted, temp_plain, length + crypto_box_ZEROBYTES, nonce,
  271|       |                           shared_key) != 0) {
  272|       |        crypto_free(mem, temp_plain, size_temp_plain);
  273|       |        crypto_free(mem, temp_encrypted, size_temp_encrypted);
  274|       |        return -1;
  275|       |    }
  276|       |
  277|       |    // Unpad the encrypted message.
  278|       |    memcpy(encrypted, temp_encrypted + crypto_box_BOXZEROBYTES, length + crypto_box_MACBYTES);
  279|       |
  280|       |    crypto_free(mem, temp_plain, size_temp_plain);
  281|       |    crypto_free(mem, temp_encrypted, size_temp_encrypted);
  282|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  283|     76|    assert(length < INT32_MAX - crypto_box_MACBYTES);
  ------------------
  |  Branch (283:5): [True: 76, False: 0]
  ------------------
  284|     76|    return (int32_t)(length + crypto_box_MACBYTES);
  285|     76|}
random_nonce:
  416|    121|{
  417|       |    random_bytes(rng, nonce, crypto_box_NONCEBYTES);
  418|    121|}
new_symmetric_key:
  421|    573|{
  422|    573|    random_bytes(rng, key, CRYPTO_SYMMETRIC_KEY_SIZE);
  ------------------
  |  |   59|    573|#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE
  |  |  ------------------
  |  |  |  |   54|    573|#define CRYPTO_SHARED_KEY_SIZE         32
  |  |  ------------------
  ------------------
  423|    573|}
crypto_new_keypair:
  428|  1.04k|{
  429|  1.04k|    random_bytes(rng, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   49|  1.04k|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
  430|  1.04k|    memzero(public_key, CRYPTO_PUBLIC_KEY_SIZE);  // Make MSAN happy
  ------------------
  |  |   44|  1.04k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  431|  1.04k|    crypto_derive_public_key(public_key, secret_key);
  432|  1.04k|    return 0;
  433|  1.04k|}
crypto_derive_public_key:
  437|  1.27k|{
  438|  1.27k|    crypto_scalarmult_curve25519_base(public_key, secret_key);
  439|  1.27k|}
new_hmac_key:
  442|    538|{
  443|    538|    random_bytes(rng, key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  125|    538|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  444|    538|}
random_bytes:
  488|  2.82k|{
  489|  2.82k|    rng_bytes(rng, bytes, length);
  490|  2.82k|}

tox_events_free:
   44|     82|{
   45|     82|    if (events == nullptr) {
  ------------------
  |  |   63|     82|#define nullptr NULL
  ------------------
  |  Branch (45:9): [True: 82, False: 0]
  ------------------
   46|     82|        return;
   47|     82|    }
   48|       |
   49|      0|    for (uint32_t i = 0; i < events->events_size; ++i) {
  ------------------
  |  Branch (49:26): [True: 0, False: 0]
  ------------------
   50|      0|        tox_event_destruct(&events->events[i], events->mem);
   51|      0|    }
   52|       |
   53|      0|    mem_delete(events->mem, events->events);
   54|      0|    mem_delete(events->mem, events);
   55|      0|}

set_callback_forwarded_request:
  329|    348|{
  330|    348|    forwarding->forwarded_request_callback = function;
  331|    348|    forwarding->forwarded_request_callback_object = object;
  332|    348|}
set_callback_forward_reply:
  341|     72|{
  342|     72|    forwarding->forward_reply_callback = function;
  343|     72|    forwarding->forward_reply_callback_object = object;
  344|     72|}
new_forwarding:
  348|    195|{
  349|    195|    if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   63|    390|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   63|    390|#define nullptr NULL
  ------------------
                  if (log == nullptr || mono_time == nullptr || dht == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (349:9): [True: 0, False: 195]
  |  Branch (349:27): [True: 0, False: 195]
  |  Branch (349:51): [True: 0, False: 195]
  ------------------
  350|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  351|      0|    }
  352|       |
  353|    195|    Forwarding *forwarding = (Forwarding *)mem_alloc(mem, sizeof(Forwarding));
  354|       |
  355|    195|    if (forwarding == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (355:9): [True: 18, False: 177]
  ------------------
  356|     18|        return nullptr;
  ------------------
  |  |   63|     18|#define nullptr NULL
  ------------------
  357|     18|    }
  358|       |
  359|    177|    forwarding->log = log;
  360|    177|    forwarding->mem = mem;
  361|    177|    forwarding->rng = rng;
  362|    177|    forwarding->mono_time = mono_time;
  363|    177|    forwarding->dht = dht;
  364|    177|    forwarding->net = net;
  365|       |
  366|    177|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, &handle_forward_request, forwarding);
  367|    177|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, &handle_forward_reply, forwarding);
  368|    177|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, &handle_forwarding, forwarding);
  369|       |
  370|    177|    new_hmac_key(forwarding->rng, forwarding->hmac_key);
  371|       |
  372|    177|    return forwarding;
  373|    195|}
kill_forwarding:
  376|    195|{
  377|    195|    if (forwarding == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (377:9): [True: 18, False: 177]
  ------------------
  378|     18|        return;
  379|     18|    }
  380|       |
  381|    177|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    177|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    177|#define nullptr NULL
  ------------------
  382|    177|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, nullptr, nullptr);
  ------------------
  |  |   63|    177|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, nullptr, nullptr);
  ------------------
  |  |   63|    177|#define nullptr NULL
  ------------------
  383|    177|    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, nullptr, nullptr);
  ------------------
  |  |   63|    177|#define nullptr NULL
  ------------------
                  networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, nullptr, nullptr);
  ------------------
  |  |   63|    177|#define nullptr NULL
  ------------------
  384|       |
  385|    177|    crypto_memzero(forwarding->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  125|    177|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  386|       |
  387|    177|    mem_delete(forwarding->mem, forwarding);
  388|    177|}

set_global_status_callback:
  742|    132|{
  743|    132|    if (object != nullptr && global_status_callback == nullptr) {
  ------------------
  |  |   63|    264|#define nullptr NULL
  ------------------
                  if (object != nullptr && global_status_callback == nullptr) {
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
  |  Branch (743:9): [True: 66, False: 66]
  |  Branch (743:30): [True: 0, False: 66]
  ------------------
  744|      0|        LOGGER_ERROR(fr_c->logger, "non-null user data object but null callback");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  745|      0|        object = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  746|      0|    }
  747|       |
  748|    132|    fr_c->global_status_callback = global_status_callback;
  749|    132|    fr_c->global_status_callback_object = object;
  750|    132|}
set_friend_request_callback:
  842|     67|{
  843|     67|    fr_c->fr_request_callback = fr_request_callback;
  844|     67|    fr_c->fr_request_object = object;
  845|     67|    oniondata_registerhandler(fr_c->onion_c, CRYPTO_PACKET_FRIEND_REQ, fr_request_callback, object);
  ------------------
  |  |   69|     67|#define CRYPTO_PACKET_FRIEND_REQ    32  // Friend request crypto packet ID.
  ------------------
  846|     67|}
new_friend_connections:
  897|    192|{
  898|    192|    if (onion_c == nullptr) {
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
  |  Branch (898:9): [True: 0, False: 192]
  ------------------
  899|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  900|      0|    }
  901|       |
  902|    192|    Friend_Connections *const temp = (Friend_Connections *)mem_alloc(mem, sizeof(Friend_Connections));
  903|       |
  904|    192|    if (temp == nullptr) {
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
  |  Branch (904:9): [True: 1, False: 191]
  ------------------
  905|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  906|      1|    }
  907|       |
  908|    191|    temp->local_discovery_enabled = local_discovery_enabled;
  909|       |
  910|    191|    if (temp->local_discovery_enabled) {
  ------------------
  |  Branch (910:9): [True: 191, False: 0]
  ------------------
  911|    191|        temp->broadcast = lan_discovery_init(mem, ns);
  912|       |
  913|    191|        if (temp->broadcast == nullptr) {
  ------------------
  |  |   63|    191|#define nullptr NULL
  ------------------
  |  Branch (913:13): [True: 31, False: 160]
  ------------------
  914|     31|            LOGGER_ERROR(logger, "could not initialise LAN discovery");
  ------------------
  |  |   80|     31|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     31|    do {                                                                         \
  |  |  |  |   70|     31|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     62|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 31, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|     31|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|     31|        }                                                                        \
  |  |  |  |   73|     31|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 31]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  915|     31|            temp->local_discovery_enabled = false;
  916|     31|        }
  917|    191|    }
  918|       |
  919|    191|    temp->mono_time = mono_time;
  920|    191|    temp->mem = mem;
  921|    191|    temp->logger = logger;
  922|    191|    temp->dht = dht;
  923|    191|    temp->net = net;
  924|    191|    temp->net_crypto = net_crypto;
  925|    191|    temp->onion_c = onion_c;
  926|       |    // Don't include default port in port range
  927|    191|    temp->next_lan_port = TOX_PORTRANGE_FROM + 1;
  ------------------
  |  |   79|    191|#define TOX_PORTRANGE_FROM 33445
  ------------------
  928|       |
  929|    191|    new_connection_handler(temp->net_crypto, &handle_new_connections, temp);
  930|       |
  931|    191|    return temp;
  932|    192|}
do_friend_connections:
  962|     82|{
  963|     82|    const uint64_t temp_time = mono_time_get(fr_c->mono_time);
  964|       |
  965|     82|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (965:26): [True: 0, False: 82]
  ------------------
  966|      0|        Friend_Conn *const friend_con = get_conn(fr_c, i);
  967|       |
  968|      0|        if (friend_con != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (968:13): [True: 0, False: 0]
  ------------------
  969|      0|            if (friend_con->status == FRIENDCONN_STATUS_CONNECTING) {
  ------------------
  |  Branch (969:17): [True: 0, False: 0]
  ------------------
  970|      0|                if (friend_con->dht_pk_lastrecv + FRIEND_DHT_TIMEOUT < temp_time) {
  ------------------
  |  |   40|      0|#define FRIEND_DHT_TIMEOUT BAD_NODE_TIMEOUT
  |  |  ------------------
  |  |  |  |   57|      0|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   52|      0|#define PING_INTERVAL 60
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   55|      0|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   52|      0|#define PING_INTERVAL 60
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   56|      0|#define PING_ROUNDTRIP 2
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (970:21): [True: 0, False: 0]
  ------------------
  971|      0|                    if (friend_con->dht_lock_token > 0) {
  ------------------
  |  Branch (971:25): [True: 0, False: 0]
  ------------------
  972|      0|                        dht_delfriend(fr_c->dht, friend_con->dht_temp_pk, friend_con->dht_lock_token);
  973|      0|                        friend_con->dht_lock_token = 0;
  974|      0|                        memzero(friend_con->dht_temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  975|      0|                    }
  976|      0|                }
  977|       |
  978|      0|                if (friend_con->dht_ip_port_lastrecv + FRIEND_DHT_TIMEOUT < temp_time) {
  ------------------
  |  |   40|      0|#define FRIEND_DHT_TIMEOUT BAD_NODE_TIMEOUT
  |  |  ------------------
  |  |  |  |   57|      0|#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   52|      0|#define PING_INTERVAL 60
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   55|      0|#define PINGS_MISSED_NODE_GOES_BAD 1
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   52|      0|#define PING_INTERVAL 60
  |  |  |  |  ------------------
  |  |  |  |               #define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))
  |  |  |  |  ------------------
  |  |  |  |  |  |   56|      0|#define PING_ROUNDTRIP 2
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (978:21): [True: 0, False: 0]
  ------------------
  979|      0|                    friend_con->dht_ip_port.ip.family = net_family_unspec();
  980|      0|                }
  981|       |
  982|      0|                if (friend_con->dht_lock_token > 0) {
  ------------------
  |  Branch (982:21): [True: 0, False: 0]
  ------------------
  983|      0|                    if (friend_new_connection(fr_c, i) == 0) {
  ------------------
  |  Branch (983:25): [True: 0, False: 0]
  ------------------
  984|      0|                        set_direct_ip_port(fr_c->net_crypto, friend_con->crypt_connection_id, &friend_con->dht_ip_port, false);
  985|      0|                        connect_to_saved_tcp_relays(fr_c, i, MAX_FRIEND_TCP_CONNECTIONS / 2); /* Only fill it half up. */
  ------------------
  |  |   42|      0|#define MAX_FRIEND_TCP_CONNECTIONS 6
  ------------------
  986|      0|                    }
  987|      0|                }
  988|      0|            } else if (friend_con->status == FRIENDCONN_STATUS_CONNECTED) {
  ------------------
  |  Branch (988:24): [True: 0, False: 0]
  ------------------
  989|      0|                if (friend_con->ping_lastsent + FRIEND_PING_INTERVAL < temp_time) {
  ------------------
  |  |   34|      0|#define FRIEND_PING_INTERVAL 8
  ------------------
  |  Branch (989:21): [True: 0, False: 0]
  ------------------
  990|      0|                    send_ping(fr_c, i);
  991|      0|                }
  992|       |
  993|      0|                if (friend_con->share_relays_lastsent + SHARE_RELAYS_INTERVAL < temp_time) {
  ------------------
  |  |   48|      0|#define SHARE_RELAYS_INTERVAL (60 * 2)
  ------------------
  |  Branch (993:21): [True: 0, False: 0]
  ------------------
  994|      0|                    send_relays(fr_c, i);
  995|      0|                }
  996|       |
  997|      0|                if (friend_con->ping_lastrecv + FRIEND_CONNECTION_TIMEOUT < temp_time) {
  ------------------
  |  |   37|      0|#define FRIEND_CONNECTION_TIMEOUT (FRIEND_PING_INTERVAL * 4)
  |  |  ------------------
  |  |  |  |   34|      0|#define FRIEND_PING_INTERVAL 8
  |  |  ------------------
  ------------------
  |  Branch (997:21): [True: 0, False: 0]
  ------------------
  998|       |                    /* If we stopped receiving ping packets, kill it. */
  999|      0|                    crypto_kill(fr_c->net_crypto, friend_con->crypt_connection_id);
 1000|      0|                    friend_con->crypt_connection_id = -1;
 1001|      0|                    handle_status(fr_c, i, false, userdata); /* Going offline. */
 1002|      0|                }
 1003|      0|            }
 1004|      0|        }
 1005|      0|    }
 1006|       |
 1007|     82|    if (fr_c->local_discovery_enabled) {
  ------------------
  |  Branch (1007:9): [True: 67, False: 15]
  ------------------
 1008|     67|        lan_discovery(fr_c);
 1009|     67|    }
 1010|     82|}
kill_friend_connections:
 1014|    195|{
 1015|    195|    if (fr_c == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (1015:9): [True: 4, False: 191]
  ------------------
 1016|      4|        return;
 1017|      4|    }
 1018|       |
 1019|    191|    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
  ------------------
  |  Branch (1019:26): [True: 0, False: 191]
  ------------------
 1020|      0|        kill_friend_connection(fr_c, i);
 1021|      0|    }
 1022|       |
 1023|       |    // there might be allocated NONE connections
 1024|    191|    if (fr_c->conns != nullptr) {
  ------------------
  |  |   63|    191|#define nullptr NULL
  ------------------
  |  Branch (1024:9): [True: 0, False: 191]
  ------------------
 1025|      0|        mem_delete(fr_c->mem, fr_c->conns);
 1026|      0|    }
 1027|       |
 1028|    191|    lan_discovery_kill(fr_c->broadcast);
 1029|    191|    mem_delete(fr_c->mem, fr_c);
 1030|    191|}
friend_connection.c:lan_discovery:
  936|     67|{
  937|     67|    if (fr_c->last_lan_discovery + LAN_DISCOVERY_INTERVAL < mono_time_get(fr_c->mono_time)) {
  ------------------
  |  |   23|     67|#define LAN_DISCOVERY_INTERVAL         10
  ------------------
  |  Branch (937:9): [True: 37, False: 30]
  ------------------
  938|     37|        if (fr_c->broadcast == nullptr) {
  ------------------
  |  |   63|     37|#define nullptr NULL
  ------------------
  |  Branch (938:13): [True: 0, False: 37]
  ------------------
  939|      0|            return;
  940|      0|        }
  941|     37|        const uint16_t first = fr_c->next_lan_port;
  942|     37|        uint16_t last = first + PORTS_PER_DISCOVERY;
  ------------------
  |  |   29|     37|#define PORTS_PER_DISCOVERY 10
  ------------------
  943|     37|        last = last > TOX_PORTRANGE_TO ? TOX_PORTRANGE_TO : last;
  ------------------
  |  |   80|     37|#define TOX_PORTRANGE_TO   33545
  ------------------
                      last = last > TOX_PORTRANGE_TO ? TOX_PORTRANGE_TO : last;
  ------------------
  |  |   80|      0|#define TOX_PORTRANGE_TO   33545
  ------------------
  |  Branch (943:16): [True: 0, False: 37]
  ------------------
  944|       |
  945|       |        // Always send to default port
  946|     37|        lan_discovery_send(fr_c->net, fr_c->broadcast, dht_get_self_public_key(fr_c->dht),
  947|     37|                           net_htons(TOX_PORT_DEFAULT));
  ------------------
  |  |   81|     37|#define TOX_PORT_DEFAULT   TOX_PORTRANGE_FROM
  |  |  ------------------
  |  |  |  |   79|     37|#define TOX_PORTRANGE_FROM 33445
  |  |  ------------------
  ------------------
  948|       |
  949|       |        // And check some extra ports
  950|    407|        for (uint16_t port = first; port < last; ++port) {
  ------------------
  |  Branch (950:37): [True: 370, False: 37]
  ------------------
  951|    370|            lan_discovery_send(fr_c->net, fr_c->broadcast, dht_get_self_public_key(fr_c->dht), net_htons(port));
  952|    370|        }
  953|       |
  954|       |        // Don't include default port in port range
  955|     37|        fr_c->next_lan_port = last != TOX_PORTRANGE_TO ? last : TOX_PORTRANGE_FROM + 1;
  ------------------
  |  |   80|     37|#define TOX_PORTRANGE_TO   33545
  ------------------
                      fr_c->next_lan_port = last != TOX_PORTRANGE_TO ? last : TOX_PORTRANGE_FROM + 1;
  ------------------
  |  |   79|      0|#define TOX_PORTRANGE_FROM 33445
  ------------------
  |  Branch (955:31): [True: 37, False: 0]
  ------------------
  956|     37|        fr_c->last_lan_discovery = mono_time_get(fr_c->mono_time);
  957|     37|    }
  958|     67|}

set_nospam:
   54|     67|{
   55|     67|    fr->nospam = num;
   56|     67|}
callback_friendrequest:
   65|     67|{
   66|     67|    fr->handle_friendrequest = function;
   67|     67|    fr->handle_friendrequest_isset = 1;
   68|     67|    fr->handle_friendrequest_object = object;
   69|     67|}
set_filter_function:
   75|     67|{
   76|     67|    fr->filter_function = function;
   77|     67|    fr->filter_function_userdata = userdata;
   78|     67|}
friendreq_init:
  165|     67|{
  166|     67|    set_friend_request_callback(fr_c, &friendreq_handlepacket, fr);
  167|     67|}
friendreq_new:
  170|    216|{
  171|    216|    Friend_Requests *fr = (Friend_Requests *)mem_alloc(mem, sizeof(Friend_Requests));
  172|       |
  173|    216|    if (fr == nullptr) {
  ------------------
  |  |   63|    216|#define nullptr NULL
  ------------------
  |  Branch (173:9): [True: 1, False: 215]
  ------------------
  174|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  175|      1|    }
  176|       |
  177|    215|    fr->mem = mem;
  178|       |
  179|    215|    return fr;
  180|    216|}
friendreq_kill:
  183|    215|{
  184|    215|    if (fr == nullptr) {
  ------------------
  |  |   63|    215|#define nullptr NULL
  ------------------
  |  Branch (184:9): [True: 0, False: 215]
  ------------------
  185|      0|        return;
  186|      0|    }
  187|       |
  188|    215|    mem_delete(fr->mem, fr);
  189|    215|}

g_callback_group_invite:
 1810|     66|{
 1811|     66|    g_c->invite_callback = function;
 1812|     66|}
g_callback_group_connected:
 1816|     66|{
 1817|     66|    g_c->connected_callback = function;
 1818|     66|}
g_callback_group_message:
 1822|     66|{
 1823|     66|    g_c->message_callback = function;
 1824|     66|}
g_callback_peer_name:
 1831|     66|{
 1832|     66|    g_c->peer_name_callback = function;
 1833|     66|}
g_callback_peer_list_changed:
 1840|     66|{
 1841|     66|    g_c->peer_list_changed_callback = function;
 1842|     66|}
g_callback_group_title:
 1846|     66|{
 1847|     66|    g_c->title_callback = function;
 1848|     66|}
new_groupchats:
 3695|     67|{
 3696|     67|    if (m == nullptr) {
  ------------------
  |  |   63|     67|#define nullptr NULL
  ------------------
  |  Branch (3696:9): [True: 0, False: 67]
  ------------------
 3697|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3698|      0|    }
 3699|       |
 3700|     67|    Group_Chats *temp = (Group_Chats *)mem_alloc(mem, sizeof(Group_Chats));
 3701|       |
 3702|     67|    if (temp == nullptr) {
  ------------------
  |  |   63|     67|#define nullptr NULL
  ------------------
  |  Branch (3702:9): [True: 1, False: 66]
  ------------------
 3703|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 3704|      1|    }
 3705|       |
 3706|     66|    temp->mem = mem;
 3707|     66|    temp->mono_time = mono_time;
 3708|     66|    temp->m = m;
 3709|     66|    temp->fr_c = m->fr_c;
 3710|     66|    m_callback_conference_invite(m, &handle_friend_invite_packet);
 3711|       |
 3712|     66|    set_global_status_callback(m->fr_c, &g_handle_any_status, temp);
 3713|       |
 3714|     66|    return temp;
 3715|     67|}
do_groupchats:
 3719|     82|{
 3720|     82|    if (g_c == nullptr) {
  ------------------
  |  |   63|     82|#define nullptr NULL
  ------------------
  |  Branch (3720:9): [True: 0, False: 82]
  ------------------
 3721|      0|        return;
 3722|      0|    }
 3723|       |
 3724|     82|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3724:26): [True: 0, False: 82]
  ------------------
 3725|      0|        Group_c *g = get_group_c(g_c, i);
 3726|       |
 3727|      0|        if (g == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3727:13): [True: 0, False: 0]
  ------------------
 3728|      0|            continue;
 3729|      0|        }
 3730|       |
 3731|      0|        if (g->status == GROUPCHAT_STATUS_CONNECTED) {
  ------------------
  |  Branch (3731:13): [True: 0, False: 0]
  ------------------
 3732|      0|            connect_to_closest(g_c, i, userdata);
 3733|      0|            ping_groupchat(g_c, i);
 3734|      0|            groupchat_freeze_timedout(g_c, i, userdata);
 3735|      0|            clean_connections(g_c, g);
 3736|       |
 3737|      0|            if (g->need_send_name) {
  ------------------
  |  Branch (3737:17): [True: 0, False: 0]
  ------------------
 3738|      0|                group_name_send(g_c, i, g_c->m->name, g_c->m->name_length);
 3739|      0|                g->need_send_name = false;
 3740|      0|            }
 3741|      0|        }
 3742|      0|    }
 3743|       |
 3744|       |    // TODO(irungentoo):
 3745|     82|}
kill_groupchats:
 3749|     66|{
 3750|     66|    if (g_c == nullptr) {
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
  |  Branch (3750:9): [True: 0, False: 66]
  ------------------
 3751|      0|        return;
 3752|      0|    }
 3753|       |
 3754|     66|    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
  ------------------
  |  Branch (3754:26): [True: 0, False: 66]
  ------------------
 3755|      0|        del_groupchat(g_c, i, false);
 3756|      0|    }
 3757|       |
 3758|     66|    m_callback_conference_invite(g_c->m, nullptr);
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
 3759|     66|    set_global_status_callback(g_c->m->fr_c, nullptr, nullptr);
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
                  set_global_status_callback(g_c->m->fr_c, nullptr, nullptr);
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
 3760|       |    g_c->m->conferences_object = nullptr;
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
 3761|     66|    mem_delete(g_c->mem, g_c);
 3762|     66|}

new_gca_list:
  408|    196|{
  409|    196|    GC_Announces_List *announces_list = (GC_Announces_List *)mem_alloc(mem, sizeof(GC_Announces_List));
  410|       |
  411|    196|    if (announces_list == nullptr) {
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
  |  Branch (411:9): [True: 1, False: 195]
  ------------------
  412|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  413|      1|    }
  414|       |
  415|    195|    announces_list->mem = mem;
  416|       |
  417|    195|    return announces_list;
  418|    196|}
kill_gca:
  421|    195|{
  422|    195|    if (announces_list == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (422:9): [True: 0, False: 195]
  ------------------
  423|      0|        return;
  424|      0|    }
  425|       |
  426|    195|    GC_Announces *root = announces_list->root_announces;
  427|       |
  428|    195|    while (root != nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (428:12): [True: 0, False: 195]
  ------------------
  429|      0|        GC_Announces *next = root->next_announce;
  430|      0|        mem_delete(announces_list->mem, root);
  431|      0|        root = next;
  432|      0|    }
  433|       |
  434|    195|    mem_delete(announces_list->mem, announces_list);
  435|    195|}
do_gca:
  444|     82|{
  445|     82|    if (gc_announces_list == nullptr) {
  ------------------
  |  |   63|     82|#define nullptr NULL
  ------------------
  |  Branch (445:9): [True: 0, False: 82]
  ------------------
  446|      0|        return;
  447|      0|    }
  448|       |
  449|     82|    if (!mono_time_is_timeout(mono_time, gc_announces_list->last_timeout_check, GCA_DO_GCA_TIMEOUT)) {
  ------------------
  |  |  441|     82|#define GCA_DO_GCA_TIMEOUT 1
  ------------------
  |  Branch (449:9): [True: 35, False: 47]
  ------------------
  450|     35|        return;
  451|     35|    }
  452|       |
  453|     47|    gc_announces_list->last_timeout_check = mono_time_get(mono_time);
  454|       |
  455|     47|    GC_Announces *announces = gc_announces_list->root_announces;
  456|       |
  457|     47|    while (announces != nullptr) {
  ------------------
  |  |   63|     47|#define nullptr NULL
  ------------------
  |  Branch (457:12): [True: 0, False: 47]
  ------------------
  458|      0|        if (mono_time_is_timeout(mono_time, announces->last_announce_received_timestamp, GCA_ANNOUNCE_SAVE_TIMEOUT)) {
  ------------------
  |  |  438|      0|#define GCA_ANNOUNCE_SAVE_TIMEOUT 30
  ------------------
  |  Branch (458:13): [True: 0, False: 0]
  ------------------
  459|      0|            GC_Announces *to_delete = announces;
  460|      0|            announces = announces->next_announce;
  461|      0|            remove_announces(gc_announces_list, to_delete);
  462|      0|            continue;
  463|      0|        }
  464|       |
  465|      0|        announces = announces->next_announce;
  466|      0|    }
  467|     47|}

gc_callback_message:
 6453|     66|{
 6454|     66|    GC_Session *c = m->group_handler;
 6455|     66|    c->message = function;
 6456|     66|}
gc_callback_private_message:
 6459|     66|{
 6460|     66|    GC_Session *c = m->group_handler;
 6461|     66|    c->private_message = function;
 6462|     66|}
gc_callback_custom_packet:
 6465|     66|{
 6466|     66|    GC_Session *c = m->group_handler;
 6467|     66|    c->custom_packet = function;
 6468|     66|}
gc_callback_custom_private_packet:
 6471|     66|{
 6472|     66|    GC_Session *c = m->group_handler;
 6473|     66|    c->custom_private_packet = function;
 6474|     66|}
gc_callback_moderation:
 6477|     66|{
 6478|     66|    GC_Session *c = m->group_handler;
 6479|     66|    c->moderation = function;
 6480|     66|}
gc_callback_nick_change:
 6483|     66|{
 6484|     66|    GC_Session *c = m->group_handler;
 6485|     66|    c->nick_change = function;
 6486|     66|}
gc_callback_status_change:
 6489|     66|{
 6490|     66|    GC_Session *c = m->group_handler;
 6491|     66|    c->status_change = function;
 6492|     66|}
gc_callback_topic_change:
 6495|     66|{
 6496|     66|    GC_Session *c = m->group_handler;
 6497|     66|    c->topic_change = function;
 6498|     66|}
gc_callback_topic_lock:
 6501|     66|{
 6502|     66|    GC_Session *c = m->group_handler;
 6503|     66|    c->topic_lock = function;
 6504|     66|}
gc_callback_voice_state:
 6507|     66|{
 6508|     66|    GC_Session *c = m->group_handler;
 6509|     66|    c->voice_state = function;
 6510|     66|}
gc_callback_peer_limit:
 6513|     66|{
 6514|     66|    GC_Session *c = m->group_handler;
 6515|     66|    c->peer_limit = function;
 6516|     66|}
gc_callback_privacy_state:
 6519|     66|{
 6520|     66|    GC_Session *c = m->group_handler;
 6521|     66|    c->privacy_state = function;
 6522|     66|}
gc_callback_password:
 6525|     66|{
 6526|     66|    GC_Session *c = m->group_handler;
 6527|     66|    c->password = function;
 6528|     66|}
gc_callback_peer_join:
 6531|     66|{
 6532|     66|    GC_Session *c = m->group_handler;
 6533|     66|    c->peer_join = function;
 6534|     66|}
gc_callback_peer_exit:
 6537|     66|{
 6538|     66|    GC_Session *c = m->group_handler;
 6539|     66|    c->peer_exit = function;
 6540|     66|}
gc_callback_self_join:
 6543|     66|{
 6544|     66|    GC_Session *c = m->group_handler;
 6545|     66|    c->self_join = function;
 6546|     66|}
gc_callback_rejected:
 6549|     66|{
 6550|     66|    GC_Session *c = m->group_handler;
 6551|     66|    c->rejected = function;
 6552|     66|}
do_gc:
 7146|     82|{
 7147|     82|    if (c == nullptr) {
  ------------------
  |  |   63|     82|#define nullptr NULL
  ------------------
  |  Branch (7147:9): [True: 0, False: 82]
  ------------------
 7148|      0|        return;
 7149|      0|    }
 7150|       |
 7151|     82|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (7151:26): [True: 0, False: 82]
  ------------------
 7152|      0|        GC_Chat *chat = &c->chats[i];
 7153|       |
 7154|      0|        const GC_Conn_State state = chat->connection_state;
 7155|       |
 7156|      0|        if (state == CS_NONE) {
  ------------------
  |  Branch (7156:13): [True: 0, False: 0]
  ------------------
 7157|      0|            continue;
 7158|      0|        }
 7159|       |
 7160|      0|        if (state != CS_DISCONNECTED) {
  ------------------
  |  Branch (7160:13): [True: 0, False: 0]
  ------------------
 7161|      0|            do_peer_connections(c, chat, userdata);
 7162|      0|            do_gc_tcp(c, chat, userdata);
 7163|      0|            do_handshakes(c, chat);
 7164|      0|            do_self_connection(c, chat);
 7165|      0|        }
 7166|       |
 7167|      0|        if (chat->connection_state == CS_CONNECTED) {
  ------------------
  |  Branch (7167:13): [True: 0, False: 0]
  ------------------
 7168|      0|            do_gc_ping_and_key_rotation(chat);
 7169|      0|            do_timed_out_reconn(chat);
 7170|      0|        }
 7171|       |
 7172|      0|        do_new_connection_cooldown(chat);
 7173|      0|        do_peer_delete(c, chat, userdata);
 7174|       |
 7175|      0|        if (chat->flag_exit) {  // should always come last as it modifies the chats array
  ------------------
  |  Branch (7175:13): [True: 0, False: 0]
  ------------------
 7176|      0|            group_delete(c, chat);
 7177|      0|        }
 7178|      0|    }
 7179|     82|}
new_dht_groupchats:
 8108|    170|{
 8109|    170|    if (m == nullptr) {
  ------------------
  |  |   63|    170|#define nullptr NULL
  ------------------
  |  Branch (8109:9): [True: 0, False: 170]
  ------------------
 8110|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 8111|      0|    }
 8112|       |
 8113|    170|    GC_Session *c = (GC_Session *)mem_alloc(m->mem, sizeof(GC_Session));
 8114|       |
 8115|    170|    if (c == nullptr) {
  ------------------
  |  |   63|    170|#define nullptr NULL
  ------------------
  |  Branch (8115:9): [True: 1, False: 169]
  ------------------
 8116|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 8117|      1|    }
 8118|       |
 8119|    169|    c->messenger = m;
 8120|    169|    c->announces_list = m->group_announce;
 8121|    169|    c->tcp_np = m->tcp_np;
 8122|       |
 8123|    169|    networking_registerhandler(m->net, NET_PACKET_GC_LOSSLESS, &handle_gc_udp_packet, m);
 8124|    169|    networking_registerhandler(m->net, NET_PACKET_GC_LOSSY, &handle_gc_udp_packet, m);
 8125|    169|    networking_registerhandler(m->net, NET_PACKET_GC_HANDSHAKE, &handle_gc_udp_packet, m);
 8126|    169|    onion_group_announce_register(m->onion_c, gc_handle_announce_response_callback, c);
 8127|       |
 8128|    169|    return c;
 8129|    170|}
kill_dht_groupchats:
 8200|    169|{
 8201|    169|    if (c == nullptr) {
  ------------------
  |  |   63|    169|#define nullptr NULL
  ------------------
  |  Branch (8201:9): [True: 0, False: 169]
  ------------------
 8202|      0|        return;
 8203|      0|    }
 8204|       |
 8205|    169|    for (uint32_t i = 0; i < c->chats_index; ++i) {
  ------------------
  |  Branch (8205:26): [True: 0, False: 169]
  ------------------
 8206|      0|        GC_Chat *chat = &c->chats[i];
 8207|       |
 8208|      0|        if (chat->connection_state == CS_NONE) {
  ------------------
  |  Branch (8208:13): [True: 0, False: 0]
  ------------------
 8209|      0|            continue;
 8210|      0|        }
 8211|       |
 8212|      0|        if (kill_group(c, chat) != 0) {
  ------------------
  |  Branch (8212:13): [True: 0, False: 0]
  ------------------
 8213|      0|            LOGGER_WARNING(c->messenger->log, "Failed to send group exit packet");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8214|      0|        }
 8215|      0|    }
 8216|       |
 8217|    169|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSY, nullptr, nullptr);
  ------------------
  |  |   63|    169|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSY, nullptr, nullptr);
  ------------------
  |  |   63|    169|#define nullptr NULL
  ------------------
 8218|    169|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSLESS, nullptr, nullptr);
  ------------------
  |  |   63|    169|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSLESS, nullptr, nullptr);
  ------------------
  |  |   63|    169|#define nullptr NULL
  ------------------
 8219|    169|    networking_registerhandler(c->messenger->net, NET_PACKET_GC_HANDSHAKE, nullptr, nullptr);
  ------------------
  |  |   63|    169|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->messenger->net, NET_PACKET_GC_HANDSHAKE, nullptr, nullptr);
  ------------------
  |  |   63|    169|#define nullptr NULL
  ------------------
 8220|    169|    onion_group_announce_register(c->messenger->onion_c, nullptr, nullptr);
  ------------------
  |  |   63|    169|#define nullptr NULL
  ------------------
                  onion_group_announce_register(c->messenger->onion_c, nullptr, nullptr);
  ------------------
  |  |   63|    169|#define nullptr NULL
  ------------------
 8221|       |
 8222|    169|    mem_delete(c->messenger->mem, c->chats);
 8223|    169|    mem_delete(c->messenger->mem, c);
 8224|    169|}

gca_onion_init:
   76|    170|{
   77|    170|    onion_announce_extra_data_callback(onion_a, GCA_MAX_SENT_ANNOUNCES * sizeof(GC_Announce), pack_group_announces,
  ------------------
  |  |   35|    170|#define GCA_MAX_SENT_ANNOUNCES 4
  ------------------
   78|    170|                                       group_announce);
   79|    170|}

bs_list_init:
  136|    424|{
  137|    424|    list->mem = mem;
  138|       |
  139|       |    // set initial values
  140|    424|    list->n = 0;
  141|    424|    list->element_size = element_size;
  142|    424|    list->capacity = 0;
  143|    424|    list->data = nullptr;
  ------------------
  |  |   63|    424|#define nullptr NULL
  ------------------
  144|    424|    list->ids = nullptr;
  ------------------
  |  |   63|    424|#define nullptr NULL
  ------------------
  145|    424|    list->cmp_callback = cmp_callback;
  146|       |
  147|    424|    if (initial_capacity != 0) {
  ------------------
  |  Branch (147:9): [True: 232, False: 192]
  ------------------
  148|    232|        if (!resize(list, initial_capacity)) {
  ------------------
  |  Branch (148:13): [True: 102, False: 130]
  ------------------
  149|    102|            return 0;
  150|    102|        }
  151|    232|    }
  152|       |
  153|    322|    list->capacity = initial_capacity;
  154|       |
  155|    322|    return 1;
  156|    424|}
bs_list_free:
  159|    424|{
  160|    424|    if (list == nullptr) {
  ------------------
  |  |   63|    424|#define nullptr NULL
  ------------------
  |  Branch (160:9): [True: 0, False: 424]
  ------------------
  161|      0|        return;
  162|      0|    }
  163|       |
  164|       |    // free both arrays
  165|    424|    mem_delete(list->mem, list->data);
  166|    424|    list->data = nullptr;
  ------------------
  |  |   63|    424|#define nullptr NULL
  ------------------
  167|       |
  168|    424|    mem_delete(list->mem, list->ids);
  169|       |    list->ids = nullptr;
  ------------------
  |  |   63|    424|#define nullptr NULL
  ------------------
  170|    424|}
list.c:resize:
  110|    232|{
  111|    232|    if (new_size == 0) {
  ------------------
  |  Branch (111:9): [True: 0, False: 232]
  ------------------
  112|      0|        bs_list_free(list);
  113|      0|        return true;
  114|      0|    }
  115|       |
  116|    232|    uint8_t *data = (uint8_t *)mem_brealloc(list->mem, list->data, new_size * list->element_size);
  117|       |
  118|    232|    if (data == nullptr) {
  ------------------
  |  |   63|    232|#define nullptr NULL
  ------------------
  |  Branch (118:9): [True: 92, False: 140]
  ------------------
  119|     92|        return false;
  120|     92|    }
  121|       |
  122|    140|    list->data = data;
  123|       |
  124|    140|    int *ids = (int *)mem_vrealloc(list->mem, list->ids, new_size, sizeof(int));
  125|       |
  126|    140|    if (ids == nullptr) {
  ------------------
  |  |   63|    140|#define nullptr NULL
  ------------------
  |  Branch (126:9): [True: 10, False: 130]
  ------------------
  127|     10|        return false;
  128|     10|    }
  129|       |
  130|    130|    list->ids = ids;
  131|       |
  132|       |    return true;
  133|    140|}

logger_new:
   33|    220|{
   34|    220|    Logger *log = (Logger *)mem_alloc(mem, sizeof(Logger));
   35|       |
   36|    220|    if (log == nullptr) {
  ------------------
  |  |   63|    220|#define nullptr NULL
  ------------------
  |  Branch (36:9): [True: 1, False: 219]
  ------------------
   37|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
   38|      1|    }
   39|       |
   40|    219|    log->mem = mem;
   41|       |
   42|    219|    return log;
   43|    220|}
logger_kill:
   46|    219|{
   47|    219|    if (log == nullptr) {
  ------------------
  |  |   63|    219|#define nullptr NULL
  ------------------
  |  Branch (47:9): [True: 0, False: 219]
  ------------------
   48|      0|        return;
   49|      0|    }
   50|       |
   51|    219|    mem_delete(log->mem, log);
   52|    219|}
logger_callback_log:
   55|    219|{
   56|    219|    assert(log != nullptr);
  ------------------
  |  Branch (56:5): [True: 219, False: 0]
  ------------------
   57|    219|    log->callback = function;
   58|    219|    log->context  = context;
   59|    219|    log->userdata = userdata;
   60|    219|}
logger_write:
   64|    323|{
   65|    323|    if (log == nullptr) {
  ------------------
  |  |   63|    323|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 0, False: 323]
  ------------------
   66|      0|        return;
   67|      0|    }
   68|       |
   69|    323|    if (log->callback == nullptr) {
  ------------------
  |  |   63|    323|#define nullptr NULL
  ------------------
  |  Branch (69:9): [True: 0, False: 323]
  ------------------
   70|      0|        return;
   71|      0|    }
   72|       |
   73|       |    // Only pass the file name, not the entire file path, for privacy reasons.
   74|       |    // The full path may contain PII of the person compiling toxcore (their
   75|       |    // username and directory layout).
   76|    323|    const char *filename = strrchr(file, '/');
   77|    323|    if (filename != nullptr) {
  ------------------
  |  |   63|    323|#define nullptr NULL
  ------------------
  |  Branch (77:9): [True: 323, False: 0]
  ------------------
   78|    323|        file = &filename[1];
   79|    323|    }
   80|       |#if defined(_WIN32) || defined(__CYGWIN__)
   81|       |    // On Windows, the path separator *may* be a backslash, so we look for that
   82|       |    // one too.
   83|       |    const char *windows_filename = strrchr(file, '\\');
   84|       |    file = windows_filename != nullptr ? windows_filename + 1 : file;
   85|       |#endif /* WIN32 */
   86|       |
   87|       |    // Format message
   88|    323|    char msg[1024];
   89|    323|    va_list args;
   90|    323|    va_start(args, format);
   91|    323|    vsnprintf(msg, sizeof(msg), format, args);
   92|    323|    va_end(args);
   93|       |
   94|    323|    log->callback(log->context, level, file, line, func, msg, log->userdata);
   95|    323|}

mem_balloc:
   13|  9.11k|{
   14|  9.11k|    void *const ptr = mem->funcs->malloc_callback(mem->user_data, size);
   15|  9.11k|    return ptr;
   16|  9.11k|}
mem_brealloc:
   19|  1.40k|{
   20|  1.40k|    void *const new_ptr = mem->funcs->realloc_callback(mem->user_data, ptr, size);
   21|  1.40k|    return new_ptr;
   22|  1.40k|}
mem_alloc:
   25|  8.88k|{
   26|  8.88k|    void *const ptr = mem_balloc(mem, size);
   27|  8.88k|    if (ptr != nullptr) {
  ------------------
  |  |   63|  8.88k|#define nullptr NULL
  ------------------
  |  Branch (27:9): [True: 8.72k, False: 157]
  ------------------
   28|  8.72k|        memset(ptr, 0, size);
   29|  8.72k|    }
   30|  8.88k|    return ptr;
   31|  8.88k|}
mem_valloc:
   34|  2.05k|{
   35|  2.05k|    const uint32_t bytes = nmemb * size;
   36|       |
   37|  2.05k|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (37:9): [True: 2.05k, False: 0]
  |  Branch (37:22): [True: 0, False: 2.05k]
  ------------------
   38|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   39|      0|    }
   40|       |
   41|  2.05k|    void *const ptr = mem_alloc(mem, bytes);
   42|  2.05k|    return ptr;
   43|  2.05k|}
mem_vrealloc:
   46|  1.16k|{
   47|  1.16k|    const uint32_t bytes = nmemb * size;
   48|       |
   49|  1.16k|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (49:9): [True: 1.16k, False: 0]
  |  Branch (49:22): [True: 0, False: 1.16k]
  ------------------
   50|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   51|      0|    }
   52|       |
   53|  1.16k|    void *const new_ptr = mem_brealloc(mem, ptr, bytes);
   54|  1.16k|    return new_ptr;
   55|  1.16k|}
mem_delete:
   58|  55.8k|{
   59|  55.8k|    mem->funcs->dealloc_callback(mem->user_data, ptr);
   60|  55.8k|}

mono_time_new:
  111|    219|{
  112|    219|    Mono_Time *mono_time = (Mono_Time *)mem_alloc(mem, sizeof(Mono_Time));
  113|       |
  114|    219|    if (mono_time == nullptr) {
  ------------------
  |  |   63|    219|#define nullptr NULL
  ------------------
  |  Branch (114:9): [True: 1, False: 218]
  ------------------
  115|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  116|      1|    }
  117|       |
  118|    218|#ifndef ESP_PLATFORM
  119|    218|    pthread_rwlock_t *const rwlock = (pthread_rwlock_t *)mem_alloc(mem, sizeof(pthread_rwlock_t));
  120|       |
  121|    218|    if (rwlock == nullptr) {
  ------------------
  |  |   63|    218|#define nullptr NULL
  ------------------
  |  Branch (121:9): [True: 1, False: 217]
  ------------------
  122|      1|        mem_delete(mem, mono_time);
  123|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  124|      1|    }
  125|       |
  126|    217|    if (pthread_rwlock_init(rwlock, nullptr) != 0) {
  ------------------
  |  |   63|    217|#define nullptr NULL
  ------------------
  |  Branch (126:9): [True: 0, False: 217]
  ------------------
  127|      0|        mem_delete(mem, rwlock);
  128|      0|        mem_delete(mem, mono_time);
  129|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  130|      0|    }
  131|       |
  132|    217|    mono_time->time_update_lock = rwlock;
  133|    217|#endif /* ESP_PLATFORM */
  134|       |
  135|    217|    mono_time_set_current_time_callback(mono_time, current_time_callback, user_data);
  136|       |
  137|    217|    mono_time->cur_time = 0;
  138|    217|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  139|       |    // Maximum reproducibility. Never return time = 0.
  140|    217|    mono_time->base_time = 1000000000;
  141|       |#else
  142|       |    // Never return time = 0 in case time() returns 0 (e.g. on microcontrollers
  143|       |    // without battery-powered RTC or ones where NTP didn't initialise it yet).
  144|       |    mono_time->base_time = max_u64(1, (uint64_t)time(nullptr)) * UINT64_C(1000) - current_time_monotonic(mono_time);
  145|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  146|       |
  147|    217|    mono_time_update(mono_time);
  148|       |
  149|    217|    return mono_time;
  150|    217|}
mono_time_free:
  153|    217|{
  154|    217|    if (mono_time == nullptr) {
  ------------------
  |  |   63|    217|#define nullptr NULL
  ------------------
  |  Branch (154:9): [True: 0, False: 217]
  ------------------
  155|      0|        return;
  156|      0|    }
  157|    217|#ifndef ESP_PLATFORM
  158|    217|    pthread_rwlock_destroy(mono_time->time_update_lock);
  159|    217|    mem_delete(mem, mono_time->time_update_lock);
  160|    217|#endif /* ESP_PLATFORM */
  161|    217|    mem_delete(mem, mono_time);
  162|    217|}
mono_time_update:
  165|    299|{
  166|    299|    const uint64_t cur_time =
  167|    299|        mono_time->base_time + mono_time->current_time_callback(mono_time->user_data);
  168|       |
  169|    299|#ifndef ESP_PLATFORM
  170|    299|    pthread_rwlock_wrlock(mono_time->time_update_lock);
  171|    299|#endif /* ESP_PLATFORM */
  172|    299|    mono_time->cur_time = cur_time;
  173|    299|#ifndef ESP_PLATFORM
  174|    299|    pthread_rwlock_unlock(mono_time->time_update_lock);
  175|    299|#endif /* ESP_PLATFORM */
  176|    299|}
mono_time_get_ms:
  179|  3.32k|{
  180|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  181|       |    // Fuzzing is only single thread for now, no locking needed */
  182|       |    pthread_rwlock_rdlock(mono_time->time_update_lock);
  183|       |#endif /* !ESP_PLATFORM */
  184|  3.32k|    const uint64_t cur_time = mono_time->cur_time;
  185|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  186|       |    pthread_rwlock_unlock(mono_time->time_update_lock);
  187|       |#endif /* !ESP_PLATFORM */
  188|  3.32k|    return cur_time;
  189|  3.32k|}
mono_time_get:
  192|  3.13k|{
  193|       |    return mono_time_get_ms(mono_time) / UINT64_C(1000);
  194|  3.13k|}
mono_time_is_timeout:
  197|    223|{
  198|    223|    return timestamp + timeout <= mono_time_get(mono_time);
  199|    223|}
mono_time_set_current_time_callback:
  203|    217|{
  204|    217|    if (current_time_callback == nullptr) {
  ------------------
  |  |   63|    217|#define nullptr NULL
  ------------------
  |  Branch (204:9): [True: 0, False: 217]
  ------------------
  205|      0|        mono_time->current_time_callback = current_time_monotonic_default;
  206|      0|        mono_time->user_data = mono_time;
  207|    217|    } else {
  208|    217|        mono_time->current_time_callback = current_time_callback;
  209|    217|        mono_time->user_data = user_data;
  210|    217|    }
  211|    217|}
current_time_monotonic:
  219|     82|{
  220|     82|    return mono_time->current_time_callback(mono_time->user_data);
  221|     82|}

net_socket_to_native:
    9|  2.95k|{
   10|  2.95k|    return (force int)sock.value;
   11|  2.95k|}
net_socket_from_native:
   14|    968|{
   15|    968|    const Socket res = {(force Socket_Value)sock};
   16|    968|    return res;
   17|    968|}
ns_close:
   20|    205|{
   21|    205|    return ns->funcs->close(ns->obj, sock);
   22|    205|}
ns_bind:
   30|    317|{
   31|    317|    return ns->funcs->bind(ns->obj, sock, addr);
   32|    317|}
ns_listen:
   35|    135|{
   36|    135|    return ns->funcs->listen(ns->obj, sock, backlog);
   37|    135|}
ns_recvfrom:
   55|     65|{
   56|     65|    return ns->funcs->recvfrom(ns->obj, sock, buf, len, addr);
   57|     65|}
ns_send:
   60|     88|{
   61|     88|    return ns->funcs->send(ns->obj, sock, buf, len);
   62|     88|}
ns_sendto:
   65|    625|{
   66|    625|    return ns->funcs->sendto(ns->obj, sock, buf, len, addr);
   67|    625|}
ns_socket:
   70|    304|{
   71|    304|    return ns->funcs->socket(ns->obj, domain, type, proto);
   72|    304|}
ns_socket_nonblock:
   75|    304|{
   76|    304|    return ns->funcs->socket_nonblock(ns->obj, sock, nonblock);
   77|    304|}
ns_getsockopt:
   80|    226|{
   81|    226|    return ns->funcs->getsockopt(ns->obj, sock, level, optname, optval, optlen);
   82|    226|}
ns_setsockopt:
   85|    499|{
   86|    499|    return ns->funcs->setsockopt(ns->obj, sock, level, optname, optval, optlen);
   87|    499|}
net_family_unspec:
  175|    524|{
  176|    524|    return family_unspec;
  177|    524|}
net_family_ipv4:
  180|  2.67k|{
  181|  2.67k|    return family_ipv4;
  182|  2.67k|}
net_family_ipv6:
  185|  1.79k|{
  186|  1.79k|    return family_ipv6;
  187|  1.79k|}
net_family_is_unspec:
  220|   100k|{
  221|   100k|    return family.value == family_unspec.value;
  222|   100k|}
net_family_is_ipv4:
  225|   420k|{
  226|   420k|    return family.value == family_ipv4.value;
  227|   420k|}
net_family_is_ipv6:
  230|   420k|{
  231|   420k|    return family.value == family_ipv6.value;
  232|   420k|}
net_family_is_tcp_ipv4:
  245|     95|{
  246|     95|    return family.value == family_tcp_ipv4.value;
  247|     95|}
net_family_is_tcp_ipv6:
  250|     95|{
  251|     95|    return family.value == family_tcp_ipv6.value;
  252|     95|}

nc_get_tcp_c:
  182|    431|{
  183|    431|    return c->tcp_c;
  184|    431|}
new_connection_handler:
 1931|    191|{
 1932|    191|    c->new_connection_callback = new_connection_callback;
 1933|    191|    c->new_connection_callback_object = object;
 1934|    191|}
add_tcp_relay:
 2215|     95|{
 2216|     95|    return add_tcp_relay_global(c->tcp_c, ip_port, public_key);
 2217|     95|}
new_keys:
 2936|    196|{
 2937|    196|    crypto_new_keypair(c->rng, c->self_public_key, c->self_secret_key);
 2938|    196|}
new_net_crypto:
 2965|    199|{
 2966|    199|    if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|    398|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|    398|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|    398|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|    398|#define nullptr NULL
  ------------------
                  if (dht == nullptr || dht_funcs == nullptr || dht_funcs->get_shared_key_sent == nullptr || dht_funcs->get_self_public_key == nullptr || dht_funcs->get_self_secret_key == nullptr) {
  ------------------
  |  |   63|    199|#define nullptr NULL
  ------------------
  |  Branch (2966:9): [True: 0, False: 199]
  |  Branch (2966:27): [True: 0, False: 199]
  |  Branch (2966:51): [True: 0, False: 199]
  |  Branch (2966:96): [True: 0, False: 199]
  |  Branch (2966:141): [True: 0, False: 199]
  ------------------
 2967|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2968|      0|    }
 2969|       |
 2970|    199|    Net_Crypto *temp = (Net_Crypto *)mem_alloc(mem, sizeof(Net_Crypto));
 2971|       |
 2972|    199|    if (temp == nullptr) {
  ------------------
  |  |   63|    199|#define nullptr NULL
  ------------------
  |  Branch (2972:9): [True: 1, False: 198]
  ------------------
 2973|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 2974|      1|    }
 2975|       |
 2976|    198|    temp->log = log;
 2977|    198|    temp->mem = mem;
 2978|    198|    temp->rng = rng;
 2979|    198|    temp->mono_time = mono_time;
 2980|    198|    temp->ns = ns;
 2981|    198|    temp->net = net;
 2982|       |
 2983|    198|    temp->dht = dht;
 2984|    198|    temp->dht_funcs = dht_funcs;
 2985|       |
 2986|    198|    TCP_Connections *const tcp_c = new_tcp_connections(log, mem, rng, ns, mono_time, dht_funcs->get_self_secret_key(dht), proxy_info, tcp_np);
 2987|       |
 2988|    198|    if (tcp_c == nullptr) {
  ------------------
  |  |   63|    198|#define nullptr NULL
  ------------------
  |  Branch (2988:9): [True: 2, False: 196]
  ------------------
 2989|      2|        mem_delete(mem, temp);
 2990|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 2991|      2|    }
 2992|       |
 2993|    196|    temp->tcp_c = tcp_c;
 2994|       |
 2995|    196|    set_packet_tcp_connection_callback(temp->tcp_c, &tcp_data_callback, temp);
 2996|    196|    set_oob_packet_tcp_connection_callback(temp->tcp_c, &tcp_oob_callback, temp);
 2997|       |
 2998|    196|    new_keys(temp);
 2999|    196|    new_symmetric_key(rng, temp->secret_symmetric_key);
 3000|       |
 3001|    196|    temp->current_sleep_time = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |  111|    196|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 3002|       |
 3003|    196|    networking_registerhandler(net, NET_PACKET_COOKIE_REQUEST, &udp_handle_cookie_request, temp);
 3004|    196|    networking_registerhandler(net, NET_PACKET_COOKIE_RESPONSE, &udp_handle_packet, temp);
 3005|    196|    networking_registerhandler(net, NET_PACKET_CRYPTO_HS, &udp_handle_packet, temp);
 3006|    196|    networking_registerhandler(net, NET_PACKET_CRYPTO_DATA, &udp_handle_packet, temp);
 3007|       |
 3008|    196|    bs_list_init(&temp->ip_port_list, mem, sizeof(IP_Port), 8, ipport_cmp_handler);
 3009|       |
 3010|    196|    temp->cookie_request_tokens = COOKIE_REQUEST_MAX_TOKENS;
  ------------------
  |  |  212|    196|#define COOKIE_REQUEST_MAX_TOKENS 10
  ------------------
 3011|    196|    temp->cookie_request_last_time = mono_time_get_ms(mono_time);
 3012|       |
 3013|    196|    return temp;
 3014|    198|}
do_net_crypto:
 3052|     82|{
 3053|     82|    kill_timedout(c, userdata);
 3054|     82|    do_tcp(c, userdata);
 3055|     82|    send_crypto_packets(c);
 3056|     82|}
kill_net_crypto:
 3059|    196|{
 3060|    196|    if (c == nullptr) {
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
  |  Branch (3060:9): [True: 0, False: 196]
  ------------------
 3061|      0|        return;
 3062|      0|    }
 3063|       |
 3064|    196|    const Memory *mem = c->mem;
 3065|       |
 3066|    196|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (3066:26): [True: 0, False: 196]
  ------------------
 3067|      0|        crypto_kill(c, i);
 3068|      0|    }
 3069|       |
 3070|    196|    kill_tcp_connections(c->tcp_c);
 3071|    196|    bs_list_free(&c->ip_port_list);
 3072|    196|    networking_registerhandler(c->net, NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
 3073|    196|    networking_registerhandler(c->net, NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
 3074|    196|    networking_registerhandler(c->net, NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_CRYPTO_HS, nullptr, nullptr);
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
 3075|    196|    networking_registerhandler(c->net, NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
                  networking_registerhandler(c->net, NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
  ------------------
  |  |   63|    196|#define nullptr NULL
  ------------------
 3076|    196|    crypto_memzero(c, sizeof(Net_Crypto));
 3077|    196|    mem_delete(mem, c);
 3078|    196|}
net_crypto.c:kill_timedout:
 3017|     82|{
 3018|     82|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (3018:26): [True: 0, False: 82]
  ------------------
 3019|      0|        const Crypto_Connection *conn = get_crypto_connection(c, i);
 3020|      0|        if (conn == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3020:13): [True: 0, False: 0]
  ------------------
 3021|      0|            continue;
 3022|      0|        }
 3023|       |
 3024|      0|        if (conn->status == CRYPTO_CONN_COOKIE_REQUESTING || conn->status == CRYPTO_CONN_HANDSHAKE_SENT
  ------------------
  |  Branch (3024:13): [True: 0, False: 0]
  |  Branch (3024:62): [True: 0, False: 0]
  ------------------
 3025|      0|                || conn->status == CRYPTO_CONN_NOT_CONFIRMED) {
  ------------------
  |  Branch (3025:20): [True: 0, False: 0]
  ------------------
 3026|      0|            if (conn->temp_packet_num_sent < MAX_NUM_SENDPACKET_TRIES) {
  ------------------
  |  |  117|      0|#define MAX_NUM_SENDPACKET_TRIES 8
  ------------------
  |  Branch (3026:17): [True: 0, False: 0]
  ------------------
 3027|      0|                continue;
 3028|      0|            }
 3029|       |
 3030|      0|            connection_kill(c, i, userdata);
 3031|      0|        }
 3032|       |
 3033|       |#if 0
 3034|       |
 3035|       |        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
 3036|       |            // TODO(irungentoo): add a timeout here?
 3037|       |            /* do_timeout_here(); */
 3038|       |        }
 3039|       |
 3040|       |#endif /* 0 */
 3041|      0|    }
 3042|     82|}
net_crypto.c:do_tcp:
 2294|     82|{
 2295|     82|    do_tcp_connections(c->log, c->tcp_c, userdata);
 2296|       |
 2297|     82|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (2297:26): [True: 0, False: 82]
  ------------------
 2298|      0|        const Crypto_Connection *conn = get_crypto_connection(c, i);
 2299|       |
 2300|      0|        if (conn == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (2300:13): [True: 0, False: 0]
  ------------------
 2301|      0|            continue;
 2302|      0|        }
 2303|       |
 2304|      0|        if (conn->status != CRYPTO_CONN_ESTABLISHED) {
  ------------------
  |  Branch (2304:13): [True: 0, False: 0]
  ------------------
 2305|      0|            continue;
 2306|      0|        }
 2307|       |
 2308|      0|        bool direct_connected = false;
 2309|       |
 2310|      0|        if (!crypto_connection_status(c, i, &direct_connected, nullptr)) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (2310:13): [True: 0, False: 0]
  ------------------
 2311|      0|            continue;
 2312|      0|        }
 2313|       |
 2314|      0|        set_tcp_connection_to_status(c->tcp_c, conn->connection_number_tcp, !direct_connected);
 2315|      0|    }
 2316|     82|}
net_crypto.c:send_crypto_packets:
 2496|     82|{
 2497|     82|    const uint64_t temp_time = current_time_monotonic(c->mono_time);
 2498|     82|    double total_send_rate = 0;
 2499|     82|    uint32_t peak_request_packet_interval = -1;
 2500|       |
 2501|     82|    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
  ------------------
  |  Branch (2501:26): [True: 0, False: 82]
  ------------------
 2502|      0|        Crypto_Connection *conn = get_crypto_connection(c, i);
 2503|       |
 2504|      0|        if (conn == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (2504:13): [True: 0, False: 0]
  ------------------
 2505|      0|            continue;
 2506|      0|        }
 2507|       |
 2508|      0|        if ((CRYPTO_SEND_PACKET_INTERVAL + conn->temp_packet_sent_time) < temp_time) {
  ------------------
  |  |  111|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
  |  Branch (2508:13): [True: 0, False: 0]
  ------------------
 2509|      0|            send_temp_packet(c, i);
 2510|      0|        }
 2511|       |
 2512|      0|        if ((conn->status == CRYPTO_CONN_NOT_CONFIRMED || conn->status == CRYPTO_CONN_ESTABLISHED)
  ------------------
  |  Branch (2512:14): [True: 0, False: 0]
  |  Branch (2512:59): [True: 0, False: 0]
  ------------------
 2513|      0|                && (CRYPTO_SEND_PACKET_INTERVAL + conn->last_request_packet_sent) < temp_time) {
  ------------------
  |  |  111|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
  |  Branch (2513:20): [True: 0, False: 0]
  ------------------
 2514|      0|            if (send_request_packet(c, i) == 0) {
  ------------------
  |  Branch (2514:17): [True: 0, False: 0]
  ------------------
 2515|      0|                conn->last_request_packet_sent = temp_time;
 2516|      0|            }
 2517|      0|        }
 2518|       |
 2519|      0|        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
  ------------------
  |  Branch (2519:13): [True: 0, False: 0]
  ------------------
 2520|      0|            if (conn->packet_recv_rate > CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2520:17): [True: 0, False: 0]
  ------------------
 2521|      0|                double request_packet_interval = REQUEST_PACKETS_COMPARE_CONSTANT / ((num_packets_array(
  ------------------
  |  | 2483|      0|#define REQUEST_PACKETS_COMPARE_CONSTANT (0.125 * 100.0)
  ------------------
 2522|      0|                                                     &conn->recv_array) + 1.0) / (conn->packet_recv_rate + 1.0));
 2523|       |
 2524|      0|                const double request_packet_interval2 = ((CRYPTO_PACKET_MIN_RATE / conn->packet_recv_rate) *
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
 2525|      0|                                                        (double)CRYPTO_SEND_PACKET_INTERVAL) + (double)PACKET_COUNTER_AVERAGE_INTERVAL;
  ------------------
  |  |  111|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
                                                                      (double)CRYPTO_SEND_PACKET_INTERVAL) + (double)PACKET_COUNTER_AVERAGE_INTERVAL;
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2526|       |
 2527|      0|                if (request_packet_interval2 < request_packet_interval) {
  ------------------
  |  Branch (2527:21): [True: 0, False: 0]
  ------------------
 2528|      0|                    request_packet_interval = request_packet_interval2;
 2529|      0|                }
 2530|       |
 2531|      0|                if (request_packet_interval < PACKET_COUNTER_AVERAGE_INTERVAL) {
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
  |  Branch (2531:21): [True: 0, False: 0]
  ------------------
 2532|      0|                    request_packet_interval = PACKET_COUNTER_AVERAGE_INTERVAL;
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2533|      0|                }
 2534|       |
 2535|      0|                if (request_packet_interval > CRYPTO_SEND_PACKET_INTERVAL) {
  ------------------
  |  |  111|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
  |  Branch (2535:21): [True: 0, False: 0]
  ------------------
 2536|      0|                    request_packet_interval = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |  111|      0|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 2537|      0|                }
 2538|       |
 2539|      0|                if (temp_time - conn->last_request_packet_sent > (uint64_t)request_packet_interval) {
  ------------------
  |  Branch (2539:21): [True: 0, False: 0]
  ------------------
 2540|      0|                    if (send_request_packet(c, i) == 0) {
  ------------------
  |  Branch (2540:25): [True: 0, False: 0]
  ------------------
 2541|      0|                        conn->last_request_packet_sent = temp_time;
 2542|      0|                    }
 2543|      0|                }
 2544|       |
 2545|      0|                if (request_packet_interval < peak_request_packet_interval) {
  ------------------
  |  Branch (2545:21): [True: 0, False: 0]
  ------------------
 2546|      0|                    peak_request_packet_interval = request_packet_interval;
 2547|      0|                }
 2548|      0|            }
 2549|       |
 2550|      0|            if ((PACKET_COUNTER_AVERAGE_INTERVAL + conn->packet_counter_set) < temp_time) {
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
  |  Branch (2550:17): [True: 0, False: 0]
  ------------------
 2551|      0|                const double dt = (double)(temp_time - conn->packet_counter_set);
 2552|       |
 2553|      0|                conn->packet_recv_rate = (double)conn->packet_counter / (dt / 1000.0);
 2554|      0|                conn->packet_counter = 0;
 2555|      0|                conn->packet_counter_set = temp_time;
 2556|       |
 2557|      0|                const uint32_t packets_sent = conn->packets_sent;
 2558|      0|                conn->packets_sent = 0;
 2559|       |
 2560|      0|                const uint32_t packets_resent = conn->packets_resent;
 2561|      0|                conn->packets_resent = 0;
 2562|       |
 2563|       |                /* conjestion control
 2564|       |                 *  calculate a new value of conn->packet_send_rate based on some data
 2565|       |                 */
 2566|       |
 2567|      0|                const unsigned int pos = conn->last_sendqueue_counter % CONGESTION_QUEUE_ARRAY_SIZE;
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2568|      0|                conn->last_sendqueue_size[pos] = num_packets_array(&conn->send_array);
 2569|       |
 2570|      0|                long signed int sum = 0;
 2571|      0|                sum = (long signed int)conn->last_sendqueue_size[pos] -
 2572|      0|                      (long signed int)conn->last_sendqueue_size[(pos + 1) % CONGESTION_QUEUE_ARRAY_SIZE];
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2573|       |
 2574|      0|                const unsigned int n_p_pos = conn->last_sendqueue_counter % CONGESTION_LAST_SENT_ARRAY_SIZE;
  ------------------
  |  |  133|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
 2575|      0|                conn->last_num_packets_sent[n_p_pos] = packets_sent;
 2576|      0|                conn->last_num_packets_resent[n_p_pos] = packets_resent;
 2577|       |
 2578|      0|                conn->last_sendqueue_counter = (conn->last_sendqueue_counter + 1) %
 2579|      0|                                               (CONGESTION_QUEUE_ARRAY_SIZE * CONGESTION_LAST_SENT_ARRAY_SIZE);
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
                                                             (CONGESTION_QUEUE_ARRAY_SIZE * CONGESTION_LAST_SENT_ARRAY_SIZE);
  ------------------
  |  |  133|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
 2580|       |
 2581|      0|                bool direct_connected = false;
 2582|       |                /* return value can be ignored since the `if` above ensures the connection is established */
 2583|      0|                crypto_connection_status(c, i, &direct_connected, nullptr);
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2584|       |
 2585|       |                /* When switching from TCP to UDP, don't change the packet send rate for CONGESTION_EVENT_TIMEOUT ms. */
 2586|      0|                if (!(direct_connected && conn->last_tcp_sent + CONGESTION_EVENT_TIMEOUT > temp_time)) {
  ------------------
  |  | 2486|      0|#define CONGESTION_EVENT_TIMEOUT 1000
  ------------------
  |  Branch (2586:23): [True: 0, False: 0]
  |  Branch (2586:43): [True: 0, False: 0]
  ------------------
 2587|      0|                    long signed int total_sent = 0;
 2588|      0|                    long signed int total_resent = 0;
 2589|       |
 2590|       |                    // TODO(irungentoo): use real delay
 2591|      0|                    unsigned int delay = (unsigned int)(((double)conn->rtt_time / PACKET_COUNTER_AVERAGE_INTERVAL) + 0.5);
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2592|      0|                    const unsigned int packets_set_rem_array = CONGESTION_LAST_SENT_ARRAY_SIZE - CONGESTION_QUEUE_ARRAY_SIZE;
  ------------------
  |  |  133|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
                                  const unsigned int packets_set_rem_array = CONGESTION_LAST_SENT_ARRAY_SIZE - CONGESTION_QUEUE_ARRAY_SIZE;
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2593|       |
 2594|      0|                    if (delay > packets_set_rem_array) {
  ------------------
  |  Branch (2594:25): [True: 0, False: 0]
  ------------------
 2595|      0|                        delay = packets_set_rem_array;
 2596|      0|                    }
 2597|       |
 2598|      0|                    for (unsigned j = 0; j < CONGESTION_QUEUE_ARRAY_SIZE; ++j) {
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
  |  Branch (2598:42): [True: 0, False: 0]
  ------------------
 2599|      0|                        const unsigned int ind = (j + (packets_set_rem_array  - delay) + n_p_pos) % CONGESTION_LAST_SENT_ARRAY_SIZE;
  ------------------
  |  |  133|      0|#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)
  |  |  ------------------
  |  |  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  |  |  ------------------
  ------------------
 2600|      0|                        total_sent += conn->last_num_packets_sent[ind];
 2601|      0|                        total_resent += conn->last_num_packets_resent[ind];
 2602|      0|                    }
 2603|       |
 2604|      0|                    if (sum > 0) {
  ------------------
  |  Branch (2604:25): [True: 0, False: 0]
  ------------------
 2605|      0|                        total_sent -= sum;
 2606|      0|                    } else {
 2607|      0|                        if (total_resent > -sum) {
  ------------------
  |  Branch (2607:29): [True: 0, False: 0]
  ------------------
 2608|      0|                            total_resent = -sum;
 2609|      0|                        }
 2610|      0|                    }
 2611|       |
 2612|       |                    /* if queue is too big only allow resending packets. */
 2613|      0|                    const uint32_t npackets = num_packets_array(&conn->send_array);
 2614|      0|                    double min_speed = 1000.0 * (((double)total_sent) / ((double)CONGESTION_QUEUE_ARRAY_SIZE *
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
 2615|      0|                                                 PACKET_COUNTER_AVERAGE_INTERVAL));
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2616|       |
 2617|      0|                    const double min_speed_request = 1000.0 * (((double)(total_sent + total_resent)) / (
 2618|      0|                                                         (double)CONGESTION_QUEUE_ARRAY_SIZE * PACKET_COUNTER_AVERAGE_INTERVAL));
  ------------------
  |  |  132|      0|#define CONGESTION_QUEUE_ARRAY_SIZE 12
  ------------------
                                                                       (double)CONGESTION_QUEUE_ARRAY_SIZE * PACKET_COUNTER_AVERAGE_INTERVAL));
  ------------------
  |  | 2478|      0|#define PACKET_COUNTER_AVERAGE_INTERVAL 50
  ------------------
 2619|       |
 2620|      0|                    if (min_speed < CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2620:25): [True: 0, False: 0]
  ------------------
 2621|      0|                        min_speed = CRYPTO_PACKET_MIN_RATE;
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
 2622|      0|                    }
 2623|       |
 2624|      0|                    const double send_array_ratio = (double)npackets / min_speed;
 2625|       |
 2626|       |                    // TODO(irungentoo): Improve formula?
 2627|      0|                    if (send_array_ratio > SEND_QUEUE_RATIO && CRYPTO_MIN_QUEUE_LENGTH < npackets) {
  ------------------
  |  | 2493|      0|#define SEND_QUEUE_RATIO 2.0
  ------------------
                                  if (send_array_ratio > SEND_QUEUE_RATIO && CRYPTO_MIN_QUEUE_LENGTH < npackets) {
  ------------------
  |  |  100|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
  |  Branch (2627:25): [True: 0, False: 0]
  |  Branch (2627:64): [True: 0, False: 0]
  ------------------
 2628|      0|                        conn->packet_send_rate = min_speed * (1.0 / (send_array_ratio / SEND_QUEUE_RATIO));
  ------------------
  |  | 2493|      0|#define SEND_QUEUE_RATIO 2.0
  ------------------
 2629|      0|                    } else if (conn->last_congestion_event + CONGESTION_EVENT_TIMEOUT < temp_time) {
  ------------------
  |  | 2486|      0|#define CONGESTION_EVENT_TIMEOUT 1000
  ------------------
  |  Branch (2629:32): [True: 0, False: 0]
  ------------------
 2630|      0|                        conn->packet_send_rate = min_speed * 1.2;
 2631|      0|                    } else {
 2632|      0|                        conn->packet_send_rate = min_speed * 0.9;
 2633|      0|                    }
 2634|       |
 2635|      0|                    conn->packet_send_rate_requested = min_speed_request * 1.2;
 2636|       |
 2637|      0|                    if (conn->packet_send_rate < CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2637:25): [True: 0, False: 0]
  ------------------
 2638|      0|                        conn->packet_send_rate = CRYPTO_PACKET_MIN_RATE;
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
 2639|      0|                    }
 2640|       |
 2641|      0|                    if (conn->packet_send_rate_requested < conn->packet_send_rate) {
  ------------------
  |  Branch (2641:25): [True: 0, False: 0]
  ------------------
 2642|      0|                        conn->packet_send_rate_requested = conn->packet_send_rate;
 2643|      0|                    }
 2644|      0|                }
 2645|      0|            }
 2646|       |
 2647|      0|            if (conn->last_packets_left_set == 0 || conn->last_packets_left_requested_set == 0) {
  ------------------
  |  Branch (2647:17): [True: 0, False: 0]
  |  Branch (2647:53): [True: 0, False: 0]
  ------------------
 2648|      0|                conn->last_packets_left_requested_set = temp_time;
 2649|      0|                conn->last_packets_left_set = temp_time;
 2650|      0|                conn->packets_left_requested = CRYPTO_MIN_QUEUE_LENGTH;
  ------------------
  |  |  100|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
 2651|      0|                conn->packets_left = CRYPTO_MIN_QUEUE_LENGTH;
  ------------------
  |  |  100|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
 2652|      0|            } else {
 2653|      0|                if (((uint64_t)((1000.0 / conn->packet_send_rate) + 0.5) + conn->last_packets_left_set) <= temp_time) {
  ------------------
  |  Branch (2653:21): [True: 0, False: 0]
  ------------------
 2654|      0|                    double n_packets = conn->packet_send_rate * (((double)(temp_time - conn->last_packets_left_set)) / 1000.0);
 2655|      0|                    n_packets += conn->last_packets_left_rem;
 2656|       |
 2657|      0|                    const uint32_t num_packets = n_packets;
 2658|      0|                    const double rem = n_packets - (double)num_packets;
 2659|       |
 2660|      0|                    if (conn->packets_left > num_packets * 4 + CRYPTO_MIN_QUEUE_LENGTH) {
  ------------------
  |  |  100|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
  |  Branch (2660:25): [True: 0, False: 0]
  ------------------
 2661|      0|                        conn->packets_left = num_packets * 4 + CRYPTO_MIN_QUEUE_LENGTH;
  ------------------
  |  |  100|      0|#define CRYPTO_MIN_QUEUE_LENGTH 64
  ------------------
 2662|      0|                    } else {
 2663|      0|                        conn->packets_left += num_packets;
 2664|      0|                    }
 2665|       |
 2666|      0|                    conn->last_packets_left_set = temp_time;
 2667|      0|                    conn->last_packets_left_rem = rem;
 2668|      0|                }
 2669|       |
 2670|      0|                if (((uint64_t)((1000.0 / conn->packet_send_rate_requested) + 0.5) + conn->last_packets_left_requested_set) <=
  ------------------
  |  Branch (2670:21): [True: 0, False: 0]
  ------------------
 2671|      0|                        temp_time) {
 2672|      0|                    double n_packets = conn->packet_send_rate_requested * (((double)(temp_time - conn->last_packets_left_requested_set)) /
 2673|      0|                                       1000.0);
 2674|      0|                    n_packets += conn->last_packets_left_requested_rem;
 2675|       |
 2676|      0|                    const uint32_t num_packets = n_packets;
 2677|      0|                    const double rem = n_packets - (double)num_packets;
 2678|      0|                    conn->packets_left_requested = num_packets;
 2679|       |
 2680|      0|                    conn->last_packets_left_requested_set = temp_time;
 2681|      0|                    conn->last_packets_left_requested_rem = rem;
 2682|      0|                }
 2683|       |
 2684|      0|                if (conn->packets_left > conn->packets_left_requested) {
  ------------------
  |  Branch (2684:21): [True: 0, False: 0]
  ------------------
 2685|      0|                    conn->packets_left_requested = conn->packets_left;
 2686|      0|                }
 2687|      0|            }
 2688|       |
 2689|      0|            const int ret = send_requested_packets(c, i, conn->packets_left_requested);
 2690|       |
 2691|      0|            if (ret != -1) {
  ------------------
  |  Branch (2691:17): [True: 0, False: 0]
  ------------------
 2692|      0|                conn->packets_left_requested -= ret;
 2693|      0|                conn->packets_resent += ret;
 2694|       |
 2695|      0|                if ((unsigned int)ret < conn->packets_left) {
  ------------------
  |  Branch (2695:21): [True: 0, False: 0]
  ------------------
 2696|      0|                    conn->packets_left -= ret;
 2697|      0|                } else {
 2698|      0|                    conn->last_congestion_event = temp_time;
 2699|      0|                    conn->packets_left = 0;
 2700|      0|                }
 2701|      0|            }
 2702|       |
 2703|      0|            if (conn->packet_send_rate > CRYPTO_PACKET_MIN_RATE * 1.5) {
  ------------------
  |  |   97|      0|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2703:17): [True: 0, False: 0]
  ------------------
 2704|      0|                total_send_rate += conn->packet_send_rate;
 2705|      0|            }
 2706|      0|        }
 2707|      0|    }
 2708|       |
 2709|     82|    c->current_sleep_time = -1;
 2710|     82|    uint32_t sleep_time = peak_request_packet_interval;
 2711|       |
 2712|     82|    if (c->current_sleep_time > sleep_time) {
  ------------------
  |  Branch (2712:9): [True: 0, False: 82]
  ------------------
 2713|      0|        c->current_sleep_time = sleep_time;
 2714|      0|    }
 2715|       |
 2716|     82|    if (total_send_rate > CRYPTO_PACKET_MIN_RATE) {
  ------------------
  |  |   97|     82|#define CRYPTO_PACKET_MIN_RATE 4.0
  ------------------
  |  Branch (2716:9): [True: 0, False: 82]
  ------------------
 2717|      0|        sleep_time = 1000.0 / total_send_rate;
 2718|       |
 2719|      0|        if (c->current_sleep_time > sleep_time) {
  ------------------
  |  Branch (2719:13): [True: 0, False: 0]
  ------------------
 2720|      0|            c->current_sleep_time = sleep_time + 1;
 2721|      0|        }
 2722|      0|    }
 2723|       |
 2724|     82|    sleep_time = CRYPTO_SEND_PACKET_INTERVAL;
  ------------------
  |  |  111|     82|#define CRYPTO_SEND_PACKET_INTERVAL 1000
  ------------------
 2725|       |
 2726|     82|    if (c->current_sleep_time > sleep_time) {
  ------------------
  |  Branch (2726:9): [True: 82, False: 0]
  ------------------
 2727|     82|        c->current_sleep_time = sleep_time;
 2728|     82|    }
 2729|     82|}

net_log_data:
  155|    713|{
  156|    713|    if (res < 0) { /* Windows doesn't necessarily know `%zu` */
  ------------------
  |  Branch (156:9): [True: 88, False: 625]
  ------------------
  157|     88|        Ip_Ntoa ip_str;
  158|     88|        const int error = net_error();
  159|     88|        Net_Strerror error_str;
  160|     88|        LOGGER_TRACE(log, "[%02x = %-21s] %s %3u%c %s:%u (%d: %s) | %08x%08x...%02x",
  ------------------
  |  |   76|     88|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     88|    do {                                                                         \
  |  |  |  |   70|     88|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    176|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 88]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     88|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 88]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  161|     88|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  162|     88|                     min_u16(buflen, 999), 'E',
  163|     88|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), error,
  164|     88|                     net_strerror(error, &error_str), data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  165|    625|    } else if ((res > 0) && ((size_t)res <= buflen)) {
  ------------------
  |  Branch (165:16): [True: 625, False: 0]
  |  Branch (165:29): [True: 625, False: 0]
  ------------------
  166|    625|        Ip_Ntoa ip_str;
  167|    625|        LOGGER_TRACE(log, "[%02x = %-21s] %s %3u%c %s:%u (%d: %s) | %08x%08x...%02x",
  ------------------
  |  |   76|    625|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|    625|    do {                                                                         \
  |  |  |  |   70|    625|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|  1.25k|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 625]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (71:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|    625|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 625]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  168|    625|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  169|    625|                     min_u16(res, 999), (size_t)res < buflen ? '<' : '=',
  170|    625|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
  171|    625|                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  172|    625|    } else { /* empty or overwrite */
  173|      0|        Ip_Ntoa ip_str;
  174|      0|        LOGGER_TRACE(log, "[%02x = %-21s] %s %ld%c%u %s:%u (%d: %s) | %08x%08x...%02x",
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (71:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  175|      0|                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
  176|      0|                     res, res == 0 ? '!' : '>', buflen,
  177|      0|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
  178|      0|                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
  179|      0|    }
  180|    713|}

netprof_record_packet:
   72|    625|{
   73|    625|    if (profile == nullptr) {
  ------------------
  |  |   63|    625|#define nullptr NULL
  ------------------
  |  Branch (73:9): [True: 0, False: 625]
  ------------------
   74|      0|        return;
   75|      0|    }
   76|       |
   77|    625|    if (dir == PACKET_DIRECTION_SEND) {
  ------------------
  |  Branch (77:9): [True: 625, False: 0]
  ------------------
   78|    625|        ++profile->total_packets_sent;
   79|    625|        ++profile->packets_sent[id];
   80|       |
   81|    625|        profile->total_bytes_sent += length;
   82|    625|        profile->bytes_sent[id] += length;
   83|    625|    } else {
   84|      0|        ++profile->total_packets_recv;
   85|      0|        ++profile->packets_recv[id];
   86|       |
   87|      0|        profile->total_bytes_recv += length;
   88|      0|        profile->bytes_recv[id] += length;
   89|      0|    }
   90|    625|}
netprof_new:
  139|    429|{
  140|    429|    Net_Profile *np = (Net_Profile *)mem_alloc(mem, sizeof(Net_Profile));
  141|       |
  142|    429|    if (np == nullptr) {
  ------------------
  |  |   63|    429|#define nullptr NULL
  ------------------
  |  Branch (142:9): [True: 3, False: 426]
  ------------------
  143|      3|        LOGGER_ERROR(log, "failed to allocate memory for net profiler");
  ------------------
  |  |   80|      3|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      3|    do {                                                                         \
  |  |  |  |   70|      3|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      6|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 3, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      3|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      3|        }                                                                        \
  |  |  |  |   73|      3|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 3]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  144|      3|        return nullptr;
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
  145|      3|    }
  146|       |
  147|    426|    return np;
  148|    429|}
netprof_kill:
  151|    547|{
  152|    547|    if (net_profile != nullptr) {
  ------------------
  |  |   63|    547|#define nullptr NULL
  ------------------
  |  Branch (152:9): [True: 426, False: 121]
  ------------------
  153|    426|        mem_delete(mem, net_profile);
  154|    426|    }
  155|    547|}

get_ip6_broadcast:
   41|    297|{
   42|    297|    return net_get_ip6_broadcast();
   43|    297|}
get_ip4_loopback:
   46|     36|{
   47|     36|    return net_get_ip4_loopback();
   48|     36|}
sock_valid:
   56|    439|{
   57|    439|    const Socket invalid_socket = net_invalid_socket();
   58|    439|    return sock.value != invalid_socket.value;
   59|    439|}
net_send:
   63|     88|{
   64|     88|    const int res = ns_send(ns, sock, buf, len);
   65|       |
   66|     88|    if (res > 0) {
  ------------------
  |  Branch (66:9): [True: 0, False: 88]
  ------------------
   67|      0|        netprof_record_packet(net_profile, buf[0], res, PACKET_DIRECTION_SEND);
   68|      0|    }
   69|       |
   70|     88|    net_log_data(log, "T=>", buf, len, ip_port, res);
   71|     88|    return res;
   72|     88|}
net_listen:
   83|    135|{
   84|    135|    return ns_listen(ns, sock, backlog);
   85|    135|}
kill_sock:
   94|    205|{
   95|    205|    ns_close(ns, sock);
   96|    205|}
set_socket_nonblock:
   99|    304|{
  100|    304|    return net_set_socket_nonblock(ns, sock);
  101|    304|}
set_socket_nosigpipe:
  104|    169|{
  105|    169|    return net_set_socket_nosigpipe(ns, sock);
  106|    169|}
set_socket_reuseaddr:
  109|    135|{
  110|    135|    return net_set_socket_reuseaddr(ns, sock);
  111|    135|}
set_socket_dualstack:
  114|    226|{
  115|    226|    return net_set_socket_dualstack(ns, sock);
  116|    226|}
net_family:
  138|    814|{
  139|    814|    return net->family;
  140|    814|}
net_send_packet:
  151|    625|{
  152|    625|    IP_Port ipp_copy = *ip_port;
  153|       |
  154|    625|    if (net_family_is_unspec(ip_port->ip.family)) {
  ------------------
  |  Branch (154:9): [True: 0, False: 625]
  ------------------
  155|       |        // TODO(iphydf): Make this an error. Currently this fails sometimes when
  156|       |        // called from DHT.c:do_ping_and_sendnode_requests.
  157|      0|        return -1;
  158|      0|    }
  159|       |
  160|    625|    if (net_family_is_unspec(net->family)) { /* Socket not initialized */
  ------------------
  |  Branch (160:9): [True: 0, False: 625]
  ------------------
  161|       |        // TODO(iphydf): Make this an error. Currently, the onion client calls
  162|       |        // this via DHT nodes requests.
  163|      0|        LOGGER_WARNING(net->log, "attempted to send message of length %u on uninitialised socket", packet.length);
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  164|      0|        return -1;
  165|      0|    }
  166|       |
  167|       |    /* socket TOX_AF_INET, but target IP NOT: can't send */
  168|    625|    if (net_family_is_ipv4(net->family) && !net_family_is_ipv4(ipp_copy.ip.family)) {
  ------------------
  |  Branch (168:9): [True: 0, False: 625]
  |  Branch (168:44): [True: 0, False: 0]
  ------------------
  169|       |        // TODO(iphydf): Make this an error. Occasionally we try to send to an
  170|       |        // all-zero ip_port.
  171|      0|        Ip_Ntoa ip_str;
  172|      0|        LOGGER_WARNING(net->log, "attempted to send message with network family %d (probably IPv6) on IPv4 socket (%s)",
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  173|      0|                       ipp_copy.ip.family.value, net_ip_ntoa(&ipp_copy.ip, &ip_str));
  174|      0|        return -1;
  175|      0|    }
  176|       |
  177|    625|    if (net_family_is_ipv4(ipp_copy.ip.family) && net_family_is_ipv6(net->family)) {
  ------------------
  |  Branch (177:9): [True: 31, False: 594]
  |  Branch (177:51): [True: 31, False: 0]
  ------------------
  178|       |        /* must convert to IPV4-in-IPV6 address */
  179|     31|        IP6 ip6;
  180|       |
  181|       |        /* there should be a macro for this in a standards compliant
  182|       |         * environment, not found */
  183|     31|        ip6.uint32[0] = 0;
  184|     31|        ip6.uint32[1] = 0;
  185|     31|        ip6.uint32[2] = net_htonl(0xFFFF);
  186|     31|        ip6.uint32[3] = ipp_copy.ip.ip.v4.uint32;
  187|       |
  188|     31|        ipp_copy.ip.family = net_family_ipv6();
  189|     31|        ipp_copy.ip.ip.v6 = ip6;
  190|     31|    }
  191|       |
  192|    625|    const long res = ns_sendto(net->ns, net->sock, packet.data, packet.length, &ipp_copy);
  193|    625|    net_log_data(net->log, "O=>", packet.data, packet.length, ip_port, res);
  194|       |
  195|    625|    assert(res <= INT_MAX);
  ------------------
  |  Branch (195:5): [True: 625, False: 0]
  ------------------
  196|       |
  197|    625|    if (res == packet.length && packet.data != nullptr) {
  ------------------
  |  |   63|    625|#define nullptr NULL
  ------------------
  |  Branch (197:9): [True: 625, False: 0]
  |  Branch (197:33): [True: 625, False: 0]
  ------------------
  198|    625|        netprof_record_packet(net->udp_net_profile, packet.data[0], packet.length, PACKET_DIRECTION_SEND);
  199|    625|    }
  200|       |
  201|    625|    return (int)res;
  202|    625|}
sendpacket:
  210|    625|{
  211|    625|    const Net_Packet packet = {data, length};
  212|    625|    return net_send_packet(net, ip_port, packet);
  213|    625|}
networking_registerhandler:
  251|  11.8k|{
  252|  11.8k|    net->packethandlers[byte].function = cb;
  253|  11.8k|    net->packethandlers[byte].object = object;
  254|  11.8k|}
networking_poll:
  257|     65|{
  258|     65|    if (net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (258:9): [True: 0, False: 65]
  ------------------
  259|       |        /* Socket not initialized */
  260|      0|        return;
  261|      0|    }
  262|       |
  263|     65|    IP_Port ip_port;
  264|     65|    uint8_t data[MAX_UDP_PACKET_SIZE] = {0};
  265|     65|    uint32_t length;
  266|       |
  267|     65|    while (receivepacket(net->ns, net->log, net->sock, &ip_port, data, &length) != -1) {
  ------------------
  |  Branch (267:12): [True: 0, False: 65]
  ------------------
  268|      0|        if (length < 1) {
  ------------------
  |  Branch (268:13): [True: 0, False: 0]
  ------------------
  269|      0|            continue;
  270|      0|        }
  271|       |
  272|      0|        netprof_record_packet(net->udp_net_profile, data[0], length, PACKET_DIRECTION_RECV);
  273|       |
  274|      0|        const Packet_Handler *const handler = &net->packethandlers[data[0]];
  275|       |
  276|      0|        if (handler->function == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (276:13): [True: 0, False: 0]
  ------------------
  277|       |            // TODO(https://github.com/TokTok/c-toxcore/issues/1115): Make this
  278|       |            // a warning or error again.
  279|      0|            LOGGER_DEBUG(net->log, "[%02u] -- Packet has no handler", data[0]);
  ------------------
  |  |   77|      0|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  280|      0|            continue;
  281|      0|        }
  282|       |
  283|      0|        handler->function(handler->object, &ip_port, data, length, userdata);
  284|      0|    }
  285|     65|}
new_networking_ex:
  300|     93|{
  301|       |    /* If both from and to are 0, use default port range
  302|       |     * If one is 0 and the other is non-0, use the non-0 value as only port
  303|       |     * If from > to, swap
  304|       |     */
  305|     93|    if (port_from == 0 && port_to == 0) {
  ------------------
  |  Branch (305:9): [True: 93, False: 0]
  |  Branch (305:27): [True: 93, False: 0]
  ------------------
  306|     93|        port_from = TOX_PORTRANGE_FROM;
  ------------------
  |  |   79|     93|#define TOX_PORTRANGE_FROM 33445
  ------------------
  307|     93|        port_to = TOX_PORTRANGE_TO;
  ------------------
  |  |   80|     93|#define TOX_PORTRANGE_TO   33545
  ------------------
  308|     93|    } else if (port_from == 0 && port_to != 0) {
  ------------------
  |  Branch (308:16): [True: 0, False: 0]
  |  Branch (308:34): [True: 0, False: 0]
  ------------------
  309|      0|        port_from = port_to;
  310|      0|    } else if (port_from != 0 && port_to == 0) {
  ------------------
  |  Branch (310:16): [True: 0, False: 0]
  |  Branch (310:34): [True: 0, False: 0]
  ------------------
  311|      0|        port_to = port_from;
  312|      0|    } else if (port_from > port_to) {
  ------------------
  |  Branch (312:16): [True: 0, False: 0]
  ------------------
  313|      0|        const uint16_t temp_port = port_from;
  314|      0|        port_from = port_to;
  315|      0|        port_to = temp_port;
  316|      0|    }
  317|       |
  318|     93|    if (error != nullptr) {
  ------------------
  |  |   63|     93|#define nullptr NULL
  ------------------
  |  Branch (318:9): [True: 93, False: 0]
  ------------------
  319|     93|        *error = 2;
  320|     93|    }
  321|       |
  322|       |    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
  323|     93|    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (323:9): [True: 93, False: 0]
  |  Branch (323:44): [True: 0, False: 93]
  ------------------
  324|      0|        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  325|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  326|      0|    }
  327|       |
  328|     93|    Networking_Core *temp = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
  329|       |
  330|     93|    if (temp == nullptr) {
  ------------------
  |  |   63|     93|#define nullptr NULL
  ------------------
  |  Branch (330:9): [True: 1, False: 92]
  ------------------
  331|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  332|      1|    }
  333|       |
  334|     92|    Net_Profile *np = netprof_new(log, mem);
  335|       |
  336|     92|    if (np == nullptr) {
  ------------------
  |  |   63|     92|#define nullptr NULL
  ------------------
  |  Branch (336:9): [True: 1, False: 91]
  ------------------
  337|      1|        mem_delete(mem, temp);
  338|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  339|      1|    }
  340|       |
  341|     91|    temp->udp_net_profile = np;
  342|     91|    temp->ns = ns;
  343|     91|    temp->log = log;
  344|     91|    temp->mem = mem;
  345|     91|    temp->family = ip->family;
  346|     91|    temp->port = 0;
  347|       |
  348|       |    /* Initialize our socket. */
  349|       |    /* add log message what we're creating */
  350|     91|    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |   71|     91|#define TOX_SOCK_DGRAM 2
  ------------------
                  temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |   74|     91|#define TOX_PROTO_UDP 2
  ------------------
  351|       |
  352|       |    /* Check for socket error. */
  353|     91|    if (!sock_valid(temp->sock)) {
  ------------------
  |  Branch (353:9): [True: 0, False: 91]
  ------------------
  354|      0|        const int neterror = net_error();
  355|      0|        Net_Strerror error_str;
  356|      0|        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  357|      0|        netprof_kill(mem, temp->udp_net_profile);
  358|      0|        mem_delete(mem, temp);
  359|       |
  360|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (360:13): [True: 0, False: 0]
  ------------------
  361|      0|            *error = 1;
  362|      0|        }
  363|       |
  364|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  365|      0|    }
  366|       |
  367|       |    /* Functions to increase the size of the send and receive UDP buffers.
  368|       |     */
  369|     91|    if (!net_set_socket_buffer_size(ns, temp->sock, 1024 * 1024 * 2)) {
  ------------------
  |  Branch (369:9): [True: 0, False: 91]
  ------------------
  370|      0|        LOGGER_WARNING(log, "failed to set socket buffer size");
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  371|      0|    }
  372|       |
  373|       |    /* Enable broadcast on socket */
  374|     91|    if (!net_set_socket_broadcast(ns, temp->sock)) {
  ------------------
  |  Branch (374:9): [True: 0, False: 91]
  ------------------
  375|      0|        LOGGER_ERROR(log, "failed to set socket broadcast");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  376|      0|    }
  377|       |
  378|       |    /* iOS UDP sockets are weird and apparently can SIGPIPE */
  379|     91|    if (!set_socket_nosigpipe(ns, temp->sock)) {
  ------------------
  |  Branch (379:9): [True: 0, False: 91]
  ------------------
  380|      0|        kill_networking(temp);
  381|       |
  382|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (382:13): [True: 0, False: 0]
  ------------------
  383|      0|            *error = 1;
  384|      0|        }
  385|       |
  386|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  387|      0|    }
  388|       |
  389|       |    /* Set socket nonblocking. */
  390|     91|    if (!set_socket_nonblock(ns, temp->sock)) {
  ------------------
  |  Branch (390:9): [True: 0, False: 91]
  ------------------
  391|      0|        kill_networking(temp);
  392|       |
  393|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (393:13): [True: 0, False: 0]
  ------------------
  394|      0|            *error = 1;
  395|      0|        }
  396|       |
  397|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  398|      0|    }
  399|       |
  400|       |    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
  401|     91|    uint16_t *portptr = nullptr;
  ------------------
  |  |   63|     91|#define nullptr NULL
  ------------------
  402|     91|    IP_Port addr;
  403|     91|    ip_init(&addr.ip, net_family_is_ipv6(temp->family));
  404|       |
  405|     91|    if (net_family_is_ipv4(temp->family) || net_family_is_ipv6(temp->family)) {
  ------------------
  |  Branch (405:9): [True: 0, False: 91]
  |  Branch (405:45): [True: 91, False: 0]
  ------------------
  406|     91|        ip_copy(&addr.ip, ip);
  407|     91|        addr.port = 0;
  408|     91|        portptr = &addr.port;
  409|     91|    } else {
  410|      0|        mem_delete(mem, temp);
  411|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  412|      0|    }
  413|       |
  414|     91|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (414:9): [True: 91, False: 0]
  ------------------
  415|     91|        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);
  416|       |
  417|     91|        if (is_dualstack) {
  ------------------
  |  Branch (417:13): [True: 91, False: 0]
  ------------------
  418|     91|            LOGGER_TRACE(log, "Dual-stack socket: enabled");
  ------------------
  |  |   76|     91|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     91|    do {                                                                         \
  |  |  |  |   70|     91|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    182|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 91]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     91|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 91]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  419|     91|        } else {
  420|      0|            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  421|      0|        }
  422|       |
  423|     91|        if (!net_join_multicast(ns, temp->sock, ip->family)) {
  ------------------
  |  Branch (423:13): [True: 0, False: 91]
  ------------------
  424|      0|            const int neterror = net_error();
  425|      0|            Net_Strerror error_str;
  426|      0|            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   78|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  427|     91|        } else {
  428|     91|            const int neterror = net_error();
  429|     91|            Net_Strerror error_str;
  430|     91|            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   76|     91|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     91|    do {                                                                         \
  |  |  |  |   70|     91|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    182|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 91]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     91|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 91]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  431|     91|        }
  432|     91|    }
  433|       |
  434|       |    /* A hanging program or a different user might block the standard port.
  435|       |     * As long as it isn't a parameter coming from the commandline,
  436|       |     * try a few ports after it, to see if we can find a "free" one.
  437|       |     *
  438|       |     * If we go on without binding, the first sendto() automatically binds to
  439|       |     * a free port chosen by the system (i.e. anything from 1024 to 65535).
  440|       |     *
  441|       |     * Returning NULL after bind fails has both advantages and disadvantages:
  442|       |     * advantage:
  443|       |     *   we can rely on getting the port in the range 33445..33450, which
  444|       |     *   enables us to tell joe user to open their firewall to a small range
  445|       |     *
  446|       |     * disadvantage:
  447|       |     *   some clients might not test return of tox_new(), blindly assuming that
  448|       |     *   it worked ok (which it did previously without a successful bind)
  449|       |     */
  450|     91|    uint16_t port_to_try = port_from;
  451|     91|    *portptr = net_htons(port_to_try);
  452|       |
  453|    182|    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
  ------------------
  |  Branch (453:38): [True: 182, False: 0]
  ------------------
  454|    182|        const int res = ns_bind(ns, temp->sock, &addr);
  455|       |
  456|    182|        if (res == 0) {
  ------------------
  |  Branch (456:13): [True: 91, False: 91]
  ------------------
  457|     91|            temp->port = *portptr;
  458|       |
  459|     91|            Ip_Ntoa ip_str;
  460|     91|            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
  ------------------
  |  |   77|     91|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     91|    do {                                                                         \
  |  |  |  |   70|     91|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|    182|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 91]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     91|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 91]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  461|     91|                         net_ntohs(temp->port));
  462|       |
  463|       |            /* errno isn't reset on success, only set on failure, the failed
  464|       |             * binds with parallel clients yield a -EPERM to the outside if
  465|       |             * errno isn't cleared here */
  466|     91|            if (tries > 0) {
  ------------------
  |  Branch (466:17): [True: 91, False: 0]
  ------------------
  467|     91|                net_clear_error();
  468|     91|            }
  469|       |
  470|     91|            if (error != nullptr) {
  ------------------
  |  |   63|     91|#define nullptr NULL
  ------------------
  |  Branch (470:17): [True: 91, False: 0]
  ------------------
  471|     91|                *error = 0;
  472|     91|            }
  473|       |
  474|     91|            return temp;
  475|     91|        }
  476|       |
  477|     91|        ++port_to_try;
  478|       |
  479|     91|        if (port_to_try > port_to) {
  ------------------
  |  Branch (479:13): [True: 0, False: 91]
  ------------------
  480|      0|            port_to_try = port_from;
  481|      0|        }
  482|       |
  483|     91|        *portptr = net_htons(port_to_try);
  484|     91|    }
  485|       |
  486|      0|    Ip_Ntoa ip_str;
  487|      0|    const int neterror = net_error();
  488|      0|    Net_Strerror error_str;
  489|      0|    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u",
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  490|      0|                 neterror, net_strerror(neterror, &error_str), net_ip_ntoa(ip, &ip_str), port_from, port_to);
  491|      0|    kill_networking(temp);
  492|       |
  493|      0|    if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (493:9): [True: 0, False: 0]
  ------------------
  494|      0|        *error = 1;
  495|      0|    }
  496|       |
  497|       |    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  498|     91|}
new_networking_no_udp:
  501|    122|{
  502|       |    /* this is the easiest way to completely disable UDP without changing too much code. */
  503|    122|    Networking_Core *net = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
  504|       |
  505|    122|    if (net == nullptr) {
  ------------------
  |  |   63|    122|#define nullptr NULL
  ------------------
  |  Branch (505:9): [True: 1, False: 121]
  ------------------
  506|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  507|      1|    }
  508|       |
  509|    121|    net->ns = ns;
  510|    121|    net->log = log;
  511|    121|    net->mem = mem;
  512|       |
  513|    121|    return net;
  514|    122|}
kill_networking:
  518|    212|{
  519|    212|    if (net == nullptr) {
  ------------------
  |  |   63|    212|#define nullptr NULL
  ------------------
  |  Branch (519:9): [True: 0, False: 212]
  ------------------
  520|      0|        return;
  521|      0|    }
  522|       |
  523|    212|    if (!net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (523:9): [True: 91, False: 121]
  ------------------
  524|       |        /* Socket is initialized, so we close it. */
  525|     91|        kill_sock(net->ns, net->sock);
  526|     91|    }
  527|       |
  528|    212|    netprof_kill(net->mem, net->udp_net_profile);
  529|    212|    mem_delete(net->mem, net);
  530|    212|}
ip_reset:
  635|  3.12k|{
  636|  3.12k|    if (ip == nullptr) {
  ------------------
  |  |   63|  3.12k|#define nullptr NULL
  ------------------
  |  Branch (636:9): [True: 0, False: 3.12k]
  ------------------
  637|      0|        return;
  638|      0|    }
  639|       |
  640|  3.12k|    *ip = empty_ip;
  641|  3.12k|}
ipport_reset:
  647|    213|{
  648|    213|    if (ipport == nullptr) {
  ------------------
  |  |   63|    213|#define nullptr NULL
  ------------------
  |  Branch (648:9): [True: 0, False: 213]
  ------------------
  649|      0|        return;
  650|      0|    }
  651|       |
  652|    213|    *ipport = empty_ip_port;
  653|    213|}
ip_init:
  657|  2.42k|{
  658|  2.42k|    if (ip == nullptr) {
  ------------------
  |  |   63|  2.42k|#define nullptr NULL
  ------------------
  |  Branch (658:9): [True: 0, False: 2.42k]
  ------------------
  659|      0|        return;
  660|      0|    }
  661|       |
  662|  2.42k|    ip_reset(ip);
  663|  2.42k|    ip->family = ipv6enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (663:18): [True: 442, False: 1.97k]
  ------------------
  664|  2.42k|}
ip_isset:
  668|  98.4k|{
  669|  98.4k|    if (ip == nullptr) {
  ------------------
  |  |   63|  98.4k|#define nullptr NULL
  ------------------
  |  Branch (669:9): [True: 0, False: 98.4k]
  ------------------
  670|      0|        return false;
  671|      0|    }
  672|       |
  673|  98.4k|    return !net_family_is_unspec(ip->family);
  674|  98.4k|}
ip_copy:
  692|     91|{
  693|     91|    if (source == nullptr || target == nullptr) {
  ------------------
  |  |   63|    182|#define nullptr NULL
  ------------------
                  if (source == nullptr || target == nullptr) {
  ------------------
  |  |   63|     91|#define nullptr NULL
  ------------------
  |  Branch (693:9): [True: 0, False: 91]
  |  Branch (693:30): [True: 0, False: 91]
  ------------------
  694|      0|        return;
  695|      0|    }
  696|       |
  697|     91|    *target = *source;
  698|     91|}
bin_pack_ip_port:
  740|     72|{
  741|     72|    bool is_ipv4;
  742|     72|    uint8_t family;
  743|       |
  744|     72|    if (net_family_is_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (744:9): [True: 72, False: 0]
  ------------------
  745|       |        // TODO(irungentoo): use functions to convert endianness
  746|     72|        is_ipv4 = true;
  747|     72|        family = TOX_AF_INET;
  ------------------
  |  |   65|     72|#define TOX_AF_INET 2
  ------------------
  748|     72|    } else if (net_family_is_tcp_ipv4(ip_port->ip.family)) {
  ------------------
  |  Branch (748:16): [True: 0, False: 0]
  ------------------
  749|      0|        is_ipv4 = true;
  750|      0|        family = TOX_TCP_INET;
  ------------------
  |  |   67|      0|#define TOX_TCP_INET 130
  ------------------
  751|      0|    } else if (net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (751:16): [True: 0, False: 0]
  ------------------
  752|      0|        is_ipv4 = false;
  753|      0|        family = TOX_AF_INET6;
  ------------------
  |  |   66|      0|#define TOX_AF_INET6 10
  ------------------
  754|      0|    } else if (net_family_is_tcp_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (754:16): [True: 0, False: 0]
  ------------------
  755|      0|        is_ipv4 = false;
  756|      0|        family = TOX_TCP_INET6;
  ------------------
  |  |   68|      0|#define TOX_TCP_INET6 138
  ------------------
  757|      0|    } else {
  758|      0|        Ip_Ntoa ip_str;
  759|       |        // TODO(iphydf): Find out why we're trying to pack invalid IPs, stop
  760|       |        // doing that, and turn this into an error.
  761|      0|        LOGGER_TRACE(logger, "cannot pack invalid IP: %s", net_ip_ntoa(&ip_port->ip, &ip_str));
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  762|      0|        return false;
  763|      0|    }
  764|       |
  765|     72|    return bin_pack_u08_b(bp, family)
  ------------------
  |  Branch (765:12): [True: 72, False: 0]
  ------------------
  766|     72|           && bin_pack_ip(bp, &ip_port->ip, is_ipv4)
  ------------------
  |  Branch (766:15): [True: 72, False: 0]
  ------------------
  767|     72|           && bin_pack_u16_b(bp, net_ntohs(ip_port->port));
  ------------------
  |  Branch (767:15): [True: 72, False: 0]
  ------------------
  768|     72|}
ip_parse_addr:
  879|     11|{
  880|     11|    if (address == nullptr || ip == nullptr) {
  ------------------
  |  |   63|     22|#define nullptr NULL
  ------------------
                  if (address == nullptr || ip == nullptr) {
  ------------------
  |  |   63|     11|#define nullptr NULL
  ------------------
  |  Branch (880:9): [True: 0, False: 11]
  |  Branch (880:31): [True: 0, False: 11]
  ------------------
  881|      0|        return false;
  882|      0|    }
  883|       |
  884|     11|    if (net_family_is_ipv4(ip->family) || net_family_is_tcp_ipv4(ip->family)) {
  ------------------
  |  Branch (884:9): [True: 11, False: 0]
  |  Branch (884:43): [True: 0, False: 0]
  ------------------
  885|     11|        return net_inet_ntop4(&ip->ip.v4, address, length) != nullptr;
  ------------------
  |  |   63|     11|#define nullptr NULL
  ------------------
  886|     11|    }
  887|       |
  888|      0|    if (net_family_is_ipv6(ip->family) || net_family_is_tcp_ipv6(ip->family)) {
  ------------------
  |  Branch (888:9): [True: 0, False: 0]
  |  Branch (888:43): [True: 0, False: 0]
  ------------------
  889|      0|        return net_inet_ntop6(&ip->ip.v6, address, length) != nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  890|      0|    }
  891|       |
  892|      0|    return false;
  893|      0|}
addr_parse_ip:
  896|    255|{
  897|    255|    if (address == nullptr || to == nullptr) {
  ------------------
  |  |   63|    510|#define nullptr NULL
  ------------------
                  if (address == nullptr || to == nullptr) {
  ------------------
  |  |   63|    255|#define nullptr NULL
  ------------------
  |  Branch (897:9): [True: 0, False: 255]
  |  Branch (897:31): [True: 0, False: 255]
  ------------------
  898|      0|        return false;
  899|      0|    }
  900|       |
  901|    255|    if (net_inet_pton4(address, &to->ip.v4) == 1) {
  ------------------
  |  Branch (901:9): [True: 255, False: 0]
  ------------------
  902|    255|        to->family = net_family_ipv4();
  903|    255|        return true;
  904|    255|    }
  905|       |
  906|      0|    if (net_inet_pton6(address, &to->ip.v6) == 1) {
  ------------------
  |  Branch (906:9): [True: 0, False: 0]
  ------------------
  907|      0|        to->family = net_family_ipv6();
  908|      0|        return true;
  909|      0|    }
  910|       |
  911|      0|    return false;
  912|      0|}
addr_resolve_or_parse_ip:
 1008|    123|{
 1009|    123|    if (dns_enabled && addr_resolve(ns, mem, address, to, extra)) {
  ------------------
  |  Branch (1009:9): [True: 123, False: 0]
  |  Branch (1009:24): [True: 0, False: 123]
  ------------------
 1010|      0|        return true;
 1011|      0|    }
 1012|       |
 1013|    123|    return addr_parse_ip(address, to);
 1014|    123|}
net_connect:
 1031|     78|{
 1032|     78|    if (!(net_family_is_ipv4(ip_port->ip.family) || net_family_is_ipv6(ip_port->ip.family))) {
  ------------------
  |  Branch (1032:11): [True: 78, False: 0]
  |  Branch (1032:53): [True: 0, False: 0]
  ------------------
 1033|      0|        Ip_Ntoa ip_str;
 1034|      0|        LOGGER_ERROR(log, "cannot connect to %s:%d which is neither IPv4 nor IPv6",
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1035|      0|                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port));
 1036|      0|        *err = NET_ERR_CONNECT_INVALID_FAMILY;
 1037|      0|        return false;
 1038|      0|    }
 1039|       |
 1040|     78|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
 1041|     78|    if ((true)) {
  ------------------
  |  Branch (1041:9): [True: 78, Folded]
  ------------------
 1042|     78|        *err = NET_ERR_CONNECT_OK;
 1043|     78|        return true;
 1044|     78|    }
 1045|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
 1046|       |
 1047|      0|    Ip_Ntoa ip_str;
 1048|      0|    LOGGER_DEBUG(log, "connecting socket %d to %s:%d",
  ------------------
  |  |   77|      0|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1049|      0|                 net_socket_to_native(sock), net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port));
 1050|      0|    net_clear_error();
 1051|       |
 1052|      0|    if (ns_connect(ns, sock, ip_port) == -1) {
  ------------------
  |  Branch (1052:9): [True: 0, False: 0]
  ------------------
 1053|      0|        const int error = net_error();
 1054|       |
 1055|       |        // Non-blocking socket: "Operation in progress" means it's connecting.
 1056|      0|        if (!net_should_ignore_connect_error(error)) {
  ------------------
  |  Branch (1056:13): [True: 0, False: 0]
  ------------------
 1057|      0|            Net_Strerror error_str;
 1058|      0|            LOGGER_WARNING(log, "failed to connect to %s:%d: %d (%s)",
  ------------------
  |  |   79|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1059|      0|                           net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), error, net_strerror(error, &error_str));
 1060|      0|            *err = NET_ERR_CONNECT_FAILED;
 1061|      0|            return false;
 1062|      0|        }
 1063|      0|    }
 1064|       |
 1065|      0|    *err = NET_ERR_CONNECT_OK;
 1066|       |    return true;
 1067|      0|}
net_getipport:
 1070|    132|{
 1071|    132|    assert(node != nullptr);
  ------------------
  |  Branch (1071:5): [True: 132, False: 0]
  ------------------
 1072|       |
 1073|       |    // Try parsing as IP address first.
 1074|    132|    IP_Port parsed = {{{0}}};
 1075|       |    // Initialise to nullptr. In error paths, at least we initialise the out
 1076|       |    // parameter.
 1077|    132|    *res = nullptr;
  ------------------
  |  |   63|    132|#define nullptr NULL
  ------------------
 1078|       |
 1079|    132|    if (addr_parse_ip(node, &parsed.ip)) {
  ------------------
  |  Branch (1079:9): [True: 132, False: 0]
  ------------------
 1080|    132|        IP_Port *tmp = (IP_Port *)mem_alloc(mem, sizeof(IP_Port));
 1081|       |
 1082|    132|        if (tmp == nullptr) {
  ------------------
  |  |   63|    132|#define nullptr NULL
  ------------------
  |  Branch (1082:13): [True: 16, False: 116]
  ------------------
 1083|     16|            return -1;
 1084|     16|        }
 1085|       |
 1086|    116|        tmp[0] = parsed;
 1087|    116|        *res = tmp;
 1088|    116|        return 1;
 1089|    132|    }
 1090|       |
 1091|      0|    if (!dns_enabled) {
  ------------------
  |  Branch (1091:9): [True: 0, False: 0]
  ------------------
 1092|      0|        return -1;
 1093|      0|    }
 1094|       |
 1095|      0|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
 1096|      0|    if ((true)) {
  ------------------
  |  Branch (1096:9): [True: 0, Folded]
  ------------------
 1097|      0|        IP_Port *ip_port = (IP_Port *)mem_alloc(mem, sizeof(IP_Port));
 1098|      0|        if (ip_port == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1098:13): [True: 0, False: 0]
  ------------------
 1099|      0|            abort();
 1100|      0|        }
 1101|      0|        ip_port->ip.ip.v4.uint32 = net_htonl(0x7F000003); // 127.0.0.3
 1102|      0|        ip_port->ip.family = net_family_ipv4();
 1103|       |
 1104|      0|        *res = ip_port;
 1105|      0|        return 1;
 1106|      0|    }
 1107|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
 1108|       |
 1109|      0|    int type = tox_type;
 1110|       |    // ugly
 1111|      0|    if (tox_type == -1) {
  ------------------
  |  Branch (1111:9): [True: 0, False: 0]
  ------------------
 1112|      0|        type = 0;
 1113|      0|    }
 1114|       |
 1115|       |    // It's not an IP address, so now we try doing a DNS lookup.
 1116|      0|    IP_Port *addrs = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1117|      0|    const int rc = ns_getaddrinfo(ns, mem, node, TOX_AF_UNSPEC, type, &addrs);
  ------------------
  |  |   64|      0|#define TOX_AF_UNSPEC 0
  ------------------
 1118|       |
 1119|       |    // Lookup failed / empty.
 1120|      0|    if (rc <= 0) {
  ------------------
  |  Branch (1120:9): [True: 0, False: 0]
  ------------------
 1121|      0|        return -1;
 1122|      0|    }
 1123|       |
 1124|      0|    assert(addrs != nullptr);
  ------------------
  |  Branch (1124:5): [True: 0, False: 0]
  ------------------
 1125|       |
 1126|      0|    *res = addrs;
 1127|      0|    return rc;
 1128|      0|}
net_freeipport:
 1131|    132|{
 1132|    132|    mem_delete(mem, ip_ports);
 1133|    132|}
bind_to_port:
 1136|    135|{
 1137|    135|    IP_Port addr;
 1138|    135|    ip_init(&addr.ip, net_family_is_ipv6(family));
 1139|    135|    addr.ip.family = family;
 1140|       |
 1141|    135|    if (net_family_is_ipv4(family)) {
  ------------------
  |  Branch (1141:9): [True: 0, False: 135]
  ------------------
 1142|      0|        addr.ip.ip.v4.uint32 = 0;
 1143|    135|    } else {
 1144|    135|        memset(addr.ip.ip.v6.uint8, 0, 16);
 1145|    135|    }
 1146|       |
 1147|    135|    addr.port = net_htons(port);
 1148|       |
 1149|    135|    return ns_bind(ns, sock, &addr) == 0;
 1150|    135|}
net_socket:
 1153|    304|{
 1154|    304|    return ns_socket(ns, domain.value, type, protocol);
 1155|    304|}
network.c:receivepacket:
  221|     65|{
  222|     65|    memset(ip_port, 0, sizeof(IP_Port));
  223|     65|    *length = 0;
  224|       |
  225|     65|    const int fail_or_len = ns_recvfrom(ns, sock, data, MAX_UDP_PACKET_SIZE, ip_port);
  ------------------
  |  |   28|     65|#define MAX_UDP_PACKET_SIZE 2048
  ------------------
  226|       |
  227|     65|    if (fail_or_len < 0) {
  ------------------
  |  Branch (227:9): [True: 65, False: 0]
  ------------------
  228|     65|        const int error = net_error();
  229|       |
  230|     65|        if (!net_should_ignore_recv_error(error)) {
  ------------------
  |  Branch (230:13): [True: 0, False: 65]
  ------------------
  231|      0|            Net_Strerror error_str;
  232|      0|            LOGGER_ERROR(log, "unexpected error reading from socket: %u, %s", (unsigned int)error, net_strerror(error, &error_str));
  ------------------
  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  233|      0|        }
  234|       |
  235|     65|        return -1; /* Nothing received. */
  236|     65|    }
  237|       |
  238|      0|    *length = (uint32_t)fail_or_len;
  239|       |
  240|      0|    if (net_family_is_ipv6(ip_port->ip.family) && ipv6_ipv4_in_v6(&ip_port->ip.ip.v6)) {
  ------------------
  |  Branch (240:9): [True: 0, False: 0]
  |  Branch (240:51): [True: 0, False: 0]
  ------------------
  241|      0|        ip_port->ip.family = net_family_ipv4();
  242|      0|        ip_port->ip.ip.v4.uint32 = ip_port->ip.ip.v6.uint32[3];
  243|      0|    }
  244|       |
  245|      0|    net_log_data(log, "=>O", data, MAX_UDP_PACKET_SIZE, ip_port, *length);
  ------------------
  |  |   28|      0|#define MAX_UDP_PACKET_SIZE 2048
  ------------------
  246|       |
  247|      0|    return 0;
  248|     65|}
network.c:bin_pack_ip:
  727|     72|{
  728|     72|    if (is_ipv4) {
  ------------------
  |  Branch (728:9): [True: 72, False: 0]
  ------------------
  729|     72|        return bin_pack_bin_b(bp, ip->ip.v4.uint8, SIZE_IP4);
  ------------------
  |  |   25|     72|#define SIZE_IP4 4
  ------------------
  730|     72|    } else {
  731|      0|        return bin_pack_bin_b(bp, ip->ip.v6.uint8, SIZE_IP6);
  ------------------
  |  |   26|      0|#define SIZE_IP6 16
  ------------------
  732|      0|    }
  733|     72|}
network.c:addr_resolve:
  936|    123|{
  937|    123|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  938|    123|    if ((true)) {
  ------------------
  |  Branch (938:9): [True: 123, Folded]
  ------------------
  939|    123|        return false;
  940|    123|    }
  941|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  942|       |
  943|      0|    if (address == nullptr || to == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
                  if (address == nullptr || to == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (943:9): [True: 0, False: 0]
  |  Branch (943:31): [True: 0, False: 0]
  ------------------
  944|      0|        return false;
  945|      0|    }
  946|       |
  947|      0|    const int family = to->family.value;
  948|       |
  949|      0|    IP_Port *addrs = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  950|      0|    const int rc = ns_getaddrinfo(ns, mem, address, family, 0, &addrs);
  951|       |
  952|       |    // Lookup failed / empty.
  953|      0|    if (rc <= 0) {
  ------------------
  |  Branch (953:9): [True: 0, False: 0]
  ------------------
  954|      0|        return false;
  955|      0|    }
  956|       |
  957|      0|    assert(addrs != nullptr);
  ------------------
  |  Branch (957:5): [True: 0, False: 0]
  ------------------
  958|       |
  959|      0|    IP ip4;
  960|      0|    ip_init(&ip4, false); // ipv6enabled = false
  961|      0|    IP ip6;
  962|      0|    ip_init(&ip6, true); // ipv6enabled = true
  963|       |
  964|      0|    int result = 0;
  965|      0|    bool done = false;
  966|       |
  967|      0|    for (int i = 0; i < rc && !done; ++i) {
  ------------------
  |  Branch (967:21): [True: 0, False: 0]
  |  Branch (967:31): [True: 0, False: 0]
  ------------------
  968|      0|        if (net_family_is_ipv4(addrs[i].ip.family)) {
  ------------------
  |  Branch (968:13): [True: 0, False: 0]
  ------------------
  969|      0|            if (addrs[i].ip.family.value == to->family.value) { /* AF_INET requested, done */
  ------------------
  |  Branch (969:17): [True: 0, False: 0]
  ------------------
  970|      0|                ip_copy(to, &addrs[i].ip);
  971|      0|                result = TOX_ADDR_RESOLVE_INET;
  ------------------
  |  |  915|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
  972|      0|                done = true;
  973|      0|            } else if ((result & TOX_ADDR_RESOLVE_INET) == 0) { /* AF_UNSPEC requested, store away */
  ------------------
  |  |  915|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
  |  Branch (973:24): [True: 0, False: 0]
  ------------------
  974|      0|                ip_copy(&ip4, &addrs[i].ip);
  975|      0|                result |= TOX_ADDR_RESOLVE_INET;
  ------------------
  |  |  915|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
  976|      0|            }
  977|      0|        } else if (net_family_is_ipv6(addrs[i].ip.family)) {
  ------------------
  |  Branch (977:20): [True: 0, False: 0]
  ------------------
  978|      0|            if (addrs[i].ip.family.value == to->family.value) { /* AF_INET6 requested, done */
  ------------------
  |  Branch (978:17): [True: 0, False: 0]
  ------------------
  979|      0|                ip_copy(to, &addrs[i].ip);
  980|      0|                result = TOX_ADDR_RESOLVE_INET6;
  ------------------
  |  |  916|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
  981|      0|                done = true;
  982|      0|            } else if ((result & TOX_ADDR_RESOLVE_INET6) == 0) { /* AF_UNSPEC requested, store away */
  ------------------
  |  |  916|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
  |  Branch (982:24): [True: 0, False: 0]
  ------------------
  983|      0|                ip_copy(&ip6, &addrs[i].ip);
  984|      0|                result |= TOX_ADDR_RESOLVE_INET6;
  ------------------
  |  |  916|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
  985|      0|            }
  986|      0|        }
  987|      0|    }
  988|       |
  989|      0|    if (family == TOX_AF_UNSPEC) {
  ------------------
  |  |   64|      0|#define TOX_AF_UNSPEC 0
  ------------------
  |  Branch (989:9): [True: 0, False: 0]
  ------------------
  990|      0|        if ((result & TOX_ADDR_RESOLVE_INET6) != 0) {
  ------------------
  |  |  916|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
  |  Branch (990:13): [True: 0, False: 0]
  ------------------
  991|      0|            ip_copy(to, &ip6);
  992|       |
  993|      0|            if ((result & TOX_ADDR_RESOLVE_INET) != 0 && (extra != nullptr)) {
  ------------------
  |  |  915|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
                          if ((result & TOX_ADDR_RESOLVE_INET) != 0 && (extra != nullptr)) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (993:17): [True: 0, False: 0]
  |  Branch (993:58): [True: 0, False: 0]
  ------------------
  994|      0|                ip_copy(extra, &ip4);
  995|      0|            }
  996|      0|        } else if ((result & TOX_ADDR_RESOLVE_INET) != 0) {
  ------------------
  |  |  915|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
  |  Branch (996:20): [True: 0, False: 0]
  ------------------
  997|      0|            ip_copy(to, &ip4);
  998|      0|        } else {
  999|      0|            result = 0;
 1000|      0|        }
 1001|      0|    }
 1002|       |
 1003|      0|    ns_freeaddrinfo(ns, mem, addrs);
 1004|      0|    return result != 0;
 1005|      0|}

set_callback_handle_recv_1:
  700|     72|{
  701|     72|    onion->recv_1_function = function;
  702|     72|    onion->callback_object = object;
  703|     72|}
new_onion:
  706|    195|{
  707|    195|    if (dht == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (707:9): [True: 0, False: 195]
  ------------------
  708|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  709|      0|    }
  710|       |
  711|    195|    Onion *onion = (Onion *)mem_alloc(mem, sizeof(Onion));
  712|       |
  713|    195|    if (onion == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (713:9): [True: 10, False: 185]
  ------------------
  714|     10|        return nullptr;
  ------------------
  |  |   63|     10|#define nullptr NULL
  ------------------
  715|     10|    }
  716|       |
  717|    185|    onion->log = log;
  718|    185|    onion->dht = dht;
  719|    185|    onion->net = net;
  720|    185|    onion->mono_time = mono_time;
  721|    185|    onion->rng = rng;
  722|    185|    onion->mem = mem;
  723|    185|    new_symmetric_key(rng, onion->secret_symmetric_key);
  724|    185|    onion->timestamp = mono_time_get(onion->mono_time);
  725|       |
  726|    185|    const uint8_t *secret_key = dht_get_self_secret_key(dht);
  727|    185|    Shared_Key_Cache *const temp_shared_keys_1 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   38|    185|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_1 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   37|    185|#define MAX_KEYS_PER_SLOT 4
  ------------------
  728|    185|    Shared_Key_Cache *const temp_shared_keys_2 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   38|    185|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_2 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   37|    185|#define MAX_KEYS_PER_SLOT 4
  ------------------
  729|    185|    Shared_Key_Cache *const temp_shared_keys_3 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   38|    185|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const temp_shared_keys_3 = shared_key_cache_new(log, mono_time, mem, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   37|    185|#define MAX_KEYS_PER_SLOT 4
  ------------------
  730|       |
  731|    185|    if (temp_shared_keys_1 == nullptr || temp_shared_keys_2 == nullptr || temp_shared_keys_3 == nullptr) {
  ------------------
  |  |   63|    370|#define nullptr NULL
  ------------------
                  if (temp_shared_keys_1 == nullptr || temp_shared_keys_2 == nullptr || temp_shared_keys_3 == nullptr) {
  ------------------
  |  |   63|    363|#define nullptr NULL
  ------------------
                  if (temp_shared_keys_1 == nullptr || temp_shared_keys_2 == nullptr || temp_shared_keys_3 == nullptr) {
  ------------------
  |  |   63|    177|#define nullptr NULL
  ------------------
  |  Branch (731:9): [True: 7, False: 178]
  |  Branch (731:42): [True: 1, False: 177]
  |  Branch (731:75): [True: 1, False: 176]
  ------------------
  732|      9|        shared_key_cache_free(temp_shared_keys_3);
  733|      9|        shared_key_cache_free(temp_shared_keys_2);
  734|      9|        shared_key_cache_free(temp_shared_keys_1);
  735|       |        // cppcheck-suppress mismatchAllocDealloc
  736|      9|        kill_onion(onion);
  737|      9|        return nullptr;
  ------------------
  |  |   63|      9|#define nullptr NULL
  ------------------
  738|      9|    }
  739|       |
  740|    176|    onion->shared_keys_1 = temp_shared_keys_1;
  741|    176|    onion->shared_keys_2 = temp_shared_keys_2;
  742|    176|    onion->shared_keys_3 = temp_shared_keys_3;
  743|       |
  744|    176|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, &handle_send_initial, onion);
  745|    176|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, &handle_send_1, onion);
  746|    176|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, &handle_send_2, onion);
  747|       |
  748|    176|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, &handle_recv_3, onion);
  749|    176|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, &handle_recv_2, onion);
  750|    176|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, &handle_recv_1, onion);
  751|       |
  752|    176|    return onion;
  753|    185|}
kill_onion:
  756|    204|{
  757|    204|    if (onion == nullptr) {
  ------------------
  |  |   63|    204|#define nullptr NULL
  ------------------
  |  Branch (757:9): [True: 19, False: 185]
  ------------------
  758|     19|        return;
  759|     19|    }
  760|       |
  761|    185|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
  762|    185|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
  763|    185|    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
  764|       |
  765|    185|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
  766|    185|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
  767|    185|    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
  768|       |
  769|    185|    crypto_memzero(onion->secret_symmetric_key, sizeof(onion->secret_symmetric_key));
  770|       |
  771|    185|    shared_key_cache_free(onion->shared_keys_1);
  772|    185|    shared_key_cache_free(onion->shared_keys_2);
  773|    185|    shared_key_cache_free(onion->shared_keys_3);
  774|       |
  775|    185|    mem_delete(onion->mem, onion);
  776|    185|}

onion_announce_extra_data_callback:
   76|    170|{
   77|    170|    onion_a->extra_data_max_size = extra_data_max_size;
   78|    170|    onion_a->extra_data_callback = extra_data_callback;
   79|    170|    onion_a->extra_data_object = extra_data_object;
   80|    170|}
new_onion_announce:
  685|    195|{
  686|    195|    if (dht == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (686:9): [True: 0, False: 195]
  ------------------
  687|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  688|      0|    }
  689|       |
  690|    195|    Onion_Announce *onion_a = (Onion_Announce *)mem_alloc(mem, sizeof(Onion_Announce));
  691|       |
  692|    195|    if (onion_a == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (692:9): [True: 8, False: 187]
  ------------------
  693|      8|        return nullptr;
  ------------------
  |  |   63|      8|#define nullptr NULL
  ------------------
  694|      8|    }
  695|       |
  696|    187|    Shared_Key_Cache *const shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht_get_self_secret_key(dht), KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   44|    187|#define KEYS_TIMEOUT 600
  ------------------
                  Shared_Key_Cache *const shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht_get_self_secret_key(dht), KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   43|    187|#define MAX_KEYS_PER_SLOT 4
  ------------------
  697|    187|    if (shared_keys_recv == nullptr) {
  ------------------
  |  |   63|    187|#define nullptr NULL
  ------------------
  |  Branch (697:9): [True: 2, False: 185]
  ------------------
  698|      2|        mem_delete(mem, onion_a);
  699|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
  700|      2|    }
  701|    185|    onion_a->shared_keys_recv = shared_keys_recv;
  702|       |
  703|    185|    onion_a->log = log;
  704|    185|    onion_a->rng = rng;
  705|    185|    onion_a->mem = mem;
  706|    185|    onion_a->mono_time = mono_time;
  707|    185|    onion_a->dht = dht;
  708|    185|    onion_a->net = net;
  709|    185|    onion_a->extra_data_max_size = 0;
  710|    185|    onion_a->extra_data_callback = nullptr;
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
  711|    185|    onion_a->extra_data_object = nullptr;
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
  712|    185|    new_hmac_key(rng, onion_a->hmac_key);
  713|       |
  714|    185|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, &handle_announce_request, onion_a);
  715|    185|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, &handle_announce_request_old, onion_a);
  716|    185|    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, &handle_data_request, onion_a);
  717|       |
  718|    185|    return onion_a;
  719|    187|}
kill_onion_announce:
  722|    195|{
  723|    195|    if (onion_a == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (723:9): [True: 10, False: 185]
  ------------------
  724|     10|        return;
  725|     10|    }
  726|       |
  727|    185|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
  728|    185|    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
  729|    185|    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    185|#define nullptr NULL
  ------------------
  730|       |
  731|    185|    crypto_memzero(onion_a->hmac_key, CRYPTO_HMAC_KEY_SIZE);
  ------------------
  |  |  125|    185|#define CRYPTO_HMAC_KEY_SIZE           32
  ------------------
  732|    185|    shared_key_cache_free(onion_a->shared_keys_recv);
  733|       |
  734|    185|    mem_delete(onion_a->mem, onion_a);
  735|    185|}

onion_get_friend_count:
  171|     82|{
  172|     82|    return onion_c->num_friends;
  173|     82|}
onion_add_bs_path_node:
  224|     57|{
  225|     57|    if (!net_family_is_ipv4(ip_port->ip.family) && !net_family_is_ipv6(ip_port->ip.family)) {
  ------------------
  |  Branch (225:9): [True: 0, False: 57]
  |  Branch (225:52): [True: 0, False: 0]
  ------------------
  226|      0|        return false;
  227|      0|    }
  228|       |
  229|     57|    for (unsigned int i = 0; i < MAX_PATH_NODES; ++i) {
  ------------------
  |  |   52|     57|#define MAX_PATH_NODES 32
  ------------------
  |  Branch (229:30): [True: 57, False: 0]
  ------------------
  230|     57|        if (pk_equal(public_key, onion_c->path_nodes_bs[i].public_key)) {
  ------------------
  |  Branch (230:13): [True: 57, False: 0]
  ------------------
  231|     57|            return true;
  232|     57|        }
  233|     57|    }
  234|       |
  235|      0|    onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].ip_port = *ip_port;
  ------------------
  |  |   52|      0|#define MAX_PATH_NODES 32
  ------------------
  236|      0|    memcpy(onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].public_key, public_key,
  ------------------
  |  |   52|      0|#define MAX_PATH_NODES 32
  ------------------
  237|      0|           CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  238|       |
  239|      0|    const uint16_t last = onion_c->path_nodes_index_bs;
  240|      0|    ++onion_c->path_nodes_index_bs;
  241|       |
  242|      0|    if (onion_c->path_nodes_index_bs < last) {
  ------------------
  |  Branch (242:9): [True: 0, False: 0]
  ------------------
  243|      0|        onion_c->path_nodes_index_bs = MAX_PATH_NODES + 1;
  ------------------
  |  |   52|      0|#define MAX_PATH_NODES 32
  ------------------
  244|      0|    }
  245|       |
  246|       |    return true;
  247|     57|}
oniondata_registerhandler:
 1894|    451|{
 1895|    451|    onion_c->onion_data_handlers[byte].function = cb;
 1896|    451|    onion_c->onion_data_handlers[byte].object = object;
 1897|    451|}
onion_group_announce_register:
 1900|    338|{
 1901|    338|    onion_c->group_announce_response = func;
 1902|    338|    onion_c->group_announce_response_user_data = user_data;
 1903|    338|}
onion_connection_status:
 2122|    129|{
 2123|    129|    if (onion_c->onion_connected >= ONION_CONNECTION_SECONDS) {
  ------------------
  |  | 2118|    129|#define ONION_CONNECTION_SECONDS 3
  ------------------
  |  Branch (2123:9): [True: 0, False: 129]
  ------------------
 2124|      0|        if (onion_c->udp_connected) {
  ------------------
  |  Branch (2124:13): [True: 0, False: 0]
  ------------------
 2125|      0|            return ONION_CONNECTION_STATUS_UDP;
 2126|      0|        }
 2127|       |
 2128|      0|        return ONION_CONNECTION_STATUS_TCP;
 2129|      0|    }
 2130|       |
 2131|    129|    return ONION_CONNECTION_STATUS_NONE;
 2132|    129|}
do_onion_client:
 2135|     82|{
 2136|     82|    if (onion_c->last_run == mono_time_get(onion_c->mono_time)) {
  ------------------
  |  Branch (2136:9): [True: 35, False: 47]
  ------------------
 2137|     35|        return;
 2138|     35|    }
 2139|       |
 2140|     47|    if (mono_time_is_timeout(onion_c->mono_time, onion_c->first_run, ONION_CONNECTION_SECONDS)) {
  ------------------
  |  | 2118|     47|#define ONION_CONNECTION_SECONDS 3
  ------------------
  |  Branch (2140:9): [True: 47, False: 0]
  ------------------
 2141|     47|        populate_path_nodes(onion_c);
 2142|     47|        do_announce(onion_c);
 2143|     47|    }
 2144|       |
 2145|     47|    if (onion_isconnected(onion_c)) {
  ------------------
  |  Branch (2145:9): [True: 0, False: 47]
  ------------------
 2146|      0|        if (mono_time_is_timeout(onion_c->mono_time, onion_c->last_time_connected, ONION_CONNECTED_TIMEOUT)) {
  ------------------
  |  | 2119|      0|#define ONION_CONNECTED_TIMEOUT 10
  ------------------
  |  Branch (2146:13): [True: 0, False: 0]
  ------------------
 2147|      0|            reset_friend_run_counts(onion_c);
 2148|      0|        }
 2149|       |
 2150|      0|        onion_c->last_time_connected = mono_time_get(onion_c->mono_time);
 2151|       |
 2152|      0|        if (onion_c->onion_connected < ONION_CONNECTION_SECONDS * 2) {
  ------------------
  |  | 2118|      0|#define ONION_CONNECTION_SECONDS 3
  ------------------
  |  Branch (2152:13): [True: 0, False: 0]
  ------------------
 2153|      0|            ++onion_c->onion_connected;
 2154|      0|        }
 2155|     47|    } else {
 2156|     47|        if (onion_c->onion_connected != 0) {
  ------------------
  |  Branch (2156:13): [True: 0, False: 47]
  ------------------
 2157|      0|            --onion_c->onion_connected;
 2158|      0|        }
 2159|     47|    }
 2160|       |
 2161|     47|    onion_c->udp_connected = dht_non_lan_connected(onion_c->dht);
 2162|       |
 2163|     47|    if (mono_time_is_timeout(onion_c->mono_time, onion_c->first_run, ONION_CONNECTION_SECONDS * 2)) {
  ------------------
  |  | 2118|     47|#define ONION_CONNECTION_SECONDS 3
  ------------------
  |  Branch (2163:9): [True: 47, False: 0]
  ------------------
 2164|     47|        set_tcp_onion_status(nc_get_tcp_c(onion_c->c), !onion_c->udp_connected);
 2165|     47|    }
 2166|       |
 2167|     47|    if (onion_connection_status(onion_c) != ONION_CONNECTION_STATUS_NONE) {
  ------------------
  |  Branch (2167:9): [True: 0, False: 47]
  ------------------
 2168|      0|        for (uint32_t i = 0; i < onion_c->num_friends; ++i) {
  ------------------
  |  Branch (2168:30): [True: 0, False: 0]
  ------------------
 2169|      0|            do_friend(onion_c, i);
 2170|      0|        }
 2171|      0|    }
 2172|       |
 2173|     47|    if (onion_c->last_run == 0) {
  ------------------
  |  Branch (2173:9): [True: 47, False: 0]
  ------------------
 2174|     47|        onion_c->first_run = mono_time_get(onion_c->mono_time);
 2175|     47|    }
 2176|       |
 2177|     47|    onion_c->last_run = mono_time_get(onion_c->mono_time);
 2178|     47|}
new_onion_client:
 2182|    195|{
 2183|    195|    if (c == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (2183:9): [True: 0, False: 195]
  ------------------
 2184|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2185|      0|    }
 2186|       |
 2187|    195|    Onion_Client *onion_c = (Onion_Client *)mem_alloc(mem, sizeof(Onion_Client));
 2188|       |
 2189|    195|    if (onion_c == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (2189:9): [True: 2, False: 193]
  ------------------
 2190|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
 2191|      2|    }
 2192|       |
 2193|    193|    Ping_Array *const temp_ping_array = ping_array_new(mem, ANNOUNCE_ARRAY_SIZE, ANNOUNCE_TIMEOUT);
  ------------------
  |  |   37|    193|#define ANNOUNCE_ARRAY_SIZE 256
  ------------------
                  Ping_Array *const temp_ping_array = ping_array_new(mem, ANNOUNCE_ARRAY_SIZE, ANNOUNCE_TIMEOUT);
  ------------------
  |  |   38|    193|#define ANNOUNCE_TIMEOUT 10
  ------------------
 2194|       |
 2195|    193|    if (temp_ping_array == nullptr) {
  ------------------
  |  |   63|    193|#define nullptr NULL
  ------------------
  |  Branch (2195:9): [True: 1, False: 192]
  ------------------
 2196|      1|        mem_delete(mem, onion_c);
 2197|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 2198|      1|    }
 2199|    192|    onion_c->announce_ping_array = temp_ping_array;
 2200|       |
 2201|    192|    onion_c->mono_time = mono_time;
 2202|    192|    onion_c->logger = logger;
 2203|    192|    onion_c->rng = rng;
 2204|    192|    onion_c->mem = mem;
 2205|    192|    onion_c->dht = dht;
 2206|    192|    onion_c->net = net;
 2207|    192|    onion_c->c = c;
 2208|    192|    onion_c->friends_list_capacity = 0;
 2209|    192|    bs_list_init(&onion_c->friends_lookup, mem, CRYPTO_PUBLIC_KEY_SIZE, 0, memcmp);
  ------------------
  |  |   44|    192|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 2210|       |
 2211|    192|    new_symmetric_key(rng, onion_c->secret_symmetric_key);
 2212|    192|    crypto_new_keypair(rng, onion_c->temp_public_key, onion_c->temp_secret_key);
 2213|    192|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, &handle_announce_response, onion_c);
 2214|    192|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, &handle_announce_response_old, onion_c);
 2215|    192|    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, &handle_data_response, onion_c);
 2216|    192|    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, &handle_dhtpk_announce, onion_c);
  ------------------
  |  |   66|    192|#define ONION_DATA_DHTPK CRYPTO_PACKET_DHTPK
  |  |  ------------------
  |  |  |  |   70|    192|#define CRYPTO_PACKET_DHTPK         156
  |  |  ------------------
  ------------------
 2217|    192|    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, &handle_dht_dhtpk, onion_c);
  ------------------
  |  |   70|    192|#define CRYPTO_PACKET_DHTPK         156
  ------------------
 2218|    192|    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), &handle_tcp_onion, onion_c);
 2219|       |
 2220|    192|    return onion_c;
 2221|    193|}
kill_onion_client:
 2224|    195|{
 2225|    195|    if (onion_c == nullptr) {
  ------------------
  |  |   63|    195|#define nullptr NULL
  ------------------
  |  Branch (2225:9): [True: 3, False: 192]
  ------------------
 2226|      3|        return;
 2227|      3|    }
 2228|       |
 2229|    192|    const Memory *mem = onion_c->mem;
 2230|       |
 2231|    192|    ping_array_kill(onion_c->announce_ping_array);
 2232|    192|    realloc_onion_friends(onion_c, 0);
 2233|    192|    bs_list_free(&onion_c->friends_lookup);
 2234|    192|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
 2235|    192|    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
 2236|    192|    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
                  networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
 2237|    192|    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   66|    192|#define ONION_DATA_DHTPK CRYPTO_PACKET_DHTPK
  |  |  ------------------
  |  |  |  |   70|    192|#define CRYPTO_PACKET_DHTPK         156
  |  |  ------------------
  ------------------
                  oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
                  oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
 2238|    192|    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   70|    192|#define CRYPTO_PACKET_DHTPK         156
  ------------------
                  cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
 2239|    192|    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
                  set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), nullptr, nullptr);
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
 2240|    192|    crypto_memzero(onion_c, sizeof(Onion_Client));
 2241|    192|    mem_delete(mem, onion_c);
 2242|    192|}
onion_client.c:onion_node_timed_out:
  413|    564|{
  414|    564|    return node->timestamp == 0
  ------------------
  |  Branch (414:12): [True: 564, False: 0]
  ------------------
  415|      0|           || (node->pings_since_last_response >= ONION_NODE_MAX_PINGS
  ------------------
  |  |   50|      0|#define ONION_NODE_MAX_PINGS 3
  ------------------
  |  Branch (415:16): [True: 0, False: 0]
  ------------------
  416|      0|               && mono_time_is_timeout(mono_time, node->last_pinged, ONION_NODE_TIMEOUT));
  ------------------
  |  |   30|      0|#define ONION_NODE_TIMEOUT ONION_NODE_PING_INTERVAL
  |  |  ------------------
  |  |  |  |   29|      0|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  ------------------
  |  Branch (416:19): [True: 0, False: 0]
  ------------------
  417|    564|}
onion_client.c:realloc_onion_friends:
 1502|    192|{
 1503|    192|    if (num == 0) {
  ------------------
  |  Branch (1503:9): [True: 192, False: 0]
  ------------------
 1504|    192|        mem_delete(onion_c->mem, onion_c->friends_list);
 1505|    192|        onion_c->friends_list = nullptr;
  ------------------
  |  |   63|    192|#define nullptr NULL
  ------------------
 1506|    192|        onion_c->friends_list_capacity = 0;
 1507|    192|        return 0;
 1508|    192|    }
 1509|       |
 1510|      0|    if (num <= onion_c->friends_list_capacity) {
  ------------------
  |  Branch (1510:9): [True: 0, False: 0]
  ------------------
 1511|      0|        return 0;
 1512|      0|    }
 1513|       |
 1514|       |    // Geometric growth: Double the capacity or set to num if starting.
 1515|      0|    uint32_t new_capacity = onion_c->friends_list_capacity == 0 ? num : onion_c->friends_list_capacity * 2;
  ------------------
  |  Branch (1515:29): [True: 0, False: 0]
  ------------------
 1516|      0|    if (new_capacity < num) {
  ------------------
  |  Branch (1516:9): [True: 0, False: 0]
  ------------------
 1517|      0|        new_capacity = num;
 1518|      0|    }
 1519|       |
 1520|      0|    Onion_Friend *newonion_friends = (Onion_Friend *)mem_vrealloc(onion_c->mem, onion_c->friends_list, new_capacity, sizeof(Onion_Friend));
 1521|       |
 1522|      0|    if (newonion_friends == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1522:9): [True: 0, False: 0]
  ------------------
 1523|      0|        return -1;
 1524|      0|    }
 1525|       |
 1526|      0|    onion_c->friends_list = newonion_friends;
 1527|      0|    onion_c->friends_list_capacity = new_capacity;
 1528|      0|    return 0;
 1529|      0|}
onion_client.c:populate_path_nodes:
 1748|     47|{
 1749|     47|    Node_format node_list[MAX_FRIEND_CLIENTS];
 1750|       |
 1751|     47|    const unsigned int num_nodes = randfriends_nodes(onion_c->dht, node_list, MAX_FRIEND_CLIENTS);
  ------------------
  |  |   32|     47|#define MAX_FRIEND_CLIENTS 8
  ------------------
 1752|       |
 1753|     47|    for (unsigned int i = 0; i < num_nodes; ++i) {
  ------------------
  |  Branch (1753:30): [True: 0, False: 47]
  ------------------
 1754|      0|        onion_add_path_node(onion_c, &node_list[i].ip_port, node_list[i].public_key);
 1755|      0|    }
 1756|     47|}
onion_client.c:do_announce:
 1947|     47|{
 1948|     47|    unsigned int count = 0;
 1949|     47|    Onion_Node *node_list = onion_c->clients_announce_list;
 1950|       |
 1951|    611|    for (unsigned int i = 0; i < MAX_ONION_CLIENTS_ANNOUNCE; ++i) {
  ------------------
  |  |   28|    611|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (1951:30): [True: 564, False: 47]
  ------------------
 1952|    564|        if (onion_node_timed_out(&node_list[i], onion_c->mono_time)) {
  ------------------
  |  Branch (1952:13): [True: 564, False: 0]
  ------------------
 1953|    564|            continue;
 1954|    564|        }
 1955|       |
 1956|      0|        ++count;
 1957|       |
 1958|       |        /* Don't announce ourselves the first time this is run to new peers */
 1959|      0|        if (node_list[i].last_pinged == 0) {
  ------------------
  |  Branch (1959:13): [True: 0, False: 0]
  ------------------
 1960|      0|            node_list[i].last_pinged = 1;
 1961|      0|            continue;
 1962|      0|        }
 1963|       |
 1964|      0|        if (node_list[i].pings_since_last_response >= ONION_NODE_MAX_PINGS) {
  ------------------
  |  |   50|      0|#define ONION_NODE_MAX_PINGS 3
  ------------------
  |  Branch (1964:13): [True: 0, False: 0]
  ------------------
 1965|      0|            continue;
 1966|      0|        }
 1967|       |
 1968|      0|        unsigned int interval = ANNOUNCE_INTERVAL_NOT_ANNOUNCED;
  ------------------
  |  | 1905|      0|#define ANNOUNCE_INTERVAL_NOT_ANNOUNCED 3
  ------------------
 1969|       |
 1970|      0|        if (node_list[i].is_stored != 0
  ------------------
  |  Branch (1970:13): [True: 0, False: 0]
  ------------------
 1971|      0|                && path_exists(onion_c->mono_time, &onion_c->onion_paths_self, node_list[i].path_used)) {
  ------------------
  |  Branch (1971:20): [True: 0, False: 0]
  ------------------
 1972|      0|            interval = ANNOUNCE_INTERVAL_ANNOUNCED;
  ------------------
  |  | 1906|      0|#define ANNOUNCE_INTERVAL_ANNOUNCED ONION_NODE_PING_INTERVAL
  |  |  ------------------
  |  |  |  |   29|      0|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  ------------------
 1973|       |
 1974|      0|            const uint32_t pathnum = node_list[i].path_used % NUMBER_ONION_PATHS;
  ------------------
  |  |   36|      0|#define NUMBER_ONION_PATHS 6
  ------------------
 1975|       |
 1976|       |            /* If a node/path is considered "stable", it can be pinged less aggressively. */
 1977|      0|            if (path_is_stable(onion_c->mono_time, &onion_c->onion_paths_self, pathnum, &node_list[i])) {
  ------------------
  |  Branch (1977:17): [True: 0, False: 0]
  ------------------
 1978|      0|                interval = ANNOUNCE_INTERVAL_STABLE;
  ------------------
  |  | 1909|      0|#define ANNOUNCE_INTERVAL_STABLE (ONION_NODE_PING_INTERVAL * 8)
  |  |  ------------------
  |  |  |  |   29|      0|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  ------------------
 1979|      0|            }
 1980|      0|        }
 1981|       |
 1982|      0|        if (mono_time_is_timeout(onion_c->mono_time, node_list[i].last_pinged, interval)
  ------------------
  |  Branch (1982:13): [True: 0, False: 0]
  ------------------
 1983|      0|                || mono_time_is_timeout(onion_c->mono_time, onion_c->last_announce, ONION_NODE_PING_INTERVAL)) {
  ------------------
  |  |   29|      0|#define ONION_NODE_PING_INTERVAL 15
  ------------------
  |  Branch (1983:20): [True: 0, False: 0]
  ------------------
 1984|      0|            uint32_t path_to_use = node_list[i].path_used;
 1985|       |
 1986|      0|            if (node_list[i].pings_since_last_response == ONION_NODE_MAX_PINGS - 1
  ------------------
  |  |   50|      0|#define ONION_NODE_MAX_PINGS 3
  ------------------
  |  Branch (1986:17): [True: 0, False: 0]
  ------------------
 1987|      0|                    && mono_time_is_timeout(onion_c->mono_time, node_list[i].added_time, TIME_TO_STABLE)) {
  ------------------
  |  | 1908|      0|#define TIME_TO_STABLE (ONION_NODE_PING_INTERVAL * 6)
  |  |  ------------------
  |  |  |  |   29|      0|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  ------------------
  |  Branch (1987:24): [True: 0, False: 0]
  ------------------
 1988|       |                /* Last chance for a long-lived node - try a random path */
 1989|      0|                path_to_use = -1;
 1990|      0|            }
 1991|       |
 1992|      0|            if (client_send_announce_request(onion_c, 0, &node_list[i].ip_port, node_list[i].public_key,
  ------------------
  |  Branch (1992:17): [True: 0, False: 0]
  ------------------
 1993|      0|                                             node_list[i].ping_id, path_to_use) == 0) {
 1994|      0|                node_list[i].last_pinged = mono_time_get(onion_c->mono_time);
 1995|      0|                ++node_list[i].pings_since_last_response;
 1996|      0|                onion_c->last_announce = mono_time_get(onion_c->mono_time);
 1997|      0|            }
 1998|      0|        }
 1999|      0|    }
 2000|       |
 2001|     47|    if (count == MAX_ONION_CLIENTS_ANNOUNCE) {
  ------------------
  |  |   28|     47|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (2001:9): [True: 0, False: 47]
  ------------------
 2002|      0|        onion_c->last_populated = mono_time_get(onion_c->mono_time);
 2003|      0|        return;
 2004|      0|    }
 2005|       |
 2006|       |    // check if list needs to be re-populated
 2007|     47|    if (count <= MAX_ONION_CLIENTS_ANNOUNCE / 2
  ------------------
  |  |   28|     47|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (2007:9): [True: 47, False: 0]
  ------------------
 2008|     47|            || mono_time_is_timeout(onion_c->mono_time, onion_c->last_populated, ANNOUNCE_POPULATE_TIMEOUT)) {
  ------------------
  |  | 1765|      0|#define ANNOUNCE_POPULATE_TIMEOUT (60 * 10)
  ------------------
  |  Branch (2008:16): [True: 0, False: 0]
  ------------------
 2009|     47|        uint16_t num_nodes;
 2010|     47|        const Node_format *path_nodes;
 2011|       |
 2012|     47|        if (onion_c->path_nodes_index == 0) {
  ------------------
  |  Branch (2012:13): [True: 47, False: 0]
  ------------------
 2013|     47|            num_nodes = min_u16(onion_c->path_nodes_index_bs, MAX_PATH_NODES);
  ------------------
  |  |   52|     47|#define MAX_PATH_NODES 32
  ------------------
 2014|     47|            path_nodes = onion_c->path_nodes_bs;
 2015|     47|        } else {
 2016|      0|            num_nodes = min_u16(onion_c->path_nodes_index, MAX_PATH_NODES);
  ------------------
  |  |   52|      0|#define MAX_PATH_NODES 32
  ------------------
 2017|      0|            path_nodes = onion_c->path_nodes;
 2018|      0|        }
 2019|       |
 2020|     47|        if (num_nodes == 0) {
  ------------------
  |  Branch (2020:13): [True: 47, False: 0]
  ------------------
 2021|     47|            return;
 2022|     47|        }
 2023|       |
 2024|       |        // Don't send announces to the same node twice. If we don't have many nodes,
 2025|       |        // the random selection below may have overlaps. This ensures that we deduplicate
 2026|       |        // nodes before sending packets to save some bandwidth.
 2027|       |        //
 2028|       |        // TODO(iphydf): Figure out why on esp32, this is necessary for the onion
 2029|       |        // connection to succeed. This is an optimisation and shouldn't be necessary.
 2030|      0|        const uint8_t *targets[MAX_ONION_CLIENTS_ANNOUNCE / 2];
 2031|      0|        unsigned int targets_count = 0;
 2032|       |
 2033|      0|        for (unsigned int i = 0; i < MAX_ONION_CLIENTS_ANNOUNCE / 2; ++i) {
  ------------------
  |  |   28|      0|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (2033:34): [True: 0, False: 0]
  ------------------
 2034|      0|            const uint32_t num = random_range_u32(onion_c->rng, num_nodes);
 2035|      0|            const Node_format *target = &path_nodes[num];
 2036|       |
 2037|      0|            if (!key_list_contains(targets, targets_count, target->public_key)) {
  ------------------
  |  Branch (2037:17): [True: 0, False: 0]
  ------------------
 2038|      0|                client_send_announce_request(onion_c, 0, &target->ip_port, target->public_key, nullptr, -1);
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2039|       |
 2040|      0|                targets[targets_count] = target->public_key;
 2041|      0|                ++targets_count;
 2042|      0|                assert(targets_count <= MAX_ONION_CLIENTS_ANNOUNCE / 2);
  ------------------
  |  Branch (2042:17): [True: 0, False: 0]
  ------------------
 2043|      0|            } else {
 2044|      0|                Ip_Ntoa ip_str;
 2045|      0|                LOGGER_TRACE(onion_c->logger, "not sending repeated announce request to %s:%d",
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2046|      0|                             net_ip_ntoa(&target->ip_port.ip, &ip_str), net_ntohs(target->ip_port.port));
 2047|      0|            }
 2048|      0|        }
 2049|      0|    }
 2050|     47|}
onion_client.c:onion_isconnected:
 2057|     47|{
 2058|     47|    unsigned int live = 0;
 2059|     47|    unsigned int announced = 0;
 2060|       |
 2061|     47|    if (mono_time_is_timeout(onion_c->mono_time, onion_c->last_packet_recv, ONION_OFFLINE_TIMEOUT)) {
  ------------------
  |  |   62|     47|#define ONION_OFFLINE_TIMEOUT (ONION_NODE_PING_INTERVAL * (ONION_NODE_MAX_PINGS+2))
  |  |  ------------------
  |  |  |  |   29|     47|#define ONION_NODE_PING_INTERVAL 15
  |  |  ------------------
  |  |               #define ONION_OFFLINE_TIMEOUT (ONION_NODE_PING_INTERVAL * (ONION_NODE_MAX_PINGS+2))
  |  |  ------------------
  |  |  |  |   50|     47|#define ONION_NODE_MAX_PINGS 3
  |  |  ------------------
  ------------------
  |  Branch (2061:9): [True: 47, False: 0]
  ------------------
 2062|     47|        LOGGER_TRACE(onion_c->logger, "onion is NOT connected: last packet received at %llu (timeout=%u)",
  ------------------
  |  |   76|     47|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     47|    do {                                                                         \
  |  |  |  |   70|     47|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     94|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 47]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     47|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 47]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2063|     47|                     (unsigned long long)onion_c->last_packet_recv, (unsigned int)ONION_OFFLINE_TIMEOUT);
 2064|     47|        onion_c->last_populated = 0;
 2065|     47|        return false;
 2066|     47|    }
 2067|       |
 2068|      0|    if (onion_c->path_nodes_index == 0) {
  ------------------
  |  Branch (2068:9): [True: 0, False: 0]
  ------------------
 2069|      0|        LOGGER_TRACE(onion_c->logger, "onion is NOT connected: no path nodes available");
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2070|      0|        onion_c->last_populated = 0;
 2071|      0|        return false;
 2072|      0|    }
 2073|       |
 2074|      0|    for (unsigned int i = 0; i < MAX_ONION_CLIENTS_ANNOUNCE; ++i) {
  ------------------
  |  |   28|      0|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (2074:30): [True: 0, False: 0]
  ------------------
 2075|      0|        if (!onion_node_timed_out(&onion_c->clients_announce_list[i], onion_c->mono_time)) {
  ------------------
  |  Branch (2075:13): [True: 0, False: 0]
  ------------------
 2076|      0|            ++live;
 2077|       |
 2078|      0|            if (onion_c->clients_announce_list[i].is_stored != 0) {
  ------------------
  |  Branch (2078:17): [True: 0, False: 0]
  ------------------
 2079|      0|                ++announced;
 2080|      0|            }
 2081|      0|        }
 2082|      0|    }
 2083|       |
 2084|      0|    unsigned int pnodes = onion_c->path_nodes_index;
 2085|       |
 2086|      0|    if (pnodes > MAX_ONION_CLIENTS_ANNOUNCE) {
  ------------------
  |  |   28|      0|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
  |  Branch (2086:9): [True: 0, False: 0]
  ------------------
 2087|      0|        pnodes = MAX_ONION_CLIENTS_ANNOUNCE;
  ------------------
  |  |   28|      0|#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
  ------------------
 2088|      0|    }
 2089|       |
 2090|       |    /* Consider ourselves online if we are announced to half or more nodes
 2091|       |     * we are connected to */
 2092|      0|    if (live != 0 && announced != 0) {
  ------------------
  |  Branch (2092:9): [True: 0, False: 0]
  |  Branch (2092:22): [True: 0, False: 0]
  ------------------
 2093|      0|        if ((live / 2) <= announced && (pnodes / 2) <= live) {
  ------------------
  |  Branch (2093:13): [True: 0, False: 0]
  |  Branch (2093:40): [True: 0, False: 0]
  ------------------
 2094|      0|            LOGGER_TRACE(onion_c->logger, "onion is connected: %u live nodes, %u announced, %d path nodes",
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2095|      0|                         live, announced, (int)pnodes);
 2096|      0|            return true;
 2097|      0|        }
 2098|      0|    }
 2099|       |
 2100|      0|    onion_c->last_populated = 0;
 2101|       |
 2102|      0|    LOGGER_TRACE(onion_c->logger, "onion is NOT connected: %u live nodes, %u announced, %d path nodes",
  ------------------
  |  |   76|      0|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2103|      0|                 live, announced, (int)pnodes);
 2104|       |    return false;
 2105|      0|}

os_memory:
   37|    221|{
   38|    221|    return &os_memory_obj;
   39|    221|}

net_inet_ntop4:
  309|     11|{
  310|     11|    struct in_addr a;
  311|     11|    fill_addr4(addr, &a);
  312|     11|    return inet_ntop4(&a, buf, bufsize);
  313|     11|}
net_inet_pton4:
  323|    255|{
  324|    255|    struct in_addr a;
  325|    255|    const int ret = inet_pton4(addr_string, &a);
  326|    255|    if (ret == 1) {
  ------------------
  |  Branch (326:9): [True: 255, False: 0]
  ------------------
  327|    255|        get_ip4(addrbuf, &a);
  328|    255|    }
  329|    255|    return ret;
  330|    255|}
net_should_ignore_recv_error:
  343|     65|{
  344|     65|    return should_ignore_recv_error(err);
  345|     65|}
os_network:
  569|    221|{
  570|    221|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  571|    221|    if ((true)) {
  ------------------
  |  Branch (571:9): [True: 221, Folded]
  ------------------
  572|    221|        return nullptr;
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
  573|    221|    }
  574|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  575|       |#ifdef OS_WIN32
  576|       |    WSADATA wsaData;
  577|       |
  578|       |    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != NO_ERROR) {
  579|       |        return nullptr;
  580|       |    }
  581|       |#endif /* OS_WIN32 */
  582|      0|    return &os_network_obj;
  583|    221|}
net_invalid_socket:
  586|    439|{
  587|    439|    return net_socket_from_native(INVALID_SOCKET);
  ------------------
  |  |  152|    439|#define INVALID_SOCKET (-1)
  ------------------
  588|    439|}
net_htonl:
  591|  1.46k|{
  592|       |    return htonl(hostlong);
  593|  1.46k|}
net_htons:
  596|  1.84k|{
  597|       |    return htons(hostshort);
  598|  1.84k|}
net_ntohs:
  606|  1.57k|{
  607|       |    return ntohs(hostshort);
  608|  1.57k|}
net_get_ip6_broadcast:
  621|    297|{
  622|    297|    const IP6 ip6_broadcast = {
  623|    297|        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
  624|    297|    };
  625|    297|    return ip6_broadcast;
  626|    297|}
net_get_ip4_loopback:
  629|     36|{
  630|     36|    IP4 loopback;
  631|       |    loopback.uint32 = htonl(INADDR_LOOPBACK);
  632|     36|    return loopback;
  633|     36|}
net_join_multicast:
  650|     91|{
  651|     91|#ifndef ESP_PLATFORM
  652|     91|    if (net_family_is_ipv6(family)) {
  ------------------
  |  Branch (652:9): [True: 91, False: 0]
  ------------------
  653|       |        /* multicast local nodes */
  654|     91|        struct ipv6_mreq mreq = {{{{0}}}};
  655|     91|        mreq.ipv6mr_multiaddr.s6_addr[0] = 0xFF;
  656|     91|        mreq.ipv6mr_multiaddr.s6_addr[1] = 0x02;
  657|     91|        mreq.ipv6mr_multiaddr.s6_addr[15] = 0x01;
  658|     91|        mreq.ipv6mr_interface = 0;
  659|       |
  660|     91|        return ns_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) == 0;
  661|     91|    }
  662|      0|#endif /* ESP_PLATFORM */
  663|      0|    return false;
  664|     91|}
net_set_socket_nonblock:
  667|    304|{
  668|       |    return ns_socket_nonblock(ns, sock, true) == 0;
  669|    304|}
net_set_socket_nosigpipe:
  672|    169|{
  673|       |#if defined(__APPLE__)
  674|       |    int set = 1;
  675|       |    return ns_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
  676|       |#else
  677|       |    return true;
  678|    169|#endif /* __APPLE__ */
  679|    169|}
net_set_socket_reuseaddr:
  682|    135|{
  683|    135|    int set = 1;
  684|       |#if defined(OS_WIN32)
  685|       |    return ns_setsockopt(ns, sock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, &set, sizeof(set)) == 0;
  686|       |#else
  687|    135|    return ns_setsockopt(ns, sock, SOL_SOCKET, SO_REUSEADDR, &set, sizeof(set)) == 0;
  688|    135|#endif /* OS_WIN32 */
  689|    135|}
net_set_socket_dualstack:
  692|    226|{
  693|    226|    int ipv6only = 0;
  694|    226|    size_t optsize = sizeof(ipv6only);
  695|    226|    const int res = ns_getsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, &optsize);
  696|       |
  697|    226|    if ((res == 0) && (ipv6only == 0)) {
  ------------------
  |  Branch (697:9): [True: 226, False: 0]
  |  Branch (697:23): [True: 226, False: 0]
  ------------------
  698|    226|        return true;
  699|    226|    }
  700|       |
  701|      0|    ipv6only = 0;
  702|      0|    return ns_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only)) == 0;
  703|    226|}
net_set_socket_buffer_size:
  706|     91|{
  707|     91|    bool ok = true;
  708|       |
  709|     91|    if (ns_setsockopt(ns, sock, SOL_SOCKET, SO_RCVBUF, &size, sizeof(size)) != 0) {
  ------------------
  |  Branch (709:9): [True: 0, False: 91]
  ------------------
  710|      0|        ok = false;
  711|      0|    }
  712|       |
  713|     91|    if (ns_setsockopt(ns, sock, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size)) != 0) {
  ------------------
  |  Branch (713:9): [True: 0, False: 91]
  ------------------
  714|      0|        ok = false;
  715|      0|    }
  716|       |
  717|     91|    return ok;
  718|     91|}
net_set_socket_broadcast:
  721|     91|{
  722|     91|    int broadcast = 1;
  723|     91|    return ns_setsockopt(ns, sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) == 0;
  724|     91|}
net_error:
  727|    244|{
  728|       |#ifdef OS_WIN32
  729|       |    return WSAGetLastError();
  730|       |#else
  731|       |    return errno;
  732|    244|#endif /* OS_WIN32 */
  733|    244|}
net_clear_error:
  736|     91|{
  737|       |#ifdef OS_WIN32
  738|       |    WSASetLastError(0);
  739|       |#else
  740|       |    errno = 0;
  741|     91|#endif /* OS_WIN32 */
  742|     91|}
os_network.c:fill_addr4:
  142|     11|{
  143|     11|    addr->s_addr = ip->uint32;
  144|     11|}
os_network.c:inet_ntop4:
  211|     11|{
  212|       |    return inet_ntop(AF_INET, addr, buf, bufsize);
  213|     11|}
os_network.c:inet_pton4:
  221|    255|{
  222|       |    return inet_pton(AF_INET, addr_string, addrbuf);
  223|    255|}
os_network.c:get_ip4:
  128|    255|{
  129|       |    static_assert(sizeof(result->uint32) == sizeof(addr->s_addr),
  130|    255|                  "Tox and operating system don't agree on size of IPv4 addresses");
  131|    255|    result->uint32 = addr->s_addr;
  132|    255|}
os_network.c:should_ignore_recv_error:
  201|     65|{
  202|       |    return err == EWOULDBLOCK;
  203|     65|}

os_random:
   31|    221|{
   32|    221|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
   33|    221|    if ((true)) {
  ------------------
  |  Branch (33:9): [True: 221, Folded]
  ------------------
   34|    221|        return nullptr;
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
   35|    221|    }
   36|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
   37|       |    // It is safe to call this function more than once and from different
   38|       |    // threads -- subsequent calls won't have any effects.
   39|      0|    if (sodium_init() == -1) {
  ------------------
  |  Branch (39:9): [True: 0, False: 0]
  ------------------
   40|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   41|      0|    }
   42|      0|    return &os_random_obj;
   43|      0|}

ping_new:
  329|    210|{
  330|    210|    Ping *ping = (Ping *)mem_alloc(mem, sizeof(Ping));
  331|       |
  332|    210|    if (ping == nullptr) {
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
  |  Branch (332:9): [True: 1, False: 209]
  ------------------
  333|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  334|      1|    }
  335|       |
  336|    209|    Ping_Array *const ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   23|    209|#define PING_NUM_MAX 512
  ------------------
                  Ping_Array *const ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   46|    209|#define PING_TIMEOUT 5
  ------------------
  337|       |
  338|    209|    if (ping_array == nullptr) {
  ------------------
  |  |   63|    209|#define nullptr NULL
  ------------------
  |  Branch (338:9): [True: 2, False: 207]
  ------------------
  339|      2|        mem_delete(mem, ping);
  340|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
  341|      2|    }
  342|    207|    ping->ping_array = ping_array;
  343|       |
  344|    207|    ping->mono_time = mono_time;
  345|    207|    ping->rng = rng;
  346|    207|    ping->mem = mem;
  347|    207|    ping->dht = dht;
  348|    207|    ping->net = net;
  349|    207|    networking_registerhandler(ping->net, NET_PACKET_PING_REQUEST, &handle_ping_request, dht);
  350|    207|    networking_registerhandler(ping->net, NET_PACKET_PING_RESPONSE, &handle_ping_response, dht);
  351|       |
  352|    207|    return ping;
  353|    209|}
ping_kill:
  356|    210|{
  357|    210|    if (ping == nullptr) {
  ------------------
  |  |   63|    210|#define nullptr NULL
  ------------------
  |  Branch (357:9): [True: 3, False: 207]
  ------------------
  358|      3|        return;
  359|      3|    }
  360|       |
  361|    207|    networking_registerhandler(ping->net, NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    207|#define nullptr NULL
  ------------------
                  networking_registerhandler(ping->net, NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|    207|#define nullptr NULL
  ------------------
  362|    207|    networking_registerhandler(ping->net, NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|    207|#define nullptr NULL
  ------------------
                  networking_registerhandler(ping->net, NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|    207|#define nullptr NULL
  ------------------
  363|    207|    ping_array_kill(ping->ping_array);
  364|       |
  365|    207|    mem_delete(mem, ping);
  366|    207|}

ping_array_new:
   37|    605|{
   38|    605|    if (size == 0 || timeout == 0) {
  ------------------
  |  Branch (38:9): [True: 0, False: 605]
  |  Branch (38:22): [True: 0, False: 605]
  ------------------
   39|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   40|      0|    }
   41|       |
   42|    605|    if ((size & (size - 1)) != 0) {
  ------------------
  |  Branch (42:9): [True: 0, False: 605]
  ------------------
   43|       |        // Not a power of 2.
   44|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   45|      0|    }
   46|       |
   47|    605|    Ping_Array *const empty_array = (Ping_Array *)mem_alloc(mem, sizeof(Ping_Array));
   48|       |
   49|    605|    if (empty_array == nullptr) {
  ------------------
  |  |   63|    605|#define nullptr NULL
  ------------------
  |  Branch (49:9): [True: 3, False: 602]
  ------------------
   50|      3|        return nullptr;
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
   51|      3|    }
   52|       |
   53|    602|    Ping_Array_Entry *const entries = (Ping_Array_Entry *)mem_valloc(mem, size, sizeof(Ping_Array_Entry));
   54|       |
   55|    602|    if (entries == nullptr) {
  ------------------
  |  |   63|    602|#define nullptr NULL
  ------------------
  |  Branch (55:9): [True: 1, False: 601]
  ------------------
   56|      1|        mem_delete(mem, empty_array);
   57|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
   58|      1|    }
   59|    601|    empty_array->entries = entries;
   60|       |
   61|    601|    empty_array->mem = mem;
   62|    601|    empty_array->last_deleted = 0;
   63|    601|    empty_array->last_added = 0;
   64|    601|    empty_array->total_size = size;
   65|    601|    empty_array->timeout = timeout;
   66|    601|    return empty_array;
   67|    602|}
ping_array_kill:
   77|    609|{
   78|    609|    if (array == nullptr) {
  ------------------
  |  |   63|    609|#define nullptr NULL
  ------------------
  |  Branch (78:9): [True: 8, False: 601]
  ------------------
   79|      8|        return;
   80|      8|    }
   81|       |
   82|    635|    while (array->last_deleted != array->last_added) {
  ------------------
  |  Branch (82:12): [True: 34, False: 601]
  ------------------
   83|     34|        const uint32_t index = array->last_deleted % array->total_size;
   84|     34|        clear_entry(array, index);
   85|     34|        ++array->last_deleted;
   86|     34|    }
   87|       |
   88|    601|    mem_delete(array->mem, array->entries);
   89|    601|    mem_delete(array->mem, array);
   90|    601|}
ping_array_add:
  109|     36|{
  110|     36|    ping_array_clear_timedout(array, mono_time);
  111|     36|    const uint32_t index = array->last_added % array->total_size;
  112|       |
  113|     36|    if (array->entries[index].data != nullptr) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (113:9): [True: 0, False: 36]
  ------------------
  114|      0|        array->last_deleted = array->last_added - array->total_size;
  115|      0|        clear_entry(array, index);
  116|      0|    }
  117|       |
  118|     36|    uint8_t *entry_data = (uint8_t *)mem_balloc(array->mem, length);
  119|       |
  120|     36|    if (entry_data == nullptr) {
  ------------------
  |  |   63|     36|#define nullptr NULL
  ------------------
  |  Branch (120:9): [True: 2, False: 34]
  ------------------
  121|      2|        array->entries[index].data = nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
  122|      2|        return 0;
  123|      2|    }
  124|       |
  125|     34|    memcpy(entry_data, data, length);
  126|       |
  127|     34|    array->entries[index].data = entry_data;
  128|     34|    array->entries[index].length = length;
  129|     34|    array->entries[index].ping_time = mono_time_get(mono_time);
  130|     34|    ++array->last_added;
  131|     34|    uint64_t ping_id = random_u64(rng);
  132|     34|    ping_id /= array->total_size;
  133|     34|    ping_id *= array->total_size;
  134|     34|    ping_id += index;
  135|       |
  136|     34|    if (ping_id == 0) {
  ------------------
  |  Branch (136:9): [True: 0, False: 34]
  ------------------
  137|      0|        ping_id += array->total_size;
  138|      0|    }
  139|       |
  140|     34|    array->entries[index].ping_id = ping_id;
  141|     34|    return ping_id;
  142|     36|}
ping_array.c:clear_entry:
   70|     34|{
   71|       |    const Ping_Array_Entry empty = {nullptr};
  ------------------
  |  |   63|     34|#define nullptr NULL
  ------------------
   72|     34|    mem_delete(array->mem, array->entries[index].data);
   73|     34|    array->entries[index] = empty;
   74|     34|}
ping_array.c:ping_array_clear_timedout:
   94|     36|{
   95|     36|    while (array->last_deleted != array->last_added) {
  ------------------
  |  Branch (95:12): [True: 0, False: 36]
  ------------------
   96|      0|        const uint32_t index = array->last_deleted % array->total_size;
   97|       |
   98|      0|        if (!mono_time_is_timeout(mono_time, array->entries[index].ping_time, array->timeout)) {
  ------------------
  |  Branch (98:13): [True: 0, False: 0]
  ------------------
   99|      0|            break;
  100|      0|        }
  101|       |
  102|      0|        clear_entry(array, index);
  103|      0|        ++array->last_deleted;
  104|      0|    }
  105|     36|}

rng_bytes:
    7|  2.82k|{
    8|  2.82k|    rng->funcs->bytes_callback(rng->user_data, bytes, length);
    9|  2.82k|}

shared_key_cache_new:
   50|  1.33k|{
   51|  1.33k|    if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|  2.66k|#define nullptr NULL
  ------------------
                  if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|  2.66k|#define nullptr NULL
  ------------------
  |  Branch (51:9): [True: 0, False: 1.33k]
  |  Branch (51:33): [True: 0, False: 1.33k]
  |  Branch (51:63): [True: 0, False: 1.33k]
  |  Branch (51:79): [True: 0, False: 1.33k]
  ------------------
   52|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   53|      0|    }
   54|       |
   55|       |    // Time must not be zero, since we use that as special value for empty slots
   56|  1.33k|    if (mono_time_get(mono_time) == 0) {
  ------------------
  |  Branch (56:9): [True: 0, False: 1.33k]
  ------------------
   57|       |        // Fail loudly in debug environments
   58|      0|        LOGGER_FATAL(log, "time must not be zero (mono_time not initialised?)");
  ------------------
  |  |   83|      0|    do {                                \
  |  |   84|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   85|      0|        logger_abort();                 \
  |  |   86|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (86:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
   59|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   60|      0|    }
   61|       |
   62|  1.33k|    Shared_Key_Cache *res = (Shared_Key_Cache *)mem_alloc(mem, sizeof(Shared_Key_Cache));
   63|  1.33k|    if (res == nullptr) {
  ------------------
  |  |   63|  1.33k|#define nullptr NULL
  ------------------
  |  Branch (63:9): [True: 16, False: 1.31k]
  ------------------
   64|     16|        return nullptr;
  ------------------
  |  |   63|     16|#define nullptr NULL
  ------------------
   65|     16|    }
   66|       |
   67|  1.31k|    res->self_secret_key = self_secret_key;
   68|  1.31k|    res->mono_time = mono_time;
   69|  1.31k|    res->mem = mem;
   70|  1.31k|    res->log = log;
   71|  1.31k|    res->keys_per_slot = keys_per_slot;
   72|       |
   73|       |    // We take one byte from the public key for each bucket and store keys_per_slot elements there
   74|  1.31k|    const size_t cache_size = 256 * keys_per_slot;
   75|  1.31k|    Shared_Key *keys = (Shared_Key *)mem_valloc(mem, cache_size, sizeof(Shared_Key));
   76|       |
   77|  1.31k|    if (keys == nullptr) {
  ------------------
  |  |   63|  1.31k|#define nullptr NULL
  ------------------
  |  Branch (77:9): [True: 13, False: 1.30k]
  ------------------
   78|     13|        mem_delete(mem, res);
   79|     13|        return nullptr;
  ------------------
  |  |   63|     13|#define nullptr NULL
  ------------------
   80|     13|    }
   81|       |
   82|  1.30k|    crypto_memlock(keys, cache_size * sizeof(Shared_Key));
   83|       |
   84|  1.30k|    res->keys = keys;
   85|       |
   86|  1.30k|    return res;
   87|  1.31k|}
shared_key_cache_free:
   90|  1.36k|{
   91|  1.36k|    if (cache == nullptr) {
  ------------------
  |  |   63|  1.36k|#define nullptr NULL
  ------------------
  |  Branch (91:9): [True: 60, False: 1.30k]
  ------------------
   92|     60|        return;
   93|     60|    }
   94|       |
   95|  1.30k|    const size_t cache_size = 256 * cache->keys_per_slot;
   96|       |    // Don't leave key material in memory
   97|  1.30k|    crypto_memzero(cache->keys, cache_size * sizeof(Shared_Key));
   98|  1.30k|    crypto_memunlock(cache->keys, cache_size * sizeof(Shared_Key));
   99|  1.30k|    mem_delete(cache->mem, cache->keys);
  100|  1.30k|    mem_delete(cache->mem, cache);
  101|  1.30k|}
shared_key_cache_lookup:
  105|     34|{
  106|       |    // caching the time is not necessary, but calls to mono_time_get(...) are not free
  107|     34|    const uint64_t cur_time = mono_time_get(cache->mono_time);
  108|       |    // We can't use the first and last bytes because they are masked in curve25519. Selected 8 for good alignment.
  109|     34|    const uint8_t bucket_idx = public_key[8];
  110|     34|    Shared_Key *bucket_start = &cache->keys[bucket_idx * cache->keys_per_slot];
  111|       |
  112|     34|    const uint8_t *found = nullptr;
  ------------------
  |  |   63|     34|#define nullptr NULL
  ------------------
  113|       |
  114|       |    // Perform lookup
  115|    170|    for (size_t i = 0; i < cache->keys_per_slot; ++i) {
  ------------------
  |  Branch (115:24): [True: 136, False: 34]
  ------------------
  116|    136|        if (shared_key_is_empty(cache->log, &bucket_start[i])) {
  ------------------
  |  Branch (116:13): [True: 136, False: 0]
  ------------------
  117|    136|            continue;
  118|    136|        }
  119|       |
  120|      0|        if (pk_equal(public_key, bucket_start[i].public_key)) {
  ------------------
  |  Branch (120:13): [True: 0, False: 0]
  ------------------
  121|      0|            found = bucket_start[i].shared_key;
  122|      0|            bucket_start[i].time_last_requested = cur_time;
  123|      0|            break;
  124|      0|        }
  125|      0|    }
  126|       |
  127|       |    // Perform housekeeping for this bucket
  128|    170|    for (size_t i = 0; i < cache->keys_per_slot; ++i) {
  ------------------
  |  Branch (128:24): [True: 136, False: 34]
  ------------------
  129|    136|        if (shared_key_is_empty(cache->log, &bucket_start[i])) {
  ------------------
  |  Branch (129:13): [True: 136, False: 0]
  ------------------
  130|    136|            continue;
  131|    136|        }
  132|       |
  133|      0|        const bool timed_out = (bucket_start[i].time_last_requested + cache->timeout) < cur_time;
  134|      0|        if (timed_out) {
  ------------------
  |  Branch (134:13): [True: 0, False: 0]
  ------------------
  135|      0|            shared_key_set_empty(cache->log, &bucket_start[i]);
  136|      0|        }
  137|      0|    }
  138|       |
  139|     34|    if (found == nullptr) {
  ------------------
  |  |   63|     34|#define nullptr NULL
  ------------------
  |  Branch (139:9): [True: 34, False: 0]
  ------------------
  140|       |        // Insert into cache
  141|       |
  142|     34|        uint64_t oldest_timestamp = UINT64_MAX;
  143|     34|        size_t oldest_index = 0;
  144|       |
  145|       |        /*
  146|       |         *  Find least recently used entry, unused entries are prioritised,
  147|       |         *  because their time_last_requested field is zeroed.
  148|       |         */
  149|    170|        for (size_t i = 0; i < cache->keys_per_slot; ++i) {
  ------------------
  |  Branch (149:28): [True: 136, False: 34]
  ------------------
  150|    136|            if (bucket_start[i].time_last_requested < oldest_timestamp) {
  ------------------
  |  Branch (150:17): [True: 34, False: 102]
  ------------------
  151|     34|                oldest_timestamp = bucket_start[i].time_last_requested;
  152|     34|                oldest_index = i;
  153|     34|            }
  154|    136|        }
  155|       |
  156|       |        // Compute the shared key for the cache
  157|     34|        if (encrypt_precompute(public_key, cache->self_secret_key, bucket_start[oldest_index].shared_key) != 0) {
  ------------------
  |  Branch (157:13): [True: 0, False: 34]
  ------------------
  158|       |            // Don't put anything in the cache on error
  159|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  160|      0|        }
  161|       |
  162|       |        // update cache entry
  163|     34|        memcpy(bucket_start[oldest_index].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   44|     34|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  164|     34|        bucket_start[oldest_index].time_last_requested = cur_time;
  165|     34|        found = bucket_start[oldest_index].shared_key;
  166|     34|    }
  167|       |
  168|     34|    return found;
  169|     34|}
shared_key_cache.c:shared_key_is_empty:
   34|    272|{
   35|    272|    LOGGER_ASSERT(log, k != nullptr, "shared key must not be NULL");
  ------------------
  |  |   89|    272|    do {                                           \
  |  |   90|    272|        if (!(cond)) {                             \
  |  |  ------------------
  |  |  |  Branch (90:13): [True: 0, False: 272]
  |  |  ------------------
  |  |   91|      0|            LOGGER_ERROR(log, "Assertion failed"); \
  |  |  ------------------
  |  |  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   92|      0|            LOGGER_FATAL(log, __VA_ARGS__);        \
  |  |  ------------------
  |  |  |  |   83|      0|    do {                                \
  |  |  |  |   84|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |   85|      0|        logger_abort();                 \
  |  |  |  |   86|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (86:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   93|      0|        }                                          \
  |  |   94|    272|    } while (0)
  |  |  ------------------
  |  |  |  Branch (94:14): [Folded, False: 272]
  |  |  ------------------
  ------------------
   36|       |    /*
   37|       |     * Since time can never be 0, we use that to determine if a key slot is empty.
   38|       |     * Additionally this allows us to use crypto_memzero and leave the slot in a valid state.
   39|       |     */
   40|    272|    return k->time_last_requested == 0;
   41|    272|}

tox_new_testing:
  979|    221|{
  980|    221|    if (testing == nullptr) {
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
  |  Branch (980:9): [True: 0, False: 221]
  ------------------
  981|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  982|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  983|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  984|      0|    }
  985|       |
  986|    221|    if (testing->operating_system == nullptr) {
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
  |  Branch (986:9): [True: 0, False: 221]
  ------------------
  987|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  988|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  989|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  990|      0|    }
  991|       |
  992|    221|    const Tox_System *sys = testing->operating_system;
  993|       |
  994|    221|    if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|    442|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|    442|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
  |  Branch (994:9): [True: 0, False: 221]
  |  Branch (994:32): [True: 0, False: 221]
  |  Branch (994:54): [True: 0, False: 221]
  ------------------
  995|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  996|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  997|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  998|      0|    }
  999|       |
 1000|    221|    SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_OK);
  ------------------
  |  |   45|    221|    do {                              \
  |  |   46|    221|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|    442|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 221, False: 0]
  |  |  ------------------
  |  |   47|    221|            *param = x;               \
  |  |   48|    221|        }                             \
  |  |   49|    221|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 221]
  |  |  ------------------
  ------------------
 1001|    221|    return tox_new_system(options, error, sys);
 1002|    221|}
tox_kill:
 1005|     66|{
 1006|     66|    if (tox == nullptr) {
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
  |  Branch (1006:9): [True: 0, False: 66]
  ------------------
 1007|      0|        return;
 1008|      0|    }
 1009|       |
 1010|     66|    tox_lock(tox);
 1011|     66|    LOGGER_ASSERT(tox->m->log, tox->toxav_object == nullptr, "Attempted to kill tox while toxav is still alive");
  ------------------
  |  |   89|     66|    do {                                           \
  |  |   90|     66|        if (!(cond)) {                             \
  |  |  ------------------
  |  |  |  Branch (90:13): [True: 0, False: 66]
  |  |  ------------------
  |  |   91|      0|            LOGGER_ERROR(log, "Assertion failed"); \
  |  |  ------------------
  |  |  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   92|      0|            LOGGER_FATAL(log, __VA_ARGS__);        \
  |  |  ------------------
  |  |  |  |   83|      0|    do {                                \
  |  |  |  |   84|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  |   80|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   69|      0|    do {                                                                         \
  |  |  |  |  |  |  |  |   70|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (70:13): [True: 0, Folded]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |  |  |  |  |   73|      0|    } while (0)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (73:14): [Folded, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |   85|      0|        logger_abort();                 \
  |  |  |  |   86|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (86:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   93|      0|        }                                          \
  |  |   94|     66|    } while (0)
  |  |  ------------------
  |  |  |  Branch (94:14): [Folded, False: 66]
  |  |  ------------------
  ------------------
 1012|     66|    kill_groupchats(tox->m->conferences_object);
 1013|     66|    kill_messenger(tox->m);
 1014|     66|    logger_kill(tox->log);
 1015|     66|    mono_time_free(tox->sys.mem, tox->mono_time);
 1016|     66|    tox_unlock(tox);
 1017|       |
 1018|     66|    if (tox->mutex != nullptr) {
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
  |  Branch (1018:9): [True: 0, False: 66]
  ------------------
 1019|      0|        pthread_mutex_destroy(tox->mutex);
 1020|      0|        mem_delete(tox->sys.mem, tox->mutex);
 1021|      0|    }
 1022|       |
 1023|     66|    mem_delete(tox->sys.mem, tox);
 1024|     66|}
tox_bootstrap:
 1105|     66|{
 1106|     66|    IP_Port *root;
 1107|     66|    const int32_t count = resolve_bootstrap_node(tox, host, port, public_key, &root, error);
 1108|       |
 1109|     66|    if (count == -1) {
  ------------------
  |  Branch (1109:9): [True: 9, False: 57]
  ------------------
 1110|      9|        return false;
 1111|      9|    }
 1112|       |
 1113|     57|    tox_lock(tox);
 1114|     57|    assert(count >= 0);
  ------------------
  |  Branch (1114:5): [True: 57, False: 0]
  ------------------
 1115|     57|    bool onion_success = false;
 1116|       |    // UDP bootstrap is default success if it's disabled (because we don't even try).
 1117|     57|    bool udp_success = tox->m->options.udp_disabled;
 1118|       |
 1119|    114|    for (int32_t i = 0; i < count; ++i) {
  ------------------
  |  Branch (1119:25): [True: 57, False: 57]
  ------------------
 1120|     57|        if (!tox->m->options.ipv6enabled && net_family_is_ipv6(root[i].ip.family)) {
  ------------------
  |  Branch (1120:13): [True: 0, False: 57]
  |  Branch (1120:45): [True: 0, False: 0]
  ------------------
 1121|       |            // We can't use ipv6 when it's disabled.
 1122|      0|            continue;
 1123|      0|        }
 1124|       |
 1125|     57|        root[i].port = net_htons(port);
 1126|       |
 1127|     57|        if (onion_add_bs_path_node(tox->m->onion_c, &root[i], public_key)) {
  ------------------
  |  Branch (1127:13): [True: 57, False: 0]
  ------------------
 1128|       |            // If UDP is enabled, the caller cares about whether any of the
 1129|       |            // bootstrap calls below will succeed. In TCP-only mode, adding
 1130|       |            // onion path nodes successfully is sufficient.
 1131|     57|            onion_success = true;
 1132|     57|        }
 1133|       |
 1134|     57|        if (!tox->m->options.udp_disabled) {
  ------------------
  |  Branch (1134:13): [True: 36, False: 21]
  ------------------
 1135|     36|            if (dht_bootstrap(tox->m->dht, &root[i], public_key)) {
  ------------------
  |  Branch (1135:17): [True: 31, False: 5]
  ------------------
 1136|       |                // If any of the bootstrap calls worked, we call it success.
 1137|     31|                udp_success = true;
 1138|     31|            }
 1139|     36|        }
 1140|     57|    }
 1141|       |
 1142|     57|    tox_unlock(tox);
 1143|       |
 1144|     57|    net_freeipport(tox->sys.mem, root);
 1145|       |
 1146|     57|    if (count == 0 || !onion_success || !udp_success) {
  ------------------
  |  Branch (1146:9): [True: 0, False: 57]
  |  Branch (1146:23): [True: 0, False: 57]
  |  Branch (1146:41): [True: 5, False: 52]
  ------------------
 1147|      5|        LOGGER_DEBUG(tox->m->log, "bootstrap node '%s' resolved to %d IP_Ports%s (onion: %s, UDP: %s)",
  ------------------
  |  |   77|      5|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|      5|    do {                                                                         \
  |  |  |  |   70|      5|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     10|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 5]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (71:68): [True: 0, False: 0]
  |  |  |  |  |  Branch (71:68): [True: 0, False: 0]
  |  |  |  |  |  Branch (71:68): [True: 0, False: 0]
  |  |  |  |  |  Branch (71:68): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|      5|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 5]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1148|      5|                     host, count,
 1149|      5|                     count > 0 ? ", but failed to bootstrap with any of them" : "",
 1150|      5|                     onion_success ? "success" : "FAILURE",
 1151|      5|                     tox->m->options.udp_disabled ? "disabled" : (udp_success ? "success" : "FAILURE"));
 1152|      5|        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_HOST);
  ------------------
  |  |   45|      5|    do {                              \
  |  |   46|      5|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|     10|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 5]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      5|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 5]
  |  |  ------------------
  ------------------
 1153|      5|        return false;
 1154|      5|    }
 1155|       |
 1156|     52|    SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_OK);
  ------------------
  |  |   45|     52|    do {                              \
  |  |   46|     52|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|    104|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 52]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|     52|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 52]
  |  |  ------------------
  ------------------
 1157|       |    return true;
 1158|     57|}
tox_add_tcp_relay:
 1162|     66|{
 1163|     66|    IP_Port *root;
 1164|     66|    const int32_t count = resolve_bootstrap_node(tox, host, port, public_key, &root, error);
 1165|       |
 1166|     66|    if (count == -1) {
  ------------------
  |  Branch (1166:9): [True: 7, False: 59]
  ------------------
 1167|      7|        return false;
 1168|      7|    }
 1169|       |
 1170|     59|    tox_lock(tox);
 1171|     59|    assert(count >= 0);
  ------------------
  |  Branch (1171:5): [True: 59, False: 0]
  ------------------
 1172|       |
 1173|    118|    for (int32_t i = 0; i < count; ++i) {
  ------------------
  |  Branch (1173:25): [True: 59, False: 59]
  ------------------
 1174|     59|        root[i].port = net_htons(port);
 1175|       |
 1176|     59|        add_tcp_relay(tox->m->net_crypto, &root[i], public_key);
 1177|     59|    }
 1178|       |
 1179|     59|    tox_unlock(tox);
 1180|       |
 1181|     59|    net_freeipport(tox->sys.mem, root);
 1182|       |
 1183|     59|    if (count == 0) {
  ------------------
  |  Branch (1183:9): [True: 0, False: 59]
  ------------------
 1184|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_HOST);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
 1185|      0|        return false;
 1186|      0|    }
 1187|       |
 1188|     59|    SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_OK);
  ------------------
  |  |   45|     59|    do {                              \
  |  |   46|     59|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|    118|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 59]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|     59|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 59]
  |  |  ------------------
  ------------------
 1189|       |    return true;
 1190|     59|}
tox_callback_self_connection_status:
 1215|     66|{
 1216|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (1216:5): [True: 66, False: 0]
  ------------------
 1217|     66|    tox->self_connection_status_callback = callback;
 1218|     66|}
tox_iterate:
 1235|     82|{
 1236|     82|    assert(tox != nullptr);
  ------------------
  |  Branch (1236:5): [True: 82, False: 0]
  ------------------
 1237|     82|    tox_lock(tox);
 1238|       |
 1239|     82|    mono_time_update(tox->mono_time);
 1240|       |
 1241|     82|    struct Tox_Userdata tox_data = { tox, user_data };
 1242|     82|    do_messenger(tox->m, &tox_data);
 1243|     82|    do_groupchats(tox->m->conferences_object, &tox_data);
 1244|       |
 1245|     82|    tox_unlock(tox);
 1246|     82|}
tox_callback_friend_name:
 1641|     66|{
 1642|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (1642:5): [True: 66, False: 0]
  ------------------
 1643|     66|    tox->friend_name_callback = callback;
 1644|     66|}
tox_callback_friend_status_message:
 1690|     66|{
 1691|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (1691:5): [True: 66, False: 0]
  ------------------
 1692|     66|    tox->friend_status_message_callback = callback;
 1693|     66|}
tox_callback_friend_status:
 1712|     66|{
 1713|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (1713:5): [True: 66, False: 0]
  ------------------
 1714|     66|    tox->friend_status_callback = callback;
 1715|     66|}
tox_callback_friend_connection_status:
 1734|     66|{
 1735|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (1735:5): [True: 66, False: 0]
  ------------------
 1736|     66|    tox->friend_connection_status_callback = callback;
 1737|     66|}
tox_callback_friend_typing:
 1756|     66|{
 1757|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (1757:5): [True: 66, False: 0]
  ------------------
 1758|     66|    tox->friend_typing_callback = callback;
 1759|     66|}
tox_callback_friend_read_receipt:
 1842|     66|{
 1843|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (1843:5): [True: 66, False: 0]
  ------------------
 1844|     66|    tox->friend_read_receipt_callback = callback;
 1845|     66|}
tox_callback_friend_request:
 1848|     66|{
 1849|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (1849:5): [True: 66, False: 0]
  ------------------
 1850|     66|    tox->friend_request_callback = callback;
 1851|     66|}
tox_callback_friend_message:
 1854|     66|{
 1855|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (1855:5): [True: 66, False: 0]
  ------------------
 1856|     66|    tox->friend_message_callback = callback;
 1857|     66|}
tox_callback_file_recv_control:
 1984|     66|{
 1985|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (1985:5): [True: 66, False: 0]
  ------------------
 1986|     66|    tox->file_recv_control_callback = callback;
 1987|     66|}
tox_callback_file_chunk_request:
 2157|     66|{
 2158|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2158:5): [True: 66, False: 0]
  ------------------
 2159|     66|    tox->file_chunk_request_callback = callback;
 2160|     66|}
tox_callback_file_recv:
 2163|     66|{
 2164|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2164:5): [True: 66, False: 0]
  ------------------
 2165|     66|    tox->file_recv_callback = callback;
 2166|     66|}
tox_callback_file_recv_chunk:
 2169|     66|{
 2170|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2170:5): [True: 66, False: 0]
  ------------------
 2171|     66|    tox->file_recv_chunk_callback = callback;
 2172|     66|}
tox_callback_conference_invite:
 2175|     66|{
 2176|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2176:5): [True: 66, False: 0]
  ------------------
 2177|     66|    tox->conference_invite_callback = callback;
 2178|     66|}
tox_callback_conference_connected:
 2181|     66|{
 2182|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2182:5): [True: 66, False: 0]
  ------------------
 2183|     66|    tox->conference_connected_callback = callback;
 2184|     66|}
tox_callback_conference_message:
 2187|     66|{
 2188|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2188:5): [True: 66, False: 0]
  ------------------
 2189|     66|    tox->conference_message_callback = callback;
 2190|     66|}
tox_callback_conference_title:
 2193|     66|{
 2194|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2194:5): [True: 66, False: 0]
  ------------------
 2195|     66|    tox->conference_title_callback = callback;
 2196|     66|}
tox_callback_conference_peer_name:
 2199|     66|{
 2200|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2200:5): [True: 66, False: 0]
  ------------------
 2201|     66|    tox->conference_peer_name_callback = callback;
 2202|     66|}
tox_callback_conference_peer_list_changed:
 2205|     66|{
 2206|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2206:5): [True: 66, False: 0]
  ------------------
 2207|     66|    tox->conference_peer_list_changed_callback = callback;
 2208|     66|}
tox_callback_friend_lossy_packet:
 2859|     66|{
 2860|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2860:5): [True: 66, False: 0]
  ------------------
 2861|       |
 2862|       |    /* start at PACKET_ID_RANGE_LOSSY_CUSTOM_START so ToxAV Packets are excluded */
 2863|  3.69k|    for (uint8_t i = PACKET_ID_RANGE_LOSSY_CUSTOM_START; i <= PACKET_ID_RANGE_LOSSY_END; ++i) {
  ------------------
  |  |   62|     66|#define PACKET_ID_RANGE_LOSSY_CUSTOM_START 200
  ------------------
                  for (uint8_t i = PACKET_ID_RANGE_LOSSY_CUSTOM_START; i <= PACKET_ID_RANGE_LOSSY_END; ++i) {
  ------------------
  |  |   64|  3.69k|#define PACKET_ID_RANGE_LOSSY_END 254
  ------------------
  |  Branch (2863:58): [True: 3.63k, False: 66]
  ------------------
 2864|  3.63k|        tox->friend_lossy_packet_callback_per_pktid[i] = callback;
 2865|  3.63k|    }
 2866|     66|}
tox_callback_friend_lossless_packet:
 2894|     66|{
 2895|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2895:5): [True: 66, False: 0]
  ------------------
 2896|       |
 2897|  2.17k|    for (uint8_t i = PACKET_ID_RANGE_LOSSLESS_CUSTOM_START; i <= PACKET_ID_RANGE_LOSSLESS_CUSTOM_END; ++i) {
  ------------------
  |  |   54|     66|#define PACKET_ID_RANGE_LOSSLESS_CUSTOM_START 160
  ------------------
                  for (uint8_t i = PACKET_ID_RANGE_LOSSLESS_CUSTOM_START; i <= PACKET_ID_RANGE_LOSSLESS_CUSTOM_END; ++i) {
  ------------------
  |  |   55|  2.17k|#define PACKET_ID_RANGE_LOSSLESS_CUSTOM_END 191
  ------------------
  |  Branch (2897:61): [True: 2.11k, False: 66]
  ------------------
 2898|  2.11k|        tox->friend_lossless_packet_callback_per_pktid[i] = callback;
 2899|  2.11k|    }
 2900|     66|}
tox_callback_group_invite:
 2949|     66|{
 2950|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2950:5): [True: 66, False: 0]
  ------------------
 2951|     66|    tox->group_invite_callback = callback;
 2952|     66|}
tox_callback_group_message:
 2955|     66|{
 2956|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2956:5): [True: 66, False: 0]
  ------------------
 2957|     66|    tox->group_message_callback = callback;
 2958|     66|}
tox_callback_group_private_message:
 2961|     66|{
 2962|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2962:5): [True: 66, False: 0]
  ------------------
 2963|     66|    tox->group_private_message_callback = callback;
 2964|     66|}
tox_callback_group_custom_packet:
 2967|     66|{
 2968|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2968:5): [True: 66, False: 0]
  ------------------
 2969|     66|    tox->group_custom_packet_callback = callback;
 2970|     66|}
tox_callback_group_custom_private_packet:
 2973|     66|{
 2974|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2974:5): [True: 66, False: 0]
  ------------------
 2975|     66|    tox->group_custom_private_packet_callback = callback;
 2976|     66|}
tox_callback_group_moderation:
 2979|     66|{
 2980|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2980:5): [True: 66, False: 0]
  ------------------
 2981|     66|    tox->group_moderation_callback = callback;
 2982|     66|}
tox_callback_group_peer_name:
 2985|     66|{
 2986|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2986:5): [True: 66, False: 0]
  ------------------
 2987|     66|    tox->group_peer_name_callback = callback;
 2988|     66|}
tox_callback_group_peer_status:
 2991|     66|{
 2992|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2992:5): [True: 66, False: 0]
  ------------------
 2993|     66|    tox->group_peer_status_callback = callback;
 2994|     66|}
tox_callback_group_topic:
 2997|     66|{
 2998|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (2998:5): [True: 66, False: 0]
  ------------------
 2999|     66|    tox->group_topic_callback = callback;
 3000|     66|}
tox_callback_group_privacy_state:
 3003|     66|{
 3004|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (3004:5): [True: 66, False: 0]
  ------------------
 3005|     66|    tox->group_privacy_state_callback = callback;
 3006|     66|}
tox_callback_group_topic_lock:
 3009|     66|{
 3010|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (3010:5): [True: 66, False: 0]
  ------------------
 3011|     66|    tox->group_topic_lock_callback = callback;
 3012|     66|}
tox_callback_group_voice_state:
 3015|     66|{
 3016|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (3016:5): [True: 66, False: 0]
  ------------------
 3017|     66|    tox->group_voice_state_callback = callback;
 3018|     66|}
tox_callback_group_peer_limit:
 3021|     66|{
 3022|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (3022:5): [True: 66, False: 0]
  ------------------
 3023|     66|    tox->group_peer_limit_callback = callback;
 3024|     66|}
tox_callback_group_password:
 3027|     66|{
 3028|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (3028:5): [True: 66, False: 0]
  ------------------
 3029|     66|    tox->group_password_callback = callback;
 3030|     66|}
tox_callback_group_peer_join:
 3033|     66|{
 3034|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (3034:5): [True: 66, False: 0]
  ------------------
 3035|     66|    tox->group_peer_join_callback = callback;
 3036|     66|}
tox_callback_group_peer_exit:
 3039|     66|{
 3040|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (3040:5): [True: 66, False: 0]
  ------------------
 3041|     66|    tox->group_peer_exit_callback = callback;
 3042|     66|}
tox_callback_group_self_join:
 3045|     66|{
 3046|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (3046:5): [True: 66, False: 0]
  ------------------
 3047|     66|    tox->group_self_join_callback = callback;
 3048|     66|}
tox_callback_group_join_fail:
 3051|     66|{
 3052|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (3052:5): [True: 66, False: 0]
  ------------------
 3053|     66|    tox->group_join_fail_callback = callback;
 3054|     66|}
tox_get_system:
 4727|     82|{
 4728|     82|    assert(tox != nullptr);
  ------------------
  |  Branch (4728:5): [True: 82, False: 0]
  ------------------
 4729|     82|    return &tox->sys;
 4730|     82|}
tox.c:tox_new_system:
  638|    221|{
  639|    221|    struct Tox_Options *default_options = nullptr;
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
  640|    221|    if (options == nullptr) {
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
  |  Branch (640:9): [True: 0, False: 221]
  ------------------
  641|      0|        Tox_Err_Options_New err;
  642|      0|        default_options = tox_options_new(&err);
  643|       |
  644|      0|        switch (err) {
  ------------------
  |  Branch (644:17): [True: 0, False: 0]
  ------------------
  645|      0|            case TOX_ERR_OPTIONS_NEW_OK: {
  ------------------
  |  Branch (645:13): [True: 0, False: 0]
  ------------------
  646|      0|                assert(default_options != nullptr);
  ------------------
  |  Branch (646:17): [True: 0, False: 0]
  ------------------
  647|      0|                break;
  648|      0|            }
  649|       |
  650|      0|            case TOX_ERR_OPTIONS_NEW_MALLOC: {
  ------------------
  |  Branch (650:13): [True: 0, False: 0]
  ------------------
  651|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  652|      0|                return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  653|      0|            }
  654|      0|        }
  655|      0|    }
  656|       |
  657|    221|    const struct Tox_Options *const opts = options != nullptr ? options : default_options;
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
  |  Branch (657:44): [True: 221, False: 0]
  ------------------
  658|    221|    assert(opts != nullptr);
  ------------------
  |  Branch (658:5): [True: 221, False: 0]
  ------------------
  659|       |
  660|    221|    const Tox_System default_system = tox_default_system();
  661|       |
  662|    221|    if (sys == nullptr) {
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
  |  Branch (662:9): [True: 0, False: 221]
  ------------------
  663|      0|        sys = &default_system;
  664|      0|    }
  665|       |
  666|    221|    if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|    442|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|    442|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
  |  Branch (666:9): [True: 0, False: 221]
  |  Branch (666:32): [True: 0, False: 221]
  |  Branch (666:54): [True: 0, False: 221]
  ------------------
  667|       |        // TODO(iphydf): Not quite right, but similar.
  668|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  669|      0|        tox_options_free(default_options);
  670|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  671|      0|    }
  672|       |
  673|    221|    const Random *const rng = sys->rng;
  674|    221|    const Network *const ns = sys->ns;
  675|    221|    const Memory *const mem = sys->mem;
  676|       |
  677|    221|    Messenger_Options m_options = {nullptr};
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
  678|       |
  679|    221|    m_options.dns_enabled = !tox_options_get_experimental_disable_dns(opts);
  680|       |
  681|    221|    bool load_savedata_sk = false;
  682|    221|    bool load_savedata_tox = false;
  683|       |
  684|    221|    if (tox_options_get_savedata_type(opts) != TOX_SAVEDATA_TYPE_NONE) {
  ------------------
  |  Branch (684:9): [True: 0, False: 221]
  ------------------
  685|      0|        if (tox_options_get_savedata_data(opts) == nullptr || tox_options_get_savedata_length(opts) == 0) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (685:13): [True: 0, False: 0]
  |  Branch (685:63): [True: 0, False: 0]
  ------------------
  686|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  687|      0|            tox_options_free(default_options);
  688|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  689|      0|        }
  690|      0|    }
  691|       |
  692|    221|    if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_SECRET_KEY) {
  ------------------
  |  Branch (692:9): [True: 0, False: 221]
  ------------------
  693|      0|        if (tox_options_get_savedata_length(opts) != TOX_SECRET_KEY_SIZE) {
  ------------------
  |  |  221|      0|#define TOX_SECRET_KEY_SIZE            32
  ------------------
  |  Branch (693:13): [True: 0, False: 0]
  ------------------
  694|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  695|      0|            tox_options_free(default_options);
  696|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  697|      0|        }
  698|       |
  699|      0|        load_savedata_sk = true;
  700|    221|    } else if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_TOX_SAVE) {
  ------------------
  |  Branch (700:16): [True: 0, False: 221]
  ------------------
  701|      0|        if (tox_options_get_savedata_length(opts) < TOX_ENC_SAVE_MAGIC_LENGTH) {
  ------------------
  |  |   10|      0|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (701:13): [True: 0, False: 0]
  ------------------
  702|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  703|      0|            tox_options_free(default_options);
  704|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  705|      0|        }
  706|       |
  707|      0|        if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |    9|      0|#define TOX_ENC_SAVE_MAGIC_NUMBER ((const uint8_t *)"toxEsave")
  ------------------
                      if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |   10|      0|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (707:13): [True: 0, False: 0]
  ------------------
  708|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_ENCRYPTED);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  709|      0|            tox_options_free(default_options);
  710|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  711|      0|        }
  712|       |
  713|      0|        load_savedata_tox = true;
  714|      0|    }
  715|       |
  716|    221|    m_options.ipv6enabled = tox_options_get_ipv6_enabled(opts);
  717|    221|    m_options.udp_disabled = !tox_options_get_udp_enabled(opts);
  718|    221|    m_options.port_range[0] = tox_options_get_start_port(opts);
  719|    221|    m_options.port_range[1] = tox_options_get_end_port(opts);
  720|    221|    m_options.tcp_server_port = tox_options_get_tcp_port(opts);
  721|    221|    m_options.hole_punching_enabled = tox_options_get_hole_punching_enabled(opts);
  722|    221|    m_options.local_discovery_enabled = tox_options_get_local_discovery_enabled(opts);
  723|    221|    m_options.dht_announcements_enabled = tox_options_get_dht_announcements_enabled(opts);
  724|    221|    m_options.groups_persistence_enabled = tox_options_get_experimental_groups_persistence(opts);
  725|       |
  726|    221|    if (m_options.udp_disabled) {
  ------------------
  |  Branch (726:9): [True: 0, False: 221]
  ------------------
  727|      0|        m_options.local_discovery_enabled = false;
  728|      0|    }
  729|       |
  730|    221|    Tox *tox = (Tox *)mem_alloc(mem, sizeof(Tox));
  731|       |
  732|    221|    if (tox == nullptr) {
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
  |  Branch (732:9): [True: 1, False: 220]
  ------------------
  733|      1|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      1|    do {                              \
  |  |   46|      1|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      2|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 1, False: 0]
  |  |  ------------------
  |  |   47|      1|            *param = x;               \
  |  |   48|      1|        }                             \
  |  |   49|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 1]
  |  |  ------------------
  ------------------
  734|      1|        tox_options_free(default_options);
  735|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  736|      1|    }
  737|       |
  738|    220|    tox->log_callback = tox_options_get_log_callback(opts);
  739|       |
  740|    220|    Logger *log = logger_new(mem);
  741|       |
  742|    220|    if (log == nullptr) {
  ------------------
  |  |   63|    220|#define nullptr NULL
  ------------------
  |  Branch (742:9): [True: 1, False: 219]
  ------------------
  743|      1|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      1|    do {                              \
  |  |   46|      1|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      2|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 1, False: 0]
  |  |  ------------------
  |  |   47|      1|            *param = x;               \
  |  |   48|      1|        }                             \
  |  |   49|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 1]
  |  |  ------------------
  ------------------
  744|      1|        mem_delete(mem, tox);
  745|      1|        tox_options_free(default_options);
  746|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  747|      1|    }
  748|       |
  749|    219|    tox->log = log;
  750|       |
  751|    219|    m_options.log = tox->log;
  752|       |
  753|    219|    logger_callback_log(tox->log, tox_log_handler, tox, tox_options_get_log_user_data(opts));
  754|       |
  755|    219|    switch (tox_options_get_proxy_type(opts)) {
  756|     51|        case TOX_PROXY_TYPE_HTTP: {
  ------------------
  |  Branch (756:9): [True: 51, False: 168]
  ------------------
  757|     51|            m_options.proxy_info.proxy_type = TCP_PROXY_HTTP;
  758|     51|            break;
  759|      0|        }
  760|       |
  761|     72|        case TOX_PROXY_TYPE_SOCKS5: {
  ------------------
  |  Branch (761:9): [True: 72, False: 147]
  ------------------
  762|     72|            m_options.proxy_info.proxy_type = TCP_PROXY_SOCKS5;
  763|     72|            break;
  764|      0|        }
  765|       |
  766|     96|        case TOX_PROXY_TYPE_NONE: {
  ------------------
  |  Branch (766:9): [True: 96, False: 123]
  ------------------
  767|     96|            m_options.proxy_info.proxy_type = TCP_PROXY_NONE;
  768|     96|            break;
  769|      0|        }
  770|       |
  771|      0|        default: {
  ------------------
  |  Branch (771:9): [True: 0, False: 219]
  ------------------
  772|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_TYPE);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  773|      0|            logger_kill(tox->log);
  774|      0|            mem_delete(mem, tox);
  775|      0|            tox_options_free(default_options);
  776|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  777|      0|        }
  778|    219|    }
  779|       |
  780|    219|    tox->sys = *sys;
  781|       |
  782|    219|    if (m_options.proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (782:9): [True: 123, False: 96]
  ------------------
  783|    123|        if (tox_options_get_proxy_port(opts) == 0) {
  ------------------
  |  Branch (783:13): [True: 0, False: 123]
  ------------------
  784|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_PORT);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  785|      0|            logger_kill(tox->log);
  786|      0|            mem_delete(mem, tox);
  787|      0|            tox_options_free(default_options);
  788|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  789|      0|        }
  790|       |
  791|    123|        ip_init(&m_options.proxy_info.ip_port.ip, m_options.ipv6enabled);
  792|       |
  793|    123|        if (m_options.ipv6enabled) {
  ------------------
  |  Branch (793:13): [True: 123, False: 0]
  ------------------
  794|    123|            m_options.proxy_info.ip_port.ip.family = net_family_unspec();
  795|    123|        }
  796|       |
  797|    123|        const char *const proxy_host = tox_options_get_proxy_host(opts);
  798|    123|        const bool dns_enabled = !tox_options_get_experimental_disable_dns(opts);
  799|       |
  800|    123|        if (proxy_host == nullptr
  ------------------
  |  |   63|    246|#define nullptr NULL
  ------------------
  |  Branch (800:13): [True: 0, False: 123]
  ------------------
  801|    123|                || !addr_resolve_or_parse_ip(ns, mem, proxy_host, &m_options.proxy_info.ip_port.ip, nullptr, dns_enabled)) {
  ------------------
  |  |   63|    123|#define nullptr NULL
  ------------------
  |  Branch (801:20): [True: 0, False: 123]
  ------------------
  802|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_HOST);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  803|       |            // TODO(irungentoo): TOX_ERR_NEW_PROXY_NOT_FOUND if domain.
  804|      0|            logger_kill(tox->log);
  805|      0|            mem_delete(mem, tox);
  806|      0|            tox_options_free(default_options);
  807|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  808|      0|        }
  809|       |
  810|    123|        m_options.proxy_info.ip_port.port = net_htons(tox_options_get_proxy_port(opts));
  811|    123|    }
  812|       |
  813|    219|    Mono_Time *temp_mono_time = mono_time_new(mem, sys->mono_time_callback, sys->mono_time_user_data);
  814|       |
  815|    219|    if (temp_mono_time == nullptr) {
  ------------------
  |  |   63|    219|#define nullptr NULL
  ------------------
  |  Branch (815:9): [True: 2, False: 217]
  ------------------
  816|      2|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      2|    do {                              \
  |  |   46|      2|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      4|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 2, False: 0]
  |  |  ------------------
  |  |   47|      2|            *param = x;               \
  |  |   48|      2|        }                             \
  |  |   49|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 2]
  |  |  ------------------
  ------------------
  817|      2|        logger_kill(tox->log);
  818|      2|        mem_delete(mem, tox);
  819|      2|        tox_options_free(default_options);
  820|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
  821|      2|    }
  822|    217|    tox->mono_time = temp_mono_time;
  823|       |
  824|    217|    if (tox_options_get_experimental_thread_safety(opts)) {
  ------------------
  |  Branch (824:9): [True: 0, False: 217]
  ------------------
  825|      0|        pthread_mutex_t *mutex = (pthread_mutex_t *)mem_alloc(mem, sizeof(pthread_mutex_t));
  826|       |
  827|      0|        if (mutex == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (827:13): [True: 0, False: 0]
  ------------------
  828|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  829|      0|            mono_time_free(mem, tox->mono_time);
  830|      0|            logger_kill(tox->log);
  831|      0|            mem_delete(mem, tox);
  832|      0|            tox_options_free(default_options);
  833|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  834|      0|        }
  835|       |
  836|      0|        pthread_mutex_init(mutex, nullptr);
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  837|       |
  838|      0|        tox->mutex = mutex;
  839|    217|    } else {
  840|    217|        tox->mutex = nullptr;
  ------------------
  |  |   63|    217|#define nullptr NULL
  ------------------
  841|    217|    }
  842|       |
  843|    217|    tox_lock(tox);
  844|       |
  845|    217|    Messenger_Error m_error;
  846|    217|    Messenger *temp_m = new_messenger(tox->mono_time, mem, rng, ns, &m_options, &m_error);
  847|       |
  848|    217|    if (temp_m == nullptr) {
  ------------------
  |  |   63|    217|#define nullptr NULL
  ------------------
  |  Branch (848:9): [True: 150, False: 67]
  ------------------
  849|    150|        switch (m_error) {
  ------------------
  |  Branch (849:17): [True: 150, False: 0]
  ------------------
  850|      0|            case MESSENGER_ERROR_PORT:
  ------------------
  |  Branch (850:13): [True: 0, False: 150]
  ------------------
  851|    102|            case MESSENGER_ERROR_TCP_SERVER: {
  ------------------
  |  Branch (851:13): [True: 102, False: 48]
  ------------------
  852|    102|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PORT_ALLOC);
  ------------------
  |  |   45|    102|    do {                              \
  |  |   46|    102|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|    204|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 102, False: 0]
  |  |  ------------------
  |  |   47|    102|            *param = x;               \
  |  |   48|    102|        }                             \
  |  |   49|    102|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 102]
  |  |  ------------------
  ------------------
  853|    102|                break;
  854|      0|            }
  855|     48|            case MESSENGER_ERROR_OTHER:
  ------------------
  |  Branch (855:13): [True: 48, False: 102]
  ------------------
  856|     48|            case MESSENGER_ERROR_NONE: {
  ------------------
  |  Branch (856:13): [True: 0, False: 150]
  ------------------
  857|     48|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|     48|    do {                              \
  |  |   46|     48|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|     96|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 48, False: 0]
  |  |  ------------------
  |  |   47|     48|            *param = x;               \
  |  |   48|     48|        }                             \
  |  |   49|     48|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 48]
  |  |  ------------------
  ------------------
  858|     48|                break;
  859|     48|            }
  860|    150|        }
  861|       |
  862|    150|        mono_time_free(mem, tox->mono_time);
  863|    150|        tox_unlock(tox);
  864|       |
  865|    150|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|    150|#define nullptr NULL
  ------------------
  |  Branch (865:13): [True: 0, False: 150]
  ------------------
  866|      0|            pthread_mutex_destroy(tox->mutex);
  867|      0|        }
  868|       |
  869|    150|        mem_delete(mem, tox->mutex);
  870|    150|        logger_kill(tox->log);
  871|    150|        mem_delete(mem, tox);
  872|    150|        tox_options_free(default_options);
  873|    150|        return nullptr;
  ------------------
  |  |   63|    150|#define nullptr NULL
  ------------------
  874|    150|    }
  875|     67|    tox->m = temp_m;
  876|       |
  877|     67|    tox->m->conferences_object = new_groupchats(tox->mono_time, mem, tox->m);
  878|       |
  879|     67|    if (tox->m->conferences_object == nullptr) {
  ------------------
  |  |   63|     67|#define nullptr NULL
  ------------------
  |  Branch (879:9): [True: 1, False: 66]
  ------------------
  880|      1|        kill_messenger(tox->m);
  881|       |
  882|      1|        mono_time_free(mem, tox->mono_time);
  883|      1|        tox_unlock(tox);
  884|       |
  885|      1|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  |  Branch (885:13): [True: 0, False: 1]
  ------------------
  886|      0|            pthread_mutex_destroy(tox->mutex);
  887|      0|        }
  888|       |
  889|      1|        mem_delete(mem, tox->mutex);
  890|      1|        logger_kill(tox->log);
  891|      1|        mem_delete(mem, tox);
  892|       |
  893|      1|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   45|      1|    do {                              \
  |  |   46|      1|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      2|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 1, False: 0]
  |  |  ------------------
  |  |   47|      1|            *param = x;               \
  |  |   48|      1|        }                             \
  |  |   49|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 1]
  |  |  ------------------
  ------------------
  894|      1|        tox_options_free(default_options);
  895|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  896|      1|    }
  897|       |
  898|     66|    if (load_savedata_tox
  ------------------
  |  Branch (898:9): [True: 0, False: 66]
  ------------------
  899|      0|            && tox_load(tox, tox_options_get_savedata_data(opts), tox_options_get_savedata_length(opts)) == -1) {
  ------------------
  |  Branch (899:16): [True: 0, False: 0]
  ------------------
  900|      0|        kill_groupchats(tox->m->conferences_object);
  901|      0|        kill_messenger(tox->m);
  902|       |
  903|      0|        mono_time_free(mem, tox->mono_time);
  904|      0|        tox_unlock(tox);
  905|       |
  906|      0|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (906:13): [True: 0, False: 0]
  ------------------
  907|      0|            pthread_mutex_destroy(tox->mutex);
  908|      0|        }
  909|       |
  910|      0|        mem_delete(mem, tox->mutex);
  911|      0|        logger_kill(tox->log);
  912|      0|        mem_delete(mem, tox);
  913|       |
  914|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  915|      0|        tox_options_free(default_options);
  916|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  917|      0|    }
  918|       |
  919|     66|    if (load_savedata_sk) {
  ------------------
  |  Branch (919:9): [True: 0, False: 66]
  ------------------
  920|      0|        load_secret_key(tox->m->net_crypto, tox_options_get_savedata_data(opts));
  921|      0|    }
  922|       |
  923|     66|    m_callback_namechange(tox->m, tox_friend_name_handler);
  924|     66|    m_callback_core_connection(tox->m, tox_self_connection_status_handler);
  925|     66|    m_callback_statusmessage(tox->m, tox_friend_status_message_handler);
  926|     66|    m_callback_userstatus(tox->m, tox_friend_status_handler);
  927|     66|    m_callback_connectionstatus(tox->m, tox_friend_connection_status_handler);
  928|     66|    m_callback_typingchange(tox->m, tox_friend_typing_handler);
  929|     66|    m_callback_read_receipt(tox->m, tox_friend_read_receipt_handler);
  930|     66|    m_callback_friendrequest(tox->m, tox_friend_request_handler);
  931|     66|    m_callback_friendmessage(tox->m, tox_friend_message_handler);
  932|     66|    callback_file_control(tox->m, tox_file_recv_control_handler);
  933|     66|    callback_file_reqchunk(tox->m, tox_file_chunk_request_handler);
  934|     66|    callback_file_sendrequest(tox->m, tox_file_recv_handler);
  935|     66|    callback_file_data(tox->m, tox_file_recv_chunk_handler);
  936|     66|    dht_callback_nodes_response(tox->m->dht, tox_dht_nodes_response_handler);
  937|     66|    g_callback_group_invite(tox->m->conferences_object, tox_conference_invite_handler);
  938|     66|    g_callback_group_connected(tox->m->conferences_object, tox_conference_connected_handler);
  939|     66|    g_callback_group_message(tox->m->conferences_object, tox_conference_message_handler);
  940|     66|    g_callback_group_title(tox->m->conferences_object, tox_conference_title_handler);
  941|     66|    g_callback_peer_name(tox->m->conferences_object, tox_conference_peer_name_handler);
  942|     66|    g_callback_peer_list_changed(tox->m->conferences_object, tox_conference_peer_list_changed_handler);
  943|     66|    custom_lossy_packet_registerhandler(tox->m, tox_friend_lossy_packet_handler);
  944|     66|    custom_lossless_packet_registerhandler(tox->m, tox_friend_lossless_packet_handler);
  945|       |
  946|     66|    m_callback_group_invite(tox->m, tox_group_invite_handler);
  947|     66|    gc_callback_message(tox->m, tox_group_message_handler);
  948|     66|    gc_callback_private_message(tox->m, tox_group_private_message_handler);
  949|     66|    gc_callback_custom_packet(tox->m, tox_group_custom_packet_handler);
  950|     66|    gc_callback_custom_private_packet(tox->m, tox_group_custom_private_packet_handler);
  951|     66|    gc_callback_moderation(tox->m, tox_group_moderation_handler);
  952|     66|    gc_callback_nick_change(tox->m, tox_group_peer_name_handler);
  953|     66|    gc_callback_status_change(tox->m, tox_group_peer_status_handler);
  954|     66|    gc_callback_topic_change(tox->m, tox_group_topic_handler);
  955|     66|    gc_callback_peer_limit(tox->m, tox_group_peer_limit_handler);
  956|     66|    gc_callback_privacy_state(tox->m, tox_group_privacy_state_handler);
  957|     66|    gc_callback_topic_lock(tox->m, tox_group_topic_lock_handler);
  958|     66|    gc_callback_password(tox->m, tox_group_password_handler);
  959|     66|    gc_callback_peer_join(tox->m, tox_group_peer_join_handler);
  960|     66|    gc_callback_peer_exit(tox->m, tox_group_peer_exit_handler);
  961|     66|    gc_callback_self_join(tox->m, tox_group_self_join_handler);
  962|     66|    gc_callback_rejected(tox->m, tox_group_join_fail_handler);
  963|     66|    gc_callback_voice_state(tox->m, tox_group_voice_state_handler);
  964|       |
  965|     66|    tox_unlock(tox);
  966|       |
  967|     66|    SET_ERROR_PARAMETER(error, TOX_ERR_NEW_OK);
  ------------------
  |  |   45|     66|    do {                              \
  |  |   46|     66|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|    132|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 66, False: 0]
  |  |  ------------------
  |  |   47|     66|            *param = x;               \
  |  |   48|     66|        }                             \
  |  |   49|     66|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 66]
  |  |  ------------------
  ------------------
  968|       |
  969|     66|    tox_options_free(default_options);
  970|     66|    return tox;
  971|     66|}
tox.c:tox_log_handler:
   86|    323|{
   87|    323|    Tox *tox = (Tox *)context;
   88|    323|    assert(tox != nullptr);
  ------------------
  |  Branch (88:5): [True: 323, False: 0]
  ------------------
   89|       |
   90|    323|    if (tox->log_callback != nullptr) {
  ------------------
  |  |   63|    323|#define nullptr NULL
  ------------------
  |  Branch (90:9): [True: 323, False: 0]
  ------------------
   91|    323|        tox->log_callback(tox, (Tox_Log_Level)level, file, line, func, message, userdata);
   92|    323|    }
   93|    323|}
tox.c:resolve_bootstrap_node:
 1077|    132|{
 1078|    132|    assert(tox != nullptr);
  ------------------
  |  Branch (1078:5): [True: 132, False: 0]
  ------------------
 1079|    132|    assert(root != nullptr);
  ------------------
  |  Branch (1079:5): [True: 132, False: 0]
  ------------------
 1080|       |
 1081|    132|    if (host == nullptr || public_key == nullptr) {
  ------------------
  |  |   63|    264|#define nullptr NULL
  ------------------
                  if (host == nullptr || public_key == nullptr) {
  ------------------
  |  |   63|    132|#define nullptr NULL
  ------------------
  |  Branch (1081:9): [True: 0, False: 132]
  |  Branch (1081:28): [True: 0, False: 132]
  ------------------
 1082|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_NULL);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
 1083|      0|        return -1;
 1084|      0|    }
 1085|       |
 1086|    132|    if (port == 0) {
  ------------------
  |  Branch (1086:9): [True: 0, False: 132]
  ------------------
 1087|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_PORT);
  ------------------
  |  |   45|      0|    do {                              \
  |  |   46|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
 1088|      0|        return -1;
 1089|      0|    }
 1090|       |
 1091|    132|    const int32_t count = net_getipport(tox->sys.ns, tox->sys.mem, host, root, TOX_SOCK_DGRAM, tox->m->options.dns_enabled);
  ------------------
  |  |   71|    132|#define TOX_SOCK_DGRAM 2
  ------------------
 1092|       |
 1093|    132|    if (count < 1) {
  ------------------
  |  Branch (1093:9): [True: 16, False: 116]
  ------------------
 1094|     16|        LOGGER_DEBUG(tox->m->log, "could not resolve bootstrap node '%s'", host);
  ------------------
  |  |   77|     16|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   69|     16|    do {                                                                         \
  |  |  |  |   70|     16|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     32|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:13): [Folded, False: 16]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   72|      0|        }                                                                        \
  |  |  |  |   73|     16|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (73:14): [Folded, False: 16]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1095|     16|        net_freeipport(tox->sys.mem, *root);
 1096|     16|        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_HOST);
  ------------------
  |  |   45|     16|    do {                              \
  |  |   46|     16|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|     32|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (46:13): [True: 0, False: 16]
  |  |  ------------------
  |  |   47|      0|            *param = x;               \
  |  |   48|      0|        }                             \
  |  |   49|     16|    } while (0)
  |  |  ------------------
  |  |  |  Branch (49:14): [Folded, False: 16]
  |  |  ------------------
  ------------------
 1097|     16|        return -1;
 1098|     16|    }
 1099|       |
 1100|    132|    assert(*root != nullptr);
  ------------------
  |  Branch (1100:5): [True: 116, False: 0]
  ------------------
 1101|    116|    return count;
 1102|    116|}

tox_dispatch_new:
   60|     66|{
   61|     66|    Tox_Dispatch *dispatch = (Tox_Dispatch *)calloc(1, sizeof(Tox_Dispatch));
   62|       |
   63|     66|    if (dispatch == nullptr) {
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
  |  Branch (63:9): [True: 0, False: 66]
  ------------------
   64|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (64:13): [True: 0, False: 0]
  ------------------
   65|      0|            *error = TOX_ERR_DISPATCH_NEW_MALLOC;
   66|      0|        }
   67|       |
   68|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   69|      0|    }
   70|       |
   71|     66|    *dispatch = (Tox_Dispatch) {
   72|     66|        nullptr
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
   73|     66|    };
   74|       |
   75|     66|    if (error != nullptr) {
  ------------------
  |  |   63|     66|#define nullptr NULL
  ------------------
  |  Branch (75:9): [True: 0, False: 66]
  ------------------
   76|      0|        *error = TOX_ERR_DISPATCH_NEW_OK;
   77|      0|    }
   78|       |
   79|     66|    return dispatch;
   80|     66|}
tox_dispatch_free:
   83|     66|{
   84|     66|    free(dispatch);
   85|     66|}
tox_events_callback_conference_connected:
   89|    132|{
   90|    132|    dispatch->conference_connected_callback = callback;
   91|    132|}
tox_events_callback_conference_invite:
   94|     66|{
   95|     66|    dispatch->conference_invite_callback = callback;
   96|     66|}
tox_events_callback_conference_message:
   99|     66|{
  100|     66|    dispatch->conference_message_callback = callback;
  101|     66|}
tox_events_callback_conference_peer_list_changed:
  104|     66|{
  105|     66|    dispatch->conference_peer_list_changed_callback = callback;
  106|     66|}
tox_events_callback_conference_peer_name:
  109|     66|{
  110|     66|    dispatch->conference_peer_name_callback = callback;
  111|     66|}
tox_events_callback_conference_title:
  114|     66|{
  115|     66|    dispatch->conference_title_callback = callback;
  116|     66|}
tox_events_callback_file_chunk_request:
  119|     66|{
  120|     66|    dispatch->file_chunk_request_callback = callback;
  121|     66|}
tox_events_callback_file_recv:
  124|     66|{
  125|     66|    dispatch->file_recv_callback = callback;
  126|     66|}
tox_events_callback_file_recv_chunk:
  129|     66|{
  130|     66|    dispatch->file_recv_chunk_callback = callback;
  131|     66|}
tox_events_callback_file_recv_control:
  134|     66|{
  135|     66|    dispatch->file_recv_control_callback = callback;
  136|     66|}
tox_events_callback_friend_connection_status:
  139|     66|{
  140|     66|    dispatch->friend_connection_status_callback = callback;
  141|     66|}
tox_events_callback_friend_lossless_packet:
  144|     66|{
  145|     66|    dispatch->friend_lossless_packet_callback = callback;
  146|     66|}
tox_events_callback_friend_lossy_packet:
  149|     66|{
  150|     66|    dispatch->friend_lossy_packet_callback = callback;
  151|     66|}
tox_events_callback_friend_message:
  154|     66|{
  155|     66|    dispatch->friend_message_callback = callback;
  156|     66|}
tox_events_callback_friend_name:
  159|     66|{
  160|     66|    dispatch->friend_name_callback = callback;
  161|     66|}
tox_events_callback_friend_read_receipt:
  164|     66|{
  165|     66|    dispatch->friend_read_receipt_callback = callback;
  166|     66|}
tox_events_callback_friend_request:
  169|     66|{
  170|     66|    dispatch->friend_request_callback = callback;
  171|     66|}
tox_events_callback_friend_status:
  174|     66|{
  175|     66|    dispatch->friend_status_callback = callback;
  176|     66|}
tox_events_callback_friend_status_message:
  179|     66|{
  180|     66|    dispatch->friend_status_message_callback = callback;
  181|     66|}
tox_events_callback_friend_typing:
  184|     66|{
  185|     66|    dispatch->friend_typing_callback = callback;
  186|     66|}
tox_events_callback_self_connection_status:
  189|     66|{
  190|     66|    dispatch->self_connection_status_callback = callback;
  191|     66|}
tox_dispatch_invoke:
  618|     82|{
  619|     82|    const uint32_t size = tox_events_get_size(events);
  620|     82|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (620:26): [True: 0, False: 82]
  ------------------
  621|      0|        const Tox_Event *event = &events->events[i];
  622|      0|        tox_dispatch_invoke_event(dispatch, event, user_data);
  623|      0|    }
  624|     82|}

tox_events_init:
   29|     66|{
   30|     66|    tox_callback_conference_connected(tox, tox_events_handle_conference_connected);
   31|     66|    tox_callback_conference_invite(tox, tox_events_handle_conference_invite);
   32|     66|    tox_callback_conference_message(tox, tox_events_handle_conference_message);
   33|     66|    tox_callback_conference_peer_list_changed(tox, tox_events_handle_conference_peer_list_changed);
   34|     66|    tox_callback_conference_peer_name(tox, tox_events_handle_conference_peer_name);
   35|     66|    tox_callback_conference_title(tox, tox_events_handle_conference_title);
   36|     66|    tox_callback_file_chunk_request(tox, tox_events_handle_file_chunk_request);
   37|     66|    tox_callback_file_recv_chunk(tox, tox_events_handle_file_recv_chunk);
   38|     66|    tox_callback_file_recv_control(tox, tox_events_handle_file_recv_control);
   39|     66|    tox_callback_file_recv(tox, tox_events_handle_file_recv);
   40|     66|    tox_callback_friend_connection_status(tox, tox_events_handle_friend_connection_status);
   41|     66|    tox_callback_friend_lossless_packet(tox, tox_events_handle_friend_lossless_packet);
   42|     66|    tox_callback_friend_lossy_packet(tox, tox_events_handle_friend_lossy_packet);
   43|     66|    tox_callback_friend_message(tox, tox_events_handle_friend_message);
   44|     66|    tox_callback_friend_name(tox, tox_events_handle_friend_name);
   45|     66|    tox_callback_friend_read_receipt(tox, tox_events_handle_friend_read_receipt);
   46|     66|    tox_callback_friend_request(tox, tox_events_handle_friend_request);
   47|     66|    tox_callback_friend_status_message(tox, tox_events_handle_friend_status_message);
   48|     66|    tox_callback_friend_status(tox, tox_events_handle_friend_status);
   49|     66|    tox_callback_friend_typing(tox, tox_events_handle_friend_typing);
   50|     66|    tox_callback_self_connection_status(tox, tox_events_handle_self_connection_status);
   51|     66|    tox_callback_group_peer_name(tox, tox_events_handle_group_peer_name);
   52|     66|    tox_callback_group_peer_status(tox, tox_events_handle_group_peer_status);
   53|     66|    tox_callback_group_topic(tox, tox_events_handle_group_topic);
   54|     66|    tox_callback_group_privacy_state(tox, tox_events_handle_group_privacy_state);
   55|     66|    tox_callback_group_voice_state(tox, tox_events_handle_group_voice_state);
   56|     66|    tox_callback_group_topic_lock(tox, tox_events_handle_group_topic_lock);
   57|     66|    tox_callback_group_peer_limit(tox, tox_events_handle_group_peer_limit);
   58|     66|    tox_callback_group_password(tox, tox_events_handle_group_password);
   59|     66|    tox_callback_group_message(tox, tox_events_handle_group_message);
   60|     66|    tox_callback_group_private_message(tox, tox_events_handle_group_private_message);
   61|     66|    tox_callback_group_custom_packet(tox, tox_events_handle_group_custom_packet);
   62|     66|    tox_callback_group_custom_private_packet(tox, tox_events_handle_group_custom_private_packet);
   63|     66|    tox_callback_group_invite(tox, tox_events_handle_group_invite);
   64|     66|    tox_callback_group_peer_join(tox, tox_events_handle_group_peer_join);
   65|     66|    tox_callback_group_peer_exit(tox, tox_events_handle_group_peer_exit);
   66|     66|    tox_callback_group_self_join(tox, tox_events_handle_group_self_join);
   67|     66|    tox_callback_group_join_fail(tox, tox_events_handle_group_join_fail);
   68|     66|    tox_callback_group_moderation(tox, tox_events_handle_group_moderation);
   69|     66|    tox_callback_dht_nodes_response(tox, tox_events_handle_dht_nodes_response);
   70|     66|}
tox_events_get_size:
   73|    410|{
   74|    410|    return events == nullptr ? 0 : events->events_size;
  ------------------
  |  |   63|    410|#define nullptr NULL
  ------------------
  |  Branch (74:12): [True: 410, False: 0]
  ------------------
   75|    410|}
tox_events_iterate:
   92|     82|{
   93|     82|    const Tox_System *sys = tox_get_system(tox);
   94|     82|    Tox_Events_State state = {TOX_ERR_EVENTS_ITERATE_OK, sys->mem};
   95|     82|    tox_iterate(tox, &state);
   96|       |
   97|     82|    if (error != nullptr) {
  ------------------
  |  |   63|     82|#define nullptr NULL
  ------------------
  |  Branch (97:9): [True: 82, False: 0]
  ------------------
   98|     82|        *error = state.error;
   99|     82|    }
  100|       |
  101|     82|    if (fail_hard && state.error != TOX_ERR_EVENTS_ITERATE_OK) {
  ------------------
  |  Branch (101:9): [True: 82, False: 0]
  |  Branch (101:22): [True: 0, False: 82]
  ------------------
  102|      0|        tox_events_free(state.events);
  103|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  104|      0|    }
  105|       |
  106|     82|    return state.events;
  107|     82|}
tox_events_bytes_size:
  123|    164|{
  124|       |    return bin_pack_obj_size(tox_events_pack_handler, events, nullptr);
  ------------------
  |  |   63|    164|#define nullptr NULL
  ------------------
  125|    164|}
tox_events_get_bytes:
  128|    164|{
  129|    164|    return bin_pack_obj(tox_events_pack_handler, events, nullptr, bytes, UINT32_MAX);
  ------------------
  |  |   63|    164|#define nullptr NULL
  ------------------
  130|    164|}
tox_events_equal:
  181|     82|{
  182|     82|    assert(sys != nullptr);
  ------------------
  |  Branch (182:5): [True: 82, False: 0]
  ------------------
  183|     82|    assert(sys->mem != nullptr);
  ------------------
  |  Branch (183:5): [True: 82, False: 0]
  ------------------
  184|       |
  185|     82|    const uint32_t a_size = tox_events_bytes_size(a);
  186|     82|    const uint32_t b_size = tox_events_bytes_size(b);
  187|       |
  188|     82|    if (a_size != b_size) {
  ------------------
  |  Branch (188:9): [True: 0, False: 82]
  ------------------
  189|      0|        return false;
  190|      0|    }
  191|       |
  192|     82|    uint8_t *a_bytes = (uint8_t *)mem_balloc(sys->mem, a_size);
  193|     82|    uint8_t *b_bytes = (uint8_t *)mem_balloc(sys->mem, b_size);
  194|       |
  195|     82|    if (a_bytes == nullptr || b_bytes == nullptr) {
  ------------------
  |  |   63|    164|#define nullptr NULL
  ------------------
                  if (a_bytes == nullptr || b_bytes == nullptr) {
  ------------------
  |  |   63|     82|#define nullptr NULL
  ------------------
  |  Branch (195:9): [True: 0, False: 82]
  |  Branch (195:31): [True: 0, False: 82]
  ------------------
  196|      0|        mem_delete(sys->mem, b_bytes);
  197|      0|        mem_delete(sys->mem, a_bytes);
  198|      0|        return false;
  199|      0|    }
  200|       |
  201|     82|    tox_events_get_bytes(a, a_bytes);
  202|     82|    tox_events_get_bytes(b, b_bytes);
  203|       |
  204|     82|    const bool ret = memcmp(a_bytes, b_bytes, a_size) == 0;
  205|       |
  206|     82|    mem_delete(sys->mem, b_bytes);
  207|     82|    mem_delete(sys->mem, a_bytes);
  208|       |
  209|     82|    return ret;
  210|     82|}
tox_events.c:tox_events_pack_handler:
  117|    328|{
  118|    328|    const Tox_Events *events = (const Tox_Events *)obj;
  119|    328|    return bin_pack_obj_array(bp, tox_event_pack_handler, tox_events_get_events(events), tox_events_get_size(events), logger);
  120|    328|}
tox_events.c:tox_events_get_events:
   78|    328|{
   79|    328|    return events == nullptr ? nullptr : events->events;
  ------------------
  |  |   63|    328|#define nullptr NULL
  ------------------
                  return events == nullptr ? nullptr : events->events;
  ------------------
  |  |   63|    328|#define nullptr NULL
  ------------------
  |  Branch (79:12): [True: 328, False: 0]
  ------------------
   80|    328|}

tox_options_get_ipv6_enabled:
   22|    221|{
   23|    221|    return options->ipv6_enabled;
   24|    221|}
tox_options_set_ipv6_enabled:
   26|    225|{
   27|    225|    options->ipv6_enabled = ipv6_enabled;
   28|    225|}
tox_options_get_udp_enabled:
   30|    221|{
   31|    221|    return options->udp_enabled;
   32|    221|}
tox_options_set_udp_enabled:
   34|    225|{
   35|    225|    options->udp_enabled = udp_enabled;
   36|    225|}
tox_options_get_proxy_type:
   38|    219|{
   39|    219|    return options->proxy_type;
   40|    219|}
tox_options_set_proxy_type:
   42|    364|{
   43|    364|    options->proxy_type = proxy_type;
   44|    364|}
tox_options_get_proxy_host:
   46|    123|{
   47|    123|    return options->proxy_host;
   48|    123|}
tox_options_set_proxy_host:
   50|    576|{
   51|    576|    if (!options->experimental_owned_data) {
  ------------------
  |  Branch (51:9): [True: 576, False: 0]
  ------------------
   52|    576|        options->proxy_host = proxy_host;
   53|    576|        return true;
   54|    576|    }
   55|       |
   56|      0|    if (options->owned_proxy_host != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (56:9): [True: 0, False: 0]
  ------------------
   57|      0|        free(options->owned_proxy_host);
   58|      0|        options->owned_proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   59|      0|    }
   60|      0|    if (proxy_host == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (60:9): [True: 0, False: 0]
  ------------------
   61|      0|        options->proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   62|      0|        return true;
   63|      0|    }
   64|       |
   65|      0|    const size_t proxy_host_length = strlen(proxy_host) + 1;
   66|      0|    char *owned_ptr = (char *)malloc(proxy_host_length);
   67|      0|    if (owned_ptr == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (67:9): [True: 0, False: 0]
  ------------------
   68|      0|        options->proxy_host = proxy_host;
   69|      0|        options->owned_proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   70|      0|        return false;
   71|      0|    }
   72|       |
   73|      0|    memcpy(owned_ptr, proxy_host, proxy_host_length);
   74|      0|    options->proxy_host = owned_ptr;
   75|      0|    options->owned_proxy_host = owned_ptr;
   76|       |    return true;
   77|      0|}
tox_options_get_proxy_port:
   79|    246|{
   80|    246|    return options->proxy_port;
   81|    246|}
tox_options_set_proxy_port:
   83|    126|{
   84|    126|    options->proxy_port = proxy_port;
   85|    126|}
tox_options_get_start_port:
   87|    221|{
   88|    221|    return options->start_port;
   89|    221|}
tox_options_get_end_port:
   95|    221|{
   96|    221|    return options->end_port;
   97|    221|}
tox_options_get_tcp_port:
  103|    221|{
  104|    221|    return options->tcp_port;
  105|    221|}
tox_options_set_tcp_port:
  107|    164|{
  108|    164|    options->tcp_port = tcp_port;
  109|    164|}
tox_options_get_hole_punching_enabled:
  111|    221|{
  112|    221|    return options->hole_punching_enabled;
  113|    221|}
tox_options_set_hole_punching_enabled:
  115|    225|{
  116|    225|    options->hole_punching_enabled = hole_punching_enabled;
  117|    225|}
tox_options_get_savedata_type:
  119|    663|{
  120|    663|    return options->savedata_type;
  121|    663|}
tox_options_get_log_callback:
  135|    220|{
  136|    220|    return options->log_callback;
  137|    220|}
tox_options_set_log_callback:
  139|    225|{
  140|    225|    options->log_callback = log_callback;
  141|    225|}
tox_options_get_log_user_data:
  143|    219|{
  144|    219|    return options->log_user_data;
  145|    219|}
tox_options_get_local_discovery_enabled:
  151|    221|{
  152|    221|    return options->local_discovery_enabled;
  153|    221|}
tox_options_set_local_discovery_enabled:
  155|    225|{
  156|    225|    options->local_discovery_enabled = local_discovery_enabled;
  157|    225|}
tox_options_get_dht_announcements_enabled:
  159|    221|{
  160|    221|    return options->dht_announcements_enabled;
  161|    221|}
tox_options_set_dht_announcements_enabled:
  163|    225|{
  164|    225|    options->dht_announcements_enabled = dht_announcements_enabled;
  165|    225|}
tox_options_get_experimental_thread_safety:
  167|    217|{
  168|    217|    return options->experimental_thread_safety;
  169|    217|}
tox_options_set_experimental_thread_safety:
  172|    225|{
  173|    225|    options->experimental_thread_safety = experimental_thread_safety;
  174|    225|}
tox_options_get_experimental_groups_persistence:
  176|    221|{
  177|    221|    return options->experimental_groups_persistence;
  178|    221|}
tox_options_set_experimental_groups_persistence:
  181|    225|{
  182|    225|    options->experimental_groups_persistence = experimental_groups_persistence;
  183|    225|}
tox_options_get_experimental_disable_dns:
  185|    344|{
  186|    344|    return options->experimental_disable_dns;
  187|    344|}
tox_options_set_experimental_disable_dns:
  189|    225|{
  190|    225|    options->experimental_disable_dns = experimental_disable_dns;
  191|    225|}
tox_options_set_experimental_owned_data:
  198|    225|{
  199|    225|    options->experimental_owned_data = experimental_owned_data;
  200|    225|}
tox_options_set_savedata_data:
  208|    450|{
  209|    450|    if (!options->experimental_owned_data) {
  ------------------
  |  Branch (209:9): [True: 450, False: 0]
  ------------------
  210|    450|        options->savedata_data = savedata_data;
  211|    450|        options->savedata_length = length;
  212|    450|        return true;
  213|    450|    }
  214|       |
  215|      0|    if (options->owned_savedata_data != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (215:9): [True: 0, False: 0]
  ------------------
  216|      0|        free(options->owned_savedata_data);
  217|      0|        options->owned_savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  218|      0|    }
  219|      0|    if (savedata_data == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (219:9): [True: 0, False: 0]
  ------------------
  220|      0|        options->savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  221|      0|        options->savedata_length = 0;
  222|      0|        return true;
  223|      0|    }
  224|       |
  225|      0|    uint8_t *owned_ptr = (uint8_t *)malloc(length);
  226|      0|    if (owned_ptr == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (226:9): [True: 0, False: 0]
  ------------------
  227|      0|        options->savedata_data = savedata_data;
  228|      0|        options->savedata_length = length;
  229|      0|        options->owned_savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  230|      0|        return false;
  231|      0|    }
  232|       |
  233|      0|    memcpy(owned_ptr, savedata_data, length);
  234|      0|    options->savedata_data = owned_ptr;
  235|      0|    options->savedata_length = length;
  236|      0|    options->owned_savedata_data = owned_ptr;
  237|       |    return true;
  238|      0|}
tox_options_default:
  241|    225|{
  242|    225|    if (options != nullptr) {
  ------------------
  |  |   63|    225|#define nullptr NULL
  ------------------
  |  Branch (242:9): [True: 225, False: 0]
  ------------------
  243|       |        // Free any owned data.
  244|    225|        tox_options_set_proxy_host(options, nullptr);
  ------------------
  |  |   63|    225|#define nullptr NULL
  ------------------
  245|    225|        tox_options_set_savedata_data(options, nullptr, 0);
  ------------------
  |  |   63|    225|#define nullptr NULL
  ------------------
  246|       |
  247|       |        // Set the rest to default values.
  248|    225|        const Tox_Options default_options = {false};
  249|    225|        *options = default_options;
  250|    225|        tox_options_set_ipv6_enabled(options, true);
  251|    225|        tox_options_set_udp_enabled(options, true);
  252|    225|        tox_options_set_proxy_type(options, TOX_PROXY_TYPE_NONE);
  253|    225|        tox_options_set_hole_punching_enabled(options, true);
  254|    225|        tox_options_set_local_discovery_enabled(options, true);
  255|    225|        tox_options_set_dht_announcements_enabled(options, true);
  256|    225|        tox_options_set_experimental_thread_safety(options, false);
  257|    225|        tox_options_set_experimental_groups_persistence(options, false);
  258|    225|        tox_options_set_experimental_disable_dns(options, false);
  259|       |        tox_options_set_experimental_owned_data(options, false);
  260|    225|    }
  261|    225|}
tox_options_new:
  284|    225|{
  285|    225|    Tox_Options *options = (Tox_Options *)calloc(1, sizeof(Tox_Options));
  286|       |
  287|    225|    if (options != nullptr) {
  ------------------
  |  |   63|    225|#define nullptr NULL
  ------------------
  |  Branch (287:9): [True: 225, False: 0]
  ------------------
  288|    225|        tox_options_default(options);
  289|    225|        SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_OK);
  ------------------
  |  |   14|    225|    do {                              \
  |  |   15|    225|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|    450|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (15:13): [True: 0, False: 225]
  |  |  ------------------
  |  |   16|      0|            *param = x;               \
  |  |   17|      0|        }                             \
  |  |   18|    225|    } while (0)
  |  |  ------------------
  |  |  |  Branch (18:14): [Folded, False: 225]
  |  |  ------------------
  ------------------
  290|    225|        return options;
  291|    225|    }
  292|       |
  293|      0|    SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_MALLOC);
  ------------------
  |  |   14|      0|    do {                              \
  |  |   15|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (15:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   16|      0|            *param = x;               \
  |  |   17|      0|        }                             \
  |  |   18|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (18:14): [Folded, False: 0]
  |  |  ------------------
  ------------------
  294|       |    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  295|    225|}
tox_options_free:
  298|    446|{
  299|    446|    if (options != nullptr) {
  ------------------
  |  |   63|    446|#define nullptr NULL
  ------------------
  |  Branch (299:9): [True: 225, False: 221]
  ------------------
  300|       |        // Free any owned data.
  301|    225|        tox_options_set_proxy_host(options, nullptr);
  ------------------
  |  |   63|    225|#define nullptr NULL
  ------------------
  302|       |        tox_options_set_savedata_data(options, nullptr, 0);
  ------------------
  |  |   63|    225|#define nullptr NULL
  ------------------
  303|    225|        free(options);
  304|    225|    }
  305|    446|}

tox_default_system:
   40|    221|{
   41|    221|    const Tox_System sys = {
   42|    221|        nullptr,  // mono_time_callback
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
   43|       |        nullptr,  // mono_time_user_data
  ------------------
  |  |   63|    221|#define nullptr NULL
  ------------------
   44|    221|        os_random(),
   45|    221|        os_network(),
   46|    221|        os_memory(),
   47|    221|    };
   48|    221|    return sys;
   49|    221|}
tox_lock:
   52|    481|{
   53|    481|    if (tox->mutex != nullptr) {
  ------------------
  |  |   63|    481|#define nullptr NULL
  ------------------
  |  Branch (53:9): [True: 0, False: 481]
  ------------------
   54|      0|        pthread_mutex_lock(tox->mutex);
   55|      0|    }
   56|    481|}
tox_unlock:
   59|    481|{
   60|    481|    if (tox->mutex != nullptr) {
  ------------------
  |  |   63|    481|#define nullptr NULL
  ------------------
  |  Branch (60:9): [True: 0, False: 481]
  ------------------
   61|      0|        pthread_mutex_unlock(tox->mutex);
   62|      0|    }
   63|    481|}
tox_callback_dht_nodes_response:
  102|     66|{
  103|     66|    assert(tox != nullptr);
  ------------------
  |  Branch (103:5): [True: 66, False: 0]
  ------------------
  104|     66|    tox->dht_nodes_response_callback = callback;
  105|     66|}

memzero:
   99|  4.03k|{
  100|  4.03k|    if (data == nullptr || data_size == 0) {
  ------------------
  |  |   63|  8.06k|#define nullptr NULL
  ------------------
  |  Branch (100:9): [True: 0, False: 4.03k]
  |  Branch (100:28): [True: 0, False: 4.03k]
  ------------------
  101|      0|        return;
  102|      0|    }
  103|       |
  104|  4.03k|    memset(data, 0, data_size);
  105|  4.03k|}
min_u16:
  151|     47|{
  152|     47|    return a < b ? a : b;
  ------------------
  |  Branch (152:12): [True: 47, False: 0]
  ------------------
  153|     47|}

