LLVMFuzzerTestOneInput:
  189|     31|{
  190|     31|    Fuzz_Data input{data, size};
  191|     31|    TestBootstrap(input);
  192|     31|    return 0;  // Non-zero return values are reserved for future use.
  193|     31|}
bootstrap_fuzz_test.cc:_ZN12_GLOBAL__N_113TestBootstrapER9Fuzz_Data:
   99|     31|{
  100|       |    // Null system for regularly working memory allocations needed in
  101|       |    // tox_events_equal.
  102|     31|    Null_System null_sys;
  103|     31|    Fuzz_System sys(input);
  104|       |
  105|     31|    Ptr<Tox_Options> opts(tox_options_new(nullptr), tox_options_free);
  106|     31|    assert(opts != nullptr);
  107|       |
  108|     31|    tox_options_set_log_callback(opts.get(),
  109|     31|        [](Tox *tox, Tox_Log_Level level, const char *file, uint32_t line, const char *func,
  110|     31|            const char *message, void *user_data) {
  111|       |            // Log to stdout.
  112|     31|            if (Fuzz_Data::FUZZ_DEBUG) {
  113|     31|                std::printf("[tox1] %c %s:%d(%s): %s\n", tox_log_level_name(level), file, line,
  114|     31|                    func, message);
  115|     31|            }
  116|     31|        });
  117|       |
  118|     31|    CONSUME1_OR_RETURN(const uint8_t, proxy_type, input);
  ------------------
  |  |  105|     31|    if (INPUT.size() < sizeof(TYPE)) {        \
  |  |  ------------------
  |  |  |  Branch (105:9): [True: 0, False: 31]
  |  |  ------------------
  |  |  106|      0|        return;                               \
  |  |  107|      0|    }                                         \
  |  |  108|     31|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
  119|     31|    if (proxy_type == 0) {
  ------------------
  |  Branch (119:9): [True: 8, False: 23]
  ------------------
  120|      8|        tox_options_set_proxy_type(opts.get(), TOX_PROXY_TYPE_NONE);
  121|     23|    } else if (proxy_type == 1) {
  ------------------
  |  Branch (121:16): [True: 8, False: 15]
  ------------------
  122|      8|        tox_options_set_proxy_type(opts.get(), TOX_PROXY_TYPE_SOCKS5);
  123|      8|        tox_options_set_proxy_host(opts.get(), "127.0.0.1");
  124|      8|        tox_options_set_proxy_port(opts.get(), 8080);
  125|     15|    } else if (proxy_type == 2) {
  ------------------
  |  Branch (125:16): [True: 5, False: 10]
  ------------------
  126|      5|        tox_options_set_proxy_type(opts.get(), TOX_PROXY_TYPE_HTTP);
  127|      5|        tox_options_set_proxy_host(opts.get(), "127.0.0.1");
  128|      5|        tox_options_set_proxy_port(opts.get(), 8080);
  129|      5|    }
  130|       |
  131|     31|    CONSUME1_OR_RETURN(const uint8_t, tcp_relay_enabled, input);
  ------------------
  |  |  105|     31|    if (INPUT.size() < sizeof(TYPE)) {        \
  |  |  ------------------
  |  |  |  Branch (105:9): [True: 4, False: 27]
  |  |  ------------------
  |  |  106|      4|        return;                               \
  |  |  107|      4|    }                                         \
  |  |  108|     31|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
  132|     27|    if (tcp_relay_enabled >= (UINT8_MAX / 2)) {
  ------------------
  |  Branch (132:9): [True: 12, False: 15]
  ------------------
  133|     12|        tox_options_set_tcp_port(opts.get(), 33445);
  134|     12|    }
  135|       |
  136|     27|    Tox_Options_Testing tox_options_testing;
  137|     27|    tox_options_testing.operating_system = sys.sys.get();
  138|       |
  139|     27|    Tox_Err_New error_new;
  140|     27|    Tox_Err_New_Testing error_new_testing;
  141|     27|    Tox *tox = tox_new_testing(opts.get(), &error_new, &tox_options_testing, &error_new_testing);
  142|       |
  143|     27|    if (tox == nullptr) {
  ------------------
  |  Branch (143:9): [True: 27, False: 0]
  ------------------
  144|       |        // It might fail, because some I/O happens in tox_new, and the fuzzer
  145|       |        // might do things that make that I/O fail.
  146|     27|        return;
  147|     27|    }
  148|       |
  149|      0|    assert(error_new == TOX_ERR_NEW_OK);
  150|      0|    assert(error_new_testing == TOX_ERR_NEW_TESTING_OK);
  151|       |
  152|      0|    uint8_t pub_key[TOX_PUBLIC_KEY_SIZE] = {0};
  153|       |
  154|       |    // These may fail, but that's ok. We ignore their return values.
  155|      0|    tox_bootstrap(tox, "127.0.0.2", 33446, pub_key, nullptr);
  156|      0|    tox_add_tcp_relay(tox, "127.0.0.2", 33446, pub_key, nullptr);
  157|       |
  158|      0|    tox_events_init(tox);
  159|       |
  160|      0|    Tox_Dispatch *dispatch = tox_dispatch_new(nullptr);
  161|      0|    assert(dispatch != nullptr);
  162|      0|    setup_callbacks(dispatch);
  163|       |
  164|      0|    size_t input_size = input.size();
  165|      0|    while (!input.empty()) {
  ------------------
  |  Branch (165:12): [True: 0, False: 0]
  ------------------
  166|      0|        Tox_Err_Events_Iterate error_iterate;
  167|      0|        Tox_Events *events = tox_events_iterate(tox, true, &error_iterate);
  168|      0|        assert(tox_events_equal(null_sys.sys.get(), events, events));
  169|      0|        tox_dispatch_invoke(dispatch, events, tox);
  170|      0|        tox_events_free(events);
  171|       |        // Move the clock forward a decent amount so all the time-based checks
  172|       |        // trigger more quickly.
  173|      0|        sys.clock += 200;
  174|       |
  175|       |        // If no input was consumed, something went wrong.
  176|      0|        assert(input_size != input.size());
  177|       |
  178|      0|        input_size = input.size();
  179|      0|    }
  180|       |
  181|      0|    tox_dispatch_free(dispatch);
  182|      0|    tox_kill(tox);
  183|      0|}
bootstrap_fuzz_test.cc:_ZZN12_GLOBAL__N_113TestBootstrapER9Fuzz_DataENK3$_0clEP3Tox13Tox_Log_LevelPKcjS7_S7_Pv:
  110|     28|            const char *message, void *user_data) {
  111|       |            // Log to stdout.
  112|     28|            if (Fuzz_Data::FUZZ_DEBUG) {
  ------------------
  |  Branch (112:17): [Folded - Ignored]
  ------------------
  113|      0|                std::printf("[tox1] %c %s:%d(%s): %s\n", tox_log_level_name(level), file, line,
  114|      0|                    func, message);
  115|      0|            }
  116|     28|        });

fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Fuzz_SystemjjEXadL_ZN3$_18__invokeES3_jjEEEcvPFT_T0_DpT1_EIS1_S1_JjjEEEvENKUlS1_DpT_E_clIJjjEEEDaS1_SG_:
   31|    312|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Fuzz_SystemjjEXadL_ZN3$_18__invokeES3_jjEEE13static_casterIS1_EcvT_IS3_EEv:
   22|    312|        {
   23|    312|            return static_cast<To>(obj);
   24|    312|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFPvP11Fuzz_SystemS1_jEXadL_ZN3$_28__invokeES3_S1_jEEEcvPFT_T0_DpT1_EIS1_S1_JS1_jEEEvENKUlS1_DpT_E_clIJS1_jEEEDaS1_SG_:
   31|     11|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFPvP11Fuzz_SystemS1_jEXadL_ZN3$_28__invokeES3_S1_jEEE13static_casterIS1_EcvT_IS3_EEv:
   22|     11|        {
   23|     11|            return static_cast<To>(obj);
   24|     11|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Fuzz_SystemPvEXadL_ZN3$_38__invokeES2_S3_EEEcvPFT_T0_DpT1_EIvS3_JS3_EEEvENKUlS3_DpT_E_clIJS3_EEEDaS3_SG_:
   31|    353|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Fuzz_SystemPvEXadL_ZN3$_38__invokeES2_S3_EEE13static_casterIS3_EcvT_IS2_EEv:
   22|    353|        {
   23|    353|            return static_cast<To>(obj);
   24|    353|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketEXadL_ZN3$_48__invokeES2_S3_EEEcvPFT_T0_DpT1_EIiPvJS3_EEEvENKUlSF_DpT_E_clIJS3_EEEDaSF_SH_:
   31|     10|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketEXadL_ZN3$_48__invokeES2_S3_EEE13static_casterIPvEcvT_IS2_EEv:
   22|     10|        {
   23|     10|            return static_cast<To>(obj);
   24|     10|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketPK12Network_AddrEXadL_ZN3$_68__invokeES2_S3_S6_EEEcvPFT_T0_DpT1_EIiPvJS3_S6_EEEvENKUlSI_DpT_E_clIJS3_S6_EEEDaSI_SK_:
   31|     10|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketPK12Network_AddrEXadL_ZN3$_68__invokeES2_S3_S6_EEE13static_casterIPvEcvT_IS2_EEv:
   22|     10|        {
   23|     10|            return static_cast<To>(obj);
   24|     10|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPF6SocketP11Fuzz_SystemiiiEXadL_ZN4$_148__invokeES3_iiiEEEcvPFT_T0_DpT1_EIS1_PvJiiiEEEvENKUlSF_DpT_E_clIJiiiEEEDaSF_SH_:
   31|     10|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPF6SocketP11Fuzz_SystemiiiEXadL_ZN4$_148__invokeES3_iiiEEE13static_casterIPvEcvT_IS3_EEv:
   22|     10|        {
   23|     10|            return static_cast<To>(obj);
   24|     10|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketbEXadL_ZN4$_158__invokeES2_S3_bEEEcvPFT_T0_DpT1_EIiPvJS3_bEEEvENKUlSF_DpT_E_clIJS3_bEEEDaSF_SH_:
   31|     10|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketbEXadL_ZN4$_158__invokeES2_S3_bEEE13static_casterIPvEcvT_IS2_EEv:
   22|     10|        {
   23|     10|            return static_cast<To>(obj);
   24|     10|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketiiPvPmEXadL_ZN4$_168__invokeES2_S3_iiS4_S5_EEEcvPFT_T0_DpT1_EIiS4_JS3_iiS4_S5_EEEvENKUlS4_DpT_E_clIJS3_iiS4_S5_EEEDaS4_SI_:
   31|     10|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketiiPvPmEXadL_ZN4$_168__invokeES2_S3_iiS4_S5_EEE13static_casterIS4_EcvT_IS2_EEv:
   22|     10|        {
   23|     10|            return static_cast<To>(obj);
   24|     10|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFiP11Fuzz_System6SocketiiPKvmEXadL_ZN4$_178__invokeES2_S3_iiS5_mEEEcvPFT_T0_DpT1_EIiPvJS3_iiS5_mEEEvENKUlSH_DpT_E_clIJS3_iiS5_mEEEDaSH_SJ_:
   31|     40|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFiP11Fuzz_System6SocketiiPKvmEXadL_ZN4$_178__invokeES2_S3_iiS5_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|     40|        {
   23|     40|            return static_cast<To>(obj);
   24|     40|        }
fuzz_support.cc:_ZZN6detail15func_conversionIPFvP11Fuzz_SystemPhmEXadL_ZN4$_188__invokeES2_S3_mEEEcvPFT_T0_DpT1_EIvPvJS3_mEEEvENKUlSF_DpT_E_clIJS3_mEEEDaSF_SH_:
   31|     45|        return [](Arg obj, auto... args) { return f(static_caster<Arg>{obj}, args...); };
fuzz_support.cc:_ZNK6detail15func_conversionIPFvP11Fuzz_SystemPhmEXadL_ZN4$_188__invokeES2_S3_mEEE13static_casterIPvEcvT_IS2_EEv:
   22|     45|        {
   23|     45|            return static_cast<To>(obj);
   24|     45|        }

_ZN6SystemC2ENSt3__110unique_ptrI10Tox_SystemNS0_14default_deleteIS2_EEEENS1_I6MemoryNS3_IS6_EEEENS1_I7NetworkNS3_IS9_EEEENS1_I6RandomNS3_ISC_EEEE:
   38|     62|    : sys(std::move(in_sys))
   39|     62|    , mem(std::move(in_mem))
   40|     62|    , ns(std::move(in_ns))
   41|     62|    , rng(std::move(in_rng))
   42|     62|{
   43|     62|}
_ZN6SystemD2Ev:
   46|     62|System::~System() { }
_ZN11Fuzz_SystemC2ER9Fuzz_Data:
  232|     31|    : System{
  233|     31|        std::make_unique<Tox_System>(),
  234|     31|        std::make_unique<Memory>(Memory{&fuzz_memory_funcs, this}),
  235|     31|        std::make_unique<Network>(Network{&fuzz_network_funcs, this}),
  236|     31|        std::make_unique<Random>(Random{&fuzz_random_funcs, this}),
  237|     31|    }
  238|     31|    , data(input)
  239|     31|{
  240|     31|    sys->mono_time_callback = [](void *self) { return static_cast<Fuzz_System *>(self)->clock; };
  241|     31|    sys->mono_time_user_data = this;
  242|     31|    sys->mem = mem.get();
  243|     31|    sys->ns = ns.get();
  244|     31|    sys->rng = rng.get();
  245|     31|}
_ZN11Null_SystemC2Ev:
  321|     31|    : System{
  322|     31|        std::make_unique<Tox_System>(),
  323|     31|        std::make_unique<Memory>(Memory{&null_memory_funcs, this}),
  324|     31|        std::make_unique<Network>(Network{&null_network_funcs, this}),
  325|     31|        std::make_unique<Random>(Random{&null_random_funcs, this}),
  326|     31|    }
  327|     31|{
  328|     31|    sys->mono_time_callback = [](void *self) { return static_cast<Null_System *>(self)->clock; };
  329|     31|    sys->mono_time_user_data = this;
  330|     31|    sys->mem = mem.get();
  331|     31|    sys->ns = ns.get();
  332|     31|    sys->rng = rng.get();
  333|     31|}
fuzz_support.cc:_ZL12report_allocPKcS0_mPv:
   79|    307|{
   80|    307|    if (Fuzz_Data::FUZZ_DEBUG) {
  ------------------
  |  Branch (80:9): [Folded - Ignored]
  ------------------
   81|      0|        printf("%s: %s(%zu): %s\n", name, func, size, ptr == nullptr ? "false" : "true");
  ------------------
  |  Branch (81:55): [True: 0, False: 0]
  ------------------
   82|      0|    }
   83|    307|    return ptr;
   84|    307|}
fuzz_support.cc:_ZNK3$_1clEP11Fuzz_Systemjj:
  103|    312|    ![](Fuzz_System *self, uint32_t nmemb, uint32_t size) {
  104|    312|        return alloc_common<decltype(std::calloc), std::calloc>(
  105|    312|            "calloc", nmemb * size, self->data, nmemb, size);
  106|    312|    },
fuzz_support.cc:_ZL12alloc_commonIDoFPvmmETnT_XadL_Z6callocEEJjjEES0_PKcmR9Fuzz_DataDpT1_:
   88|    312|{
   89|    312|    CONSUME1_OR_RETURN_VAL(
  ------------------
  |  |  122|    312|    if (INPUT.size() < sizeof(TYPE)) {                 \
  |  |  ------------------
  |  |  |  Branch (122:9): [True: 143, False: 169]
  |  |  ------------------
  |  |  123|    143|        return VAL;                                    \
  |  |  124|    143|    }                                                  \
  |  |  125|    312|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
   90|    169|        const bool, want_alloc, data, report_alloc("tox1", func, size, Func(args...)));
   91|    169|    if (!want_alloc) {
  ------------------
  |  Branch (91:9): [True: 16, False: 153]
  ------------------
   92|     16|        return nullptr;
   93|     16|    }
   94|    153|    return report_alloc("tox1", func, size, Func(args...));
   95|    169|}
fuzz_support.cc:_ZNK3$_2clEP11Fuzz_SystemPvj:
  108|     11|    ![](Fuzz_System *self, void *ptr, uint32_t size) {
  109|     11|        return alloc_common<decltype(std::realloc), std::realloc>(
  110|     11|            "realloc", size, self->data, ptr, size);
  111|     11|    },
fuzz_support.cc:_ZL12alloc_commonIDoFPvS0_mETnT_XadL_Z7reallocEEJS0_jEES0_PKcmR9Fuzz_DataDpT1_:
   88|     11|{
   89|     11|    CONSUME1_OR_RETURN_VAL(
  ------------------
  |  |  122|     11|    if (INPUT.size() < sizeof(TYPE)) {                 \
  |  |  ------------------
  |  |  |  Branch (122:9): [True: 11, False: 0]
  |  |  ------------------
  |  |  123|     11|        return VAL;                                    \
  |  |  124|     11|    }                                                  \
  |  |  125|     11|    TYPE NAME = INPUT.consume1(__func__)
  ------------------
   90|      0|        const bool, want_alloc, data, report_alloc("tox1", func, size, Func(args...)));
   91|      0|    if (!want_alloc) {
  ------------------
  |  Branch (91:9): [True: 0, False: 0]
  ------------------
   92|      0|        return nullptr;
   93|      0|    }
   94|      0|    return report_alloc("tox1", func, size, Func(args...));
   95|      0|}
fuzz_support.cc:_ZNK3$_3clEP11Fuzz_SystemPv:
  113|    353|    ![](Fuzz_System *self, void *ptr) { std::free(ptr); },
fuzz_support.cc:_ZNK3$_4clEP11Fuzz_System6Socket:
  117|     10|    /* .close = */ ![](Fuzz_System *self, Socket sock) { return 0; },
fuzz_support.cc:_ZNK3$_6clEP11Fuzz_System6SocketPK12Network_Addr:
  119|     10|    /* .bind = */ ![](Fuzz_System *self, Socket sock, const Network_Addr *addr) { return 0; },
fuzz_support.cc:_ZNK4$_14clEP11Fuzz_Systemiii:
  162|     10|    /* .socket = */ ![](Fuzz_System *self, int domain, int type, int proto) { return Socket{42}; },
fuzz_support.cc:_ZNK4$_15clEP11Fuzz_System6Socketb:
  163|     10|    /* .socket_nonblock = */ ![](Fuzz_System *self, Socket sock, bool nonblock) { return 0; },
fuzz_support.cc:_ZNK4$_16clEP11Fuzz_System6SocketiiPvPm:
  165|     10|    ![](Fuzz_System *self, Socket sock, int level, int optname, void *optval, size_t *optlen) {
  166|     10|        std::memset(optval, 0, *optlen);
  167|     10|        return 0;
  168|     10|    },
fuzz_support.cc:_ZNK4$_17clEP11Fuzz_System6SocketiiPKvm:
  170|     40|    ![](Fuzz_System *self, Socket sock, int level, int optname, const void *optval, size_t optlen) {
  171|     40|        return 0;
  172|     40|    },
fuzz_support.cc:_ZNK4$_18clEP11Fuzz_SystemPhm:
  177|     45|    ![](Fuzz_System *self, uint8_t *bytes, size_t length) {
  178|       |        // Initialize the buffer with zeros in case there's no randomness left.
  179|     45|        std::fill_n(bytes, length, 0);
  180|       |
  181|       |        // For integers, we copy bytes directly, because we want to control the
  182|       |        // exact values.
  183|     45|        if (length == sizeof(uint8_t) || length == sizeof(uint16_t) || length == sizeof(uint32_t)
  ------------------
  |  Branch (183:13): [True: 0, False: 45]
  |  Branch (183:42): [True: 0, False: 45]
  |  Branch (183:72): [True: 0, False: 45]
  ------------------
  184|     45|            || length == sizeof(uint64_t)) {
  ------------------
  |  Branch (184:16): [True: 11, False: 34]
  ------------------
  185|     11|            CONSUME_OR_RETURN(const uint8_t *data, self->data, length);
  ------------------
  |  |  139|     11|    if (INPUT.size() < SIZE) {               \
  |  |  ------------------
  |  |  |  Branch (139:9): [True: 11, False: 0]
  |  |  ------------------
  |  |  140|     11|        return;                              \
  |  |  141|     11|    }                                        \
  |  |  142|     11|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
  186|      0|            std::copy(data, data + length, bytes);
  187|      0|            if (Fuzz_Data::FUZZ_DEBUG) {
  ------------------
  |  Branch (187:17): [Folded - Ignored]
  ------------------
  188|      0|                if (length == 1) {
  ------------------
  |  Branch (188:21): [True: 0, False: 0]
  ------------------
  189|      0|                    std::printf("rng: %d (0x%02x)\n", bytes[0], bytes[0]);
  190|      0|                } else {
  191|      0|                    std::printf("rng: %02x..%02x[%zu]\n", bytes[0], bytes[length - 1], length);
  192|      0|                }
  193|      0|            }
  194|      0|            return;
  195|     11|        }
  196|       |
  197|       |        // For nonces and keys, we fill the buffer with the same 1-2 bytes
  198|       |        // repeated. We only need these to be different enough to not often be
  199|       |        // the same.
  200|     34|        assert(length == 24 || length == 32);
  201|       |        // We must cover the case of having only 1 byte left in the input. In
  202|       |        // that case, we will use the same byte for all the bytes in the output.
  203|     34|        const size_t chunk_size = std::max(self->data.size(), static_cast<std::size_t>(2));
  204|     34|        CONSUME_OR_RETURN(const uint8_t *chunk, self->data, chunk_size);
  ------------------
  |  |  139|     34|    if (INPUT.size() < SIZE) {               \
  |  |  ------------------
  |  |  |  Branch (139:9): [True: 31, False: 3]
  |  |  ------------------
  |  |  140|     31|        return;                              \
  |  |  141|     31|    }                                        \
  |  |  142|     34|    DECL = INPUT.consume(__func__, SIZE)
  ------------------
  205|      3|        if (chunk_size == 2) {
  ------------------
  |  Branch (205:13): [True: 2, False: 1]
  ------------------
  206|      2|            std::fill_n(bytes, length / 2, chunk[0]);
  207|      2|            std::fill_n(bytes + length / 2, length / 2, chunk[1]);
  208|      2|        } else {
  209|      1|            std::fill_n(bytes, length, chunk[0]);
  210|      1|        }
  211|      3|        if (Fuzz_Data::FUZZ_DEBUG) {
  ------------------
  |  Branch (211:13): [Folded - Ignored]
  ------------------
  212|      0|            if (length == 1) {
  ------------------
  |  Branch (212:17): [True: 0, False: 0]
  ------------------
  213|      0|                std::printf("rng: %d (0x%02x)\n", bytes[0], bytes[0]);
  214|      0|            } else {
  215|      0|                std::printf("rng: %02x..%02x[%zu]\n", bytes[0], bytes[length - 1], length);
  216|      0|            }
  217|      0|        }
  218|      3|    },
fuzz_support.cc:_ZZN11Fuzz_SystemC1ER9Fuzz_DataENK3$_0clEPv:
  240|     24|    sys->mono_time_callback = [](void *self) { return static_cast<Fuzz_System *>(self)->clock; };

_ZN9Fuzz_DataC2EPKhm:
   32|     31|        : data_(input_data)
   33|     31|        , base_(input_data)
   34|     31|        , size_(input_size)
   35|     31|    {
   36|     31|    }
_ZNK9Fuzz_Data4sizeEv:
   69|    464|    std::size_t size() const { return size_; }
_ZN9Fuzz_Data8consume1EPKc:
   68|    227|    Consumer consume1(const char *func) { return Consumer{func, *this}; }
_ZN9Fuzz_Data8ConsumercvT_IhEEv:
   60|     58|        {
   61|     58|            const uint8_t *bytes = fd.consume(func, sizeof(T));
   62|     58|            T val;
   63|     58|            std::memcpy(&val, bytes, sizeof(T));
   64|     58|            return val;
   65|     58|        }
_ZN9Fuzz_Data7consumeEPKcm:
   75|     61|    {
   76|     61|        const uint8_t *val = data_;
   77|     61|        if (FUZZ_DEBUG) {
  ------------------
  |  Branch (77:13): [Folded - Ignored]
  ------------------
   78|      0|            if (pos() == TRACE_TRAP) {
  ------------------
  |  Branch (78:17): [True: 0, False: 0]
  ------------------
   79|      0|                __asm__("int $3");
   80|      0|            }
   81|      0|            if (count == 1) {
  ------------------
  |  Branch (81:17): [True: 0, False: 0]
  ------------------
   82|      0|                std::printf("consume@%zu(%s): %d (0x%02x)\n", pos(), func, val[0], val[0]);
   83|      0|            } else if (count != 0) {
  ------------------
  |  Branch (83:24): [True: 0, False: 0]
  ------------------
   84|      0|                std::printf("consume@%zu(%s): %02x..%02x[%zu]\n", pos(), func, val[0],
   85|      0|                    val[count - 1], count);
   86|      0|            }
   87|      0|        }
   88|     61|        data_ += count;
   89|     61|        size_ -= count;
   90|     61|        return val;
   91|     61|    }
_ZN9Fuzz_Data8ConsumercvbEv:
   46|    169|        {
   47|       |            // Special case because memcpy causes UB for bool (which can't be
   48|       |            // anything other than 0 or 1).
   49|    169|            const bool val = fd.data_[0];
   50|    169|            if (FUZZ_DEBUG) {
  ------------------
  |  Branch (50:17): [Folded - Ignored]
  ------------------
   51|      0|                std::printf("consume@%zu(%s): bool %s\n", fd.pos(), func, val ? "true" : "false");
  ------------------
  |  Branch (51:75): [True: 0, False: 0]
  ------------------
   52|      0|            }
   53|    169|            ++fd.data_;
   54|    169|            --fd.size_;
   55|    169|            return val;
   56|    169|        }

dht_get_net:
  165|     48|{
  166|     48|    return dht->net;
  167|     48|}
get_close_nodes:
  755|     11|{
  756|     11|    return get_somewhat_close_nodes(
  757|     11|               dht->cur_time, public_key, nodes_list,
  758|     11|               sa_family, dht->close_clientlist,
  759|     11|               dht->friends_list, dht->num_friends,
  760|     11|               is_lan, want_announce);
  761|     11|}
dht_addfriend:
 1630|     22|{
 1631|     22|    const uint32_t friend_num = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);
 1632|       |
 1633|     22|    if (friend_num != UINT32_MAX) { /* Is friend already in DHT? */
  ------------------
  |  Branch (1633:9): [True: 11, False: 11]
  ------------------
 1634|     11|        DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
 1635|     11|        const uint32_t tmp_lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1636|       |
 1637|     11|        if (tmp_lock_token == 0) {
  ------------------
  |  Branch (1637:13): [True: 0, False: 11]
  ------------------
 1638|      0|            return -1;
 1639|      0|        }
 1640|       |
 1641|     11|        return 0;
 1642|     11|    }
 1643|       |
 1644|     11|    DHT_Friend *const temp = (DHT_Friend *)mem_vrealloc(dht->mem, dht->friends_list, dht->num_friends + 1, sizeof(DHT_Friend));
 1645|       |
 1646|     11|    if (temp == nullptr) {
  ------------------
  |  |   63|     11|#define nullptr NULL
  ------------------
  |  Branch (1646:9): [True: 0, False: 11]
  ------------------
 1647|      0|        return -1;
 1648|      0|    }
 1649|       |
 1650|     11|    dht->friends_list = temp;
 1651|     11|    DHT_Friend *const dht_friend = &dht->friends_list[dht->num_friends];
 1652|     11|    *dht_friend = empty_dht_friend;
 1653|     11|    memcpy(dht_friend->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|     11|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
 1654|       |
 1655|     11|    dht_friend->nat.nat_ping_id = random_u64(dht->rng);
 1656|     11|    ++dht->num_friends;
 1657|       |
 1658|     11|    *lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
 1659|     11|    assert(*lock_token != 0); // Friend was newly allocated
 1660|       |
 1661|     11|    dht_friend->num_to_bootstrap = get_close_nodes(dht, dht_friend->public_key, dht_friend->to_bootstrap, net_family_unspec(),
 1662|     11|                                   true, false);
 1663|       |
 1664|     11|    return 0;
 1665|     11|}
cryptopacket_registerhandler:
 2488|     29|{
 2489|     29|    dht->cryptopackethandlers[byte].function = cb;
 2490|     29|    dht->cryptopackethandlers[byte].object = object;
 2491|     29|}
new_dht:
 2569|     18|{
 2570|     18|    if (net == nullptr) {
  ------------------
  |  |   63|     18|#define nullptr NULL
  ------------------
  |  Branch (2570:9): [True: 0, False: 18]
  ------------------
 2571|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2572|      0|    }
 2573|       |
 2574|     18|    DHT *const dht = (DHT *)mem_alloc(mem, sizeof(DHT));
 2575|       |
 2576|     18|    if (dht == nullptr) {
  ------------------
  |  |   63|     18|#define nullptr NULL
  ------------------
  |  Branch (2576:9): [True: 1, False: 17]
  ------------------
 2577|      1|        LOGGER_ERROR(log, "failed to allocate DHT struct (%ld bytes)", (unsigned long)sizeof(DHT));
  ------------------
  |  |   87|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      1|    do {                                                                         \
  |  |  |  |   77|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      1|        }                                                                        \
  |  |  |  |   80|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2578|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 2579|      1|    }
 2580|       |
 2581|     17|    dht->ns = ns;
 2582|     17|    dht->mono_time = mono_time;
 2583|     17|    dht->cur_time = mono_time_get(mono_time);
 2584|     17|    dht->log = log;
 2585|     17|    dht->net = net;
 2586|     17|    dht->rng = rng;
 2587|     17|    dht->mem = mem;
 2588|       |
 2589|     17|    dht->hole_punching_enabled = hole_punching_enabled;
 2590|     17|    dht->lan_discovery_enabled = lan_discovery_enabled;
 2591|       |
 2592|     17|    dht->ping = ping_new(mem, mono_time, rng, dht);
 2593|       |
 2594|     17|    if (dht->ping == nullptr) {
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
  |  Branch (2594:9): [True: 5, False: 12]
  ------------------
 2595|      5|        LOGGER_ERROR(log, "failed to initialise ping");
  ------------------
  |  |   87|      5|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      5|    do {                                                                         \
  |  |  |  |   77|      5|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     10|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      5|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      5|        }                                                                        \
  |  |  |  |   80|      5|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2596|      5|        kill_dht(dht);
 2597|      5|        return nullptr;
  ------------------
  |  |   63|      5|#define nullptr NULL
  ------------------
 2598|      5|    }
 2599|       |
 2600|     12|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, &handle_nodes_request, dht);
 2601|     12|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, &handle_nodes_response, dht);
 2602|     12|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, &cryptopacket_handle, dht);
 2603|     12|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, &handle_lan_discovery, dht);
 2604|     12|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, &handle_nat_ping, dht);
  ------------------
  |  |   68|     12|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
 2605|       |
 2606|     12|#ifdef CHECK_ANNOUNCE_NODE
 2607|     12|    networking_registerhandler(dht->net, NET_PACKET_DATA_SEARCH_RESPONSE, &handle_data_search_response, dht);
 2608|     12|#endif /* CHECK_ANNOUNCE_NODE */
 2609|       |
 2610|     12|    crypto_new_keypair(rng, dht->self_public_key, dht->self_secret_key);
 2611|       |
 2612|     12|    dht->shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   57|     12|#define KEYS_TIMEOUT 600
  ------------------
                  dht->shared_keys_recv = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|     12|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2613|     12|    dht->shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   57|     12|#define KEYS_TIMEOUT 600
  ------------------
                  dht->shared_keys_sent = shared_key_cache_new(log, mono_time, mem, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
  ------------------
  |  |   56|     12|#define MAX_KEYS_PER_SLOT 4
  ------------------
 2614|       |
 2615|     12|    if (dht->shared_keys_recv == nullptr || dht->shared_keys_sent == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
                  if (dht->shared_keys_recv == nullptr || dht->shared_keys_sent == nullptr) {
  ------------------
  |  |   63|     11|#define nullptr NULL
  ------------------
  |  Branch (2615:9): [True: 1, False: 11]
  |  Branch (2615:45): [True: 0, False: 11]
  ------------------
 2616|      1|        LOGGER_ERROR(log, "failed to initialise shared key cache");
  ------------------
  |  |   87|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      1|    do {                                                                         \
  |  |  |  |   77|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      1|        }                                                                        \
  |  |  |  |   80|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2617|      1|        kill_dht(dht);
 2618|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 2619|      1|    }
 2620|       |
 2621|     11|    dht->dht_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   46|     11|#define DHT_PING_ARRAY_SIZE 512
  ------------------
                  dht->dht_ping_array = ping_array_new(mem, DHT_PING_ARRAY_SIZE, PING_TIMEOUT);
  ------------------
  |  |   43|     11|#define PING_TIMEOUT 5
  ------------------
 2622|       |
 2623|     11|    if (dht->dht_ping_array == nullptr) {
  ------------------
  |  |   63|     11|#define nullptr NULL
  ------------------
  |  Branch (2623:9): [True: 0, False: 11]
  ------------------
 2624|      0|        LOGGER_ERROR(log, "failed to initialise ping array");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2625|      0|        kill_dht(dht);
 2626|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2627|      0|    }
 2628|       |
 2629|     33|    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
  ------------------
  |  |   61|     33|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2629:26): [True: 22, False: 11]
  ------------------
 2630|     22|        uint8_t random_public_key_bytes[CRYPTO_PUBLIC_KEY_SIZE];
 2631|     22|        uint8_t random_secret_key_bytes[CRYPTO_SECRET_KEY_SIZE];
 2632|       |
 2633|     22|        crypto_new_keypair(rng, random_public_key_bytes, random_secret_key_bytes);
 2634|       |
 2635|     22|        uint32_t token; // We don't intend to delete these ever, but need to pass the token
 2636|     22|        if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|     22|#define nullptr NULL
  ------------------
                      if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
  ------------------
  |  |   63|     22|#define nullptr NULL
  ------------------
  |  Branch (2636:13): [True: 0, False: 22]
  ------------------
 2637|      0|            LOGGER_ERROR(log, "failed to add initial random seed DHT friends");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2638|      0|            kill_dht(dht);
 2639|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 2640|      0|        }
 2641|     22|    }
 2642|       |
 2643|     11|    if (dht->num_friends != DHT_FAKE_FRIEND_NUMBER) {
  ------------------
  |  |   61|     11|#define DHT_FAKE_FRIEND_NUMBER 2
  ------------------
  |  Branch (2643:9): [True: 11, False: 0]
  ------------------
 2644|     11|        LOGGER_ERROR(log, "the RNG provided seems to be broken: it generated the same keypair twice");
  ------------------
  |  |   87|     11|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     11|    do {                                                                         \
  |  |  |  |   77|     11|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     22|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|     11|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|     11|        }                                                                        \
  |  |  |  |   80|     11|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2645|     11|        kill_dht(dht);
 2646|     11|        return nullptr;
  ------------------
  |  |   63|     11|#define nullptr NULL
  ------------------
 2647|     11|    }
 2648|       |
 2649|      0|    return dht;
 2650|     11|}
kill_dht:
 2674|     17|{
 2675|     17|    if (dht == nullptr) {
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
  |  Branch (2675:9): [True: 0, False: 17]
  ------------------
 2676|      0|        return;
 2677|      0|    }
 2678|       |
 2679|     17|    networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
 2680|     17|    networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_NODES_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
 2681|     17|    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
 2682|     17|    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
 2683|     17|    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   68|     17|#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
                  cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
 2684|       |
 2685|     17|    shared_key_cache_free(dht->shared_keys_recv);
 2686|     17|    shared_key_cache_free(dht->shared_keys_sent);
 2687|     17|    ping_array_kill(dht->dht_ping_array);
 2688|     17|    ping_kill(dht->mem, dht->ping);
 2689|     17|    mem_delete(dht->mem, dht->friends_list);
 2690|     17|    mem_delete(dht->mem, dht->loaded_nodes_list);
 2691|     17|    crypto_memzero(dht->self_secret_key, sizeof(dht->self_secret_key));
 2692|     17|    mem_delete(dht->mem, dht);
 2693|     17|}
DHT.c:get_somewhat_close_nodes:
  726|     11|{
  727|     55|    for (uint16_t i = 0; i < MAX_SENT_NODES; ++i) {
  ------------------
  |  |   40|     55|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (727:26): [True: 44, False: 11]
  ------------------
  728|     44|        nodes_list[i] = empty_node_format;
  729|     44|    }
  730|       |
  731|     11|    uint32_t num_nodes = 0;
  732|     11|    get_close_nodes_inner(
  733|     11|        cur_time, public_key,
  734|     11|        nodes_list, &num_nodes,
  735|     11|        sa_family, close_clientlist, LCLIENT_LIST,
  ------------------
  |  |   35|     11|#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   32|     11|#define LCLIENT_LENGTH 128
  |  |  ------------------
  |  |               #define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)
  |  |  ------------------
  |  |  |  |   31|     11|#define LCLIENT_NODES MAX_FRIEND_CLIENTS
  |  |  |  |  ------------------
  |  |  |  |  |  |   29|     11|#define MAX_FRIEND_CLIENTS 8
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  736|     11|        is_lan, want_announce);
  737|       |
  738|     22|    for (uint16_t i = 0; i < friends_list_size; ++i) {
  ------------------
  |  Branch (738:26): [True: 11, False: 11]
  ------------------
  739|     11|        const DHT_Friend *dht_friend = &friends_list[i];
  740|       |
  741|     11|        get_close_nodes_inner(
  742|     11|            cur_time, public_key,
  743|     11|            nodes_list, &num_nodes,
  744|     11|            sa_family, dht_friend->client_list, MAX_FRIEND_CLIENTS,
  ------------------
  |  |   29|     11|#define MAX_FRIEND_CLIENTS 8
  ------------------
  745|     11|            is_lan, want_announce);
  746|     11|    }
  747|       |
  748|     11|    return num_nodes;
  749|     11|}
DHT.c:get_close_nodes_inner:
  655|     22|{
  656|     22|    if (!net_family_is_ipv4(sa_family) && !net_family_is_ipv6(sa_family) && !net_family_is_unspec(sa_family)) {
  ------------------
  |  Branch (656:9): [True: 22, False: 0]
  |  Branch (656:43): [True: 22, False: 0]
  |  Branch (656:77): [True: 0, False: 22]
  ------------------
  657|      0|        return;
  658|      0|    }
  659|       |
  660|     22|    uint32_t num_nodes = *num_nodes_ptr;
  661|       |
  662|  11.3k|    for (uint32_t i = 0; i < client_list_length; ++i) {
  ------------------
  |  Branch (662:26): [True: 11.3k, False: 22]
  ------------------
  663|  11.3k|        const Client_data *const client = &client_list[i];
  664|       |
  665|       |        /* node already in list? */
  666|  11.3k|        if (index_of_node_pk(nodes_list, MAX_SENT_NODES, client->public_key) != UINT32_MAX) {
  ------------------
  |  |   40|  11.3k|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (666:13): [True: 11.3k, False: 0]
  ------------------
  667|  11.3k|            continue;
  668|  11.3k|        }
  669|       |
  670|      0|        const IPPTsPng *ipptp;
  671|       |
  672|      0|        if (net_family_is_ipv4(sa_family)) {
  ------------------
  |  Branch (672:13): [True: 0, False: 0]
  ------------------
  673|      0|            ipptp = &client->assoc4;
  674|      0|        } else if (net_family_is_ipv6(sa_family)) {
  ------------------
  |  Branch (674:20): [True: 0, False: 0]
  ------------------
  675|      0|            ipptp = &client->assoc6;
  676|      0|        } else if (client->assoc4.timestamp >= client->assoc6.timestamp) {
  ------------------
  |  Branch (676:20): [True: 0, False: 0]
  ------------------
  677|      0|            ipptp = &client->assoc4;
  678|      0|        } else {
  679|      0|            ipptp = &client->assoc6;
  680|      0|        }
  681|       |
  682|       |        /* node not in a good condition? */
  683|      0|        if (assoc_timeout(cur_time, ipptp)) {
  ------------------
  |  Branch (683:13): [True: 0, False: 0]
  ------------------
  684|      0|            continue;
  685|      0|        }
  686|       |
  687|       |        /* don't send LAN ips to non LAN peers */
  688|      0|        if (ip_is_lan(&ipptp->ip_port.ip) && !is_lan) {
  ------------------
  |  Branch (688:13): [True: 0, False: 0]
  |  Branch (688:46): [True: 0, False: 0]
  ------------------
  689|      0|            continue;
  690|      0|        }
  691|       |
  692|      0|#ifdef CHECK_ANNOUNCE_NODE
  693|       |
  694|      0|        if (want_announce && !client->announce_node) {
  ------------------
  |  Branch (694:13): [True: 0, False: 0]
  |  Branch (694:30): [True: 0, False: 0]
  ------------------
  695|      0|            continue;
  696|      0|        }
  697|       |
  698|      0|#endif /* CHECK_ANNOUNCE_NODE */
  699|       |
  700|      0|        if (num_nodes < MAX_SENT_NODES) {
  ------------------
  |  |   40|      0|#define MAX_SENT_NODES 4
  ------------------
  |  Branch (700:13): [True: 0, False: 0]
  ------------------
  701|      0|            memcpy(nodes_list[num_nodes].public_key, client->public_key, CRYPTO_PUBLIC_KEY_SIZE);
  ------------------
  |  |   43|      0|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  702|      0|            nodes_list[num_nodes].ip_port = ipptp->ip_port;
  703|      0|            ++num_nodes;
  704|      0|        } else {
  705|       |            // TODO(zugz): this could be made significantly more efficient by
  706|       |            // using a version of add_to_list which works with a sorted list.
  707|      0|            add_to_list(nodes_list, MAX_SENT_NODES, client->public_key, &ipptp->ip_port, public_key);
  ------------------
  |  |   40|      0|#define MAX_SENT_NODES 4
  ------------------
  708|      0|        }
  709|      0|    }
  710|       |
  711|     22|    *num_nodes_ptr = num_nodes;
  712|     22|}
DHT.c:index_of_node_pk:
  498|  11.3k|{
  499|  11.3k|    assert(size == 0 || array != nullptr);
  500|       |
  501|  11.3k|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (501:26): [True: 11.3k, False: 0]
  ------------------
  502|  11.3k|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (502:13): [True: 11.3k, False: 0]
  ------------------
  503|  11.3k|            return i;
  504|  11.3k|        }
  505|  11.3k|    }
  506|       |
  507|      0|    return UINT32_MAX;
  508|  11.3k|}
DHT.c:index_of_friend_pk:
  484|     22|{
  485|     22|    assert(size == 0 || array != nullptr);
  486|       |
  487|     22|    for (uint32_t i = 0; i < size; ++i) {
  ------------------
  |  Branch (487:26): [True: 11, False: 11]
  ------------------
  488|     11|        if (pk_equal(array[i].public_key, pk)) {
  ------------------
  |  Branch (488:13): [True: 11, False: 0]
  ------------------
  489|     11|            return i;
  490|     11|        }
  491|     11|    }
  492|       |
  493|     11|    return UINT32_MAX;
  494|     22|}
DHT.c:dht_friend_lock:
 1575|     22|{
 1576|       |    // find first free slot
 1577|     22|    uint8_t lock_num;
 1578|     22|    uint32_t lock_token = 0;
 1579|     33|    for (lock_num = 0; lock_num < DHT_FRIEND_MAX_LOCKS; ++lock_num) {
  ------------------
  |  |   53|     33|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1579:24): [True: 33, False: 0]
  ------------------
 1580|     33|        lock_token = UINT32_C(1) << lock_num;
 1581|     33|        if ((dht_friend->lock_flags & lock_token) == 0) {
  ------------------
  |  Branch (1581:13): [True: 22, False: 11]
  ------------------
 1582|     22|            break;
 1583|     22|        }
 1584|     33|    }
 1585|       |
 1586|       |    // One of the conditions would be enough, but static analyzers don't get that
 1587|     22|    if (lock_token == 0 || lock_num == DHT_FRIEND_MAX_LOCKS) {
  ------------------
  |  |   53|     22|#define DHT_FRIEND_MAX_LOCKS 32
  ------------------
  |  Branch (1587:9): [True: 0, False: 22]
  |  Branch (1587:28): [True: 0, False: 22]
  ------------------
 1588|      0|        return 0;
 1589|      0|    }
 1590|       |
 1591|       |    // Claim that slot
 1592|     22|    dht_friend->lock_flags |= lock_token;
 1593|       |
 1594|     22|    dht_friend->callbacks[lock_num].ip_callback = ip_callback;
 1595|     22|    dht_friend->callbacks[lock_num].data = data;
 1596|     22|    dht_friend->callbacks[lock_num].number = number;
 1597|       |
 1598|     22|    return lock_token;
 1599|     22|}

new_messenger:
 3458|     24|{
 3459|     24|    if (options == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (3459:9): [True: 0, False: 24]
  ------------------
 3460|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3461|      0|    }
 3462|       |
 3463|     24|    if (error != nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (3463:9): [True: 24, False: 0]
  ------------------
 3464|     24|        *error = MESSENGER_ERROR_OTHER;
 3465|     24|    }
 3466|       |
 3467|     24|    Messenger *m = (Messenger *)mem_alloc(mem, sizeof(Messenger));
 3468|       |
 3469|     24|    if (m == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (3469:9): [True: 1, False: 23]
  ------------------
 3470|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 3471|      1|    }
 3472|       |
 3473|     23|    m->mono_time = mono_time;
 3474|     23|    m->mem = mem;
 3475|     23|    m->rng = rng;
 3476|     23|    m->ns = ns;
 3477|       |
 3478|     23|    m->fr = friendreq_new(mem);
 3479|       |
 3480|     23|    if (m->fr == nullptr) {
  ------------------
  |  |   63|     23|#define nullptr NULL
  ------------------
  |  Branch (3480:9): [True: 1, False: 22]
  ------------------
 3481|      1|        mem_delete(mem, m);
 3482|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 3483|      1|    }
 3484|       |
 3485|     22|    m->log = logger_new(mem);
 3486|       |
 3487|     22|    if (m->log == nullptr) {
  ------------------
  |  |   63|     22|#define nullptr NULL
  ------------------
  |  Branch (3487:9): [True: 1, False: 21]
  ------------------
 3488|      1|        friendreq_kill(m->fr);
 3489|      1|        mem_delete(mem, m);
 3490|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 3491|      1|    }
 3492|       |
 3493|     21|    logger_callback_log(m->log, options->log_callback, options->log_context, options->log_user_data);
 3494|       |
 3495|     21|    unsigned int net_err = 0;
 3496|       |
 3497|     21|    if (!options->udp_disabled && options->proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (3497:9): [True: 21, False: 0]
  |  Branch (3497:35): [True: 9, False: 12]
  ------------------
 3498|       |        // We don't currently support UDP over proxy.
 3499|      9|        LOGGER_INFO(m->log, "UDP enabled and proxy set: disabling UDP");
  ------------------
  |  |   85|      9|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      9|    do {                                                                         \
  |  |  |  |   77|      9|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     18|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      9|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      9|        }                                                                        \
  |  |  |  |   80|      9|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3500|      9|        options->udp_disabled = true;
 3501|      9|    }
 3502|       |
 3503|     21|    if (options->udp_disabled) {
  ------------------
  |  Branch (3503:9): [True: 9, False: 12]
  ------------------
 3504|      9|        m->net = new_networking_no_udp(m->log, m->mem, m->ns);
 3505|     12|    } else {
 3506|     12|        IP ip;
 3507|     12|        ip_init(&ip, options->ipv6enabled);
 3508|     12|        m->net = new_networking_ex(m->log, m->mem, m->ns, &ip, options->port_range[0], options->port_range[1], &net_err);
 3509|     12|    }
 3510|       |
 3511|     21|    if (m->net == nullptr) {
  ------------------
  |  |   63|     21|#define nullptr NULL
  ------------------
  |  Branch (3511:9): [True: 3, False: 18]
  ------------------
 3512|      3|        friendreq_kill(m->fr);
 3513|       |
 3514|      3|        if (error != nullptr && net_err == 1) {
  ------------------
  |  |   63|      6|#define nullptr NULL
  ------------------
  |  Branch (3514:13): [True: 3, False: 0]
  |  Branch (3514:33): [True: 0, False: 3]
  ------------------
 3515|      0|            LOGGER_WARNING(m->log, "network initialisation failed (no ports available)");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3516|      0|            *error = MESSENGER_ERROR_PORT;
 3517|      0|        }
 3518|       |
 3519|      3|        logger_kill(m->log);
 3520|      3|        mem_delete(mem, m);
 3521|      3|        return nullptr;
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
 3522|      3|    }
 3523|       |
 3524|     18|    m->dht = new_dht(m->log, m->mem, m->rng, m->ns, m->mono_time, m->net, options->hole_punching_enabled, options->local_discovery_enabled);
 3525|       |
 3526|     18|    if (m->dht == nullptr) {
  ------------------
  |  |   63|     18|#define nullptr NULL
  ------------------
  |  Branch (3526:9): [True: 18, False: 0]
  ------------------
 3527|     18|        kill_networking(m->net);
 3528|     18|        friendreq_kill(m->fr);
 3529|     18|        logger_kill(m->log);
 3530|     18|        mem_delete(mem, m);
 3531|     18|        return nullptr;
  ------------------
  |  |   63|     18|#define nullptr NULL
  ------------------
 3532|     18|    }
 3533|       |
 3534|      0|    m->net_crypto = new_net_crypto(m->log, m->mem, m->rng, m->ns, m->mono_time, m->dht, &options->proxy_info);
 3535|       |
 3536|      0|    if (m->net_crypto == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3536:9): [True: 0, False: 0]
  ------------------
 3537|      0|        LOGGER_WARNING(m->log, "net_crypto initialisation failed");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3538|       |
 3539|      0|        kill_dht(m->dht);
 3540|      0|        kill_networking(m->net);
 3541|      0|        friendreq_kill(m->fr);
 3542|      0|        logger_kill(m->log);
 3543|      0|        mem_delete(mem, m);
 3544|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3545|      0|    }
 3546|       |
 3547|      0|    m->group_announce = new_gca_list(m->mem);
 3548|       |
 3549|      0|    if (m->group_announce == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3549:9): [True: 0, False: 0]
  ------------------
 3550|      0|        LOGGER_WARNING(m->log, "DHT group chats initialisation failed");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3551|       |
 3552|      0|        kill_net_crypto(m->net_crypto);
 3553|      0|        kill_dht(m->dht);
 3554|      0|        kill_networking(m->net);
 3555|      0|        friendreq_kill(m->fr);
 3556|      0|        logger_kill(m->log);
 3557|      0|        mem_delete(mem, m);
 3558|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3559|      0|    }
 3560|       |
 3561|      0|    if (options->dht_announcements_enabled) {
  ------------------
  |  Branch (3561:9): [True: 0, False: 0]
  ------------------
 3562|      0|        m->forwarding = new_forwarding(m->log, m->mem, m->rng, m->mono_time, m->dht);
 3563|      0|        if (m->forwarding != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3563:13): [True: 0, False: 0]
  ------------------
 3564|      0|            m->announce = new_announcements(m->log, m->mem, m->rng, m->mono_time, m->forwarding);
 3565|      0|        } else {
 3566|      0|            m->announce = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3567|      0|        }
 3568|      0|    } else {
 3569|      0|        m->forwarding = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3570|      0|        m->announce = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3571|      0|    }
 3572|       |
 3573|      0|    m->onion = new_onion(m->log, m->mem, m->mono_time, m->rng, m->dht);
 3574|      0|    m->onion_a = new_onion_announce(m->log, m->mem, m->rng, m->mono_time, m->dht);
 3575|      0|    m->onion_c = new_onion_client(m->log, m->mem, m->rng, m->mono_time, m->net_crypto);
 3576|      0|    if (m->onion_c != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3576:9): [True: 0, False: 0]
  ------------------
 3577|      0|        m->fr_c = new_friend_connections(m->log, m->mem, m->mono_time, m->ns, m->onion_c, options->local_discovery_enabled);
 3578|      0|    }
 3579|       |
 3580|      0|    if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
                  if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3580:10): [True: 0, False: 0]
  |  Branch (3580:49): [True: 0, False: 0]
  |  Branch (3580:77): [True: 0, False: 0]
  ------------------
 3581|      0|            m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
                          m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3581:13): [True: 0, False: 0]
  |  Branch (3581:36): [True: 0, False: 0]
  |  Branch (3581:61): [True: 0, False: 0]
  |  Branch (3581:86): [True: 0, False: 0]
  ------------------
 3582|      0|        LOGGER_WARNING(m->log, "onion initialisation failed");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3583|       |
 3584|      0|        kill_onion(m->onion);
 3585|      0|        kill_onion_announce(m->onion_a);
 3586|      0|        kill_onion_client(m->onion_c);
 3587|      0|        kill_gca(m->group_announce);
 3588|      0|        kill_friend_connections(m->fr_c);
 3589|      0|        kill_announcements(m->announce);
 3590|      0|        kill_forwarding(m->forwarding);
 3591|      0|        kill_net_crypto(m->net_crypto);
 3592|      0|        kill_dht(m->dht);
 3593|      0|        kill_networking(m->net);
 3594|      0|        friendreq_kill(m->fr);
 3595|      0|        logger_kill(m->log);
 3596|      0|        mem_delete(mem, m);
 3597|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3598|      0|    }
 3599|       |
 3600|      0|    gca_onion_init(m->group_announce, m->onion_a);
 3601|       |
 3602|      0|    m->group_handler = new_dht_groupchats(m);
 3603|       |
 3604|      0|    if (m->group_handler == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3604:9): [True: 0, False: 0]
  ------------------
 3605|      0|        LOGGER_WARNING(m->log, "conferences initialisation failed");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3606|       |
 3607|      0|        kill_onion(m->onion);
 3608|      0|        kill_onion_announce(m->onion_a);
 3609|      0|        kill_onion_client(m->onion_c);
 3610|      0|        kill_gca(m->group_announce);
 3611|      0|        kill_friend_connections(m->fr_c);
 3612|      0|        kill_announcements(m->announce);
 3613|      0|        kill_forwarding(m->forwarding);
 3614|      0|        kill_net_crypto(m->net_crypto);
 3615|      0|        kill_dht(m->dht);
 3616|      0|        kill_networking(m->net);
 3617|      0|        friendreq_kill(m->fr);
 3618|      0|        logger_kill(m->log);
 3619|      0|        mem_delete(mem, m);
 3620|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3621|      0|    }
 3622|       |
 3623|      0|    if (options->tcp_server_port != 0) {
  ------------------
  |  Branch (3623:9): [True: 0, False: 0]
  ------------------
 3624|      0|        m->tcp_server = new_tcp_server(m->log, m->mem, m->rng, m->ns, options->ipv6enabled, 1,
 3625|      0|                                       &options->tcp_server_port, dht_get_self_secret_key(m->dht),
 3626|      0|                                       m->onion, m->forwarding);
 3627|       |
 3628|      0|        if (m->tcp_server == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3628:13): [True: 0, False: 0]
  ------------------
 3629|      0|            LOGGER_WARNING(m->log, "TCP server initialisation failed");
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3630|       |
 3631|      0|            kill_onion(m->onion);
 3632|      0|            kill_onion_announce(m->onion_a);
 3633|      0|            kill_dht_groupchats(m->group_handler);
 3634|      0|            kill_friend_connections(m->fr_c);
 3635|      0|            kill_onion_client(m->onion_c);
 3636|      0|            kill_gca(m->group_announce);
 3637|      0|            kill_announcements(m->announce);
 3638|      0|            kill_forwarding(m->forwarding);
 3639|      0|            kill_net_crypto(m->net_crypto);
 3640|      0|            kill_dht(m->dht);
 3641|      0|            kill_networking(m->net);
 3642|      0|            friendreq_kill(m->fr);
 3643|      0|            logger_kill(m->log);
 3644|      0|            mem_delete(mem, m);
 3645|       |
 3646|      0|            if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3646:17): [True: 0, False: 0]
  ------------------
 3647|      0|                *error = MESSENGER_ERROR_TCP_SERVER;
 3648|      0|            }
 3649|       |
 3650|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 3651|      0|        }
 3652|      0|    }
 3653|       |
 3654|      0|    m->options = *options;
 3655|      0|    friendreq_init(m->fr, m->fr_c);
 3656|      0|    set_nospam(m->fr, random_u32(m->rng));
 3657|      0|    set_filter_function(m->fr, &friend_already_added, m);
 3658|       |
 3659|      0|    m->lastdump = 0;
 3660|      0|    m->is_receiving_file = 0;
 3661|       |
 3662|      0|    m_register_default_plugins(m);
 3663|      0|    callback_friendrequest(m->fr, m_handle_friend_request, m);
 3664|       |
 3665|      0|    if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (3665:9): [True: 0, False: 0]
  ------------------
 3666|      0|        *error = MESSENGER_ERROR_NONE;
 3667|      0|    }
 3668|       |
 3669|      0|    return m;
 3670|      0|}

crypto_memzero:
  116|     40|{
  117|     40|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  118|     40|    memzero((uint8_t *)data, length);
  119|       |#else
  120|       |    sodium_memzero(data, length);
  121|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  122|     40|}
crypto_memlock:
  125|     23|{
  126|     23|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  127|     23|    return false;
  128|       |#else
  129|       |
  130|       |    return sodium_mlock(data, length) == 0;
  131|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  132|     23|}
crypto_memunlock:
  135|     23|{
  136|     23|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  137|     23|    return false;
  138|       |#else
  139|       |
  140|       |    return sodium_munlock(data, length) == 0;
  141|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  142|     23|}
pk_equal:
  145|  11.3k|{
  146|  11.3k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  147|       |    // Hope that this is better for the fuzzer
  148|  11.3k|    return memcmp(pk1, pk2, CRYPTO_PUBLIC_KEY_SIZE) == 0;
  ------------------
  |  |   43|  11.3k|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  149|       |#else
  150|       |    return crypto_verify_32(pk1, pk2) == 0;
  151|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  152|  11.3k|}
random_u64:
  201|     11|{
  202|     11|    uint64_t randnum;
  203|     11|    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
  204|     11|    return randnum;
  205|     11|}
crypto_new_keypair:
  439|     34|{
  440|     34|    random_bytes(rng, secret_key, CRYPTO_SECRET_KEY_SIZE);
  ------------------
  |  |   48|     34|#define CRYPTO_SECRET_KEY_SIZE         32
  ------------------
  441|     34|    memzero(public_key, CRYPTO_PUBLIC_KEY_SIZE);  // Make MSAN happy
  ------------------
  |  |   43|     34|#define CRYPTO_PUBLIC_KEY_SIZE         32
  ------------------
  442|     34|    crypto_derive_public_key(public_key, secret_key);
  443|     34|    return 0;
  444|     34|}
crypto_derive_public_key:
  448|     34|{
  449|     34|    crypto_scalarmult_curve25519_base(public_key, secret_key);
  450|     34|}
os_random:
  518|     27|{
  519|     27|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  520|     27|    if ((true)) {
  ------------------
  |  Branch (520:9): [Folded - Ignored]
  ------------------
  521|     27|        return nullptr;
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  522|     27|    }
  523|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  524|       |    // It is safe to call this function more than once and from different
  525|       |    // threads -- subsequent calls won't have any effects.
  526|      0|    if (sodium_init() == -1) {
  ------------------
  |  Branch (526:9): [True: 0, False: 0]
  ------------------
  527|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  528|      0|    }
  529|      0|    return &os_random_obj;
  530|      0|}
random_bytes:
  533|     45|{
  534|     45|    rng->funcs->random_bytes(rng->obj, bytes, length);
  535|     45|}

friendreq_new:
  174|     23|{
  175|     23|    Friend_Requests *fr = (Friend_Requests *)mem_alloc(mem, sizeof(Friend_Requests));
  176|       |
  177|     23|    if (fr == nullptr) {
  ------------------
  |  |   63|     23|#define nullptr NULL
  ------------------
  |  Branch (177:9): [True: 1, False: 22]
  ------------------
  178|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  179|      1|    }
  180|       |
  181|     22|    fr->mem = mem;
  182|       |
  183|     22|    return fr;
  184|     23|}
friendreq_kill:
  187|     22|{
  188|     22|    if (fr == nullptr) {
  ------------------
  |  |   63|     22|#define nullptr NULL
  ------------------
  |  Branch (188:9): [True: 0, False: 22]
  ------------------
  189|      0|        return;
  190|      0|    }
  191|       |
  192|     22|    mem_delete(fr->mem, fr);
  193|     22|}

logger_new:
   33|     22|{
   34|     22|    Logger *log = (Logger *)mem_alloc(mem, sizeof(Logger));
   35|       |
   36|     22|    if (log == nullptr) {
  ------------------
  |  |   63|     22|#define nullptr NULL
  ------------------
  |  Branch (36:9): [True: 1, False: 21]
  ------------------
   37|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
   38|      1|    }
   39|       |
   40|     21|    log->mem = mem;
   41|       |
   42|     21|    return log;
   43|     22|}
logger_kill:
   46|     21|{
   47|     21|    if (log == nullptr) {
  ------------------
  |  |   63|     21|#define nullptr NULL
  ------------------
  |  Branch (47:9): [True: 0, False: 21]
  ------------------
   48|      0|        return;
   49|      0|    }
   50|       |
   51|     21|    mem_delete(log->mem, log);
   52|     21|}
logger_callback_log:
   55|     21|{
   56|     21|    assert(log != nullptr);
   57|     21|    log->callback = function;
   58|     21|    log->context  = context;
   59|     21|    log->userdata = userdata;
   60|     21|}
logger_write:
   64|     28|{
   65|     28|    if (log == nullptr) {
  ------------------
  |  |   63|     28|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 0, False: 28]
  ------------------
   66|      0|        return;
   67|      0|    }
   68|       |
   69|     28|    if (log->callback == nullptr) {
  ------------------
  |  |   63|     28|#define nullptr NULL
  ------------------
  |  Branch (69:9): [True: 0, False: 28]
  ------------------
   70|      0|        return;
   71|      0|    }
   72|       |
   73|       |    // Only pass the file name, not the entire file path, for privacy reasons.
   74|       |    // The full path may contain PII of the person compiling toxcore (their
   75|       |    // username and directory layout).
   76|     28|    const char *filename = strrchr(file, '/');
   77|     28|    file = filename != nullptr ? filename + 1 : file;
  ------------------
  |  |   63|     28|#define nullptr NULL
  ------------------
  |  Branch (77:12): [True: 28, False: 0]
  ------------------
   78|       |#if defined(_WIN32) || defined(__CYGWIN__)
   79|       |    // On Windows, the path separator *may* be a backslash, so we look for that
   80|       |    // one too.
   81|       |    const char *windows_filename = strrchr(file, '\\');
   82|       |    file = windows_filename != nullptr ? windows_filename + 1 : file;
   83|       |#endif /* WIN32 */
   84|       |
   85|       |    // Format message
   86|     28|    char msg[1024];
   87|     28|    va_list args;
   88|     28|    va_start(args, format);
   89|     28|    vsnprintf(msg, sizeof(msg), format, args);
   90|     28|    va_end(args);
   91|       |
   92|     28|    log->callback(log->context, level, file, line, func, msg, log->userdata);
   93|     28|}

os_memory:
   46|     27|{
   47|     27|    return &os_memory_obj;
   48|     27|}
mem_alloc:
   63|    265|{
   64|    265|    void *const ptr = mem->funcs->calloc(mem->obj, 1, size);
   65|    265|    return ptr;
   66|    265|}
mem_valloc:
   69|     47|{
   70|     47|    const uint32_t bytes = nmemb * size;
   71|       |
   72|     47|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (72:9): [True: 47, False: 0]
  |  Branch (72:22): [True: 0, False: 47]
  ------------------
   73|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   74|      0|    }
   75|       |
   76|     47|    void *const ptr = mem->funcs->calloc(mem->obj, nmemb, size);
   77|     47|    return ptr;
   78|     47|}
mem_vrealloc:
   81|     11|{
   82|     11|    const uint32_t bytes = nmemb * size;
   83|       |
   84|     11|    if (size != 0 && bytes / size != nmemb) {
  ------------------
  |  Branch (84:9): [True: 11, False: 0]
  |  Branch (84:22): [True: 0, False: 11]
  ------------------
   85|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   86|      0|    }
   87|       |
   88|     11|    void *const new_ptr = mem->funcs->realloc(mem->obj, ptr, bytes);
   89|     11|    return new_ptr;
   90|     11|}
mem_delete:
   93|    353|{
   94|    353|    mem->funcs->free(mem->obj, ptr);
   95|    353|}

mono_time_new:
  114|     26|{
  115|     26|    Mono_Time *mono_time = (Mono_Time *)mem_alloc(mem, sizeof(Mono_Time));
  116|       |
  117|     26|    if (mono_time == nullptr) {
  ------------------
  |  |   63|     26|#define nullptr NULL
  ------------------
  |  Branch (117:9): [True: 1, False: 25]
  ------------------
  118|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  119|      1|    }
  120|       |
  121|     25|#ifndef ESP_PLATFORM
  122|     25|    pthread_rwlock_t *rwlock = (pthread_rwlock_t *)mem_alloc(mem, sizeof(pthread_rwlock_t));
  123|       |
  124|     25|    if (rwlock == nullptr) {
  ------------------
  |  |   63|     25|#define nullptr NULL
  ------------------
  |  Branch (124:9): [True: 1, False: 24]
  ------------------
  125|      1|        mem_delete(mem, mono_time);
  126|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  127|      1|    }
  128|       |
  129|     24|    if (pthread_rwlock_init(rwlock, nullptr) != 0) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (129:9): [True: 0, False: 24]
  ------------------
  130|      0|        mem_delete(mem, rwlock);
  131|      0|        mem_delete(mem, mono_time);
  132|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  133|      0|    }
  134|       |
  135|     24|    mono_time->time_update_lock = rwlock;
  136|     24|#endif /* ESP_PLATFORM */
  137|       |
  138|     24|    mono_time_set_current_time_callback(mono_time, current_time_callback, user_data);
  139|       |
  140|     24|    mono_time->cur_time = 0;
  141|     24|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  142|       |    // Maximum reproducibility. Never return time = 0.
  143|     24|    mono_time->base_time = 1000000000;
  144|       |#else
  145|       |    // Never return time = 0 in case time() returns 0 (e.g. on microcontrollers
  146|       |    // without battery-powered RTC or ones where NTP didn't initialise it yet).
  147|       |    mono_time->base_time = max_u64(1, (uint64_t)time(nullptr)) * UINT64_C(1000) - current_time_monotonic(mono_time);
  148|       |#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  149|       |
  150|     24|    mono_time_update(mono_time);
  151|       |
  152|     24|    return mono_time;
  153|     24|}
mono_time_free:
  156|     24|{
  157|     24|    if (mono_time == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (157:9): [True: 0, False: 24]
  ------------------
  158|      0|        return;
  159|      0|    }
  160|     24|#ifndef ESP_PLATFORM
  161|     24|    pthread_rwlock_destroy(mono_time->time_update_lock);
  162|     24|    mem_delete(mem, mono_time->time_update_lock);
  163|     24|#endif /* ESP_PLATFORM */
  164|     24|    mem_delete(mem, mono_time);
  165|     24|}
mono_time_update:
  168|     24|{
  169|     24|    const uint64_t cur_time =
  170|     24|        mono_time->base_time + mono_time->current_time_callback(mono_time->user_data);
  171|       |
  172|     24|#ifndef ESP_PLATFORM
  173|     24|    pthread_rwlock_wrlock(mono_time->time_update_lock);
  174|     24|#endif /* ESP_PLATFORM */
  175|     24|    mono_time->cur_time = cur_time;
  176|     24|#ifndef ESP_PLATFORM
  177|     24|    pthread_rwlock_unlock(mono_time->time_update_lock);
  178|     24|#endif /* ESP_PLATFORM */
  179|     24|}
mono_time_get_ms:
  182|     41|{
  183|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  184|       |    // Fuzzing is only single thread for now, no locking needed */
  185|       |    pthread_rwlock_rdlock(mono_time->time_update_lock);
  186|       |#endif /* !ESP_PLATFORM */
  187|     41|    const uint64_t cur_time = mono_time->cur_time;
  188|       |#if !defined(ESP_PLATFORM) && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
  189|       |    pthread_rwlock_unlock(mono_time->time_update_lock);
  190|       |#endif /* !ESP_PLATFORM */
  191|     41|    return cur_time;
  192|     41|}
mono_time_get:
  195|     41|{
  196|     41|    return mono_time_get_ms(mono_time) / UINT64_C(1000);
  197|     41|}
mono_time_set_current_time_callback:
  206|     24|{
  207|     24|    if (current_time_callback == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (207:9): [True: 0, False: 24]
  ------------------
  208|      0|        mono_time->current_time_callback = current_time_monotonic_default;
  209|      0|        mono_time->user_data = mono_time;
  210|     24|    } else {
  211|     24|        mono_time->current_time_callback = current_time_callback;
  212|     24|        mono_time->user_data = user_data;
  213|     24|    }
  214|     24|}

netprof_new:
  141|     11|{
  142|     11|    Net_Profile *np = (Net_Profile *)mem_alloc(mem, sizeof(Net_Profile));
  143|       |
  144|     11|    if (np == nullptr) {
  ------------------
  |  |   63|     11|#define nullptr NULL
  ------------------
  |  Branch (144:9): [True: 1, False: 10]
  ------------------
  145|      1|        LOGGER_ERROR(log, "failed to allocate memory for net profiler");
  ------------------
  |  |   87|      1|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      1|    do {                                                                         \
  |  |  |  |   77|      1|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      2|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      1|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      1|        }                                                                        \
  |  |  |  |   80|      1|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  146|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  147|      1|    }
  148|       |
  149|     10|    return np;
  150|     11|}
netprof_kill:
  153|     18|{
  154|     18|    if (net_profile != nullptr) {
  ------------------
  |  |   63|     18|#define nullptr NULL
  ------------------
  |  Branch (154:9): [True: 10, False: 8]
  ------------------
  155|     10|        mem_delete(mem, net_profile);
  156|     10|    }
  157|     18|}

net_socket_from_native:
  380|     10|{
  381|     10|    const Socket res = {(force Socket_Value)sock};
  382|     10|    return res;
  383|     10|}
net_invalid_socket:
  386|     10|{
  387|     10|    return net_socket_from_native(INVALID_SOCKET);
  ------------------
  |  |  371|     10|#define INVALID_SOCKET (-1)
  ------------------
  388|     10|}
net_family_unspec:
  391|     21|{
  392|     21|    return family_unspec;
  393|     21|}
net_family_ipv4:
  396|     10|{
  397|     10|    return family_ipv4;
  398|     10|}
net_family_ipv6:
  401|     22|{
  402|     22|    return family_ipv6;
  403|     22|}
net_family_is_unspec:
  436|     40|{
  437|     40|    return family.value == family_unspec.value;
  438|     40|}
net_family_is_ipv4:
  441|     44|{
  442|     44|    return family.value == family_ipv4.value;
  443|     44|}
net_family_is_ipv6:
  446|     54|{
  447|     54|    return family.value == family_ipv6.value;
  448|     54|}
sock_valid:
  481|     10|{
  482|     10|    const Socket invalid_socket = net_invalid_socket();
  483|     10|    return sock.value != invalid_socket.value;
  484|     10|}
os_network:
  705|     27|{
  706|     27|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  707|     27|    if ((true)) {
  ------------------
  |  Branch (707:9): [Folded - Ignored]
  ------------------
  708|     27|        return nullptr;
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  709|     27|    }
  710|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
  711|       |#ifdef OS_WIN32
  712|       |    WSADATA wsaData;
  713|       |
  714|       |    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != NO_ERROR) {
  715|       |        return nullptr;
  716|       |    }
  717|       |#endif /* OS_WIN32 */
  718|      0|    return &os_network_obj;
  719|     27|}
kill_sock:
  965|     10|{
  966|     10|    ns->funcs->close(ns->obj, sock);
  967|     10|}
set_socket_nonblock:
  970|     10|{
  971|     10|    return ns->funcs->socket_nonblock(ns->obj, sock, true) == 0;
  972|     10|}
set_socket_nosigpipe:
  975|     10|{
  976|       |#if defined(__APPLE__)
  977|       |    int set = 1;
  978|       |    return net_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
  979|       |#else
  980|     10|    return true;
  981|     10|#endif /* __APPLE__ */
  982|     10|}
set_socket_dualstack:
  995|     10|{
  996|     10|    int ipv6only = 0;
  997|     10|    size_t optsize = sizeof(ipv6only);
  998|     10|    const int res = net_getsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, &optsize);
  999|       |
 1000|     10|    if ((res == 0) && (ipv6only == 0)) {
  ------------------
  |  Branch (1000:9): [True: 10, False: 0]
  |  Branch (1000:23): [True: 10, False: 0]
  ------------------
 1001|     10|        return true;
 1002|     10|    }
 1003|       |
 1004|      0|    ipv6only = 0;
 1005|      0|    return net_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only)) == 0;
 1006|     10|}
networking_registerhandler:
 1197|    176|{
 1198|    176|    net->packethandlers[byte].function = cb;
 1199|    176|    net->packethandlers[byte].object = object;
 1200|    176|}
new_networking_ex:
 1246|     12|{
 1247|       |    /* If both from and to are 0, use default port range
 1248|       |     * If one is 0 and the other is non-0, use the non-0 value as only port
 1249|       |     * If from > to, swap
 1250|       |     */
 1251|     12|    if (port_from == 0 && port_to == 0) {
  ------------------
  |  Branch (1251:9): [True: 12, False: 0]
  |  Branch (1251:27): [True: 12, False: 0]
  ------------------
 1252|     12|        port_from = TOX_PORTRANGE_FROM;
  ------------------
  |  |  162|     12|#define TOX_PORTRANGE_FROM 33445
  ------------------
 1253|     12|        port_to = TOX_PORTRANGE_TO;
  ------------------
  |  |  163|     12|#define TOX_PORTRANGE_TO   33545
  ------------------
 1254|     12|    } else if (port_from == 0 && port_to != 0) {
  ------------------
  |  Branch (1254:16): [True: 0, False: 0]
  |  Branch (1254:34): [True: 0, False: 0]
  ------------------
 1255|      0|        port_from = port_to;
 1256|      0|    } else if (port_from != 0 && port_to == 0) {
  ------------------
  |  Branch (1256:16): [True: 0, False: 0]
  |  Branch (1256:34): [True: 0, False: 0]
  ------------------
 1257|      0|        port_to = port_from;
 1258|      0|    } else if (port_from > port_to) {
  ------------------
  |  Branch (1258:16): [True: 0, False: 0]
  ------------------
 1259|      0|        const uint16_t temp_port = port_from;
 1260|      0|        port_from = port_to;
 1261|      0|        port_to = temp_port;
 1262|      0|    }
 1263|       |
 1264|     12|    if (error != nullptr) {
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
  |  Branch (1264:9): [True: 12, False: 0]
  ------------------
 1265|     12|        *error = 2;
 1266|     12|    }
 1267|       |
 1268|       |    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
 1269|     12|    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1269:9): [True: 12, False: 0]
  |  Branch (1269:44): [True: 0, False: 12]
  ------------------
 1270|      0|        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1271|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1272|      0|    }
 1273|       |
 1274|     12|    Networking_Core *temp = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
 1275|       |
 1276|     12|    if (temp == nullptr) {
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
  |  Branch (1276:9): [True: 1, False: 11]
  ------------------
 1277|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 1278|      1|    }
 1279|       |
 1280|     11|    Net_Profile *np = netprof_new(log, mem);
 1281|       |
 1282|     11|    if (np == nullptr) {
  ------------------
  |  |   63|     11|#define nullptr NULL
  ------------------
  |  Branch (1282:9): [True: 1, False: 10]
  ------------------
 1283|      1|        free(temp);
 1284|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 1285|      1|    }
 1286|       |
 1287|     10|    temp->udp_net_profile = np;
 1288|     10|    temp->ns = ns;
 1289|     10|    temp->log = log;
 1290|     10|    temp->mem = mem;
 1291|     10|    temp->family = ip->family;
 1292|     10|    temp->port = 0;
 1293|       |
 1294|       |    /* Initialize our socket. */
 1295|       |    /* add log message what we're creating */
 1296|     10|    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  174|     10|#define TOX_SOCK_DGRAM 2
  ------------------
                  temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);
  ------------------
  |  |  177|     10|#define TOX_PROTO_UDP 2
  ------------------
 1297|       |
 1298|       |    /* Check for socket error. */
 1299|     10|    if (!sock_valid(temp->sock)) {
  ------------------
  |  Branch (1299:9): [True: 0, False: 10]
  ------------------
 1300|      0|        const int neterror = net_error();
 1301|      0|        Net_Strerror error_str;
 1302|      0|        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1303|      0|        netprof_kill(mem, temp->udp_net_profile);
 1304|      0|        mem_delete(mem, temp);
 1305|       |
 1306|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1306:13): [True: 0, False: 0]
  ------------------
 1307|      0|            *error = 1;
 1308|      0|        }
 1309|       |
 1310|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1311|      0|    }
 1312|       |
 1313|       |    /* Functions to increase the size of the send and receive UDP buffers.
 1314|       |     */
 1315|     10|    int n = 1024 * 1024 * 2;
 1316|       |
 1317|     10|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1317:9): [True: 0, False: 10]
  ------------------
 1318|      0|        LOGGER_WARNING(log, "failed to set socket option %d", SO_RCVBUF);
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1319|      0|    }
 1320|       |
 1321|     10|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_SNDBUF, &n, sizeof(n)) != 0) {
  ------------------
  |  Branch (1321:9): [True: 0, False: 10]
  ------------------
 1322|      0|        LOGGER_WARNING(log, "failed to set socket option %d", SO_SNDBUF);
  ------------------
  |  |   86|      0|#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1323|      0|    }
 1324|       |
 1325|       |    /* Enable broadcast on socket */
 1326|     10|    int broadcast = 1;
 1327|       |
 1328|     10|    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) != 0) {
  ------------------
  |  Branch (1328:9): [True: 0, False: 10]
  ------------------
 1329|      0|        LOGGER_ERROR(log, "failed to set socket option %d", SO_BROADCAST);
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1330|      0|    }
 1331|       |
 1332|       |    /* iOS UDP sockets are weird and apparently can SIGPIPE */
 1333|     10|    if (!set_socket_nosigpipe(ns, temp->sock)) {
  ------------------
  |  Branch (1333:9): [True: 0, False: 10]
  ------------------
 1334|      0|        kill_networking(temp);
 1335|       |
 1336|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1336:13): [True: 0, False: 0]
  ------------------
 1337|      0|            *error = 1;
 1338|      0|        }
 1339|       |
 1340|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1341|      0|    }
 1342|       |
 1343|       |    /* Set socket nonblocking. */
 1344|     10|    if (!set_socket_nonblock(ns, temp->sock)) {
  ------------------
  |  Branch (1344:9): [True: 0, False: 10]
  ------------------
 1345|      0|        kill_networking(temp);
 1346|       |
 1347|      0|        if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1347:13): [True: 0, False: 0]
  ------------------
 1348|      0|            *error = 1;
 1349|      0|        }
 1350|       |
 1351|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1352|      0|    }
 1353|       |
 1354|       |    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
 1355|     10|    uint16_t *portptr = nullptr;
  ------------------
  |  |   63|     10|#define nullptr NULL
  ------------------
 1356|     10|    Network_Addr addr = {{0}};
 1357|       |
 1358|     10|    if (net_family_is_ipv4(temp->family)) {
  ------------------
  |  Branch (1358:9): [True: 0, False: 10]
  ------------------
 1359|      0|        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr.addr;
 1360|       |
 1361|      0|        addr.size = sizeof(struct sockaddr_in);
 1362|      0|        addr4->sin_family = AF_INET;
 1363|      0|        addr4->sin_port = 0;
 1364|      0|        fill_addr4(&ip->ip.v4, &addr4->sin_addr);
 1365|       |
 1366|      0|        portptr = &addr4->sin_port;
 1367|     10|    } else if (net_family_is_ipv6(temp->family)) {
  ------------------
  |  Branch (1367:16): [True: 10, False: 0]
  ------------------
 1368|     10|        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr.addr;
 1369|       |
 1370|     10|        addr.size = sizeof(struct sockaddr_in6);
 1371|     10|        addr6->sin6_family = AF_INET6;
 1372|     10|        addr6->sin6_port = 0;
 1373|     10|        fill_addr6(&ip->ip.v6, &addr6->sin6_addr);
 1374|       |
 1375|     10|        addr6->sin6_flowinfo = 0;
 1376|     10|        addr6->sin6_scope_id = 0;
 1377|       |
 1378|     10|        portptr = &addr6->sin6_port;
 1379|     10|    } else {
 1380|      0|        mem_delete(mem, temp);
 1381|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1382|      0|    }
 1383|       |
 1384|     10|    if (net_family_is_ipv6(ip->family)) {
  ------------------
  |  Branch (1384:9): [True: 10, False: 0]
  ------------------
 1385|     10|        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);
 1386|       |
 1387|     10|        if (is_dualstack) {
  ------------------
  |  Branch (1387:13): [True: 10, False: 0]
  ------------------
 1388|     10|            LOGGER_TRACE(log, "Dual-stack socket: enabled");
  ------------------
  |  |   83|     10|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     10|    do {                                                                         \
  |  |  |  |   77|     10|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     20|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|     10|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1389|     10|        } else {
 1390|      0|            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1391|      0|        }
 1392|       |
 1393|     10|#ifndef ESP_PLATFORM
 1394|       |        /* multicast local nodes */
 1395|     10|        struct ipv6_mreq mreq = {{{{0}}}};
 1396|     10|        mreq.ipv6mr_multiaddr.s6_addr[0] = 0xFF;
 1397|     10|        mreq.ipv6mr_multiaddr.s6_addr[1] = 0x02;
 1398|     10|        mreq.ipv6mr_multiaddr.s6_addr[15] = 0x01;
 1399|     10|        mreq.ipv6mr_interface = 0;
 1400|       |
 1401|     10|        const int res = net_setsockopt(ns, temp->sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
 1402|       |
 1403|     10|        const int neterror = net_error();
 1404|     10|        Net_Strerror error_str;
 1405|       |
 1406|     10|        if (res < 0) {
  ------------------
  |  Branch (1406:13): [True: 0, False: 10]
  ------------------
 1407|      0|            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   85|      0|#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1408|     10|        } else {
 1409|     10|            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, net_strerror(neterror, &error_str));
  ------------------
  |  |   83|     10|#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     10|    do {                                                                         \
  |  |  |  |   77|     10|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     20|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|     10|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1410|     10|        }
 1411|     10|#endif /* ESP_PLATFORM */
 1412|     10|    }
 1413|       |
 1414|       |    /* A hanging program or a different user might block the standard port.
 1415|       |     * As long as it isn't a parameter coming from the commandline,
 1416|       |     * try a few ports after it, to see if we can find a "free" one.
 1417|       |     *
 1418|       |     * If we go on without binding, the first sendto() automatically binds to
 1419|       |     * a free port chosen by the system (i.e. anything from 1024 to 65535).
 1420|       |     *
 1421|       |     * Returning NULL after bind fails has both advantages and disadvantages:
 1422|       |     * advantage:
 1423|       |     *   we can rely on getting the port in the range 33445..33450, which
 1424|       |     *   enables us to tell joe user to open their firewall to a small range
 1425|       |     *
 1426|       |     * disadvantage:
 1427|       |     *   some clients might not test return of tox_new(), blindly assuming that
 1428|       |     *   it worked ok (which it did previously without a successful bind)
 1429|       |     */
 1430|     10|    uint16_t port_to_try = port_from;
 1431|     10|    *portptr = net_htons(port_to_try);
 1432|       |
 1433|     10|    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
  ------------------
  |  Branch (1433:38): [True: 10, False: 0]
  ------------------
 1434|     10|        const int res = net_bind(ns, temp->sock, &addr);
 1435|       |
 1436|     10|        if (res == 0) {
  ------------------
  |  Branch (1436:13): [True: 10, False: 0]
  ------------------
 1437|     10|            temp->port = *portptr;
 1438|       |
 1439|     10|            Ip_Ntoa ip_str;
 1440|     10|            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
  ------------------
  |  |   84|     10|#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|     10|    do {                                                                         \
  |  |  |  |   77|     10|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|     20|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|     10|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1441|     10|                         net_ntohs(temp->port));
 1442|       |
 1443|       |            /* errno isn't reset on success, only set on failure, the failed
 1444|       |             * binds with parallel clients yield a -EPERM to the outside if
 1445|       |             * errno isn't cleared here */
 1446|     10|            if (tries > 0) {
  ------------------
  |  Branch (1446:17): [True: 10, False: 0]
  ------------------
 1447|     10|                errno = 0;
 1448|     10|            }
 1449|       |
 1450|     10|            if (error != nullptr) {
  ------------------
  |  |   63|     10|#define nullptr NULL
  ------------------
  |  Branch (1450:17): [True: 10, False: 0]
  ------------------
 1451|     10|                *error = 0;
 1452|     10|            }
 1453|       |
 1454|     10|            return temp;
 1455|     10|        }
 1456|       |
 1457|      0|        ++port_to_try;
 1458|       |
 1459|      0|        if (port_to_try > port_to) {
  ------------------
  |  Branch (1459:13): [True: 0, False: 0]
  ------------------
 1460|      0|            port_to_try = port_from;
 1461|      0|        }
 1462|       |
 1463|      0|        *portptr = net_htons(port_to_try);
 1464|      0|    }
 1465|       |
 1466|      0|    Ip_Ntoa ip_str;
 1467|      0|    const int neterror = net_error();
 1468|      0|    Net_Strerror error_str;
 1469|      0|    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u",
  ------------------
  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  ------------------
  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1470|      0|                 neterror, net_strerror(neterror, &error_str), net_ip_ntoa(ip, &ip_str), port_from, port_to);
 1471|      0|    kill_networking(temp);
 1472|       |
 1473|      0|    if (error != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1473:9): [True: 0, False: 0]
  ------------------
 1474|      0|        *error = 1;
 1475|      0|    }
 1476|       |
 1477|      0|    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1478|     10|}
new_networking_no_udp:
 1481|      9|{
 1482|       |    /* this is the easiest way to completely disable UDP without changing too much code. */
 1483|      9|    Networking_Core *net = (Networking_Core *)mem_alloc(mem, sizeof(Networking_Core));
 1484|       |
 1485|      9|    if (net == nullptr) {
  ------------------
  |  |   63|      9|#define nullptr NULL
  ------------------
  |  Branch (1485:9): [True: 1, False: 8]
  ------------------
 1486|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
 1487|      1|    }
 1488|       |
 1489|      8|    net->ns = ns;
 1490|      8|    net->log = log;
 1491|      8|    net->mem = mem;
 1492|       |
 1493|      8|    return net;
 1494|      9|}
kill_networking:
 1498|     18|{
 1499|     18|    if (net == nullptr) {
  ------------------
  |  |   63|     18|#define nullptr NULL
  ------------------
  |  Branch (1499:9): [True: 0, False: 18]
  ------------------
 1500|      0|        return;
 1501|      0|    }
 1502|       |
 1503|     18|    if (!net_family_is_unspec(net->family)) {
  ------------------
  |  Branch (1503:9): [True: 10, False: 8]
  ------------------
 1504|       |        /* Socket is initialized, so we close it. */
 1505|     10|        kill_sock(net->ns, net->sock);
 1506|     10|    }
 1507|       |
 1508|     18|    netprof_kill(net->mem, net->udp_net_profile);
 1509|     18|    mem_delete(net->mem, net);
 1510|     18|}
ip_reset:
 1626|     22|{
 1627|     22|    if (ip == nullptr) {
  ------------------
  |  |   63|     22|#define nullptr NULL
  ------------------
  |  Branch (1627:9): [True: 0, False: 22]
  ------------------
 1628|      0|        return;
 1629|      0|    }
 1630|       |
 1631|     22|    *ip = empty_ip;
 1632|     22|}
ip_init:
 1648|     22|{
 1649|     22|    if (ip == nullptr) {
  ------------------
  |  |   63|     22|#define nullptr NULL
  ------------------
  |  Branch (1649:9): [True: 0, False: 22]
  ------------------
 1650|      0|        return;
 1651|      0|    }
 1652|       |
 1653|     22|    ip_reset(ip);
 1654|     22|    ip->family = ipv6enabled ? net_family_ipv6() : net_family_ipv4();
  ------------------
  |  Branch (1654:18): [True: 22, False: 0]
  ------------------
 1655|     22|}
addr_parse_ip:
 1895|     10|{
 1896|     10|    if (address == nullptr || to == nullptr) {
  ------------------
  |  |   63|     20|#define nullptr NULL
  ------------------
                  if (address == nullptr || to == nullptr) {
  ------------------
  |  |   63|     10|#define nullptr NULL
  ------------------
  |  Branch (1896:9): [True: 0, False: 10]
  |  Branch (1896:31): [True: 0, False: 10]
  ------------------
 1897|      0|        return false;
 1898|      0|    }
 1899|       |
 1900|     10|    struct in_addr addr4;
 1901|       |
 1902|     10|    if (inet_pton4(address, &addr4) == 1) {
  ------------------
  |  Branch (1902:9): [True: 10, False: 0]
  ------------------
 1903|     10|        to->family = net_family_ipv4();
 1904|     10|        get_ip4(&to->ip.v4, &addr4);
 1905|     10|        return true;
 1906|     10|    }
 1907|       |
 1908|      0|    struct in6_addr addr6;
 1909|       |
 1910|      0|    if (inet_pton6(address, &addr6) == 1) {
  ------------------
  |  Branch (1910:9): [True: 0, False: 0]
  ------------------
 1911|      0|        to->family = net_family_ipv6();
 1912|      0|        get_ip6(&to->ip.v6, &addr6);
 1913|      0|        return true;
 1914|      0|    }
 1915|       |
 1916|      0|    return false;
 1917|      0|}
addr_resolve_or_parse_ip:
 2031|     10|{
 2032|     10|    if (dns_enabled && addr_resolve(ns, mem, address, to, extra)) {
  ------------------
  |  Branch (2032:9): [True: 10, False: 0]
  |  Branch (2032:24): [True: 0, False: 10]
  ------------------
 2033|      0|        return true;
 2034|      0|    }
 2035|       |
 2036|     10|    return addr_parse_ip(address, to);
 2037|     10|}
net_socket:
 2252|     10|{
 2253|     10|    const int platform_domain = make_family(domain);
 2254|     10|    const int platform_type = make_socktype(type);
 2255|     10|    const int platform_prot = make_proto(protocol);
 2256|     10|    return ns->funcs->socket(ns->obj, platform_domain, platform_type, platform_prot);
 2257|     10|}
net_htons:
 2271|     20|{
 2272|     20|    return htons(hostshort);
 2273|     20|}
net_error:
 2356|     10|{
 2357|       |#ifdef OS_WIN32
 2358|       |    return WSAGetLastError();
 2359|       |#else
 2360|     10|    return errno;
 2361|     10|#endif /* OS_WIN32 */
 2362|     10|}
network.c:net_setsockopt:
  733|     40|{
  734|     40|    return ns->funcs->setsockopt(ns->obj, sock, level, optname, optval, optlen);
  735|     40|}
network.c:net_getsockopt:
  739|     10|{
  740|     10|    return ns->funcs->getsockopt(ns->obj, sock, level, optname, optval, optlen);
  741|     10|}
network.c:fill_addr6:
  333|     10|{
  334|     10|    memcpy(addr->s6_addr, ip->uint8, sizeof(ip->uint8));
  335|     10|}
network.c:net_bind:
  954|     10|{
  955|     10|    return ns->funcs->bind(ns->obj, sock, addr);
  956|     10|}
network.c:make_family:
  264|     10|{
  265|     10|    switch (tox_family.value) {
  266|      0|        case TOX_AF_INET:
  ------------------
  |  |  168|      0|#define TOX_AF_INET 2
  ------------------
  |  Branch (266:9): [True: 0, False: 10]
  ------------------
  267|      0|        case TCP_INET:
  ------------------
  |  |  181|      0|#define TCP_INET (TOX_AF_INET6 + 2)
  |  |  ------------------
  |  |  |  |  169|      0|#define TOX_AF_INET6 10
  |  |  ------------------
  ------------------
  |  Branch (267:9): [True: 0, False: 10]
  ------------------
  268|      0|            return AF_INET;
  269|       |
  270|     10|        case TOX_AF_INET6:
  ------------------
  |  |  169|     10|#define TOX_AF_INET6 10
  ------------------
  |  Branch (270:9): [True: 10, False: 0]
  ------------------
  271|     10|        case TCP_INET6:
  ------------------
  |  |  182|     10|#define TCP_INET6 (TOX_AF_INET6 + 3)
  |  |  ------------------
  |  |  |  |  169|     10|#define TOX_AF_INET6 10
  |  |  ------------------
  ------------------
  |  Branch (271:9): [True: 0, False: 10]
  ------------------
  272|     10|            return AF_INET6;
  273|       |
  274|      0|        case TOX_AF_UNSPEC:
  ------------------
  |  |  167|      0|#define TOX_AF_UNSPEC 0
  ------------------
  |  Branch (274:9): [True: 0, False: 10]
  ------------------
  275|      0|            return AF_UNSPEC;
  276|       |
  277|      0|        default:
  ------------------
  |  Branch (277:9): [True: 0, False: 10]
  ------------------
  278|      0|            return tox_family.value;
  279|     10|    }
  280|     10|}
network.c:inet_pton4:
  135|     10|{
  136|     10|    return inet_pton(AF_INET, addr_string, addrbuf);
  137|     10|}
network.c:get_ip4:
  311|     10|{
  312|     10|    static_assert(sizeof(result->uint32) == sizeof(addr->s_addr),
  313|     10|                  "Tox and operating system don't agree on size of IPv4 addresses");
  314|     10|    result->uint32 = addr->s_addr;
  315|     10|}
network.c:addr_resolve:
 1942|     10|{
 1943|     10|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
 1944|     10|    if ((true)) {
  ------------------
  |  Branch (1944:9): [Folded - Ignored]
  ------------------
 1945|     10|        return false;
 1946|     10|    }
 1947|      0|#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */
 1948|       |
 1949|      0|    if (address == nullptr || to == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
                  if (address == nullptr || to == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (1949:9): [True: 0, False: 0]
  |  Branch (1949:31): [True: 0, False: 0]
  ------------------
 1950|      0|        return false;
 1951|      0|    }
 1952|       |
 1953|      0|    const Family tox_family = to->family;
 1954|      0|    const int family = make_family(tox_family);
 1955|       |
 1956|      0|    Network_Addr *addrs = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1957|      0|    const int rc = ns->funcs->getaddrinfo(ns->obj, mem, address, family, 0, &addrs);
 1958|       |
 1959|       |    // Lookup failed / empty.
 1960|      0|    if (rc <= 0) {
  ------------------
  |  Branch (1960:9): [True: 0, False: 0]
  ------------------
 1961|      0|        return false;
 1962|      0|    }
 1963|       |
 1964|      0|    assert(addrs != nullptr);
 1965|       |
 1966|      0|    IP ip4;
 1967|      0|    ip_init(&ip4, false); // ipv6enabled = false
 1968|      0|    IP ip6;
 1969|      0|    ip_init(&ip6, true); // ipv6enabled = true
 1970|       |
 1971|      0|    int result = 0;
 1972|      0|    bool done = false;
 1973|       |
 1974|      0|    for (int i = 0; i < rc && !done; ++i) {
  ------------------
  |  Branch (1974:21): [True: 0, False: 0]
  |  Branch (1974:31): [True: 0, False: 0]
  ------------------
 1975|      0|        switch (addrs[i].addr.ss_family) {
  ------------------
  |  Branch (1975:17): [True: 0, False: 0]
  ------------------
 1976|      0|            case AF_INET: {
  ------------------
  |  Branch (1976:13): [True: 0, False: 0]
  ------------------
 1977|      0|                if (addrs[i].addr.ss_family == family) { /* AF_INET requested, done */
  ------------------
  |  Branch (1977:21): [True: 0, False: 0]
  ------------------
 1978|      0|                    const struct sockaddr_in *addr = (const struct sockaddr_in *)(const void *)&addrs[i].addr;
 1979|      0|                    get_ip4(&to->ip.v4, &addr->sin_addr);
 1980|      0|                    result = TOX_ADDR_RESOLVE_INET;
  ------------------
  |  | 1920|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
 1981|      0|                    done = true;
 1982|      0|                } else if ((result & TOX_ADDR_RESOLVE_INET) == 0) { /* AF_UNSPEC requested, store away */
  ------------------
  |  | 1920|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
  |  Branch (1982:28): [True: 0, False: 0]
  ------------------
 1983|      0|                    const struct sockaddr_in *addr = (const struct sockaddr_in *)(const void *)&addrs[i].addr;
 1984|      0|                    get_ip4(&ip4.ip.v4, &addr->sin_addr);
 1985|      0|                    result |= TOX_ADDR_RESOLVE_INET;
  ------------------
  |  | 1920|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
 1986|      0|                }
 1987|       |
 1988|      0|                break; /* switch */
 1989|      0|            }
 1990|       |
 1991|      0|            case AF_INET6: {
  ------------------
  |  Branch (1991:13): [True: 0, False: 0]
  ------------------
 1992|      0|                if (addrs[i].addr.ss_family == family) { /* AF_INET6 requested, done */
  ------------------
  |  Branch (1992:21): [True: 0, False: 0]
  ------------------
 1993|      0|                    if (addrs[i].size == sizeof(struct sockaddr_in6)) {
  ------------------
  |  Branch (1993:25): [True: 0, False: 0]
  ------------------
 1994|      0|                        const struct sockaddr_in6 *addr = (const struct sockaddr_in6 *)(void *)&addrs[i].addr;
 1995|      0|                        get_ip6(&to->ip.v6, &addr->sin6_addr);
 1996|      0|                        result = TOX_ADDR_RESOLVE_INET6;
  ------------------
  |  | 1921|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
 1997|      0|                        done = true;
 1998|      0|                    }
 1999|      0|                } else if ((result & TOX_ADDR_RESOLVE_INET6) == 0) { /* AF_UNSPEC requested, store away */
  ------------------
  |  | 1921|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
  |  Branch (1999:28): [True: 0, False: 0]
  ------------------
 2000|      0|                    if (addrs[i].size == sizeof(struct sockaddr_in6)) {
  ------------------
  |  Branch (2000:25): [True: 0, False: 0]
  ------------------
 2001|      0|                        const struct sockaddr_in6 *addr = (const struct sockaddr_in6 *)(void *)&addrs[i].addr;
 2002|      0|                        get_ip6(&ip6.ip.v6, &addr->sin6_addr);
 2003|      0|                        result |= TOX_ADDR_RESOLVE_INET6;
  ------------------
  |  | 1921|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
 2004|      0|                    }
 2005|      0|                }
 2006|       |
 2007|      0|                break; /* switch */
 2008|      0|            }
 2009|      0|        }
 2010|      0|    }
 2011|       |
 2012|      0|    if (family == AF_UNSPEC) {
  ------------------
  |  Branch (2012:9): [True: 0, False: 0]
  ------------------
 2013|      0|        if ((result & TOX_ADDR_RESOLVE_INET6) != 0) {
  ------------------
  |  | 1921|      0|#define TOX_ADDR_RESOLVE_INET6 2
  ------------------
  |  Branch (2013:13): [True: 0, False: 0]
  ------------------
 2014|      0|            ip_copy(to, &ip6);
 2015|       |
 2016|      0|            if ((result & TOX_ADDR_RESOLVE_INET) != 0 && (extra != nullptr)) {
  ------------------
  |  | 1920|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
                          if ((result & TOX_ADDR_RESOLVE_INET) != 0 && (extra != nullptr)) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (2016:17): [True: 0, False: 0]
  |  Branch (2016:58): [True: 0, False: 0]
  ------------------
 2017|      0|                ip_copy(extra, &ip4);
 2018|      0|            }
 2019|      0|        } else if ((result & TOX_ADDR_RESOLVE_INET) != 0) {
  ------------------
  |  | 1920|      0|#define TOX_ADDR_RESOLVE_INET  1
  ------------------
  |  Branch (2019:20): [True: 0, False: 0]
  ------------------
 2020|      0|            ip_copy(to, &ip4);
 2021|      0|        } else {
 2022|      0|            result = 0;
 2023|      0|        }
 2024|      0|    }
 2025|       |
 2026|      0|    ns->funcs->freeaddrinfo(ns->obj, mem, addrs);
 2027|      0|    return result != 0;
 2028|      0|}
network.c:make_socktype:
  250|     10|{
  251|     10|    switch (type) {
  252|      0|        case TOX_SOCK_STREAM:
  ------------------
  |  |  173|      0|#define TOX_SOCK_STREAM 1
  ------------------
  |  Branch (252:9): [True: 0, False: 10]
  ------------------
  253|      0|            return SOCK_STREAM;
  254|       |
  255|     10|        case TOX_SOCK_DGRAM:
  ------------------
  |  |  174|     10|#define TOX_SOCK_DGRAM 2
  ------------------
  |  Branch (255:9): [True: 10, False: 0]
  ------------------
  256|     10|            return SOCK_DGRAM;
  257|       |
  258|      0|        default:
  ------------------
  |  Branch (258:9): [True: 0, False: 10]
  ------------------
  259|      0|            return type;
  260|     10|    }
  261|     10|}
network.c:make_proto:
  236|     10|{
  237|     10|    switch (proto) {
  238|      0|        case TOX_PROTO_TCP:
  ------------------
  |  |  176|      0|#define TOX_PROTO_TCP 1
  ------------------
  |  Branch (238:9): [True: 0, False: 10]
  ------------------
  239|      0|            return IPPROTO_TCP;
  240|       |
  241|     10|        case TOX_PROTO_UDP:
  ------------------
  |  |  177|     10|#define TOX_PROTO_UDP 2
  ------------------
  |  Branch (241:9): [True: 10, False: 0]
  ------------------
  242|     10|            return IPPROTO_UDP;
  243|       |
  244|      0|        default:
  ------------------
  |  Branch (244:9): [True: 0, False: 10]
  ------------------
  245|      0|            return proto;
  246|     10|    }
  247|     10|}

ping_new:
  336|     17|{
  337|     17|    Ping *ping = (Ping *)mem_alloc(mem, sizeof(Ping));
  338|       |
  339|     17|    if (ping == nullptr) {
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
  |  Branch (339:9): [True: 1, False: 16]
  ------------------
  340|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  341|      1|    }
  342|       |
  343|     16|    ping->ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   23|     16|#define PING_NUM_MAX 512
  ------------------
                  ping->ping_array = ping_array_new(mem, PING_NUM_MAX, PING_TIMEOUT);
  ------------------
  |  |   43|     16|#define PING_TIMEOUT 5
  ------------------
  344|       |
  345|     16|    if (ping->ping_array == nullptr) {
  ------------------
  |  |   63|     16|#define nullptr NULL
  ------------------
  |  Branch (345:9): [True: 4, False: 12]
  ------------------
  346|      4|        mem_delete(mem, ping);
  347|      4|        return nullptr;
  ------------------
  |  |   63|      4|#define nullptr NULL
  ------------------
  348|      4|    }
  349|       |
  350|     12|    ping->mono_time = mono_time;
  351|     12|    ping->rng = rng;
  352|     12|    ping->mem = mem;
  353|     12|    ping->dht = dht;
  354|     12|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, &handle_ping_request, dht);
  355|     12|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, &handle_ping_response, dht);
  356|       |
  357|     12|    return ping;
  358|     16|}
ping_kill:
  361|     17|{
  362|     17|    if (ping == nullptr) {
  ------------------
  |  |   63|     17|#define nullptr NULL
  ------------------
  |  Branch (362:9): [True: 5, False: 12]
  ------------------
  363|      5|        return;
  364|      5|    }
  365|       |
  366|     12|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
  367|     12|    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
                  networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, nullptr, nullptr);
  ------------------
  |  |   63|     12|#define nullptr NULL
  ------------------
  368|     12|    ping_array_kill(ping->ping_array);
  369|       |
  370|     12|    mem_delete(mem, ping);
  371|     12|}

ping_array_new:
   37|     27|{
   38|     27|    if (size == 0 || timeout == 0) {
  ------------------
  |  Branch (38:9): [True: 0, False: 27]
  |  Branch (38:22): [True: 0, False: 27]
  ------------------
   39|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   40|      0|    }
   41|       |
   42|     27|    if ((size & (size - 1)) != 0) {
  ------------------
  |  Branch (42:9): [True: 0, False: 27]
  ------------------
   43|       |        // Not a power of 2.
   44|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   45|      0|    }
   46|       |
   47|     27|    Ping_Array *const empty_array = (Ping_Array *)mem_alloc(mem, sizeof(Ping_Array));
   48|       |
   49|     27|    if (empty_array == nullptr) {
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  |  Branch (49:9): [True: 3, False: 24]
  ------------------
   50|      3|        return nullptr;
  ------------------
  |  |   63|      3|#define nullptr NULL
  ------------------
   51|      3|    }
   52|       |
   53|     24|    Ping_Array_Entry *entries = (Ping_Array_Entry *)mem_valloc(mem, size, sizeof(Ping_Array_Entry));
   54|       |
   55|     24|    if (entries == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (55:9): [True: 1, False: 23]
  ------------------
   56|      1|        mem_delete(mem, empty_array);
   57|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
   58|      1|    }
   59|       |
   60|     23|    empty_array->mem = mem;
   61|     23|    empty_array->entries = entries;
   62|     23|    empty_array->last_deleted = 0;
   63|     23|    empty_array->last_added = 0;
   64|     23|    empty_array->total_size = size;
   65|     23|    empty_array->timeout = timeout;
   66|     23|    return empty_array;
   67|     24|}
ping_array_kill:
   78|     29|{
   79|     29|    if (array == nullptr) {
  ------------------
  |  |   63|     29|#define nullptr NULL
  ------------------
  |  Branch (79:9): [True: 6, False: 23]
  ------------------
   80|      6|        return;
   81|      6|    }
   82|       |
   83|     23|    while (array->last_deleted != array->last_added) {
  ------------------
  |  Branch (83:12): [True: 0, False: 23]
  ------------------
   84|      0|        const uint32_t index = array->last_deleted % array->total_size;
   85|      0|        clear_entry(array, index);
   86|      0|        ++array->last_deleted;
   87|      0|    }
   88|       |
   89|     23|    mem_delete(array->mem, array->entries);
   90|     23|    mem_delete(array->mem, array);
   91|     23|}

shared_key_cache_new:
   52|     24|{
   53|     24|    if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|     48|#define nullptr NULL
  ------------------
                  if (mono_time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
  ------------------
  |  |   63|     48|#define nullptr NULL
  ------------------
  |  Branch (53:9): [True: 0, False: 24]
  |  Branch (53:33): [True: 0, False: 24]
  |  Branch (53:63): [True: 0, False: 24]
  |  Branch (53:79): [True: 0, False: 24]
  ------------------
   54|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   55|      0|    }
   56|       |
   57|       |    // Time must not be zero, since we use that as special value for empty slots
   58|     24|    if (mono_time_get(mono_time) == 0) {
  ------------------
  |  Branch (58:9): [True: 0, False: 24]
  ------------------
   59|       |        // Fail loudly in debug environments
   60|      0|        LOGGER_FATAL(log, "time must not be zero (mono_time not initialised?)");
  ------------------
  |  |   90|      0|    do {                                \
  |  |   91|      0|        LOGGER_ERROR(log, __VA_ARGS__); \
  |  |  ------------------
  |  |  |  |   87|      0|#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|    do {                                                                         \
  |  |  |  |  |  |   77|      0|        if (level >= MIN_LOGGER_LEVEL) {                                         \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   22|      0|#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (77:13): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
  |  |  |  |  |  |   79|      0|        }                                                                        \
  |  |  |  |  |  |   80|      0|    } while (0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (80:14): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   92|      0|        logger_abort();                 \
  |  |   93|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (93:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   61|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   62|      0|    }
   63|       |
   64|     24|    Shared_Key_Cache *res = (Shared_Key_Cache *)mem_alloc(mem, sizeof(Shared_Key_Cache));
   65|     24|    if (res == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (65:9): [True: 1, False: 23]
  ------------------
   66|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
   67|      1|    }
   68|       |
   69|     23|    res->self_secret_key = self_secret_key;
   70|     23|    res->mono_time = mono_time;
   71|     23|    res->mem = mem;
   72|     23|    res->log = log;
   73|     23|    res->keys_per_slot = keys_per_slot;
   74|       |
   75|       |    // We take one byte from the public key for each bucket and store keys_per_slot elements there
   76|     23|    const size_t cache_size = 256 * keys_per_slot;
   77|     23|    Shared_Key *keys = (Shared_Key *)mem_valloc(mem, cache_size, sizeof(Shared_Key));
   78|       |
   79|     23|    if (keys == nullptr) {
  ------------------
  |  |   63|     23|#define nullptr NULL
  ------------------
  |  Branch (79:9): [True: 0, False: 23]
  ------------------
   80|      0|        mem_delete(mem, res);
   81|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   82|      0|    }
   83|       |
   84|     23|    crypto_memlock(keys, cache_size * sizeof(Shared_Key));
   85|       |
   86|     23|    res->keys = keys;
   87|       |
   88|     23|    return res;
   89|     23|}
shared_key_cache_free:
   92|     34|{
   93|     34|    if (cache == nullptr) {
  ------------------
  |  |   63|     34|#define nullptr NULL
  ------------------
  |  Branch (93:9): [True: 11, False: 23]
  ------------------
   94|     11|        return;
   95|     11|    }
   96|       |
   97|     23|    const size_t cache_size = 256 * cache->keys_per_slot;
   98|       |    // Don't leave key material in memory
   99|     23|    crypto_memzero(cache->keys, cache_size * sizeof(Shared_Key));
  100|     23|    crypto_memunlock(cache->keys, cache_size * sizeof(Shared_Key));
  101|     23|    mem_delete(cache->mem, cache->keys);
  102|     23|    mem_delete(cache->mem, cache);
  103|     23|}

tox_new_testing:
 1036|     27|{
 1037|     27|    if (testing == nullptr) {
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  |  Branch (1037:9): [True: 0, False: 27]
  ------------------
 1038|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1039|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1040|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1041|      0|    }
 1042|       |
 1043|     27|    if (testing->operating_system == nullptr) {
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  |  Branch (1043:9): [True: 0, False: 27]
  ------------------
 1044|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1045|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1046|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1047|      0|    }
 1048|       |
 1049|     27|    const Tox_System *sys = testing->operating_system;
 1050|       |
 1051|     27|    if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|     54|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|     54|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  |  Branch (1051:9): [True: 0, False: 27]
  |  Branch (1051:32): [True: 0, False: 27]
  |  Branch (1051:54): [True: 0, False: 27]
  ------------------
 1052|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1053|      0|        SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_NULL);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1054|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
 1055|      0|    }
 1056|       |
 1057|     27|    SET_ERROR_PARAMETER(testing_error, TOX_ERR_NEW_TESTING_OK);
  ------------------
  |  |   44|     27|    do {                              \
  |  |   45|     27|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|     54|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 27, False: 0]
  |  |  ------------------
  |  |   46|     27|            *param = x;               \
  |  |   47|     27|        }                             \
  |  |   48|     27|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1058|     27|    return tox_new_system(options, error, sys);
 1059|     27|}
tox.c:tox_new_system:
  721|     27|{
  722|     27|    struct Tox_Options *default_options = nullptr;
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  723|       |
  724|     27|    if (options == nullptr) {
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  |  Branch (724:9): [True: 0, False: 27]
  ------------------
  725|      0|        Tox_Err_Options_New err;
  726|      0|        default_options = tox_options_new(&err);
  727|       |
  728|      0|        switch (err) {
  ------------------
  |  Branch (728:17): [True: 0, False: 0]
  ------------------
  729|      0|            case TOX_ERR_OPTIONS_NEW_OK: {
  ------------------
  |  Branch (729:13): [True: 0, False: 0]
  ------------------
  730|      0|                assert(default_options != nullptr);
  731|      0|                break;
  732|      0|            }
  733|       |
  734|      0|            case TOX_ERR_OPTIONS_NEW_MALLOC: {
  ------------------
  |  Branch (734:13): [True: 0, False: 0]
  ------------------
  735|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  736|      0|                return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  737|      0|            }
  738|      0|        }
  739|      0|    }
  740|       |
  741|     27|    const struct Tox_Options *const opts = options != nullptr ? options : default_options;
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  |  Branch (741:44): [True: 27, False: 0]
  ------------------
  742|     27|    assert(opts != nullptr);
  743|       |
  744|     27|    const Tox_System default_system = tox_default_system();
  745|       |
  746|     27|    if (sys == nullptr) {
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  |  Branch (746:9): [True: 0, False: 27]
  ------------------
  747|      0|        sys = &default_system;
  748|      0|    }
  749|       |
  750|     27|    if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|     54|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|     54|#define nullptr NULL
  ------------------
                  if (sys->rng == nullptr || sys->ns == nullptr || sys->mem == nullptr) {
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  |  Branch (750:9): [True: 0, False: 27]
  |  Branch (750:32): [True: 0, False: 27]
  |  Branch (750:54): [True: 0, False: 27]
  ------------------
  751|       |        // TODO(iphydf): Not quite right, but similar.
  752|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  753|      0|        tox_options_free(default_options);
  754|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  755|      0|    }
  756|       |
  757|     27|    Messenger_Options m_options = {false};
  758|       |
  759|     27|    m_options.dns_enabled = !tox_options_get_experimental_disable_dns(opts);
  760|       |
  761|     27|    bool load_savedata_sk = false;
  762|     27|    bool load_savedata_tox = false;
  763|       |
  764|     27|    if (tox_options_get_savedata_type(opts) != TOX_SAVEDATA_TYPE_NONE) {
  ------------------
  |  Branch (764:9): [True: 0, False: 27]
  ------------------
  765|      0|        if (tox_options_get_savedata_data(opts) == nullptr || tox_options_get_savedata_length(opts) == 0) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (765:13): [True: 0, False: 0]
  |  Branch (765:63): [True: 0, False: 0]
  ------------------
  766|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  767|      0|            tox_options_free(default_options);
  768|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  769|      0|        }
  770|      0|    }
  771|       |
  772|     27|    if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_SECRET_KEY) {
  ------------------
  |  Branch (772:9): [True: 0, False: 27]
  ------------------
  773|      0|        if (tox_options_get_savedata_length(opts) != TOX_SECRET_KEY_SIZE) {
  ------------------
  |  |  219|      0|#define TOX_SECRET_KEY_SIZE            32
  ------------------
  |  Branch (773:13): [True: 0, False: 0]
  ------------------
  774|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  775|      0|            tox_options_free(default_options);
  776|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  777|      0|        }
  778|       |
  779|      0|        load_savedata_sk = true;
  780|     27|    } else if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_TOX_SAVE) {
  ------------------
  |  Branch (780:16): [True: 0, False: 27]
  ------------------
  781|      0|        if (tox_options_get_savedata_length(opts) < TOX_ENC_SAVE_MAGIC_LENGTH) {
  ------------------
  |  |   10|      0|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (781:13): [True: 0, False: 0]
  ------------------
  782|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  783|      0|            tox_options_free(default_options);
  784|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  785|      0|        }
  786|       |
  787|      0|        if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |    9|      0|#define TOX_ENC_SAVE_MAGIC_NUMBER ((const uint8_t *)"toxEsave")
  ------------------
                      if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
  ------------------
  |  |   10|      0|#define TOX_ENC_SAVE_MAGIC_LENGTH 8
  ------------------
  |  Branch (787:13): [True: 0, False: 0]
  ------------------
  788|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_ENCRYPTED);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  789|      0|            tox_options_free(default_options);
  790|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  791|      0|        }
  792|       |
  793|      0|        load_savedata_tox = true;
  794|      0|    }
  795|       |
  796|     27|    m_options.ipv6enabled = tox_options_get_ipv6_enabled(opts);
  797|     27|    m_options.udp_disabled = !tox_options_get_udp_enabled(opts);
  798|     27|    m_options.port_range[0] = tox_options_get_start_port(opts);
  799|     27|    m_options.port_range[1] = tox_options_get_end_port(opts);
  800|     27|    m_options.tcp_server_port = tox_options_get_tcp_port(opts);
  801|     27|    m_options.hole_punching_enabled = tox_options_get_hole_punching_enabled(opts);
  802|     27|    m_options.local_discovery_enabled = tox_options_get_local_discovery_enabled(opts);
  803|     27|    m_options.dht_announcements_enabled = tox_options_get_dht_announcements_enabled(opts);
  804|     27|    m_options.groups_persistence_enabled = tox_options_get_experimental_groups_persistence(opts);
  805|       |
  806|     27|    if (m_options.udp_disabled) {
  ------------------
  |  Branch (806:9): [True: 0, False: 27]
  ------------------
  807|      0|        m_options.local_discovery_enabled = false;
  808|      0|    }
  809|       |
  810|     27|    Tox *tox = (Tox *)mem_alloc(sys->mem, sizeof(Tox));
  811|       |
  812|     27|    if (tox == nullptr) {
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
  |  Branch (812:9): [True: 1, False: 26]
  ------------------
  813|      1|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      1|    do {                              \
  |  |   45|      1|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      2|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 1, False: 0]
  |  |  ------------------
  |  |   46|      1|            *param = x;               \
  |  |   47|      1|        }                             \
  |  |   48|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  814|      1|        tox_options_free(default_options);
  815|      1|        return nullptr;
  ------------------
  |  |   63|      1|#define nullptr NULL
  ------------------
  816|      1|    }
  817|       |
  818|     26|    tox->log_callback = tox_options_get_log_callback(opts);
  819|     26|    m_options.log_callback = tox_log_handler;
  820|     26|    m_options.log_context = tox;
  821|     26|    m_options.log_user_data = tox_options_get_log_user_data(opts);
  822|       |
  823|     26|    switch (tox_options_get_proxy_type(opts)) {
  824|      4|        case TOX_PROXY_TYPE_HTTP: {
  ------------------
  |  Branch (824:9): [True: 4, False: 22]
  ------------------
  825|      4|            m_options.proxy_info.proxy_type = TCP_PROXY_HTTP;
  826|      4|            break;
  827|      0|        }
  828|       |
  829|      6|        case TOX_PROXY_TYPE_SOCKS5: {
  ------------------
  |  Branch (829:9): [True: 6, False: 20]
  ------------------
  830|      6|            m_options.proxy_info.proxy_type = TCP_PROXY_SOCKS5;
  831|      6|            break;
  832|      0|        }
  833|       |
  834|     16|        case TOX_PROXY_TYPE_NONE: {
  ------------------
  |  Branch (834:9): [True: 16, False: 10]
  ------------------
  835|     16|            m_options.proxy_info.proxy_type = TCP_PROXY_NONE;
  836|     16|            break;
  837|      0|        }
  838|       |
  839|      0|        default: {
  ------------------
  |  Branch (839:9): [True: 0, False: 26]
  ------------------
  840|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_TYPE);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  841|      0|            mem_delete(sys->mem, tox);
  842|      0|            tox_options_free(default_options);
  843|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  844|      0|        }
  845|     26|    }
  846|       |
  847|     26|    tox->sys = *sys;
  848|       |
  849|     26|    if (m_options.proxy_info.proxy_type != TCP_PROXY_NONE) {
  ------------------
  |  Branch (849:9): [True: 10, False: 16]
  ------------------
  850|     10|        if (tox_options_get_proxy_port(opts) == 0) {
  ------------------
  |  Branch (850:13): [True: 0, False: 10]
  ------------------
  851|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_PORT);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  852|      0|            mem_delete(sys->mem, tox);
  853|      0|            tox_options_free(default_options);
  854|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  855|      0|        }
  856|       |
  857|     10|        ip_init(&m_options.proxy_info.ip_port.ip, m_options.ipv6enabled);
  858|       |
  859|     10|        if (m_options.ipv6enabled) {
  ------------------
  |  Branch (859:13): [True: 10, False: 0]
  ------------------
  860|     10|            m_options.proxy_info.ip_port.ip.family = net_family_unspec();
  861|     10|        }
  862|       |
  863|     10|        const char *const proxy_host = tox_options_get_proxy_host(opts);
  864|     10|        const bool dns_enabled = !tox_options_get_experimental_disable_dns(opts);
  865|       |
  866|     10|        if (proxy_host == nullptr
  ------------------
  |  |   63|     20|#define nullptr NULL
  ------------------
  |  Branch (866:13): [True: 0, False: 10]
  ------------------
  867|     10|                || !addr_resolve_or_parse_ip(tox->sys.ns, tox->sys.mem, proxy_host, &m_options.proxy_info.ip_port.ip, nullptr, dns_enabled)) {
  ------------------
  |  |   63|     10|#define nullptr NULL
  ------------------
  |  Branch (867:20): [True: 0, False: 10]
  ------------------
  868|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_HOST);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  869|       |            // TODO(irungentoo): TOX_ERR_NEW_PROXY_NOT_FOUND if domain.
  870|      0|            mem_delete(sys->mem, tox);
  871|      0|            tox_options_free(default_options);
  872|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  873|      0|        }
  874|       |
  875|     10|        m_options.proxy_info.ip_port.port = net_htons(tox_options_get_proxy_port(opts));
  876|     10|    }
  877|       |
  878|     26|    tox->mono_time = mono_time_new(tox->sys.mem, sys->mono_time_callback, sys->mono_time_user_data);
  879|       |
  880|     26|    if (tox->mono_time == nullptr) {
  ------------------
  |  |   63|     26|#define nullptr NULL
  ------------------
  |  Branch (880:9): [True: 2, False: 24]
  ------------------
  881|      2|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      2|    do {                              \
  |  |   45|      2|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      4|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 2, False: 0]
  |  |  ------------------
  |  |   46|      2|            *param = x;               \
  |  |   47|      2|        }                             \
  |  |   48|      2|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  882|      2|        mem_delete(sys->mem, tox);
  883|      2|        tox_options_free(default_options);
  884|      2|        return nullptr;
  ------------------
  |  |   63|      2|#define nullptr NULL
  ------------------
  885|      2|    }
  886|       |
  887|     24|    if (tox_options_get_experimental_thread_safety(opts)) {
  ------------------
  |  Branch (887:9): [True: 0, False: 24]
  ------------------
  888|      0|        pthread_mutex_t *mutex = (pthread_mutex_t *)mem_alloc(sys->mem, sizeof(pthread_mutex_t));
  889|       |
  890|      0|        if (mutex == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (890:13): [True: 0, False: 0]
  ------------------
  891|      0|            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  892|      0|            mem_delete(sys->mem, tox);
  893|      0|            tox_options_free(default_options);
  894|      0|            return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  895|      0|        }
  896|       |
  897|      0|        pthread_mutex_init(mutex, nullptr);
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  898|       |
  899|      0|        tox->mutex = mutex;
  900|     24|    } else {
  901|     24|        tox->mutex = nullptr;
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  902|     24|    }
  903|       |
  904|     24|    tox_lock(tox);
  905|       |
  906|     24|    Messenger_Error m_error;
  907|     24|    tox->m = new_messenger(tox->mono_time, tox->sys.mem, tox->sys.rng, tox->sys.ns, &m_options, &m_error);
  908|       |
  909|     24|    if (tox->m == nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (909:9): [True: 24, False: 0]
  ------------------
  910|     24|        switch (m_error) {
  ------------------
  |  Branch (910:17): [True: 0, False: 24]
  ------------------
  911|      0|            case MESSENGER_ERROR_PORT:
  ------------------
  |  Branch (911:13): [True: 0, False: 24]
  ------------------
  912|      0|            case MESSENGER_ERROR_TCP_SERVER: {
  ------------------
  |  Branch (912:13): [True: 0, False: 24]
  ------------------
  913|      0|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PORT_ALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  914|      0|                break;
  915|      0|            }
  916|     24|            case MESSENGER_ERROR_OTHER:
  ------------------
  |  Branch (916:13): [True: 24, False: 0]
  ------------------
  917|     24|            case MESSENGER_ERROR_NONE: {
  ------------------
  |  Branch (917:13): [True: 0, False: 24]
  ------------------
  918|     24|                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|     24|    do {                              \
  |  |   45|     24|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|     48|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 24, False: 0]
  |  |  ------------------
  |  |   46|     24|            *param = x;               \
  |  |   47|     24|        }                             \
  |  |   48|     24|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  919|     24|                break;
  920|     24|            }
  921|     24|        }
  922|       |
  923|     24|        mono_time_free(tox->sys.mem, tox->mono_time);
  924|     24|        tox_unlock(tox);
  925|       |
  926|     24|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (926:13): [True: 0, False: 24]
  ------------------
  927|      0|            pthread_mutex_destroy(tox->mutex);
  928|      0|        }
  929|       |
  930|     24|        mem_delete(sys->mem, tox->mutex);
  931|     24|        mem_delete(sys->mem, tox);
  932|     24|        tox_options_free(default_options);
  933|     24|        return nullptr;
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  934|     24|    }
  935|       |
  936|      0|    tox->m->conferences_object = new_groupchats(tox->mono_time, sys->mem, tox->m);
  937|       |
  938|      0|    if (tox->m->conferences_object == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (938:9): [True: 0, False: 0]
  ------------------
  939|      0|        kill_messenger(tox->m);
  940|       |
  941|      0|        mono_time_free(tox->sys.mem, tox->mono_time);
  942|      0|        tox_unlock(tox);
  943|       |
  944|      0|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (944:13): [True: 0, False: 0]
  ------------------
  945|      0|            pthread_mutex_destroy(tox->mutex);
  946|      0|        }
  947|       |
  948|      0|        mem_delete(sys->mem, tox->mutex);
  949|      0|        mem_delete(sys->mem, tox);
  950|       |
  951|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  952|      0|        tox_options_free(default_options);
  953|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  954|      0|    }
  955|       |
  956|      0|    if (load_savedata_tox
  ------------------
  |  Branch (956:9): [True: 0, False: 0]
  ------------------
  957|      0|            && tox_load(tox, tox_options_get_savedata_data(opts), tox_options_get_savedata_length(opts)) == -1) {
  ------------------
  |  Branch (957:16): [True: 0, False: 0]
  ------------------
  958|      0|        kill_groupchats(tox->m->conferences_object);
  959|      0|        kill_messenger(tox->m);
  960|       |
  961|      0|        mono_time_free(tox->sys.mem, tox->mono_time);
  962|      0|        tox_unlock(tox);
  963|       |
  964|      0|        if (tox->mutex != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (964:13): [True: 0, False: 0]
  ------------------
  965|      0|            pthread_mutex_destroy(tox->mutex);
  966|      0|        }
  967|       |
  968|      0|        mem_delete(sys->mem, tox->mutex);
  969|      0|        mem_delete(sys->mem, tox);
  970|       |
  971|      0|        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  972|      0|        tox_options_free(default_options);
  973|      0|        return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  974|      0|    }
  975|       |
  976|      0|    if (load_savedata_sk) {
  ------------------
  |  Branch (976:9): [True: 0, False: 0]
  ------------------
  977|      0|        load_secret_key(tox->m->net_crypto, tox_options_get_savedata_data(opts));
  978|      0|    }
  979|       |
  980|      0|    m_callback_namechange(tox->m, tox_friend_name_handler);
  981|      0|    m_callback_core_connection(tox->m, tox_self_connection_status_handler);
  982|      0|    m_callback_statusmessage(tox->m, tox_friend_status_message_handler);
  983|      0|    m_callback_userstatus(tox->m, tox_friend_status_handler);
  984|      0|    m_callback_connectionstatus(tox->m, tox_friend_connection_status_handler);
  985|      0|    m_callback_typingchange(tox->m, tox_friend_typing_handler);
  986|      0|    m_callback_read_receipt(tox->m, tox_friend_read_receipt_handler);
  987|      0|    m_callback_friendrequest(tox->m, tox_friend_request_handler);
  988|      0|    m_callback_friendmessage(tox->m, tox_friend_message_handler);
  989|      0|    callback_file_control(tox->m, tox_file_recv_control_handler);
  990|      0|    callback_file_reqchunk(tox->m, tox_file_chunk_request_handler);
  991|      0|    callback_file_sendrequest(tox->m, tox_file_recv_handler);
  992|      0|    callback_file_data(tox->m, tox_file_recv_chunk_handler);
  993|      0|    dht_callback_nodes_response(tox->m->dht, tox_dht_nodes_response_handler);
  994|      0|    g_callback_group_invite(tox->m->conferences_object, tox_conference_invite_handler);
  995|      0|    g_callback_group_connected(tox->m->conferences_object, tox_conference_connected_handler);
  996|      0|    g_callback_group_message(tox->m->conferences_object, tox_conference_message_handler);
  997|      0|    g_callback_group_title(tox->m->conferences_object, tox_conference_title_handler);
  998|      0|    g_callback_peer_name(tox->m->conferences_object, tox_conference_peer_name_handler);
  999|      0|    g_callback_peer_list_changed(tox->m->conferences_object, tox_conference_peer_list_changed_handler);
 1000|      0|    custom_lossy_packet_registerhandler(tox->m, tox_friend_lossy_packet_handler);
 1001|      0|    custom_lossless_packet_registerhandler(tox->m, tox_friend_lossless_packet_handler);
 1002|       |
 1003|      0|    m_callback_group_invite(tox->m, tox_group_invite_handler);
 1004|      0|    gc_callback_message(tox->m, tox_group_message_handler);
 1005|      0|    gc_callback_private_message(tox->m, tox_group_private_message_handler);
 1006|      0|    gc_callback_custom_packet(tox->m, tox_group_custom_packet_handler);
 1007|      0|    gc_callback_custom_private_packet(tox->m, tox_group_custom_private_packet_handler);
 1008|      0|    gc_callback_moderation(tox->m, tox_group_moderation_handler);
 1009|      0|    gc_callback_nick_change(tox->m, tox_group_peer_name_handler);
 1010|      0|    gc_callback_status_change(tox->m, tox_group_peer_status_handler);
 1011|      0|    gc_callback_topic_change(tox->m, tox_group_topic_handler);
 1012|      0|    gc_callback_peer_limit(tox->m, tox_group_peer_limit_handler);
 1013|      0|    gc_callback_privacy_state(tox->m, tox_group_privacy_state_handler);
 1014|      0|    gc_callback_topic_lock(tox->m, tox_group_topic_lock_handler);
 1015|      0|    gc_callback_password(tox->m, tox_group_password_handler);
 1016|      0|    gc_callback_peer_join(tox->m, tox_group_peer_join_handler);
 1017|      0|    gc_callback_peer_exit(tox->m, tox_group_peer_exit_handler);
 1018|      0|    gc_callback_self_join(tox->m, tox_group_self_join_handler);
 1019|      0|    gc_callback_rejected(tox->m, tox_group_join_fail_handler);
 1020|      0|    gc_callback_voice_state(tox->m, tox_group_voice_state_handler);
 1021|       |
 1022|      0|    tox_unlock(tox);
 1023|       |
 1024|      0|    SET_ERROR_PARAMETER(error, TOX_ERR_NEW_OK);
  ------------------
  |  |   44|      0|    do {                              \
  |  |   45|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (45:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   46|      0|            *param = x;               \
  |  |   47|      0|        }                             \
  |  |   48|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (48:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1025|       |
 1026|      0|    tox_options_free(default_options);
 1027|      0|    return tox;
 1028|      0|}
tox.c:tox_log_handler:
   86|     28|{
   87|     28|    Tox *tox = (Tox *)context;
   88|     28|    assert(tox != nullptr);
   89|       |
   90|     28|    if (tox->log_callback != nullptr) {
  ------------------
  |  |   63|     28|#define nullptr NULL
  ------------------
  |  Branch (90:9): [True: 28, False: 0]
  ------------------
   91|     28|        tox->log_callback(tox, (Tox_Log_Level)level, file, line, func, message, userdata);
   92|     28|    }
   93|     28|}

tox_options_get_ipv6_enabled:
   22|     27|{
   23|     27|    return options->ipv6_enabled;
   24|     27|}
tox_options_set_ipv6_enabled:
   26|     31|{
   27|     31|    options->ipv6_enabled = ipv6_enabled;
   28|     31|}
tox_options_get_udp_enabled:
   30|     27|{
   31|     27|    return options->udp_enabled;
   32|     27|}
tox_options_set_udp_enabled:
   34|     31|{
   35|     31|    options->udp_enabled = udp_enabled;
   36|     31|}
tox_options_get_proxy_type:
   38|     26|{
   39|     26|    return options->proxy_type;
   40|     26|}
tox_options_set_proxy_type:
   42|     52|{
   43|     52|    options->proxy_type = proxy_type;
   44|     52|}
tox_options_get_proxy_host:
   46|     10|{
   47|     10|    return options->proxy_host;
   48|     10|}
tox_options_set_proxy_host:
   50|     75|{
   51|     75|    if (!options->experimental_owned_data) {
  ------------------
  |  Branch (51:9): [True: 75, False: 0]
  ------------------
   52|     75|        options->proxy_host = proxy_host;
   53|     75|        return true;
   54|     75|    }
   55|       |
   56|      0|    if (options->owned_proxy_host != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (56:9): [True: 0, False: 0]
  ------------------
   57|      0|        free(options->owned_proxy_host);
   58|      0|        options->owned_proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   59|      0|    }
   60|      0|    if (proxy_host == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (60:9): [True: 0, False: 0]
  ------------------
   61|      0|        options->proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   62|      0|        return true;
   63|      0|    }
   64|       |
   65|      0|    const size_t proxy_host_length = strlen(proxy_host) + 1;
   66|      0|    char *owned_ptr = (char *)malloc(proxy_host_length);
   67|      0|    if (owned_ptr == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (67:9): [True: 0, False: 0]
  ------------------
   68|      0|        options->proxy_host = proxy_host;
   69|      0|        options->owned_proxy_host = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
   70|      0|        return false;
   71|      0|    }
   72|       |
   73|      0|    memcpy(owned_ptr, proxy_host, proxy_host_length);
   74|      0|    options->proxy_host = owned_ptr;
   75|      0|    options->owned_proxy_host = owned_ptr;
   76|      0|    return true;
   77|      0|}
tox_options_get_proxy_port:
   79|     20|{
   80|     20|    return options->proxy_port;
   81|     20|}
tox_options_set_proxy_port:
   83|     13|{
   84|     13|    options->proxy_port = proxy_port;
   85|     13|}
tox_options_get_start_port:
   87|     27|{
   88|     27|    return options->start_port;
   89|     27|}
tox_options_get_end_port:
   95|     27|{
   96|     27|    return options->end_port;
   97|     27|}
tox_options_get_tcp_port:
  103|     27|{
  104|     27|    return options->tcp_port;
  105|     27|}
tox_options_set_tcp_port:
  107|     12|{
  108|     12|    options->tcp_port = tcp_port;
  109|     12|}
tox_options_get_hole_punching_enabled:
  111|     27|{
  112|     27|    return options->hole_punching_enabled;
  113|     27|}
tox_options_set_hole_punching_enabled:
  115|     31|{
  116|     31|    options->hole_punching_enabled = hole_punching_enabled;
  117|     31|}
tox_options_get_savedata_type:
  119|     81|{
  120|     81|    return options->savedata_type;
  121|     81|}
tox_options_get_log_callback:
  135|     26|{
  136|     26|    return options->log_callback;
  137|     26|}
tox_options_set_log_callback:
  139|     31|{
  140|     31|    options->log_callback = log_callback;
  141|     31|}
tox_options_get_log_user_data:
  143|     26|{
  144|     26|    return options->log_user_data;
  145|     26|}
tox_options_get_local_discovery_enabled:
  151|     27|{
  152|     27|    return options->local_discovery_enabled;
  153|     27|}
tox_options_set_local_discovery_enabled:
  155|     31|{
  156|     31|    options->local_discovery_enabled = local_discovery_enabled;
  157|     31|}
tox_options_get_dht_announcements_enabled:
  159|     27|{
  160|     27|    return options->dht_announcements_enabled;
  161|     27|}
tox_options_set_dht_announcements_enabled:
  163|     31|{
  164|     31|    options->dht_announcements_enabled = dht_announcements_enabled;
  165|     31|}
tox_options_get_experimental_thread_safety:
  167|     24|{
  168|     24|    return options->experimental_thread_safety;
  169|     24|}
tox_options_set_experimental_thread_safety:
  172|     31|{
  173|     31|    options->experimental_thread_safety = experimental_thread_safety;
  174|     31|}
tox_options_get_experimental_groups_persistence:
  176|     27|{
  177|     27|    return options->experimental_groups_persistence;
  178|     27|}
tox_options_set_experimental_groups_persistence:
  181|     31|{
  182|     31|    options->experimental_groups_persistence = experimental_groups_persistence;
  183|     31|}
tox_options_get_experimental_disable_dns:
  185|     37|{
  186|     37|    return options->experimental_disable_dns;
  187|     37|}
tox_options_set_experimental_disable_dns:
  189|     31|{
  190|     31|    options->experimental_disable_dns = experimental_disable_dns;
  191|     31|}
tox_options_set_experimental_owned_data:
  198|     31|{
  199|     31|    options->experimental_owned_data = experimental_owned_data;
  200|     31|}
tox_options_set_savedata_data:
  208|     62|{
  209|     62|    if (!options->experimental_owned_data) {
  ------------------
  |  Branch (209:9): [True: 62, False: 0]
  ------------------
  210|     62|        options->savedata_data = savedata_data;
  211|     62|        options->savedata_length = length;
  212|     62|        return true;
  213|     62|    }
  214|       |
  215|      0|    if (options->owned_savedata_data != nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (215:9): [True: 0, False: 0]
  ------------------
  216|      0|        free(options->owned_savedata_data);
  217|      0|        options->owned_savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  218|      0|    }
  219|      0|    if (savedata_data == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (219:9): [True: 0, False: 0]
  ------------------
  220|      0|        options->savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  221|      0|        options->savedata_length = 0;
  222|      0|        return true;
  223|      0|    }
  224|       |
  225|      0|    uint8_t *owned_ptr = (uint8_t *)malloc(length);
  226|      0|    if (owned_ptr == nullptr) {
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  |  Branch (226:9): [True: 0, False: 0]
  ------------------
  227|      0|        options->savedata_data = savedata_data;
  228|      0|        options->savedata_length = length;
  229|      0|        options->owned_savedata_data = nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  230|      0|        return false;
  231|      0|    }
  232|       |
  233|      0|    memcpy(owned_ptr, savedata_data, length);
  234|      0|    options->savedata_data = owned_ptr;
  235|      0|    options->savedata_length = length;
  236|      0|    options->owned_savedata_data = owned_ptr;
  237|      0|    return true;
  238|      0|}
tox_options_default:
  241|     31|{
  242|     31|    if (options != nullptr) {
  ------------------
  |  |   63|     31|#define nullptr NULL
  ------------------
  |  Branch (242:9): [True: 31, False: 0]
  ------------------
  243|       |        // Free any owned data.
  244|     31|        tox_options_set_proxy_host(options, nullptr);
  ------------------
  |  |   63|     31|#define nullptr NULL
  ------------------
  245|     31|        tox_options_set_savedata_data(options, nullptr, 0);
  ------------------
  |  |   63|     31|#define nullptr NULL
  ------------------
  246|       |
  247|       |        // Set the rest to default values.
  248|     31|        const Tox_Options default_options = {false};
  249|     31|        *options = default_options;
  250|     31|        tox_options_set_ipv6_enabled(options, true);
  251|     31|        tox_options_set_udp_enabled(options, true);
  252|     31|        tox_options_set_proxy_type(options, TOX_PROXY_TYPE_NONE);
  253|     31|        tox_options_set_hole_punching_enabled(options, true);
  254|     31|        tox_options_set_local_discovery_enabled(options, true);
  255|     31|        tox_options_set_dht_announcements_enabled(options, true);
  256|     31|        tox_options_set_experimental_thread_safety(options, false);
  257|     31|        tox_options_set_experimental_groups_persistence(options, false);
  258|     31|        tox_options_set_experimental_disable_dns(options, false);
  259|     31|        tox_options_set_experimental_owned_data(options, false);
  260|     31|    }
  261|     31|}
tox_options_new:
  264|     31|{
  265|     31|    Tox_Options *options = (Tox_Options *)calloc(1, sizeof(Tox_Options));
  266|       |
  267|     31|    if (options != nullptr) {
  ------------------
  |  |   63|     31|#define nullptr NULL
  ------------------
  |  Branch (267:9): [True: 31, False: 0]
  ------------------
  268|     31|        tox_options_default(options);
  269|     31|        SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_OK);
  ------------------
  |  |   14|     31|    do {                              \
  |  |   15|     31|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|     62|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (15:13): [True: 0, False: 31]
  |  |  ------------------
  |  |   16|      0|            *param = x;               \
  |  |   17|      0|        }                             \
  |  |   18|     31|    } while (0)
  |  |  ------------------
  |  |  |  Branch (18:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  270|     31|        return options;
  271|     31|    }
  272|       |
  273|      0|    SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_MALLOC);
  ------------------
  |  |   14|      0|    do {                              \
  |  |   15|      0|        if (param != nullptr) {       \
  |  |  ------------------
  |  |  |  |   63|      0|#define nullptr NULL
  |  |  ------------------
  |  |  |  Branch (15:13): [True: 0, False: 0]
  |  |  ------------------
  |  |   16|      0|            *param = x;               \
  |  |   17|      0|        }                             \
  |  |   18|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (18:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  274|      0|    return nullptr;
  ------------------
  |  |   63|      0|#define nullptr NULL
  ------------------
  275|     31|}
tox_options_free:
  278|     58|{
  279|     58|    if (options != nullptr) {
  ------------------
  |  |   63|     58|#define nullptr NULL
  ------------------
  |  Branch (279:9): [True: 31, False: 27]
  ------------------
  280|       |        // Free any owned data.
  281|     31|        tox_options_set_proxy_host(options, nullptr);
  ------------------
  |  |   63|     31|#define nullptr NULL
  ------------------
  282|     31|        tox_options_set_savedata_data(options, nullptr, 0);
  ------------------
  |  |   63|     31|#define nullptr NULL
  ------------------
  283|     31|        free(options);
  284|     31|    }
  285|     58|}

tox_default_system:
   36|     27|{
   37|     27|    const Tox_System sys = {
   38|     27|        nullptr,  // mono_time_callback
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
   39|     27|        nullptr,  // mono_time_user_data
  ------------------
  |  |   63|     27|#define nullptr NULL
  ------------------
   40|     27|        os_random(),
   41|     27|        os_network(),
   42|     27|        os_memory(),
   43|     27|    };
   44|     27|    return sys;
   45|     27|}
tox_lock:
   48|     24|{
   49|     24|    if (tox->mutex != nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (49:9): [True: 0, False: 24]
  ------------------
   50|      0|        pthread_mutex_lock(tox->mutex);
   51|      0|    }
   52|     24|}
tox_unlock:
   55|     24|{
   56|     24|    if (tox->mutex != nullptr) {
  ------------------
  |  |   63|     24|#define nullptr NULL
  ------------------
  |  Branch (56:9): [True: 0, False: 24]
  ------------------
   57|      0|        pthread_mutex_unlock(tox->mutex);
   58|      0|    }
   59|     24|}

memzero:
   99|     74|{
  100|     74|    if (data == nullptr || data_size == 0) {
  ------------------
  |  |   63|    148|#define nullptr NULL
  ------------------
  |  Branch (100:9): [True: 0, False: 74]
  |  Branch (100:28): [True: 0, False: 74]
  ------------------
  101|      0|        return;
  102|      0|    }
  103|       |
  104|     74|    memset(data, 0, data_size);
  105|     74|}

